# Chinese (China) translation for gtkmm-documentation.
# Copyright (C) 2010 gtkmm-documentation's COPYRIGHT HOLDER
# This file is distributed under the same license as the gtkmm-documentation package.
# Tao Wang <dancefire@gmail.com>, 2010.
#
msgid ""
msgstr ""
"Project-Id-Version: gtkmm-documentation master\n"
"POT-Creation-Date: 2020-12-30 13:36+8000\n"
"PO-Revision-Date: 2020-12-23 11:40+8000\n"
"Last-Translator: XiangQun Luo <Script.tar.gz@gmail.com>\n"
"Language-Team: Chinese (China) <i18n-zh@googlegroups.com>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgctxt "_"
msgid "translator-credits"
msgstr "译者积分"

#: C/index-in.docbook:36
msgid "Programming with <application>gtkmm</application> 4"
msgstr "<application>gtkmm</application>4 程序设计"

#: C/index-in.docbook:39
msgid "<firstname>Murray</firstname> <surname>Cumming</surname>"
msgstr "<firstname>Murray</firstname> <surname>Cumming</surname>"

#: C/index-in.docbook:43
msgid ""
"<firstname>Bernhard</firstname> <surname>Rieder</surname> <contrib>Chapter "
"on \"Timeouts\".</contrib>"
msgstr ""
"<firstname>Bernhard</firstname> <surname>Rieder</surname><contrib>编写"
"\"Timeouts\"部分。</contrib>"

#: C/index-in.docbook:48
msgid ""
"<firstname>Jonathon</firstname> <surname>Jongsma</surname> <contrib>Chapter "
"on \"Drawing with Cairo\".</contrib> <contrib>Chapter on \"Working with "
"gtkmm's Source Code\".</contrib> <contrib>Chapter on \"Recent Files\".</"
"contrib>"
msgstr ""
"<firstname>Jonathon</firstname> <surname>Jongsma</surname><contrib>编写使用开"
"罗绘图章节。</contrib><contrib>编写使用gtkmm源代码章节。</contrib><contrib>编"
"写\"最近的文件\"。</contrib>"

#: C/index-in.docbook:55
msgid ""
"<firstname>Ole</firstname> <surname>Laursen</surname> <contrib>Parts of "
"chapter on \"Internationalization\".</contrib>"
msgstr ""
"<firstname>Ole</firstname> <surname>Laursen</surname> <contrib>编写\"国际化"
"\"章节的一部分。</contrib>"

#: C/index-in.docbook:60
msgid ""
"<firstname>Marko</firstname> <surname>Anastasov</surname> <contrib>Chapter "
"on \"Printing\".</contrib> <contrib>Parts of chapter on "
"\"Internationalization\".</contrib>"
msgstr ""
"<firstname>Marko</firstname> <surname>Anastasov</surname> <contrib>编写\"打印"
"\"章节。</contrib> <contrib>编写\"国际化\"章节的一部分。</contrib>"

#: C/index-in.docbook:66
msgid ""
"<firstname>Daniel</firstname> <surname>Elstner</surname> <contrib>Section "
"\"Build Structure\" of chapter on \"Wrapping C Libraries with gmmproc\".</"
"contrib>"
msgstr ""
"<firstname>Daniel</firstname> <surname>Elstner</surname>编写《使用 gmmproc 封"
"装 C 库》〈构建结构〉章节。"

#: C/index-in.docbook:72
msgid ""
"<firstname>Chris</firstname> <surname>Vine</surname> <contrib>Chapter on "
"\"Multi-threaded programs\".</contrib>"
msgstr ""
"<firstname>Chris</firstname> <surname>Vine</surname><contrib>编写\"多线程编程"
"\"章节。</contrib>"

#: C/index-in.docbook:77
msgid ""
"<firstname>David</firstname> <surname>King</surname> <contrib>Section on "
"Gtk::Grid.</contrib>"
msgstr ""
"<firstname>David</firstname> <surname>King</surname><contrib>编写Gtk::Grid部"
"分。</contrib>"

#: C/index-in.docbook:82
msgid ""
"<firstname>Pedro</firstname> <surname>Ferreira</surname> <contrib>Chapter on "
"Keyboard Events.</contrib>"
msgstr ""
"<firstname>Pedro</firstname> <surname>Ferreira</surname><contrib>编写键盘事件"
"章节。</contrib>"

#: C/index-in.docbook:87
msgid ""
"<firstname>Kjell</firstname> <surname>Ahlstedt</surname> <contrib>Update "
"from gtkmm 3 to gtkmm 4.</contrib> <contrib>Chapter on \"Building "
"applications\".</contrib>"
msgstr ""
"<firstname>Kjell</firstname> <surname>Ahlstedt</surname> <contrib>编写从gtkmm"
"迁移到gtkmm4指南。</contrib> <contrib>编写\"构建应用\"章节。</contrib>"

#: C/index-in.docbook:98
msgid ""
"This book explains key concepts of the <application>gtkmm</application> C++ "
"API for creating user interfaces. It also introduces the main user interface "
"elements (\"widgets\")."
msgstr ""
"本书说明了使用<application>gtkmm</application> C++ API 创建用户界面的重要概"
"念，并且介绍了主要的用户界面元素(“widget”)。"

#: C/index-in.docbook:103
msgid ""
"<year>2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010</year> "
"<holder>Murray Cumming</holder>"
msgstr ""
"<year>2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010</year> "
"<holder>Murray Cumming</holder>"

#: C/index-in.docbook:109
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.2 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, no Front-Cover Texts, and no Back-Cover Texts. You may obtain a "
"copy of the GNU Free Documentation License from the Free Software Foundation "
"by visiting their Web site or by writing to: Free Software Foundation, Inc., "
"59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."
msgstr ""
"根据由自由软件基金发布的 GNU 自由文档协议版本1.2或更高版本的条款，授权复制、"
"分发和/或修改此文档；并且，没有不可变章节，没有封面文本，并且没有封底文本。您"
"可以通过访问自由软件基金(FSF)的网站或写邮件至：Free Software Foundation, "
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. 来获得一份 "
"GNU 自由文档协议。"

#: C/index-in.docbook:121
msgid "Introduction"
msgstr "序言"

#: C/index-in.docbook:124
msgid "This book"
msgstr "本书"

#: C/index-in.docbook:126
msgid ""
"This book explains key concepts of the <application>gtkmm</application> C++ "
"API for creating user interfaces. It also introduces the main user interface "
"elements (\"widgets\"). Although it mentions classes, constructors, and "
"methods, it does not go into great detail. Therefore, for full API "
"information you should follow the links into the reference documentation."
msgstr ""
"本书说明了使用<application>gtkmm</application> C++ API 创建用户界面的重要概"
"念，并且介绍了主要的用户界面元素(“widget”)。虽然提到了类、构造函数和方法，但"
"是并不会深入其细节。因此，如果需要完整的 API 信息，您应当顺着链接访问参考文"
"档。"

#: C/index-in.docbook:128
msgid ""
"This book assumes a good understanding of C++, and how to create C++ "
"programs."
msgstr "本书假定读者拥有对 C++ 良好的理解，并且知道如何去创建一个 C++ 程序。"

#: C/index-in.docbook:130
msgid ""
"We would very much like to hear of any problems you have learning "
"<application>gtkmm</application> with this document, and would appreciate "
"input regarding improvements. Please see the <link linkend=\"chapter-"
"contributing\">Contributing</link> section for further information."
msgstr ""
"我们非常愿意聆听您在使用此文档学习 <application>gtkmm</application> 时碰到的"
"任何问题，并且感激对此作出的改进。请访问 <link linkend=\"chapter-contributing"
"\">贡献</link> 节以获得进一步的信息。"

#: C/index-in.docbook:136
msgid ""
"This book describes <application>gtkmm</application> 4, but some sections "
"have not been fully updated. There are paragraphs that describe "
"<application>gtkmm</application> 3 rather than <application>gtkmm</"
"application> 4. All shown example programs are compatible with "
"<application>gtkmm</application> 4, though."
msgstr ""
"本书介绍了<application>gtkmm</application>4, 但是有些部分还没有完成更新 以下"
"是描述<application>gtkmm</application>3而不是<application>gtkmm</"
"application>4的段落。不过显式的所有示例都与<application>gtkmm</application>4"
"兼容。"

#: C/index-in.docbook:145
msgid "gtkmm"
msgstr "gtkmm"

#: C/index-in.docbook:146
msgid ""
"<application>gtkmm</application> is a C++ wrapper for <ulink url=\"http://"
"www.gtk.org/\">GTK</ulink>, a library used to create graphical user "
"interfaces. It is licensed using the LGPL license, so you can develop open "
"software, free software, or even commercial non-free software using "
"<application>gtkmm</application> without purchasing licenses."
msgstr ""
"<application>gtkmm</application> 是一个 <ulink url=\"http://www.gtk.org/"
"\">GTK</ulink> 的 C++ 封装，GTK+ 是一个用于创建图形用户界面的软件库。它使用 "
"LGPL 协议，因此您可以使用 <application>gtkmm</application> 开发开放软件、自由"
"软件，甚至商业非免费软件而不需支付任何版权费用。"

#: C/index-in.docbook:154
msgid ""
"<application>gtkmm</application> was originally named gtk-- because GTK was "
"originally named GTK+ and had a + in the name. However, as -- is not easily "
"indexed by search engines, the package generally went by the name "
"<application>gtkmm</application>, and that's what we stuck with."
msgstr ""
"<application>gtkmm</application> 曾经被称为 gtk--，那是因为 GTK+ 的名字中已经"
"有了一个加号。但是，由于 -- 不容易被搜索引擎索引，所以项目名字就渐渐的变成了"
"<application>gtkmm</application>，后来我们就一直使用这个名字。"

#: C/index-in.docbook:159
msgid "Why use <application>gtkmm</application> instead of GTK?"
msgstr "为什么要使用 <application>gtkmm</application> 而不是 GTK？"

#: C/index-in.docbook:160
msgid ""
"<application>gtkmm</application> allows you to write code using normal C++ "
"techniques such as encapsulation, derivation, and polymorphism. As a C++ "
"programmer you probably already realise that this leads to clearer and "
"better organized code."
msgstr ""
"<application>gtkmm</application> 允许你使用常用的 C++ 技术来撰写代码，比如封"
"装、继承和多态。作为一个 C++ 程序员，你可能已经意识到这会让代码更加清晰、更加"
"良好的管理代码。"

#: C/index-in.docbook:161
msgid ""
"<application>gtkmm</application> is more type-safe, so the compiler can "
"detect errors that would only be detected at run time when using C. This use "
"of specific types also makes the API clearer because you can see what types "
"should be used just by looking at a method's declaration."
msgstr ""
"<application>gtkmm</application> 更加类型安全，因此编译器可以检测出一些 C 只"
"能在运行时才能检测出来的错误。这种使用特定类型的方法同样使得 API 更加清晰，因"
"为你只需要通过看一下函数声明就可以知道应该使用什么类型了。"

#: C/index-in.docbook:162
msgid ""
"Inheritance can be used to derive new widgets. The derivation of new widgets "
"in GTK C code is so complicated and error prone that almost no C coders do "
"it. As a C++ developer you know that derivation is an essential Object "
"Orientated technique."
msgstr ""
"可以使用继承来衍生新的部件。在 GTK 中使用 C 代码来衍生新部件是非常复杂的，并"
"且很容易出错，因此几乎没有 C 的程序员这么做。作为 C++ 开发人员，你知道继承是"
"一个基本的面向对象技术。"

#: C/index-in.docbook:163
msgid ""
"Member instances can be used, simplifying memory management. All GTK C "
"widgets are dealt with by use of pointers. As a C++ coder you know that "
"pointers should be avoided where possible."
msgstr ""
"可以使用成员实例，简化了内存管理。所有的 GTK 的 C 部件都是使用指针进行操作"
"的。作为 C++ 程序员，你知道指针应当尽量避免使用。"

#: C/index-in.docbook:164
msgid ""
"<application>gtkmm</application> involves less code compared to GTK, which "
"uses prefixed function names and lots of cast macros."
msgstr ""
"<application>gtkmm</application> 比 GTK 的代码更加简短，GTK 使用了大量带前缀"
"的函数名以及大量的转型宏。"

#: C/index-in.docbook:168
msgid "<application>gtkmm</application> compared to Qt"
msgstr "<application>gtkmm</application> 对比 Qt"

#: C/index-in.docbook:169
msgid ""
"Trolltech's Qt is the closest competition to <application>gtkmm</"
"application>, so it deserves discussion."
msgstr ""
"Trolltech 公司的 Qt 是和 <application>gtkmm</application> 最相似的有竞争力的"
"产品，所以应该对其进行一下讨论。"

#: C/index-in.docbook:171
msgid ""
"<application>gtkmm</application> developers tend to prefer "
"<application>gtkmm</application> to Qt because <application>gtkmm</"
"application> does things in a more C++ way. Qt originates from a time when C+"
"+ and the standard library were not standardised or well supported by "
"compilers. It therefore duplicates a lot of stuff that is now in the "
"standard library, such as containers and type information. Most "
"significantly, Trolltech modified the C++ language to provide signals, so "
"that Qt classes cannot be used easily with non-Qt classes. "
"<application>gtkmm</application> was able to use standard C++ to provide "
"signals without changing the C++ language. See the <ulink url=\"https://wiki."
"gnome.org/Projects/gtkmm/FAQ\">FAQ</ulink> for more detailed differences."
msgstr ""
"<application>gtkmm</application> 开发人员更倾向于使用 <application>gtkmm</"
"application> 而不是 Qt，因为 <application>gtkmm</application> 的使用更加符合 "
"C++ 的方式。Qt 是诞生自 C++ 及其库尚未标准化或尚未被大多数编译器所支持的年"
"代。它重复了大量的现存于标准库中的东西，比如容器、类型信息等等。最重要的是，"
"Trolltech 修改了 C++ 语言以提供信号的功能，这样 Qt 的类无法很容易的与非 Qt 类"
"共同使用。<application>gtkmm</application> 则可以使用标准 C++ 提供信号功能，"
"而无需修改 C++ 语言。请看<ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"FAQ\">常见问题</ulink>以了解具体差异。"

#: C/index-in.docbook:176
msgid "<application>gtkmm</application> is a wrapper"
msgstr "<application>gtkmm</application> 是一个封装"

#: C/index-in.docbook:177
msgid ""
"<application>gtkmm</application> is not a native C++ toolkit, but a C++ "
"wrapper of a C toolkit. This separation of interface and implementation has "
"advantages. The <application>gtkmm</application> developers spend most of "
"their time talking about how <application>gtkmm</application> can present "
"the clearest API, without awkward compromises due to obscure technical "
"details. We contribute a little to the underlying GTK code base, but so do "
"the C coders, and the Perl coders and the Python coders, etc. Therefore GTK "
"benefits from a broader user base than language-specific toolkits - there "
"are more implementers, more developers, more testers, and more users."
msgstr ""
"<application>gtkmm</application> 并不是一个原生的 C++ 工具集，而是一个对于 C "
"工具集的 C++ 封装。这种分离接口和实现的方式存在诸多优势。<application>gtkmm</"
"application> 开发人员用了他们大量的时间来讨论如何让 <application>gtkmm</"
"application> 提供一个最清晰的 API，而不必为模糊的技术细节尴尬的进行妥协。我们"
"想其他的 C 程序员、Perl 程序员和 Python 程序员等等一样，对底层的 GTK 代码库进"
"行了一点点贡献。因此，GTK 可以从比某个语言特定的工具集更广泛的用户群中获得好"
"处，有更多的实现、更多的开发人员、更多的测试人员以及更多的用户。"

#: C/index-in.docbook:185
msgid "Installation"
msgstr "安装"

#: C/index-in.docbook:187
msgid "Dependencies"
msgstr "依赖关系"

#: C/index-in.docbook:188
msgid ""
"Before attempting to install <application>gtkmm</"
"application><application>-4.0</application>, you might first need to install "
"these other packages."
msgstr ""
"在试图安装 <application>gtkmm</application><application>-4.0</application>之"
"前，你必须已经安装了这些包。"

#: C/index-in.docbook:193
msgid "<application>sigc++-3.0</application>"
msgstr "<application>sigc++-3.0</application>"

#: C/index-in.docbook:194
msgid "<application>gtk4</application>"
msgstr "<application>gtkmm4</application>"

#: C/index-in.docbook:195
msgid "<application>glibmm-2.68</application>"
msgstr "<application>glibmm-2.68</application>"

#: C/index-in.docbook:196
msgid "<application>cairomm-1.16</application>"
msgstr "<application>cairomm-1.16</application>"

#: C/index-in.docbook:197
msgid "<application>pangomm-2.48</application>"
msgstr "<application>pangomm-2.48</application>"

#: C/index-in.docbook:199
msgid ""
"These dependencies have their own dependencies, including the following "
"applications and libraries:"
msgstr "这些依赖有它们自己所依赖的软件包，包括下列应用程序和软件库："

#: C/index-in.docbook:204
msgid "<application>pkg-config</application>"
msgstr "<application>pkg-config</application>"

#: C/index-in.docbook:205
msgid "<application>glib-2.0</application>"
msgstr "<application>glib-2.0</application>"

#: C/index-in.docbook:206
msgid "<application>pango</application>"
msgstr "<application>pango</application>"

#: C/index-in.docbook:207
msgid "<application>cairo</application>"
msgstr "<application>cairo</application>"

#: C/index-in.docbook:208
msgid "<application>gdk-pixbuf-2.0</application>"
msgstr "<application>gdk-pixbuf-2.0</application>"

#: C/index-in.docbook:209
msgid "<application>graphene-1.0</application>"
msgstr "<application>graphene-1.0</application>"

#: C/index-in.docbook:214
msgid "Unix and Linux"
msgstr "Unix 和 Linux"

#: C/index-in.docbook:217
msgid "Prebuilt Packages"
msgstr "预编译的包"

#: C/index-in.docbook:219
msgid ""
"Recent versions of <application>gtkmm</application> are packaged by nearly "
"every major Linux distribution these days. So, if you use Linux, you can "
"probably get started with <application>gtkmm</application> by installing the "
"package from the official repository for your distribution. Distributions "
"that include <application>gtkmm</application> in their repositories include "
"Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and many others."
msgstr ""
"<application>gtkmm</application> 最新的版本的软件包几乎存在于今天每一个主流"
"的 Linux 发布版本中。所以，如果你使用 Linux，你可能只需要从官方的软件库安装相"
"应的软件包，然后就可以开始使用 <application>gtkmm</application> 了。已经在它"
"们的软件库里面包含了 <application>gtkmm</application> 的发布版本有：Debian、"
"Ubuntu、Red Hat、Fedora、Mandriva、SuSE 等等。"

#: C/index-in.docbook:227
msgid ""
"The names of the <application>gtkmm</application> packages vary from "
"distribution to distribution (e.g. <application>libgtkmm-4.0-dev</"
"application> on Debian and Ubuntu or <application>gtkmm40-devel</"
"application> on Red Hat Fedora), so check with your distribution's package "
"management program for the correct package name and install it like you "
"would any other package."
msgstr ""
"<application>gtkmm</application> 软件包的名字可能在不同的发行版中所不同 (例"
"如，在 Debian 和 Ubuntu 上的名字是<application>libgtkmm-4.0-dev</"
"application>，而在 Red Hat Fedora 上则是 <application>gtkmm40-devel</"
"application>)，因此，在你的发行版的软件包管理程序中查一下正确的名字，然后像其"
"它软件包一样的安装它。"

#: C/index-in.docbook:235
msgid ""
"The package names will not change when new API/ABI-compatible versions of "
"<application>gtkmm</application> are released. Otherwise they would not be "
"API/ABI-compatible. So don't be surprised, for instance, to find "
"<application>gtkmm</application> 4.8 supplied by Debian's "
"<application>libgtkmm-4.0-dev</application> package."
msgstr ""
"当新的 API/ABI 兼容的 <application>gtkmm</application> 版本发布后，其包的名称"
"将不会改变。否则的话，就说明 API/ABI 不兼容。所以，如果在 Debian 的 "
"<application>libgtkmm-4.0-dev</application> 包中发现提供的实际上是 "
"<application>gtkmm</application> 4.8 的话不要太惊讶。"

#: C/index-in.docbook:245
msgid "Installing From Source"
msgstr "从源代码安装"

#: C/index-in.docbook:247
msgid ""
"If your distribution does not provide a pre-built <application>gtkmm</"
"application> package, or if you want to install a different version than the "
"one provided by your distribution, you can also install <application>gtkmm</"
"application> from source. The source code for <application>gtkmm</"
"application> can be downloaded from <ulink url=\"https://download.gnome.org/"
"sources/gtkmm/\"/>."
msgstr ""
"如果你的发行版没提供预编译的 <application>gtkmm</application> 包，或者如果你"
"想安装一个和发行版所提供的不同的版本，那么你也可以从源代码安装 "
"<application>gtkmm</application>。可以从 <ulink url=\"https://download.gnome."
"org/sources/gtkmm/\"/> 中下载 <application>gtkmm</application> 的源代码。"

#: C/index-in.docbook:253
msgid ""
"After you've installed all of the dependencies, download the "
"<application>gtkmm</application> source code, unpack it, and change to the "
"newly created directory. <application>gtkmm</application> can be built with "
"Meson. See the <filename>README</filename> file in the <application>gtkmm</"
"application> version you've downloaded."
msgstr ""
"在安装了所有依赖的库后，下载 <application>gtkmm</application> 源代码、解压"
"缩，并且切换到新创建的目录。<application>gtkmm</application>可以使用Meson构"
"建。 参见你所下载的<application>gtkmm</application>源代码中的"
"<filename>README</filename>。"

#: C/index-in.docbook:260
msgid ""
"Remember that on a Unix or Linux operating system, you will probably need to "
"be <literal>root</literal> to install software. The <command>su</command> or "
"<command>sudo</command> command will allow you to enter the <literal>root</"
"literal> password and have <literal>root</literal> status temporarily."
msgstr ""
"记住，在 Unix 或 Linux 操作系统上，你也许需要 <literal>root</literal> 权限以"
"安装软件。<command>su</command>或者<command>sudo</command> 命令允许你输入 "
"<literal>root</literal> 密码，并且临时拥有 <literal>root</literal> 权限。"

#: C/index-in.docbook:267
msgid ""
"The <filename>configure</filename> script or <command>meson</command> will "
"check to make sure all of the required dependencies are already installed. "
"If you are missing any dependencies, it will exit and display an error."
msgstr ""
"<filename>configure</filename>脚本或者<command>meson</command>将会检查以确认"
"所有必须的依赖软件包都已经正确的安装了。如果你遗漏了某个依赖软件包的话，它会"
"退出并提示错误信息。"

#: C/index-in.docbook:278
#, no-wrap
msgid ""
"\n"
"# ./configure --prefix=/usr\n"
msgstr ""
"\n"
"# ./configure --prefix=/usr\n"

#: C/index-in.docbook:272
msgid ""
"By default, <application>gtkmm</application> if built with Autotools, will "
"be installed under the <filename>/usr/local</filename> directory. On some "
"systems you may need to install to a different location. For instance, on "
"Red Hat Linux systems you might use the <literal>--prefix</literal> option "
"with configure, like so: <_:screen-1/>"
msgstr ""
"默认情况下，如果使用Autotools构建<application>gtkmm</application> 则其将会被"
"安装在 <filename>/usr/local</filename> 目录。在有些系统中，你也许需要安装到不"
"同的位置。比如，在 Red Hat Linux 系统中，你也许需要使用 <literal>--prefix</"
"literal> 选项进行配置，例如：<_:screen-1/>"

#: C/index-in.docbook:283
msgid ""
"You should be very careful when installing to standard system prefixes such "
"as <filename>/usr</filename>. Linux distributions install software packages "
"to <filename>/usr</filename>, so installing a source package to this prefix "
"could corrupt or conflict with software installed using your distribution's "
"package-management system. Ideally, you should use a separate prefix for all "
"software you install from source."
msgstr ""
"在安装到标准系统前缀时，如 <filename>/usr</filename>，你必须非常小心。Linux "
"发行版会安装软件到 <filename>/usr</filename>，所以安装源代码包到这个位置可能"
"会破坏或与使用软件包管理器安装的软件冲突。理想情况下，你应当将从源代码安装的"
"软件都安装到一个独立位置。"

#: C/index-in.docbook:292
msgid ""
"If you want to help develop <application>gtkmm</application> or experiment "
"with new features, you can also install <application>gtkmm</application> "
"from git. Most users will never need to do this, but if you're interested in "
"helping with <application>gtkmm</application> development, see the <link "
"linkend=\"chapter-working-with-source\">Working with gtkmm's Source Code</"
"link> appendix."
msgstr ""
"如果你想帮助开发 <application>gtkmm</application>，或实验一些新的功能，你也可"
"以直接从 Git 安装 <application>gtkmm</application>。大多数用户绝对不需要这么"
"做，但是如果你对帮助 <application>gtkmm</application> 开发感兴趣，请看附录："
"<link linkend=\"chapter-working-with-source\">使用 gtkmm 源代码</link>。"

#: C/index-in.docbook:303
msgid "Microsoft Windows"
msgstr "Microsoft Windows"

#: C/index-in.docbook:304
msgid ""
"GTK and <application>gtkmm</application> were designed to work well with "
"Microsoft Windows, and the developers encourage its use on the win32 "
"platform. However, Windows has no standard installation system for "
"development libraries. Please see the <ulink url=\"https://wiki.gnome.org/"
"Projects/gtkmm/MSWindows\">Windows Installation</ulink> page or the <link "
"linkend=\"sec-windows-installation\"><application>gtkmm</application> and "
"Win32</link> appendix for Windows-specific installation instructions and "
"notes."
msgstr ""
"GTK和<application>gtkmm</application>被设计成在Microsoft Windows上也能很好地"
"工作，而且开发者们鼓励在win32平台上使用它们。但是目前还有没为Windows平台的开"
"发库提供标准的安装方法。请参阅 <ulink url=\"https://wiki.gnome.org/Projects/"
"gtkmm/MSWindows\">Windows Intallation</ulink>或者<link linkend=\"sec-windows-"
"installation\"><application>gtkmm</application>和Win32</link>以得到关于"
"Windows相关的安装方法和注意事项。"

#: C/index-in.docbook:315
msgid "Basics"
msgstr "基础"

#: C/index-in.docbook:317
msgid ""
"This chapter will introduce some of the most important aspects of "
"<application>gtkmm</application> coding. These will be demonstrated with "
"simple working example code. However, this is just a taster, so you need to "
"look at the other chapters for more substantial information."
msgstr ""
"这一章将介绍 <application>gtkmm</application> 编程中一些重要的方面。这些将由"
"一些可以运行的示例代码来演示。然而，这仅仅是一种尝试，你还需要继续看其它章"
"节，以得到更实质性的信息。"

#: C/index-in.docbook:320
msgid ""
"Your existing knowledge of C++ will help you with <application>gtkmm</"
"application> as it would with any library. Unless we state otherwise, you "
"can expect <application>gtkmm</application> classes to behave like any other "
"C++ class, and you can expect to use your existing C++ techniques with "
"<application>gtkmm</application> classes."
msgstr ""
"你现有的 C++ 知识将会帮助你使用 <application>gtkmm</application>，因为它可以"
"和任何库一同工作。除非我们额外声明，你可以期待 <application>gtkmm</"
"application> 类会像任何其它 C++ 类一样，并且你可以期待在 <application>gtkmm</"
"application> 类上使用你现有的知识。"

#: C/index-in.docbook:325 C/index-in.docbook:3316
msgid "Simple Example"
msgstr "简单的例子"

#: C/index-in.docbook:327
msgid ""
"To begin our introduction to <application>gtkmm</application>, we'll start "
"with the simplest program possible. This program will create an empty 200 x "
"200 pixel window."
msgstr ""
"在开始介绍 <application>gtkmm</application> 之前，我们将以一个尽可能简单的程"
"序开始。这个程序创建一个 200 x 200 像素大小的空窗口。"

#: C/index-in.docbook:332
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/base\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/base\">源代码</ulink>"

#: C/index-in.docbook:334
msgid "We will now explain each line of the example"
msgstr "我们会逐行讲解这个例子"

#: C/index-in.docbook:335
#, no-wrap
msgid "#include &lt;gtkmm.h&gt;"
msgstr "#include &lt;gtkmm.h&gt;"

#: C/index-in.docbook:336
msgid ""
"All <application>gtkmm</application> programs must include certain "
"<application>gtkmm</application> headers; <literal>gtkmm.h</literal> "
"includes the entire <application>gtkmm</application> kit. This is usually "
"not a good idea, because it includes a megabyte or so of headers, but for "
"simple programs, it suffices."
msgstr ""
"所有的 <application>gtkmm</application> 程序都需要包含一些特定的 "
"<application>gtkmm</application> 头文件；<literal>gtkmm.h</literal> 包含了所"
"有 <application>gtkmm</application> 的内容。通常来说，这并不是一个好主意，因"
"为它包括了一兆左右的头文件。当然，对于这个简单的程序，这就够了。"

#: C/index-in.docbook:346
#, no-wrap
msgid "auto app = Gtk::Application::create(\"org.gtkmm.examples.base\");"
msgstr "auto app = Gtk::Application::create(\"org.gtkmm.examples.base\");"

#: C/index-in.docbook:343
msgid ""
"The next statement: <_:programlisting-1/> creates a <classname>Gtk::"
"Application</classname> object, stored in a <classname>Glib::RefPtr</"
"classname> smartpointer. This is needed in all <application>gtkmm</"
"application> applications. The <methodname>create()</methodname> method for "
"this object initializes <application>gtkmm</application>."
msgstr ""
"下一条语句: <_:programlisting-1/>创建一个<classname>Gtk::Application</"
"classname>对象，将其储存在一个<classname>Glib::RefPtr</classname>智能指针中。"
"所有的<application>gtkmm</application>应用都需要如此做。该对象的"
"<methodname>create()</methodname>方法将初始化<application>gtkmm</"
"application>。"

#: C/index-in.docbook:352
msgid ""
"The next two lines of code create a window and set its default (initial) "
"size:"
msgstr "接下来的两行代码创建一个窗口并设置其的初始大小："

#: C/index-in.docbook:355
#, no-wrap
msgid ""
"Gtk::Window window;\n"
"window.set_default_size(200, 200);"
msgstr ""
"Gtk::Window window;\n"
"window.set_default_size(200, 200);"

#: C/index-in.docbook:357
msgid ""
"The last line shows the window and enters the <application>gtkmm</"
"application> main processing loop, which will finish when the window is "
"closed. Your <function>main()</function> function will then return with an "
"appropriate success or error code. The <parameter>argc</parameter> and "
"<parameter>argv</parameter> arguments, passed to your application on the "
"command line, can be checked when <methodname>run()</methodname> is called, "
"but this simple application does not use those arguments."
msgstr ""
"最后一行显示窗口并进入<application>gtkmm</application>主循环，当窗口被关闭。"
"你的<function>main()</function>函数将会返回成功或者适当的错误码。"

#: C/index-in.docbook:364
#, no-wrap
msgid "return app-&gt;run(window, argc, argv);"
msgstr "return app-&gt;run(window, argc, argv);"

#: C/index-in.docbook:369
#, no-wrap
msgid "g++ simple.cc -o simple `pkg-config gtkmm-4.0 --cflags --libs`"
msgstr "g++ simple.cc -o simple `pkg-config gtkmm-4.0 --cflags --libs`"

#: C/index-in.docbook:366
msgid ""
"After putting the source code in <literal>simple.cc</literal> you can "
"compile the above program with <application>gcc</application> using: <_:"
"programlisting-1/> Note that you must surround the <literal>pkg-config</"
"literal> invocation with backquotes. Backquotes cause the shell to execute "
"the command inside them, and to use the command's output as part of the "
"command line. Note also that <literal>simple.cc</literal> must come before "
"the <literal>pkg-config</literal> invocation on the command line."
msgstr ""
"将源代码保存到 <literal>simple.cc</literal> 后，你可以使用 gcc 编译上面的程"
"序：<_:programlisting-1/> 注意，你必须将 <literal>pkg-config</literal> 的调用"
"包含在一对反单引号中。反单引号会导致其内的命令由 shell 执行，并且将命令的输出"
"做为该命令行的一部分来使用。另外请注意，在命令行中<literal>simple.cc</"
"literal>必须位于<literal>pkg-config</literal>调用之前。"

#: C/index-in.docbook:379
msgid "Headers and Linking"
msgstr "头文件和链接"

#: C/index-in.docbook:380
msgid ""
"Although we have shown the compilation command for the simple example, you "
"really should use the automake and autoconf tools, as described in "
"\"Autoconf, Automake, Libtool\", by G. V. Vaughan et al. The examples used "
"in this book are included in the <application>gtkmm-documentation</"
"application> package, with appropriate build files, so we won't show the "
"build commands in future. You'll just need to find the appropriate directory "
"and type <literal>make</literal>."
msgstr ""
"虽然我们已经给出了这个简单的例子的编译命令，但是你最好还是使用 automake 和 "
"autoconf 工具，就像 G. V. Vaughan 等在《Autoconf, Automake, Libtool》中所描述"
"的那样。本书中用到的例子都包含在 <application>gtkmm-documentation</"
"application> 包内，同时附有适当的编译构建的文件，所以我们以后不会再给出任何编"
"译命令。你只需要找到恰当的目录然后键入 <literal>make</literal>。"

#: C/index-in.docbook:383
msgid ""
"To simplify compilation, we use <literal>pkg-config</literal>, which is "
"present in all (properly installed) <application>gtkmm</application> "
"installations. This program 'knows' what compiler switches are needed to "
"compile programs that use <application>gtkmm</application>. The <literal>--"
"cflags</literal> option causes <literal>pkg-config</literal> to output a "
"list of include directories for the compiler to look in; the <literal>--"
"libs</literal> option requests the list of libraries for the compiler to "
"link with and the directories to find them in. Try running it from your "
"shell-prompt to see the results on your system."
msgstr ""
"为了简化编译的过程，我们使用了 <literal>pkg-config</literal>，它存在于所有的"
"(也许已经安装的) <application>gtkmm</application> 安装文件中。这个程序“知"
"道”编译使用了 <application>gtkmm</application> 的程序所需要的编译器选项。"
"<literal>--cflags</literal> 选项使 <literal>pkg-config</literal> 输出一个包含"
"编译时需要用到的头文件的目录列表；而使用 <literal>--libs</literal> 选项将得到"
"一个需要编译器去链接的库列表和一个用于寻找它们的目录列表。试着在你的命令行提"
"示符下运行它，看看在你的系统上会有什么样的结果。"

#: C/index-in.docbook:396
#, no-wrap
msgid "PKG_CHECK_MODULES([MYAPP], [gtkmm-4.0 &gt;= 4.8.0])"
msgstr "PKG_CHECK_MODULES([MYAPP], [gtkmm-4.0 &gt;= 4.8.0])"

#: C/index-in.docbook:393
msgid ""
"However, this is even simpler when using the <function>PKG_CHECK_MODULES()</"
"function> macro in a standard configure.ac file with autoconf and automake. "
"For instance: <_:programlisting-1/> This checks for the presence of gtkmm "
"and defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile.am files."
msgstr ""
"然而，在标准的 configure.ac 中使用 <function>PKG_CHECK_MODULES()</function> "
"宏，并且运行 autoconf 和 automake 后，这变的更加简单。例如：<_:"
"programlisting-1/> 这将会检查是否存在 gtkmm，并且定义了可以在你的 Makefile."
"am 文件中使用的 MYAPP_LIBS 和 MYAPP_CFLAGS 变量。"

#: C/index-in.docbook:399
msgid ""
"gtkmm-4.0 is the name of the current stable API. There are older APIs called "
"gtkmm-2.4 and gtkmm-3.0 which install in parallel when they are available. "
"There are several versions of gtkmm-2.4, such as gtkmm 2.10 and there are "
"several versions of the gtkmm-3.0 API. Note that the API name does not "
"change for every version because that would be an incompatible API and ABI "
"break. There might be a future gtkmm-5.0 API which would install in parallel "
"with gtkmm-4.0 without affecting existing applications."
msgstr ""
"gtkmm-4.0 是当前稳定 API 的名字。更早期的 API 叫做 gtkmm-2.4和gtkmm-3.0，如果"
"需要的话它可以和 gtkmm-2.4 ，gtkmm-3.0 同时安装到系统。gtkmm-2.4 有许多版本，"
"例如，gtkmm-2.10，还有多个版本gtkmm-3.0的api。注意，API 的名字并不会随着每个"
"版本变化而发生变化，因为如果这个发生变化了，则意味着 API 和 ABI 不再同以前保"
"持兼容。理论上，将来可以有 gtkmm-5.0 API 与现在的 gtkmm-4.0 同时安装到系统，"
"而现有应用程序不会受到影响。"

#: C/index-in.docbook:406
msgid ""
"Note that if you mention extra modules in addition to gtkmm-4.0, they should "
"be separated by spaces, not commas."
msgstr ""
"注意，如果你提到了除 gtkmm-4.0 之外的模块，它们需要以空格分开，而不是逗号。"

#: C/index-in.docbook:409
msgid ""
"The GNU site has more information about <ulink url=\"https://www.gnu.org/"
"software/autoconf/\">autoconf</ulink> and <ulink url=\"https://www.gnu.org/"
"software/automake/\">automake</ulink>."
msgstr ""
"GNU网站上拥有更多<ulink url=\"https://www.gnu.org/software/autoconf/"
"\">autoconf</ulink>和<ulink url=\"https://www.gnu.org/software/automake/"
"\">automake</ulink>的相关信息。"

#: C/index-in.docbook:412
msgid ""
"If you start by experimenting with a small application that you plan to use "
"just for yourself, it's easier to start with a Makefile similar to the "
"<filename>Makefile.example</filename> files in the <link linkend=\"chapter-"
"building-applications\">Building applications</link> chapter."
msgstr ""
"如果你打算自己从小型应用程序开始试验，那么使用<link linkend=\"chapter-"
"building-applications\">构建应用程序</link>章节的<filename>Makefile.example</"
"filename>文件从MakeFile开始比较容易。"

#: C/index-in.docbook:420 C/index-in.docbook:5869
msgid "Widgets"
msgstr "部件"

#: C/index-in.docbook:421
msgid ""
"<application>gtkmm</application> applications consist of windows containing "
"widgets, such as buttons and text boxes. In some other systems, widgets are "
"called \"controls\". For each widget in your application's windows, there is "
"a C++ object in your application's code. So you just need to call a method "
"of the widget's class to affect the visible widget."
msgstr ""
"<application>gtkmm</application> 应用程序由一系列包含了如按钮、文本框之类部件"
"的窗口构成。在一些其它的系统上，部件可能被称为“控件”。对于你的应用程序窗口中"
"的每个部件，在你的代码里就会有一个对应的 C++ 对象。所以当你想控制部件行为的时"
"候，只需要调用这个部件对象的相应方法即可。"

#: C/index-in.docbook:423
#, no-wrap
msgid ""
"m_box.append(m_Button1);\n"
"m_box.append(m_Button2);"
msgstr ""
"m_box.append(m_Button1);\n"
"m_box.append(m_Button2);"

#: C/index-in.docbook:426
#, no-wrap
msgid "m_frame.set_child(m_box);"
msgstr "m_frame.set_child(m_box);"

#: C/index-in.docbook:422
msgid ""
"Widgets are arranged inside container widgets such as frames and notebooks, "
"in a hierarchy of widgets within widgets. Some of these container widgets, "
"such as <classname>Gtk::Grid</classname>, are not visible - they exist only "
"to arrange other widgets. Here is some example code that adds 2 "
"<classname>Gtk::Button</classname> widgets to a <classname>Gtk::Box</"
"classname> container widget: <_:programlisting-1/> and here is how to add "
"the <classname>Gtk::Box</classname>, containing those buttons, to a "
"<classname>Gtk::Frame</classname>, which has a visible frame and title: <_:"
"programlisting-2/>"
msgstr ""
"部件被安置在褚如 frame、notebook 这样的容器部件中，以一种部件包含部件的层次结"
"构的形式。其中一些容器部件，像 <classname>Gtk::Grid</classname> 这样的容器部"
"件是不可见的，它们只是被用来安置其它部件的。这里有一些示例代码，将两个 "
"<classname>Gtk::Button</classname> 部件放到一个 <classname>Box</classname> 容"
"器部件中：<_:programlisting-1/> 接下来是如何把这个包含两个按钮的 "
"<classname>Gtk::Box</classname> 添加到一个 <classname>Gtk::Frame</classname> "
"中，它包含一个可视的边框和标题：<_:programlisting-2/>"

#: C/index-in.docbook:428
msgid ""
"Most of the chapters in this book deal with specific widgets. See the <link "
"linkend=\"chapter-container-widgets\">Container Widgets</link> section for "
"more details about adding widgets to container widgets."
msgstr ""
"本书中的大部分章节都是讲解特定的部件。要得到更多关于添加部件到容器部件的信"
"息，请看 <link linkend=\"chapter-container-widgets\">容器部件</link> 这一章。"

#: C/index-in.docbook:432
msgid ""
"Although you can specify the layout and appearance of windows and widgets "
"with C++ code, you will probably find it more convenient to design your user "
"interfaces with <literal>Glade</literal> and load them at runtime with "
"<literal>Gtk::Builder</literal>. See the <link linkend=\"chapter-builder"
"\">Glade and Gtk::Builder</link> chapter."
msgstr ""
"尽管你可以使用 C++ 代码来指定窗口和部件的外观和布局，但你可能会发现使用 "
"Glade 来设计你的界面，并且使用 <literal>Gtk::Builder</literal> 在运行时动态加"
"载界面是更方便。请参考 <link linkend=\"chapter-builder\">Glade 与 Gtk::"
"Builder</link> 这一章。"

#: C/index-in.docbook:435
msgid ""
"Although <application>gtkmm</application> widget instances have lifetimes "
"and scopes just like those of other C++ classes, <application>gtkmm</"
"application> has an optional time-saving feature that you will see in some "
"of the examples. The <function>Gtk::make_managed()</function> allows you to "
"create a new widget and state that it will become owned by the container "
"into which you place it. This allows you to create the widget, add it to the "
"container and not be concerned about deleting it, since that will occur when "
"the parent container (which may itself be managed) is deleted. You can learn "
"more about <application>gtkmm</application> memory management techniques in "
"the <link linkend=\"chapter-memory\">Memory Management chapter</link>."
msgstr ""
"尽管 <application>gtkmm</application> 部件实例拥有像其它 C++ 类那样的生存时间"
"和作用域，<application>gtkmm</application> 还是有一些可选的节省时间的特性，接"
"下来你会在接下来的一些例子中看到。<function>Gtk::make_managed()</function> 允"
"许你创建一个新的部件并声明该部件由放置它的容器部件所拥有。这将允许你创建部件"
"然后将其添加到容器中，而不必承担记住删除它的心智负担，因为当它的父容器被删除"
"时它将被一并删除。如果你需要了解更多关于 <application>gtkmm</application> 内"
"存管理技术的话，请看 <link linkend=\"chapter-memory\">内存管理</link> 章节。"

#: C/index-in.docbook:449 C/index-in.docbook:4689 C/index-in.docbook:4933
#: C/index-in.docbook:8092
msgid "Signals"
msgstr "信号"

#: C/index-in.docbook:451
msgid ""
"<application>gtkmm</application>, like most GUI toolkits, is <emphasis>event-"
"driven</emphasis>. When an event occurs, such as the press of a mouse "
"button, the appropriate signal will be <emphasis>emitted</emphasis> by the "
"Widget that was pressed. Each Widget has a different set of signals that it "
"can emit. To make a button click result in an action, we set up a "
"<emphasis>signal handler</emphasis> to catch the button's \"clicked\" signal."
msgstr ""
"像大多数GUI工具包一样，<application>gtkmm</application> 是<emphasis>事件驱动"
"</emphasis>的。当一个事件发生时，比如说一个鼠标按键被按下，那么所点击的部件就"
"会<emphasis>发出</emphasis>一个合适的信号。每种部件都可以发出一套不同的信号。"
"为了使这个按钮点击产生一个动作，我们可以设置一个<emphasis>信号处理函数"
"(signal handler)</emphasis>来捕捉这个“clicked”信号。"

#: C/index-in.docbook:459
#, no-wrap
msgid ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"
msgstr ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"

#: C/index-in.docbook:458
msgid ""
"<application>gtkmm</application> uses the libsigc++ library to implement "
"signals. Here is an example line of code that connects a Gtk::Button's "
"\"clicked\" signal with a signal handler called \"on_button_clicked\": <_:"
"programlisting-1/>"
msgstr ""
"<application>gtkmm</application> 使用 libsigc++ 来实现信号操作。下面这个例子"
"演示怎样把 Gtk::Button 的“clicked” 信号连接到命名为“on_button_clicked”的信号"
"处理函数上：<_:programlisting-1/>"

#: C/index-in.docbook:463
msgid ""
"For more detailed information about signals, see the <link linkend=\"chapter-"
"signals\">appendix</link>."
msgstr ""
"要得到更多关于信号的信息，请参考<link linkend=\"chapter-signals\">附录</"
"link>。"

#: C/index-in.docbook:464
msgid ""
"For information about implementing your own signals rather than just "
"connecting to the existing <application>gtkmm</application> signals, see the "
"<link linkend=\"chapter-custom-signals\">appendix</link>."
msgstr ""
"要想知道如何实现你自己的信号，而不仅仅是连接到现有的 <application>gtkmm</"
"application> 信号，请参考 <link linkend=\"chapter-custom-signals\">附录</"
"link>。"

#: C/index-in.docbook:470
msgid "Glib::ustring"
msgstr "Glib::ustring"

#: C/index-in.docbook:471
msgid ""
"You might be surprised to learn that <application>gtkmm</application> "
"doesn't use <classname>std::string</classname> in its interfaces. Instead it "
"uses <classname>Glib::ustring</classname>, which is so similar and "
"unobtrusive that you could actually pretend that each <classname>Glib::"
"ustring</classname> is a <classname>std::string</classname> and ignore the "
"rest of this section. But read on if you want to use languages other than "
"English in your application."
msgstr ""
"当你得知<application>gtkmm</application>没有在它的接口上使用<classname>std::"
"string</classname>而是使用了<classname>Glib::ustring</classname>的时候一定很"
"惊讶。<classname>Glib::ustring</classname>与<classname>std::string</"
"classname>非常相似，在某些场合，你甚至可以直接把它当做<classname>std::"
"string</classname>来使用，并忽略本节后面的内容。但是如果你希望在你的应用程序"
"中使用英语以外的语言的话，那么请继续读下去。"

#: C/index-in.docbook:472
msgid ""
"std::string uses 8 bits per character, but 8 bits aren't enough to encode "
"languages such as Arabic, Chinese, and Japanese. Although the encodings for "
"these languages have been specified by the <ulink url=\"http://www.unicode."
"org/\">Unicode Consortium</ulink>, the C and C++ languages do not yet "
"provide any standardised Unicode support for UTF-8 encoding. GTK and GNOME "
"chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::"
"ustring. It provides almost exactly the same interface as std::string, along "
"with automatic conversions to and from std::string."
msgstr ""
"std::string 对每个字符使用8位编码，但是这对于像阿拉伯语、汉语和日语这样的语言"
"来说，8位是不够的。尽管<ulink url=\"http://www.unicode.org/\">Unicode 协会</"
"ulink>已经详细定义了这些语言的编码，但是C和C++尚未为UTF-8编码提供任何标准化的"
"Unicode支持。GTK 和 GNOME 采用 UTF-8 编码来实现 Unicode，这就是 Glib::"
"ustring 所包装的东西。它提供了和 std::string 几乎相同的接口，以及和 std::"
"string 的自动类型转换的功能。"

#: C/index-in.docbook:477
msgid ""
"One of the benefits of UTF-8 is that you don't need to use it unless you "
"want to, so you don't need to retrofit all of your code at once. "
"<classname>std::string</classname> will still work for 7-bit ASCII strings. "
"But when you try to localize your application for languages like Chinese, "
"for instance, you will start to see strange errors, and possible crashes. "
"Then all you need to do is start using <classname>Glib::ustring</classname> "
"instead."
msgstr ""
"UTF-8 编码的优点之一是，如果不需要你可以不使用它，所以你不需要一次性的翻新你"
"的代码。<classname>std::string</classname> 还可以继续使用7位的 ASCII 字符串。"
"但是一旦你想本地化你的程序，比如说汉化，那你就会开始遇到各种奇怪的问题，可能"
"还会崩溃。那时，你所需要做的就是开始使用 <classname>Glib::ustring</"
"classname> 来取而代之。"

#: C/index-in.docbook:478
msgid ""
"Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For "
"instance, German umlauts are not in the ASCII range and need more than 1 "
"byte in the UTF-8 encoding. If your code contains 8-bit string literals, you "
"have to convert them to UTF-8 (e.g. the Bavarian greeting \"Grüß Gott\" "
"would be \"Gr\\xC3\\xBC\\xC3\\x9F Gott\")."
msgstr ""
"要注意的是 UTF-8 和其它一些8位的编码如 ISO-8859-1 并不兼容。比如，德语中的元"
"音变音并不在 ASCII 码的编码范围内，在 UTF-8 编码中需要额外的一个字节来表示。"
"如果你的代码中包含8位的字符串文字，你需要把它们转变成 UTF-8 编码 (比如，巴伐"
"利亚的问候语“Grüß Gott”可能会显示成“Gr\\xC3\\xBC\\xC3\\x9F Gott”)。"

#: C/index-in.docbook:479
msgid ""
"You should avoid C-style pointer arithmetic, and functions such as strlen(). "
"In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not "
"possible to assume that the next byte is another character. <classname>Glib::"
"ustring</classname> worries about the details of this for you so you can use "
"methods such as Glib::ustring::substr() while still thinking in terms of "
"characters instead of bytes."
msgstr ""
"你应该尽量避免 C 风格的指针算法，以及像 strlen() 这样的函数。在 UTF-8 编码"
"中，每个字符可能占1到6个字节，所以你并不能假定下一个字节一定是另一个字符。所"
"有的这些细节 <classname>Glib::ustring</classname> 都已经帮你考虑到了，所以你"
"可以从字符的层面上考虑使用 Glib::ustring::substr() 这样的函数，而不用再去考虑"
"字节这样的细节了。"

#: C/index-in.docbook:481
msgid ""
"Unlike the Windows UCS-2 Unicode solution, this does not require any special "
"compiler options to process string literals, and it does not result in "
"Unicode executables and libraries which are incompatible with ASCII ones."
msgstr ""
"不像 Windows 的 UCS-2 Unicode 解决方案，这并不需要编译器提供特别的选项来处理"
"这样字符串，也不会导致为 Unicode 编译的可执行文件或库与含为 ASCII 的不兼容之"
"类的问题。"

#: C/index-in.docbook:483
msgid ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring."
"html\">参考</ulink>"

#: C/index-in.docbook:485
msgid ""
"See the <link linkend=\"chapter-internationalization\">Internationalization</"
"link> section for information about providing the UTF-8 string literals."
msgstr ""
"要得到更多关于 UTF-8 字符的信息，请参考<link linkend=\"chapter-"
"internationalization\">国际化</link>这一节。"

#: C/index-in.docbook:490
msgid "Mixing C and C++ APIs"
msgstr "混合使用 C 和 C++ API"

#: C/index-in.docbook:491
msgid ""
"You can use C APIs which do not yet have convenient C++ interfaces. It is "
"generally not a problem to use C APIs from C++, and <application>gtkmm</"
"application> helps by providing access to the underlying C object, and "
"providing an easy way to create a C++ wrapper object from a C object, "
"provided that the C API is also based on the <classname>GObject</classname> "
"system."
msgstr ""
"你可以使用那些尚未提供 C++ 接口的 C API。对于 C++ 而言这一般不是什么问题，"
"<application>gtkmm</application> 可以提供帮助访问底层的 C 对象，并且也提供了"
"一个简单的方式来从一个 C 对象创建一个 C++ 封装的对象，当然，这个 C API 是需要"
"基于 <classname>GObject</classname> 系统的。"

#: C/index-in.docbook:502
#, no-wrap
msgid ""
"\n"
"Gtk::Button button(\"example\");\n"
"gtk_button_do_something_that_gtkmm_cannot(button.gobj());\n"
msgstr ""
"\n"
"Gtk::Button button(\"example\");\n"
"gtk_button_do_something_that_gtkmm_cannot(button.gobj());\n"

#: C/index-in.docbook:497
msgid ""
"To use a <application>gtkmm</application> instance with a C function that "
"requires a C <classname>GObject</classname> instance, use the C++ instance’s "
"<function>gobj()</function> function to obtain a pointer to the underlying C "
"instance. For example: <_:programlisting-1/>"
msgstr ""
"要用 C 函数使用一个 <application>gtkmm</application> 实例需要一个 C "
"<classname>GObject</classname> 实例，使用C++的<function>gobj()</function>接口"
"函数可以得到一个底层 GObject 实例的指针。例如：<_:programlisting-1/>"

#: C/index-in.docbook:514
#, no-wrap
msgid ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"
"button-&gt;set_label(\"Now I speak C++ too!\");\n"
msgstr ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"
"button-&gt;set_label(\"Now I speak C++ too!\");\n"

#: C/index-in.docbook:521
msgid ""
"it's a widget or other class that inherits from <classname>Gtk::Object</"
"classname>, and"
msgstr ""
"它是一个部件或者是继承自<classname>Gtk::Object</classname>的其他类，并且"

#: C/index-in.docbook:522
msgid ""
"the C instance has a floating reference when the wrapper is created, and"
msgstr "当封装被创建的时候C示例拥有一个浮动引用，并且"

#: C/index-in.docbook:523
msgid ""
"<function>Gtk::manage()</function> has not been called on it (which includes "
"if it was created with <function>Gtk::make_managed()</function>), or"
msgstr ""
"并未在其上调用<function>Gtk::manage()</function>(包括使用<function>Gtk::"
"make_managed()</function>创建的) ，或者"

#: C/index-in.docbook:524
msgid ""
"<function>Gtk::manage()</function> was called on it, but it was never added "
"to, or was later removed from, its parent."
msgstr ""
"在其上调用了<function>Gtk::manage()</function>，但是从未将其加入到父项中，也"
"从未将其从父项中删除。"

#: C/index-in.docbook:508
msgid ""
"To obtain a <application>gtkmm</application> instance from a C "
"<classname>GObject</classname> instance, use one of the many overloaded "
"<function>Glib::wrap()</function> functions. The C instance’s reference "
"count is not incremented, unless you set the optional <parameter>take_copy</"
"parameter> argument to <literal>true</literal>. For example: <_:"
"programlisting-1/> The C++ wrapper shall be explicitly deleted if <_:"
"itemizedlist-2/> <function>Glib::wrap()</function> binds the C and C++ "
"instances to each other. Don't delete the C++ instance before you want the C "
"instance to die."
msgstr ""
"要从C的<classname>GObject</classname>实例获得一个<application>gtkmm</"
"application>，请使用许多个<function>Glib::wrap()</function>函数的其中一个重"
"载。除非你将可选的<parameter>take_copy</parameter>参数设置为<literal>true</"
"literal>，否则C实例的引用计数将不会增加。例如：<_:programlisting-1/> 如果<_:"
"itemizedlist-2/> <function>Glib::wrap()</function>将C和C++示例相互绑定，则应"
"明确删除C++包装器。请不要在C示例死亡前删除C++实例。"

#: C/index-in.docbook:529
msgid ""
"In all other cases the C++ instance is automatically deleted when the last "
"reference to the C instance is dropped. This includes all <function>Glib::"
"wrap()</function> overloads that return a <classname>Glib::RefPtr</"
"classname>."
msgstr ""
"在所有其他情况下，当删除对C实例的最后一个引用时，C++实例将会自动被删除。这包"
"括所有的<function>Glib::wrap()</function>所返回的<classname>Glib::RefPtr</"
"classname>。"

#: C/index-in.docbook:536
msgid "Hello World in <application>gtkmm</application>"
msgstr "用 <application>gtkmm</application> 写 Hello World"

#: C/index-in.docbook:538
msgid ""
"We've now learned enough to look at a real example. In accordance with an "
"ancient tradition of computer science, we now introduce Hello World, a la "
"<application>gtkmm</application>:"
msgstr ""
"目前我们已经可以自己所学的知识来写一个真正的程序了。根据计算机科学的传统，我"
"们现在以 <application>gtkmm</application> 的方式来介绍 Hello World 程序："

#: C/index-in.docbook:543
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/helloworld\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/helloworld\">源代码</ulink>"

#: C/index-in.docbook:545
msgid ""
"Try to compile and run it before going on. You should see something like "
"this:"
msgstr "在继续讲解之前，可以尝试着编译并运行这个程序，你会看到这样的结果："

#: C/index-in.docbook:550
msgid "Hello World"
msgstr "Hello World"

#: C/index-in.docbook:556
msgid ""
"Pretty thrilling, eh? Let's examine the code. First, the "
"<classname>HelloWorld</classname> class:"
msgstr ""
"真让人激动，不是吗？让我们回过头来看一下代码。首先看一下 "
"<classname>HelloWorld</classname> 类："

#: C/index-in.docbook:561
#, no-wrap
msgid ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"public:\n"
"  HelloWorld();\n"
"  ~HelloWorld() override;\n"
"\n"
"protected:\n"
"  //Signal handlers:\n"
"  void on_button_clicked();\n"
"\n"
"  //Member widgets:\n"
"  Gtk::Button m_button;\n"
"};"
msgstr ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"public:\n"
"  HelloWorld();\n"
"  ~HelloWorld() override;\n"
"\n"
"protected:\n"
"  //Signal handlers:\n"
"  void on_button_clicked();\n"
"\n"
"  //Member widgets:\n"
"  Gtk::Button m_button;\n"
"};"

#: C/index-in.docbook:575
msgid ""
"This class implements the \"Hello World\" window. It's derived from "
"<classname>Gtk::Window</classname>, and has a single <classname>Gtk::Button</"
"classname> as a member. We've chosen to use the constructor to do all of the "
"initialisation work for the window, including setting up the signals. Here "
"it is, with the comments omitted:"
msgstr ""
"这个类实现了“Hello World”窗口。它由 <classname>Gtk::Window</classname> 派生，"
"并且只有一个 <classname>Gtk::Button</classname> 成员。我们已经使用构造函数为"
"该窗口完成了所有的初始化工作，包括挂接消息。在这，已经去掉注释的代码："

#: C/index-in.docbook:584
#, no-wrap
msgid ""
"HelloWorld::HelloWorld()\n"
": m_button(\"Hello World\")\n"
"{\n"
"  m_button.set_margin(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  set_child(m_button);\n"
"}"
msgstr ""
"HelloWorld::HelloWorld()\n"
": m_button(\"Hello World\")\n"
"{\n"
"  m_button.set_margin(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  set_child(m_button);\n"
"}"

#: C/index-in.docbook:593
msgid ""
"Notice that we've used an initialiser statement to give the "
"<literal>m_button</literal> object the label \"Hello World\"."
msgstr ""
"注意，我们使用初始化列表的方式给 <literal>m_button</literal> 对象添加了一"
"个“Hello World”的标签。"

#: C/index-in.docbook:598
msgid ""
"Next we call the Button's <methodname>set_margin()</methodname> method. This "
"sets the amount of space around the button."
msgstr ""
"接下来调用 Button 类的 <methodname>set_margin()</methodname> 方法。这将设置按"
"钮周围空间的大小。"

#: C/index-in.docbook:603
msgid ""
"We then hook up a signal handler to <literal>m_button</literal>'s "
"<literal>clicked</literal> signal. This prints our friendly greeting to "
"<literal>stdout</literal>."
msgstr ""
"然后，把 <literal>m_button</literal> 的 <literal>clicked</literal> 信号挂接到"
"信号处理函数上。这会向 <literal>stdout</literal> (标准输出) 打印出友好的问候"
"语。"

#: C/index-in.docbook:608
msgid ""
"Next, we use the Window's <methodname>set_child()</methodname> method to put "
"<literal>m_button</literal> in the Window. The <methodname>set_child()</"
"methodname> method places the Widget in the Window."
msgstr ""
"接下来调用 Windows 类的 <methodname>set_child()</methodname> 方法将"
"<literal>m_button</literal>放入窗口。<methodname>set_child()</methodname>方法"
"会将部件放入窗口中。"

#: C/index-in.docbook:614
msgid ""
"Now let's look at our program's <function>main()</function> function. Here "
"it is, without comments:"
msgstr "现在让我们来看看程序中没有注释过的 <function>main()</function> 函数："

#: C/index-in.docbook:619
#, no-wrap
msgid ""
"int main(int argc, char* argv[])\n"
"{\n"
"  auto app = Gtk::Application::create(\"org.gtkmm.example\");\n"
"  HelloWorld helloworld;\n"
"  return app-&gt;run(helloworld, argc, argv);\n"
"}"
msgstr ""
"int main(int argc, char* argv[])\n"
"{\n"
"  auto app = Gtk::Application::create(\"org.gtkmm.example\");\n"
"  HelloWorld helloworld;\n"
"  return app-&gt;run(helloworld, argc, argv);\n"
"}"

#: C/index-in.docbook:626
msgid ""
"First we instantiate an object stored in a <classname>RefPtr</classname> "
"smartpointer called <literal>app</literal>. This is of type <classname>Gtk::"
"Application</classname>. Every <application>gtkmm</application> program must "
"have one of these."
msgstr ""
"我们首先实例化一个储存在名为 <literal>app</literal> 的<classname>RefPtr</"
"classname>智能指针对象，它的类型为 <classname>Gtk::Application</classname> 。"
"每一个 <application>gtkmm</application> 程序都有这样的一个东西。"

#: C/index-in.docbook:631
msgid ""
"Next we make an object of our <classname>HelloWorld</classname> class, whose "
"constructor takes no arguments, but it isn't visible yet. When we call "
"<methodname>Gtk::Application::run()</methodname>, giving it the helloworld "
"Window and the command-line arguments, it shows the Window and starts the "
"<application>gtkmm</application> <emphasis>event loop</emphasis>. During the "
"event loop <application>gtkmm</application> idles, waiting for actions from "
"the user, and responding appropriately. When the user closes the Window, "
"<methodname>run()</methodname> will return, causing the final line of our "
"<function>main()</function> function be to executed. The application will "
"then finish."
msgstr ""
"接着我们创建了 <classname>HelloWorld</classname> 类的对象，它的构造函数没有参"
"数，当然，它现在还不是可视的。当我们调用<methodname>Gtk::Application::run()</"
"methodname>并给它提供一个 helloworld 窗口和命令行参数时，它将显示这个窗口并进"
"入 <application>gtkmm</application><emphasis>消息循环</emphasis>。在消息循环"
"中，<application>gtkmm</application> 是空闲的，它等待用户的操作并作出相应的反"
"应。当用户关闭窗口时，<methodname>run()</methodname> 函数将返回，导致"
"<function>main()</function>函数的最后一行将被执行。然后程序就结束了。"

#: C/index-in.docbook:640
msgid ""
"Like the simple example we showed earlier, this Hello World program does not "
"use the command-line parameters. It's not necessary to pass them to "
"<methodname>run()</methodname>."
msgstr ""
"就像我们之前显示的简单示例一样，这个 Hello World 程序不实用命令行参数。不需要"
"将其传递给<methodname>run()</methodname>。"

#: C/index-in.docbook:649
msgid "Changes in <application>gtkmm</application> 3"
msgstr "<application>gtkmm</application>3中的变更"

#: C/index-in.docbook:651
msgid ""
"<application>gtkmm</application>-3.0 is an old version of the "
"<application>gtkmm</application> API that installs in parallel with the "
"still older <application>gtkmm</application>-2.4 API and the new "
"<application>gtkmm</application>-4.0 API. The last version of the "
"<application>gtkmm</application>-2.4 API was <application>gtkmm</"
"application> 2.24. <application>gtkmm</application> 3 has no major "
"fundamental differences to <application>gtkmm</application> 2 but does make "
"several small changes that were not possible while maintaining binary "
"compatibility. If you never used the <application>gtkmm</application>-2.4 "
"API then you can safely ignore this chapter."
msgstr ""
"<application>gtkmm</application>-3.0是<application>gtkmm</application> API的"
"旧版本它依旧能与<application>gtkmm</application>-2.4和新的"
"<application>gtkmm</application>-4.0 API并行安装。<application>gtkmm</"
"application>-2.4 API的最新版本是<application>gtkmm</application> 2.24。"
"<application>gtkmm</application>3于<application>gtkmm</application>2之间并没"
"有重大的改变，但确实存在一些微小的变动，这些变动导致无法做到令他们保持二进制"
"兼容。如果你从未用过<application>gtkmm</application>-2.4 API 则你可以放心的忽"
"略本章。"

#: C/index-in.docbook:653
msgid ""
"<application>gtkmm</application> 3's library is called "
"<literal>libgtkmm-3.0</literal> rather than <literal>libgtkmm-2.4</literal> "
"and installs its headers in a similarly-versioned directory, so your pkg-"
"config check should ask for <literal>gtkmm-3.0</literal> rather than "
"<literal>gtkmm-2.4</literal>."
msgstr ""
"<application>gtkmm</application>3库调用<literal>libgtkmm-3.0</literal>而不是"
"<literal>libgtkmm-2.4</literal> 并将其的头文件安装于类似的目录下，所以你的"
"pkg-config应该检索<literal>gtkmm-3.0</literal>而不是<literal>gtkmm-2.4</"
"literal>。"

#: C/index-in.docbook:656
msgid "<application>gtkmm</application> 3 added some new classes:"
msgstr "<application>gtkmm</application>3添加了一些新的类："

#: C/index-in.docbook:659
msgid ""
"<classname>Gtk::AppChooser</classname>, <classname>Gtk::AppChooserButton</"
"classname>, <classname>Gtk::AppChooserDialog</classname> allow the user to "
"select an installed application to open a particular type of content."
msgstr ""
"<classname>Gtk::AppChooser</classname>，<classname>Gtk::AppChooserButton</"
"classname>,<classname>Gtk::AppChooserDialog</classname>允许用户选择已安装的应"
"用程序用以打开特定类型的内容。"

#: C/index-in.docbook:660
msgid ""
"<classname>Gtk::Grid</classname> is a new container widget that will "
"eventually replace <classname>Gtk::Box</classname> and <classname>Gtk::"
"Table</classname>. It arranges its children according to properties of those "
"children rather than its own layout details."
msgstr ""
"<classname>Gtk::Grid</classname>是一个新的容器部件他将在未来完全替换"
"<classname>Gtk::Box</classname>和<classname>Gtk::Table</classname>。它根据它"
"的子项的属性而不是自身的布局属性对子项进行排列。"

#: C/index-in.docbook:661
msgid ""
"<classname>Gtk::Switch</classname> displays On/Off states more explictly "
"than <classname>Gtk::CheckButton</classname>. It may be useful, for "
"instance, when allowing users to activate hardware."
msgstr ""
"与<classname>Gtk::CheckButton</classname>相比<classname>Gtk::Switch</"
"classname>更明确的显示开/关状态。例如，在允许用户激活硬件的时候，他可能很有"
"用。"

#: C/index-in.docbook:664
msgid ""
"<application>gtkmm</application> 3 also made several small changes to the "
"API, which you will probably encounter when porting code that used "
"<application>gtkmm</application>-2.4. Here is a short list:"
msgstr ""
"<application>gtkmm</application>3还对API进行了一些小的变更，在移植"
"<application>gtkmm</application>-2.4的代码的时候你可能会遇到这些变更。这是一"
"个简短的清单："

#: C/index-in.docbook:669
msgid ""
"<classname>Gtk::CellLayout</classname>, used by <classname>Gtk::IconView</"
"classname>, <classname>Gtk::TreeView::Column</classname> and <classname>Gtk::"
"ComboBox</classname>, now has a <classname>Gtk::CellArea</classname> which "
"can be used to specify more details of how the <classname>CellRenderer</"
"classname>s are arranged and aligned."
msgstr ""
"<classname>Gtk::IconView</classname>， <classname>Gtk::TreeView::Column</"
"classname>和<classname>Gtk::ComboBox</classname>使用<classname>Gtk::"
"CellLayout</classname>，现在有<classname>Gtk::CellArea</classname>可以用于指"
"示<classname>CellRenderer</classname>的排列与对齐方式的详情。"

#: C/index-in.docbook:671
msgid ""
"Gtk::ComboBox now derives from CellLayout, allowing easier layout and "
"alignment of its <classname>Gtk::CellRenderer</classname>s."
msgstr ""
"Gtk::ComboBox现在从CellLayout派生，从而使更容易对<classname>Gtk::"
"CellRenderer</classname>进行布局与对齐。"

#: C/index-in.docbook:673
msgid ""
"<classname>Gtk::Adjustment</classname> and <classname>IconSet</classname> "
"and <classname>Gdk::Cursor</classname> are now used via <classname>Glib::"
"RefPtr</classname>."
msgstr ""
"<classname>Gtk::Adjustment</classname>和<classname>Gtk::IconSet</classname>类"
"和<classname>Gdk::Cursor</classname>类现在通过<classname>Glib::RefPtr</"
"classname>使用。"

#: C/index-in.docbook:675
msgid ""
"<classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>, "
"<classname>Gtk::IconView</classname>, <classname>Gtk::Paned</classname>, "
"<classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</"
"classname>, <classname>Gtk::Scrollbar</classname> and <classname>Gtk::"
"Separator</classname> now derive from <classname>Gtk::Orientable</"
"classname>, allowing their orientation (vertical or horizontal) to be "
"specified without requiring the use of a derived class such as "
"<classname>Gtk::HBox</classname>."
msgstr ""
"<classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>,"
"<classname>Gtk::IconView</classname>, <classname>Gtk::Paned</classname>, "
"<classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</"
"classname>, <classname>Gtk::Scrollbar</classname>和<classname>Gtk::"
"Separator</classname>现在从<classname>Gtk::Orientable</classname>派生，允许在"
"不使用派生类(例如<classname>Gtk::HBox</classname>)的情况指定其方向(垂直或者水"
"平)。"

#: C/index-in.docbook:678
msgid ""
"<classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, "
"<classname>Gtk::TreeView</classname> and other widgets derive from "
"Scrollable instead of having their own methods such as "
"<methodname>get_vadjustment()</methodname> and instead of having their own "
"set_scroll_adjustments signal."
msgstr ""
"<classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, "
"<classname>Gtk::TreeView</classname>和其他部件派生自Scrollable而不使用他们自"
"己的方法，例如<methodname>get_vadjustment()</methodname>拥有自己的"
"set_scroll_adjustments信号。"

#: C/index-in.docbook:680
msgid ""
"<classname>Gtk::Style</classname> and <classname>Gtk::Rc</classname> were "
"removed, replaced by <classname>Gtk::StyleContext</classname>, and "
"<classname>Gtk::StyleProvider</classname>s, such as <classname>Gtk::"
"CssProvider</classname>."
msgstr ""
"<classname>Gtk::Style</classname>和<classname>Gtk::Rc</classname>已被删除，由"
"<classname>Gtk::StyleContext</classname>和<classname>Gtk::StyleProvider</"
"classname>替换，例如<classname>Gtk::CssProvider</classname>。"

#: C/index-in.docbook:682
msgid ""
"Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes "
"that cairomm is used for drawing, via the provided <classname>Cairo::"
"Context</classname> and does not require you to call <methodname>Cairo::"
"Context::clip()</methodname>."
msgstr ""
"Widget::on_expose_event()被Widget::on_draw()取代，通过提供的"
"<classname>Cairo::Context</classname>使用cairomm进行绘制，并且不需要你自己调"
"用<methodname>Cairo::Context::clip()</methodname>。"

#: C/index-in.docbook:684
msgid ""
"<classname>Gdk::RGBA</classname> replaces <classname>Color</classname>, "
"adding an alpha component for opacity. <classname>Colormap</classname> was "
"removed, along with its awkward use to allocate colors."
msgstr ""
"<classname>Color</classname>被<classname>Gdk::RGBA</classname>替代，添加alpha"
"分量以支持透明度。<classname>Colormap</classname>与其笨拙的颜色分配方式一并被"
"删除。"

#: C/index-in.docbook:686
msgid ""
"<classname>Gdk::Pixmap</classname> and <classname>Gdk::Bitmap</classname> "
"were removed in favour of <classname>Gdk::Pixbuf</classname>."
msgstr ""
"<classname>Gdk::Pixmap</classname>和<classname>Gdk::Bitmap</classname>现在被"
"<classname>Gdk::Pixbuf</classname>所取代。"

#: C/index-in.docbook:688
msgid ""
"<classname>Gdk::Drawable</classname> was removed, with its methods moving "
"into <classname>Gdk::Window</classname>."
msgstr ""
"<classname>Gdk::Drawable</classname>被删除，与其有关的方法被移动到了"
"<classname>Gdk::Window</classname>。"

#: C/index-in.docbook:690
msgid ""
"We now use std::vector in several methods instead of the intermediate "
"*Handle types to make the API clearer."
msgstr "我们现在使用std::vector而不是使用中间类型(*Handle)以使API更加的清晰。"

#: C/index-in.docbook:695
msgid ""
"All deprecated API was removed in <application>gtkmm</application> 3.0, "
"though there have been new deprecations in later <application>gtkmm</"
"application> 3.x versions."
msgstr ""
"在<application>gtkmm</application> 3.0中我们删除了所有弃用的API，尽管在"
"<application>gtkmm</application> 3.x版本中出现了新的被弃用的API。"

#: C/index-in.docbook:697
msgid ""
"As a first step to porting your source code to <application>gtkmm</"
"application>-3.0 you should probably ensure that your application builds "
"with the deprecated <application>gtkmm</application>-2.4 API disabled, by "
"defining macro such as GTKMM_DISABLE_DEPRECATED. There are some autotools "
"macros that can help with this by defining them optionally at build time. "
"See the <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"PortingToGtkmm3\">gtkmm 3 porting wiki page</ulink> for more details."
msgstr ""
"将源代码迁移到<application>gtkmm</application>-3.0的第一步，你应该通过定义"
"GTKMM_DISABLE_DEPRECATED宏以检查你是否使用了在<application>gtkmm</"
"application>-2.4中被弃用的API,然后删除他们。有一些autotools宏可以在编译时帮助"
"你通过构建。访问<ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"PortingToGtkmm3\">gtkmm3移植Wiki</ulink>了解更多详情。"

#: C/index-in.docbook:702
msgid ""
"Changes in <application>gtkmm</application>-4.0 and "
"<application>glibmm-2.68</application>"
msgstr ""
"<application>gtkmm</application>-4.0和<application>glibmm-2.68</application>"
"中的变更。"

#: C/index-in.docbook:704
msgid ""
"<application>gtkmm</application>-4.0 is a new version of the "
"<application>gtkmm</application> API that installs in parallel with the "
"older <application>gtkmm</application>-2.4 and <application>gtkmm</"
"application>-3.0 APIs. The last version of the <application>gtkmm</"
"application>-3.0 API is <application>gtkmm</application> 3.24. "
"<application>gtkmm</application> 4 has no major fundamental differences to "
"<application>gtkmm</application> 3 but does make several changes (both small "
"and large ones) that were not possible while maintaining binary "
"compatibility. If you never used the <application>gtkmm</application>-3.0 "
"API then you can safely ignore this chapter."
msgstr ""
"<application>gtkmm</application>-4.0是<application>gtkmm</application> API的"
"新版本。它可以与较早发行的<application>gtkmm</application>-2.4和"
"<application>gtkmm</application>-3.0并行安装。<application>gtkmm</"
"application>-3.0 API的最新版本是<application>gtkmm</application> 3.24。"
"<application>gtkmm</application> 4与<application>gtkmm</application> 3没有根"
"本性的区别，虽然有些变更但是保持了二进制兼容。如果你从未使用过"
"<application>gtkmm</application>-3.0 API则你可以放心的忽略本章。"

#: C/index-in.docbook:712
msgid ""
"<application>gtkmm</application> 4's library is called "
"<literal>libgtkmm-4.0</literal> rather than <literal>libgtkmm-3.0</literal> "
"and installs its headers in a similarly-versioned directory, so your "
"<application>pkg-config</application> check should ask for "
"<literal>gtkmm-4.0</literal> rather than <literal>gtkmm-3.0</literal>."
msgstr ""
"<application>gtkmm</application> 4库调用<literal>libgtkmm-4.0</literal>而不是"
"<literal>libgtkmm-3.0</literal>，并将其的头文件安装于类似的目录下，所以你的"
"<application>pkg-config</application>应该检索<literal>gtkmm-4.0</literal>而不"
"是<literal>gtkmm-3.0</literal>。"

#: C/index-in.docbook:718
msgid ""
"<application>gtkmm</application>-4.0 is used in combination with "
"<application>glibmm-2.68</application>, which sets the global locale for "
"your program. The older <application>glibmm-2.4</application> does not do "
"that, and <application>gtkmm</application>-3.0 does it only to some extent. "
"What this means is briefly that if your <application>gtkmm</application>-3.0 "
"program contains a call to <function>std::locale::global(std::locale(\"\"))</"
"function>, you can probably remove it. If you don't want "
"<application>glibmm</application> or <application>gtkmm</application> to set "
"the global locale for you, you should add a call to <function>Glib::"
"set_init_to_users_preferred_locale(false)</function> before any call to "
"<function>Glib::init()</function> or <methodname>Gtk::Application::create()</"
"methodname>."
msgstr ""
"<application>gtkmm</application>-4.0与<application>glibmm-2.68</application>"
"结合使用，将设置程序的全局语言环境。较旧的<application>glibmm-2.4</"
"application>不会这样做，而<application>gtkmm</application>-3.0只在一定程度上"
"做到了。简而言之，如果你的<application>gtkmm</application>-3.0应用包含了对"
"<function>std::locale::global(std::locale(\"\"))</function>的调用，则你大概率"
"可以直接将其删除。如果你不希望<application>glibmm</application>或者"
"<application>gtkmm</application>为你设置程序的全局语言环境，则应该在调用任何"
"<function>Glib::init()</function>函数或<methodname>Gtk::Application::"
"create()</methodname>方法之前添加对<function>Glib::"
"set_init_to_users_preferred_locale(false)</function>的调用。"

#: C/index-in.docbook:728
msgid ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/namespaceGlib.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/namespaceGlib.html\">"
"参考</ulink>"

#: C/index-in.docbook:730
msgid ""
"There are lots and lots of differences between <application>gtkmm</"
"application>-3.0 and <application>gtkmm</application>-4.0. The following "
"lists are not complete."
msgstr ""
"<application>gtkmm</application>-3.0和<application>gtkmm</application>-4.0之"
"间有很多不同之处。以下是不完整的列表。"

#: C/index-in.docbook:733
msgid ""
"Some new classes were added in <application>gtkmm</application> 4 and "
"<application>glibmm</application> 2.68:"
msgstr ""
"在<application>gtkmm</application> 4和<application>glibmm</application> 2.68"
"中添加了一些新的类："

#: C/index-in.docbook:736
msgid ""
"<classname>Glib::ExtraClassInit</classname> and <classname>Gtk::Snapshot</"
"classname>: These classes are needed only for writing custom widgets. See "
"the <link linkend=\"sec-custom-widgets\">Custom Widgets</link> section."
msgstr ""
"<classname>Glib::ExtraClassInit</classname>和<classname>Gtk::Snapshot</"
"classname>：这些类只用于编写自定义的窗口小部件。参见<link linkend=\"sec-"
"custom-widgets\">自定义部件</link>小节。"

#: C/index-in.docbook:739
msgid ""
"<classname>Gtk::EventControllerKey</classname>, <classname>Gtk::"
"EventControllerMotion</classname>, <classname>Gtk::EventControllerScroll</"
"classname> and <classname>Gtk::GestureStylus</classname>"
msgstr ""
"<classname>Gtk::EventControllerKey</classname>, <classname>Gtk::"
"EventControllerMotion</classname>, <classname>Gtk::EventControllerScroll</"
"classname>和<classname>Gtk::GestureStylus</classname>"

#: C/index-in.docbook:742
msgid ""
"<classname>Gdk::Paintable</classname>, <classname>Gdk::Texture</classname>, "
"<classname>Gtk::Picture</classname> and <classname>Gtk::WidgetPaintable</"
"classname>"
msgstr ""
"<classname>Gdk::Paintable</classname>, <classname>Gdk::Texture</classname>, "
"<classname>Gtk::Picture</classname>和<classname>Gtk::WidgetPaintable</"
"classname>"

#: C/index-in.docbook:745
msgid ""
"<classname>Gdk::Window</classname> has been renamed to <classname>Gdk::"
"Surface</classname>. (<classname>Gtk::Window</classname> keeps its name.)"
msgstr ""
"<classname>Gdk::Window</classname>被重命名为<classname>Gdk::Surface</"
"classname>(<classname>Gtk::Window</classname>名称保持不变)。"

#: C/index-in.docbook:747
msgid ""
"<classname>Gdk::DrawContext</classname> and <classname>Gdk::CairoContext</"
"classname> are new. <classname>Gdk::DrawingContext</classname> has been "
"removed."
msgstr ""
"新添加了<classname>Gdk::DrawContext</classname>和<classname>Gdk::"
"CairoContext</classname>。<classname>Gdk::DrawingContext</classname>已被删"
"除。"

#: C/index-in.docbook:749
msgid ""
"<classname>Gtk::Clipboard</classname> has been replaced by the new "
"<classname>Gdk::Clipboard</classname>."
msgstr ""
"<classname>Gtk::Clipboard</classname>被新的<classname>Gdk::Clipboard</"
"classname>替换。"

#: C/index-in.docbook:751
msgid ""
"<classname>Gdk::DragContext</classname> has been split into <classname>Gdk::"
"Drag</classname> and <classname>Gdk::Drop</classname>."
msgstr ""
"<classname>Gdk::DragContext</classname>现在被拆分为<classname>Gdk::Drag</"
"classname>和<classname>Gdk::Drop</classname>。"

#: C/index-in.docbook:755
msgid ""
"There have also been several changes to the API, which you will probably "
"encounter when porting code that used <application>gtkmm</application>-3.0 "
"and <application>glibmm</application>-2.4. Here is a short list:"
msgstr ""
"API也进行了一些更改，在移植<application>gtkmm</application>-3.0和"
"<application>glibmm</application>-2.4代码时你可能会遇到这些更改。以下是一个简"
"短的变更列表："

#: C/index-in.docbook:760
msgid "A C++17 compiler is required."
msgstr "需要支持C++17的编译器"

#: C/index-in.docbook:761
msgid ""
"<classname>Gtk::Button</classname>, <classname>Gtk::ToolButton</classname>, "
"<classname>Gtk::MenuItem</classname> and <classname>Gtk::Switch</classname> "
"implement the <classname>Gtk::Actionable</classname> interface instead of "
"the removed <classname>Gtk::Activatable</classname> interface."
msgstr ""
"<classname>Gtk::Button</classname>，<classname>Gtk::ToolButton</classname>，"
"<classname>Gtk::MenuItem</classname>和<classname>Gtk::Switch</classname> 实现"
"了<classname>Gtk::Actionable</classname>接口而不是已被删除的<classname>Gtk::"
"Activatable</classname>接口。"

#: C/index-in.docbook:765
msgid ""
"<classname>Gtk::FontButton</classname> implements the <classname>Gtk::"
"FontChooser</classname> interface."
msgstr ""
"<classname>Gtk::FontButton</classname>实现了<classname>Gtk::FontChooser</"
"classname>接口。"

#: C/index-in.docbook:766
msgid ""
"<classname>Gtk::Widget</classname>: The <methodname>get_preferred_*_vfunc()</"
"methodname>s have been replaced by <methodname>measure_vfunc()</methodname>. "
"This change only affects custom widgets."
msgstr ""
"<classname>Gtk::Widget</classname>：<methodname>get_preferred_*_vfunc()</"
"methodname>方法已被<methodname>measure_vfunc()</methodname>方法替代。此变更只"
"影响自定义部件。"

#: C/index-in.docbook:769
msgid ""
"<classname>sigc::slot</classname>s use the <classname>sigc::slot&lt;"
"R(Args...)&gt;</classname> syntax. Example: <classname>sigc::slot&lt;"
"void(int, int)&gt;</classname> instead of <classname>sigc::slot&lt;void, "
"int, int&gt;</classname>."
msgstr ""
"<classname>sigc::slot</classname>使用<classname>sigc::slot&lt;R(Args...)&gt;"
"</classname>语法。 例如： <classname>sigc::slot&lt;void(int, int)&gt;</"
"classname>而不是使用<classname>sigc::slot&lt;void, int, int&gt;</classname>。"

#: C/index-in.docbook:771
msgid ""
"<classname>Gtk::DrawingArea</classname> uses a draw function instead of the "
"draw signal."
msgstr "<classname>Gtk::DrawingArea</classname>使用绘制函数替代绘制信号。"

#: C/index-in.docbook:772
msgid ""
"<classname>Glib::ArrayHandle</classname>, <classname>Glib::"
"StringArrayHandle</classname>, <classname>Glib::ListHandle</classname> and "
"<classname>Glib::SListHandle</classname> have been removed. They were used "
"in <application>glibmm</application>-2.4, but not used in "
"<application>gtkmm</application>-3.0. If you've ever used these classes, "
"replace them with a standard C++ container, such as <classname>std::vector</"
"classname>."
msgstr ""
"<classname>Glib::ArrayHandle</classname>, <classname>Glib::"
"StringArrayHandle</classname>, <classname>Glib::ListHandle</classname>和"
"<classname>Glib::SListHandle</classname>已被删除。他们曾在"
"<application>glibmm</application>-2.4中被使用，而<application>gtkmm</"
"application>-3.0并未使用他们。如果你曾经使用过他们，则将他们替换为标准C++容"
"器，例如<classname>std::vector</classname>。"

#: C/index-in.docbook:776
msgid "<classname>Gtk::Container</classname> has been removed."
msgstr "<classname>Gtk::Container</classname>已被删除。"

#: C/index-in.docbook:777
msgid ""
"<methodname>Gtk::Widget::show_all()</methodname> has been removed. The "
"default value of <methodname>Gtk::Widget::property_visible()</methodname>has "
"been changed from <literal>false</literal> to <literal>true</literal>."
msgstr ""
"<methodname>Gtk::Widget::show_all()</methodname>已被删除。<methodname>Gtk::"
"Widget::property_visible()</methodname>的默认值从<literal>false</literal>改为"
"<literal>true</literal>。"

#: C/index-in.docbook:780
msgid ""
"All event signals have been removed from <classname>Gtk::Widget</classname>. "
"In most cases you can use one of the subclasses of <classname>Gtk::"
"EventController</classname> as a replacement. For instance, use "
"<classname>Gtk::GestureMultiPress</classname> instead of "
"<methodname>signal_button_press_event()</methodname> and "
"<methodname>signal_button_release_event()</methodname>, and <classname>Gtk::"
"EventControllerKey</classname> instead of "
"<methodname>signal_key_press_event()</methodname> and "
"<methodname>signal_key_release_event()</methodname>."
msgstr ""
"<classname>Gtk::Widget</classname>上的所有事件信号均已被删除。 大多数时候你可"
"以使用<classname>Gtk::EventController</classname>的子类之一进行替换。例如, 使"
"用<classname>Gtk::GestureMultiPress</classname>替代"
"<methodname>signal_button_press_event()</methodname>以及"
"<methodname>signal_button_release_event()</methodname>，使用<classname>Gtk::"
"EventControllerKey</classname>替代<methodname>signal_key_press_event()</"
"methodname>和<methodname>signal_key_release_event()</methodname>。"

#: C/index-in.docbook:787
msgid ""
"<classname>Glib::RefPtr</classname> is an alias for <classname>std::"
"shared_ptr</classname>. If you make your own <classname>Glib::ObjectBase</"
"classname>-derived classes with <methodname>create()</methodname> methods "
"that return a <classname>Glib::RefPtr</classname>, you must use "
"<methodname>Glib::make_refptr_for_instance()</methodname> in your "
"<methodname>create()</methodname> methods."
msgstr ""
"<classname>Glib::RefPtr</classname>是<classname>std::shared_ptr</classname>的"
"别名。如果你使用返回<classname>Glib::RefPtr</classname>的"
"<methodname>create()</methodname>方法用以创建派生自<classname>Glib::"
"ObjectBase</classname>的类，则你必须在你的<methodname>create()</methodname>方"
"法中调用<methodname>Glib::make_refptr_for_instance()</methodname>。"

#: C/index-in.docbook:792
msgid ""
"<methodname>Gtk::Box::pack_start()</methodname> and <methodname>Gtk::Box::"
"pack_end()</methodname> have been removed. Use the new <classname>Gtk::Box</"
"classname> methods <methodname>append()</methodname>, <methodname>prepend()</"
"methodname>, <methodname>insert_child_after()</methodname> and "
"<methodname>insert_child_at_start()</methodname>."
msgstr ""
"<methodname>Gtk::Box::pack_start()</methodname>和<methodname>Gtk::Box::"
"pack_end()</methodname>已被删除。现在<classname>Gtk::Box</classname>使用新的"
"<methodname>append()</methodname>，<methodname>prepend()</methodname>，"
"<methodname>insert_child_after()</methodname>和"
"<methodname>insert_child_at_start()</methodname>方法。"

#: C/index-in.docbook:797
msgid "<classname>Gtk::ButtonBox</classname> has been removed."
msgstr "<classname>Gtk::ButtonBox</classname>已被删除"

#: C/index-in.docbook:798
msgid ""
"<classname>Gtk::RadioButton</classname> and <classname>Gtk::"
"RadioButtonGroup</classname> have been removed. Use <classname>Gtk::"
"CheckButton</classname> or <classname>Gtk::ToggleButton</classname> with "
"<methodname>set_group()</methodname>."
msgstr ""
"<classname>Gtk::RadioButton</classname>和<classname>Gtk::RadioButtonGroup</"
"classname>已被删除。改为使用<classname>Gtk::CheckButton</classname>或者是"
"<classname>Gtk::ToggleButton</classname>的<methodname>set_group()</"
"methodname>。"

#: C/index-in.docbook:804
msgid ""
"All deprecated API was removed in <application>gtkmm</application> 4.0 and "
"<application>glibmm</application> 2.68, though there will be new "
"deprecations in future versions."
msgstr ""
"<application>gtkmm</application>和<application>glibmm</application> 2.68移除"
"了所有之前标记为弃用的API，未来还会有新的API被标记为弃用。"

#: C/index-in.docbook:807
msgid ""
"As a first step to porting your source code to <application>gtkmm</"
"application>-4.0 you should probably ensure that your application builds "
"with the deprecated <application>gtkmm</application>-3.0 and "
"<application>glibmm-2.4</application> API disabled, by defining the macros "
"GTKMM_DISABLE_DEPRECATED, GDKMM_DISABLE_DEPRECATED, "
"GLIBMM_DISABLE_DEPRECATED and GIOMM_DISABLE_DEPRECATED. There are some "
"autotools macros that can help with this by defining them optionally at "
"build time. See the <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"PortingToGtkmm3\">Porting from gtkmm-2.4 to gtkmm-3.0</ulink> wiki page for "
"more details."
msgstr ""
"将源代码移植到<application>gtkmm</application>-4.0的第一步，通过定义"
"GTKMM_DISABLE_DEPRECATED，GDKMM_DISABLE_DEPRECATED，GLIBMM_DISABLE_DEPRECATED"
"和GIOMM_DISABLE_DEPRECATED宏禁用所有在<application>gtkmm</application>-3.0和"
"<application>glibmm-2.4</application>中弃用的API，有一些autotools宏可以帮助你"
"在编译时定义他们。更多有关详情请参见<ulink url=\"https://wiki.gnome.org/"
"Projects/gtkmm/PortingToGtkmm3\">从gtkmm-2.4迁移到gtkmm-3.0</ulink>Wiki页面。"

#: C/index-in.docbook:815
msgid ""
"See also <ulink url=\"https://developer.gnome.org/gtk4/unstable/gtk-"
"migrating-3-to-4.html\"> Migrating from GTK 3.x to GTK 4</ulink>."
msgstr ""
"另请参见<ulink url=\"https://developer.gnome.org/gtk4/unstable/gtk-"
"migrating-3-to-4.html\">从GTK3.X迁移到GTK 4</ulink>。"

#: C/index-in.docbook:821
msgid "Buttons"
msgstr "按钮(Buttons)"

#: C/index-in.docbook:823
msgid "<application>gtkmm</application> provides four basic types of buttons:"
msgstr "<application>gtkmm</application> 提供以下四种基本按钮控件："

#: C/index-in.docbook:830
msgid "Push buttons"
msgstr "按钮类"

#: C/index-in.docbook:832
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button."
"html\"><classname>Gtk::Button</classname></ulink>. Standard buttons, usually "
"marked with a label or picture. Pushing one triggers an action. See the "
"<link linkend=\"sec-pushbuttons\">Button</link> section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button."
"html\"><classname>Gtk::Button</classname></ulink>。这是标准按钮，通常标有文字"
"标签或者图片。按一下就会触发一个动作。参看 <link linkend=\"sec-pushbuttons"
"\">Button</link> 小节。"

#: C/index-in.docbook:839
msgid "Toggle buttons"
msgstr "开关按钮(ToggleButton)"

#: C/index-in.docbook:841
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ToggleButton.html\"><classname>Gtk::ToggleButton</classname></"
"ulink>. Unlike a normal Button, which springs back up, a ToggleButton stays "
"down until you press it again. It might be useful as an on/off switch. See "
"the <link linkend=\"sec-toggle-buttons\">ToggleButton</link> section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ToggleButton.html\"><classname>Gtk::ToggleButton</classname></"
"ulink>。和一般按下后会自动弹起的按钮不一样，ToggleButton 需要你再按一次才会弹"
"起。它作为一个开关可能比较有用。参看 <link linkend=\"sec-toggle-buttons"
"\">ToggleButton</link> 小节。"

#: C/index-in.docbook:849
msgid "Check buttons"
msgstr "复选按钮(CheckButtons)"

#: C/index-in.docbook:851
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1CheckButton.html\"><classname>Gtk::CheckButton</classname></"
"ulink>. These act like ToggleButtons, but show their state in small squares, "
"with their label at the side. They should be used in most situations which "
"require an on/off setting. See the <link linkend=\"sec-checkbuttons"
"\">CheckButton</link> section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1CheckButton.html\"><classname>Gtk::CheckButton</classname></"
"ulink>。它们用起来和 ToggleButtons 很像，只不过它们用一个小方块来显示自己的状"
"态，而且旁边还有一个文字标签。在大多数需要布尔值设置的情况都可以使用它。参看 "
"<link linkend=\"sec-checkbuttons\">CheckButton</link> 小节。"

#: C/index-in.docbook:861
msgid "Radio buttons"
msgstr "单选按钮(RadioButton)"

#: C/index-in.docbook:863
msgid ""
"Named after the station selectors on old car radios, these buttons are used "
"in groups for options which are mutually exclusive. Pressing one causes all "
"the others in its group to turn off. They are similar to ToggleButtons or "
"CheckButtons (a small widget with a label at the side), but usually look "
"different. There is no separate radio button class. Check buttons and toggle "
"buttons can act as radio buttons. See the <link linkend=\"sec-radio-buttons"
"\">Radio Button</link> section."
msgstr ""
"它是根据老式汽车内的收音机的选台器来命名的，选台器是一组选择按钮并且它们是互"
"斥的。按下其中任何一个都会使这一组中的其它按钮都弹起。它们的布局和 "
"CheckButton (一个旁边有标签的小部件)很相似，但是通常看起来不太一样。没有单独"
"的单选按钮类。复选按钮和开关按钮可以充当单选按钮。参见<link linkend=\"sec-"
"radio-buttons\">RadioButton</link> 小节。"

#: C/index-in.docbook:877
msgid ""
"Note that, due to GTK's theming system, the appearance of these widgets will "
"vary. In the case of check buttons and radio buttons, they may vary "
"considerably."
msgstr ""
"请注意，由于GTK的主题不同，这些控件外观可能会不同。特别是复选按钮和单选按钮可"
"能会很不一样。"

#: C/index-in.docbook:884
msgid "Button"
msgstr "按钮(Button)"

#: C/index-in.docbook:886
msgid ""
"There are two ways to create a Button. You can specify a label string in the "
"<classname>Gtk::Button</classname> constructor, or set it later with "
"<methodname>set_label()</methodname>."
msgstr ""
"可以通过两种方式来创建按钮，你可以在 <classname>Gtk::Button</classname> 构造"
"函数中指定标签字符串，或者以后调用 <methodname>set_label()</methodname> 来指"
"定标签。"

#: C/index-in.docbook:892
msgid ""
"To define an accelerator key for keyboard navigation, place an underscore "
"before one of the label's characters and specify <literal>true</literal> for "
"the optional <literal>mnemonic</literal> parameter. For instance:"
msgstr ""
"如果你想为按钮定义一个快捷键，那么可以在标签字符串中的某个字符前面加上一个下"
"划线，并且指定可选的参数助记符(mnemonic)为 true。例如："

#: C/index-in.docbook:894
#, no-wrap
msgid "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"
msgstr "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"

#: C/index-in.docbook:896
msgid ""
"<classname>Gtk::Button</classname> is also a container so you could put any "
"other widget, such as a <classname>Gtk::Image</classname> into it."
msgstr ""
"<classname>Gtk::Button</classname> 同时也是一个容器，因此你可以在其中放任何其"
"它的部件，比如放一个 <classname>Gtk::Image</classname> 在里面。"

#: C/index-in.docbook:902
msgid ""
"The <classname>Gtk::Button</classname> widget has the <literal>clicked</"
"literal> signal which is emitted when the button is pressed and released."
msgstr ""
"<classname>Gtk::Button</classname>部件具有<literal>clicked</literal>信号，当"
"按下或释放按钮时将会发出该信号。"

#: C/index-in.docbook:907
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button."
"html\">参考</ulink>"

#: C/index-in.docbook:909 C/index-in.docbook:962 C/index-in.docbook:1019
#: C/index-in.docbook:1137 C/index-in.docbook:1194 C/index-in.docbook:1502
#: C/index-in.docbook:1567 C/index-in.docbook:1591 C/index-in.docbook:1621
#: C/index-in.docbook:1676 C/index-in.docbook:1716 C/index-in.docbook:1757
#: C/index-in.docbook:1791 C/index-in.docbook:2077 C/index-in.docbook:2107
#: C/index-in.docbook:2161 C/index-in.docbook:2201 C/index-in.docbook:3874
#: C/index-in.docbook:3901 C/index-in.docbook:3924 C/index-in.docbook:3948
#: C/index-in.docbook:3980 C/index-in.docbook:4158 C/index-in.docbook:4304
#: C/index-in.docbook:4379 C/index-in.docbook:4451 C/index-in.docbook:4516
#: C/index-in.docbook:4753 C/index-in.docbook:5257 C/index-in.docbook:5563
#: C/index-in.docbook:5612 C/index-in.docbook:6191 C/index-in.docbook:6311
#: C/index-in.docbook:6941 C/index-in.docbook:7014 C/index-in.docbook:7240
#: C/index-in.docbook:8675
msgid "Example"
msgstr "示例"

#: C/index-in.docbook:911
msgid "This example creates a button with a picture and a label."
msgstr "这个示例创建了一个有图片和文字标签的按钮。"

#: C/index-in.docbook:916
msgid "buttons example"
msgstr "按钮示例"

#: C/index-in.docbook:922
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buttons/button\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buttons/button\">源代码</ulink>"

#: C/index-in.docbook:929
msgid "ToggleButton"
msgstr "开关按钮(ToggleButton)"

#: C/index-in.docbook:931
msgid ""
"<classname>ToggleButton</classname>s are like normal <classname>Button</"
"classname>s, but when clicked they remain activated, or pressed, until "
"clicked again."
msgstr ""
"<classname>ToggleButton</classname> 和普通的 <classname>Button</classname> 相"
"似，但是它们在点击后会保持激活(或称为按下的)状态，直到再次点击它为止。"

#: C/index-in.docbook:933
msgid ""
"To retrieve the state of the <classname>ToggleButton</classname>, you can "
"use the <methodname>get_active()</methodname> method. This returns "
"<literal>true</literal> if the button is \"down\". You can also set the "
"toggle button's state, with <methodname>set_active()</methodname>. Note "
"that, if you do this, and the state actually changes, it causes the \"clicked"
"\" signal to be emitted. This is usually what you want."
msgstr ""
"要得到 <classname>ToggleButton</classname> 的状态，你可以使用 "
"<methodname>get_active()</methodname> 方法。如果按钮被按下了，就返回 true。当"
"然，你也可以通过 <methodname>set_active()</methodname> 来设置开关按钮的状态。"
"请注意，如果你这样做了，并且它的状态的确改变了，那么这将会引发“clicked”信号。"
"当然，一般来说，这就是你希望看到的结果。"

#: C/index-in.docbook:940
msgid ""
"You can use the <methodname>toggled()</methodname> method to toggle the "
"button, rather than forcing it to be up or down: This switches the button's "
"state, and causes the <literal>toggled</literal> signal to be emitted."
msgstr ""
"你可以使用 <methodname>toggled()</methodname> 方法来改变按钮的状态，而不要强"
"行的是设置它是开还是关：这个方法将会改变按钮的状态，并会引发 "
"<literal>toggled</literal> 信号。"

#: C/index-in.docbook:945
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ToggleButton.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ToggleButton.html\">参考</ulink>"

#: C/index-in.docbook:950 C/index-in.docbook:965
msgid "CheckButton"
msgstr "多选按钮(CheckButton)"

#: C/index-in.docbook:952
msgid ""
"<classname>Gtk::CheckButton</classname> inherits directly from "
"<classname>Gtk::Widget</classname>. It is similar to <classname>Gtk::"
"ToggleButton</classname>. The only real difference between the two is "
"<classname>Gtk::CheckButton</classname>'s appearance. You can check and set "
"a check button using the same member methods as for <classname>Gtk::"
"ToggleButton</classname>."
msgstr ""
"<classname>Gtk::CheckButton</classname> 继承自 <classname>Gtk::Widget</"
"classname>。它与<classname>Gtk::ToggleButton</classname>类似，二者只有外观不"
"同。因此你可以像<classname>Gtk::ToggleButton</classname>一样使用同样的方法来"
"检查、设置和转换多选按钮的状态。"

#: C/index-in.docbook:960
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1CheckButton.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1CheckButton.html\">参考</ulink>"

#: C/index-in.docbook:971
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buttons/checkbutton\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buttons/checkbutton\">源代码</ulink>"

#: C/index-in.docbook:977
msgid "Radio Button"
msgstr "单选按钮(RadioButton)"

#: C/index-in.docbook:979
msgid ""
"There is no separate class for radio buttons. Check buttons and toggle "
"buttons act as radio buttons when they form a group. Only one button in a "
"group can be selected at any one time."
msgstr ""
"单选按钮没有单独的类。当复选按钮和开关按钮在一个组中的时候它们充当单选按钮。"
"任何时候只能选择一个组中的一个按钮。"

#: C/index-in.docbook:985
msgid "Groups"
msgstr "组"

#: C/index-in.docbook:986
msgid ""
"You create the buttons, and set up their group afterwards. In the following "
"example, we put 3 radio buttons in a group:"
msgstr ""
"你创建了三个按钮，然后为他们设置了组。在下面的例子中，我们将三个单选按钮放入"
"一个组中。"

#: C/index-in.docbook:991
#, no-wrap
msgid ""
"\n"
"auto rb1 = Gtk::make_managed&lt;Gtk::CheckButton&gt;(\"button1\");\n"
"auto rb2 = Gtk::make_managed&lt;Gtk::CheckButton&gt;(\"button2\");\n"
"auto rb3 = Gtk::make_managed&lt;Gtk::CheckButton&gt;(\"button3\");\n"
"rb2-&gt;set_group(*rb1);\n"
"rb3-&gt;set_group(*rb1);\n"
msgstr ""
"\n"
"auto rb1 = Gtk::make_managed&lt;Gtk::CheckButton&gt;(\"button1\");\n"
"auto rb2 = Gtk::make_managed&lt;Gtk::CheckButton&gt;(\"button2\");\n"
"auto rb3 = Gtk::make_managed&lt;Gtk::CheckButton&gt;(\"button3\");\n"
"rb2-&gt;set_group(*rb1);\n"
"rb3-&gt;set_group(*rb1);\n"

#: C/index-in.docbook:999
msgid ""
"We told <application>gtkmm</application> to put all three "
"<classname>CheckButton</classname>s in the same group by using "
"<methodname>set_group()</methodname> to tell the other "
"<classname>CheckButton</classname>s to share group with the first "
"<classname>CheckButton</classname>."
msgstr ""
"我们告诉<application>gtkmm</application>把三个<classname>CheckButton</"
"classname>都放到一个组内，通过<methodname>get_group()</methodname>来得到这个"
"组，然后使用<methodname>set_group()</methodname>告诉其它的"
"<classname>CheckButton</classname>与第一个<classname>CheckButton</classname>"
"共享这个组。"

#: C/index-in.docbook:1008 C/index-in.docbook:1464 C/index-in.docbook:4627
msgid "Methods"
msgstr "方法"

#: C/index-in.docbook:1009
msgid ""
"<classname>CheckButton</classname>s and <classname>ToggleButton</classname>s "
"are \"off\" when created; this means that when you first make a group of "
"them, they will all be off. Don't forget to turn one of them on using "
"<methodname>set_active()</methodname>."
msgstr ""
"当<classname>CheckButton</classname>和<classname>ToggleButton</classname>创建"
"后默认是未选中的，也就是说当你第一次创建一组单选按钮的时候，它们都会是未选中"
"的。所以别忘了使用<methodname>set_active()</methodname>来选中一个。"

#: C/index-in.docbook:1015
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1RadioButton.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1RadioButton.html\">参考</ulink>"

#: C/index-in.docbook:1020
msgid ""
"The following example demonstrates the use of grouped "
"<classname>CheckButton</classname>s:"
msgstr ""
"接下来的例子中演示了对<classname>CheckButton</classname>进行分组的用法："

#: C/index-in.docbook:1026
msgid "RadioButton"
msgstr "单选按钮(RadioButton)"

#: C/index-in.docbook:1032
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buttons/radiobutton\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buttons/radiobutton\">源代码</ulink>"

#: C/index-in.docbook:1042 C/index-in.docbook:1148
msgid "Range Widgets"
msgstr "范围(Range)部件"

#: C/index-in.docbook:1044
msgid ""
"<classname>Gtk::Scale</classname> and <classname>Gtk::Scrollbar</classname> "
"both inherit from <classname>Gtk::Range</classname> and share much "
"functionality. They contain a \"trough\" and a \"slider\" (sometimes called "
"a \"thumbwheel\" in other GUI environments). Dragging the slider with the "
"pointer moves it within the trough, while clicking in the trough advances "
"the slider towards the location of the click, either completely, or by a "
"designated amount, depending on which mouse button is used. This should be "
"familiar scrollbar behaviour."
msgstr ""
"<classname>Gtk::Scale</classname> 和 <classname>Gtk::Scrollbar</classname> 都"
"是继承自 <classname>Gtk::Range</classname>，并且共享了很多功能。他们都有一"
"个“滑轨(trough)”和“滑块(slider)”(在其它 GUI 环境中可能被称为“指轮"
"(thumbwheel)”)。在滑轨内可以用鼠标拖动滑块，而在滑轨上点击的话则会让滑块向点"
"击的位置移动，可能是移动到终点，也可能是移动一段距离，这取决于你用的是鼠标的"
"哪个按键。这和滚动条的行为很类似。"

#: C/index-in.docbook:1055
msgid ""
"As will be explained in the <link linkend=\"chapter-adjustment"
"\">Adjustments</link> section, all Range widgets are associated with an "
"<classname>Adjustment</classname> object. To change the lower, upper, and "
"current values used by the widget you need to use the methods of its "
"<classname>Adjustment</classname>, which you can get with the "
"<methodname>get_adjustment()</methodname> method. The <classname>Range</"
"classname> widgets' default constructors create an <classname>Adjustment</"
"classname> automatically, or you can specify an existing "
"<classname>Adjustment</classname>, maybe to share it with another widget. "
"See the <link linkend=\"chapter-adjustment\">Adjustments</link> section for "
"further details."
msgstr ""
"就象将在后面的<link linkend=\"chapter-adjustment\">调整</link>小节要谈到的那"
"样，所有的 Range 部件都有一个关联的 <classname>Adjustment</classname> 对象。"
"如果你想修改部件的最小值、最大值以及当前值，你需要调用该部件关联的 "
"<classname>Adjustment</classname> 对象的方法，该对象可以通过调用 "
"<methodname>get_adjustment()</methodname> 方法来得到。<classname>Range</"
"classname> 部件默认构造函数会自动的创建一个 <classname>Adjustment</"
"classname>，当然，你也可以指定一个现有的 <classname>Adjustment</classname>，"
"而且还可以和其它部件共享。请参看 <link linkend=\"chapter-adjustment\">调整</"
"link>部分以得到更详细的信息。"

#: C/index-in.docbook:1069
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Range.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Range.html"
"\">参考</ulink>"

#: C/index-in.docbook:1072
msgid "Scrollbar Widgets"
msgstr "滚动条部件 (Scrollbar)"

#: C/index-in.docbook:1074
msgid ""
"These are standard scrollbars. They should be used only to scroll another "
"widget, such as a <classname>Gtk::Entry</classname> or a <classname>Gtk::"
"Viewport</classname>, though it's usually easier to use the <classname>Gtk::"
"ScrolledWindow</classname> widget in most cases."
msgstr ""
"这些是标准的滚动条。它们应该只被用于滚动其它部件，比如 <classname>Gtk::"
"Entry</classname> 或 <classname>Gtk::Viewport</classname>，当然，通常使用 "
"<classname>Gtk::ScrolledWindow</classname> 会更容易一些。"

#: C/index-in.docbook:1081
msgid ""
"The orientation of a <classname>Gtk::Scrollbar</classname> can be either "
"horizontal or vertical."
msgstr ""
"<classname>Gtk::Scrollbar</classname>的方向可以是水平的也可以是垂直的。"

#: C/index-in.docbook:1086
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scrollbar."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scrollbar."
"html\">参考</ulink>"

#: C/index-in.docbook:1091
msgid "Scale Widgets"
msgstr "比例部件 (Scale)"

#: C/index-in.docbook:1093
msgid ""
"<classname>Gtk::Scale</classname> widgets (or \"sliders\") allow the user to "
"visually select and manipulate a value within a specific range. You might "
"use one, for instance, to adjust the magnification level on a zoomed preview "
"of a picture, or to control the brightness of a colour, or to specify the "
"number of minutes of inactivity before a screensaver takes over the screen."
msgstr ""
"<classname>Gtk::Scale</classname> 部件 (或者说“滑块”) 可以让用户在指定范围内"
"直观地调节它的值。例如，你可以用它来调节一副预览图片的放大率、或者控制颜色的"
"亮度，或者指定多少分钟后执行屏幕保护。"

#: C/index-in.docbook:1102
msgid ""
"As with <classname>Scrollbar</classname>s, the orientation can be either "
"horizontal or vertical. The default constructor creates an "
"<classname>Adjustment</classname> with all of its values set to "
"<literal>0.0</literal>. This isn't useful so you will need to set some "
"<classname>Adjustment</classname> details to get meaningful behaviour."
msgstr ""
"像 <classname>Scrollbar</classname> 一样，也分别有水平和垂直两种方向。默认构"
"造函数会创建一个 <classname>Adjustment</classname>，并且所有值都设为 "
"<literal>0.0</literal>。当然，这显然没有意义，所以你需要设置一些 "
"<classname>Adjustment</classname> 的细节来让它获得有意义的行为。"

#: C/index-in.docbook:1111
msgid "Useful methods"
msgstr "一些有用的方法"

#: C/index-in.docbook:1113
msgid ""
"<classname>Scale</classname> widgets can display their current value as a "
"number next to the trough. By default they show the value, but you can "
"change this with the <methodname>set_draw_value()</methodname> method."
msgstr ""
"<classname>Scale</classname> 可以在滑轨旁显示它们的当前值。默认情况下是显示这"
"个数值的，但是你可以通过调用 <methodname>set_draw_value()</methodname> 方法来"
"设置是否显示该值。"

#: C/index-in.docbook:1119
msgid ""
"The value displayed by a scale widget is rounded to one decimal point by "
"default, as is the <literal>value</literal> field in its <classname>Gtk::"
"Adjustment</classname>. You can change this with the "
"<methodname>set_digits()</methodname> method."
msgstr ""
"默认情况下，Scale 部件会显示 <classname>Gtk::Adjustment</classname> 的 "
"<literal>value</literal> 的数值，并且会被四舍五入到一位小数。你可以通过 "
"<methodname>set_digits()</methodname> 方法来改变显示的小数位数。"

#: C/index-in.docbook:1126
msgid ""
"Also, the value can be drawn in different positions relative to the trough, "
"specified by the <methodname>set_value_pos()</methodname> method."
msgstr ""
"另外，通过使用 <methodname>set_value_pos()</methodname>，可以使值显示在相对于"
"滑块不同的位置。"

#: C/index-in.docbook:1131
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scale.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Scale.html"
"\">参考</ulink>"

#: C/index-in.docbook:1139
msgid ""
"This example displays a window with three range widgets all connected to the "
"same adjustment, along with a couple of controls for adjusting some of the "
"parameters mentioned above and in the section on adjustments, so you can see "
"how they affect the way these widgets work for the user."
msgstr ""
"这个示例显示了一个窗口，其中有三个关联到同一个调整对象，还有几个控制部件用来"
"调整前文讨论过的一些参数，这样你可以很清楚地看到那些参数是如何影响这些部件的"
"行为方式的。"

#: C/index-in.docbook:1154
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/range_widgets\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/range_widgets\">源代码</ulink>"

#: C/index-in.docbook:1161
msgid "Miscellaneous Widgets"
msgstr "杂项部件"

#: C/index-in.docbook:1164 C/index-in.docbook:1204
msgid "Label"
msgstr "标签(Label)"

#: C/index-in.docbook:1166
msgid ""
"Labels are the main method of placing non-editable text in windows, for "
"instance to place a title next to an <classname>Entry</classname> widget. "
"You can specify the text in the constructor, or later with the "
"<methodname>set_text()</methodname> or <methodname>set_markup()</methodname> "
"methods."
msgstr ""
"标签是用于在窗口中放置不可编辑文本的主要方法，例如将标题放于"
"<classname>Entry</classname>部件旁。你可以直接在构造函数中指定文本，也可以于"
"稍后调用<methodname>set_text()</methodname>或<methodname>set_markup()</"
"methodname>方法设置想要显示的文本。"

#: C/index-in.docbook:1173
msgid ""
"The width of the label will be adjusted automatically. You can produce multi-"
"line labels by putting line breaks (\"\\n\") in the label string."
msgstr ""
"标签会自动调整宽度。你也可以通过在标签锁显示的字符串中放置换行符(\"\\n\")来生"
"成多行标签。"

#: C/index-in.docbook:1177
msgid ""
"The label text can be justified using the <methodname>set_justify()</"
"methodname> method. The widget is also capable of word-wrapping, which can "
"be activated with <methodname>set_line_wrap()</methodname>."
msgstr ""
"标签文本可以使用<methodname>set_justify()</methodname>方法进行对齐。这个部件"
"还具有自动换行功能，你可以使用<methodname>set_line_wrap()</methodname>激活"
"它。"

#: C/index-in.docbook:1183
msgid ""
"Gtk::Label supports some simple formatting, for instance allowing you to "
"make some text bold, colored, or larger. You can do this by providing a "
"string to <methodname>set_markup()</methodname>, using the <ulink url="
"\"http://developer.gnome.org/pango/unstable/PangoMarkupFormat.html\">Pango "
"Markup syntax</ulink>. For instance, <code> &lt;b&gt;bold text&lt;/b&gt; and "
"&lt;s&gt;strikethrough text&lt;/s&gt; </code> ."
msgstr ""
"Gtk::Label支持简单的格式，例如，允许你将某些文本设置成粗体，彩色，或者更大的"
"字号。你也可以使用<ulink url=\"http://developer.gnome.org/pango/unstable/"
"PangoMarkupFormat.html\">Pango 标记语法</ulink>。例如， <code> &lt;b&gt;bold "
"text&lt;/b&gt; and &lt;s&gt;strikethrough text&lt;/s&gt; </code> 。"

#: C/index-in.docbook:1192
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Label.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Label.html"
"\">参考</ulink>"

#: C/index-in.docbook:1195
msgid ""
"Below is a short example to illustrate these functions. This example makes "
"use of the Frame widget to better demonstrate the label styles. (The Frame "
"widget is explained in the <link linkend=\"sec-frame\">Frame</link> "
"section.) It is possible that the first character in "
"<literal>m_Label_Normal</literal> is shown underlined only when you press "
"the <keycap>Alt</keycap> key."
msgstr ""
"下面是一个用于说明这些功能的简短示例。这个样例使用框架(Frame)部件以更好的演示"
"标签样式。(框架部件的教程: <link linkend=\"sec-frame\">框架(Frame)部件</"
"link>)仅当你按<keycap>Alt</keycap>键时，<literal>m_Label_Normal</literal>的第"
"一个字符才显示为下划线的样式。"

#: C/index-in.docbook:1210
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/label\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/label\">源代码</ulink>"

#: C/index-in.docbook:1217 C/index-in.docbook:1274
msgid "Entry"
msgstr "条目(Entry)"

#: C/index-in.docbook:1220
msgid "Simple Use"
msgstr "简易用法"

#: C/index-in.docbook:1222
msgid ""
"Entry widgets allow the user to enter text. You can change the contents with "
"the <methodname>set_text()</methodname> method, and read the current "
"contents with the <methodname>get_text()</methodname> method."
msgstr ""
"条目部件允许用户输入文本。你可以使用<methodname>set_text()</methodname>方法更"
"改部件当前的内容，还可以使用<methodname>get_text()</methodname>方法读取当前的"
"内容。"

#: C/index-in.docbook:1227
msgid ""
"Occasionally you might want to make an <classname>Entry</classname> widget "
"read-only. This can be done by passing <literal>false</literal> to the "
"<methodname>set_editable()</methodname> method."
msgstr ""
"有时你可能想使<classname>Entry</classname>部件变为只读的。你可以通过向"
"<methodname>set_editable()</methodname>方法传递<literal>false</literal>做到这"
"点。"

#: C/index-in.docbook:1233
msgid ""
"For the input of passwords, passphrases and other information you don't want "
"echoed on the screen, calling <methodname>set_visibility()</methodname> with "
"<literal>false</literal> will cause the text to be hidden."
msgstr ""
"对于不想在屏幕上回显的密码、密语或者其他信息，你可以通过向"
"<methodname>set_visibility()</methodname>方法传递<literal>false</literal>使输"
"入文本被隐藏。"

#: C/index-in.docbook:1239
msgid ""
"You might want to be notified whenever the user types in a text entry "
"widget. <classname>Gtk::Entry</classname> provides two signals, "
"<literal>activate</literal> and <literal>changed</literal>, for this "
"purpose. <literal>activate</literal> is emitted when the user presses the "
"<keycap>Enter</keycap> key in a text-entry widget; <literal>changed</"
"literal> is emitted when the text in the widget changes. You can use these, "
"for instance, to validate or filter the text the user types. Moving the "
"keyboard focus to another widget may also signal that the user has finished "
"entering text. The <literal>focus_out_event</literal> signal that "
"<classname>Gtk::Entry</classname> inherits from <classname>Gtk::Widget</"
"classname> can notify you when that happens. The <link linkend=\"sec-"
"comboboxentry\">ComboBox with an Entry</link> section contains example "
"programs that use these signals."
msgstr ""
"当用户在条目部件上输入文本时你可能想要收到通知。为此<classname>Gtk::Entry</"
"classname>提供了两个信号，他们分别是<literal>activate</literal>和"
"<literal>changed</literal>。当用户在条目部件上按下<keycap>Enter</keycap>键"
"时，部件将发出<literal>activate</literal>信号；当部件上的文本发生更改的时候，"
"部件将会发出<literal>changed</literal>信号。你可以利用这些信号对用户的输入进"
"行校验或者是过滤。将键盘焦点移动到其他的部件可能表示用户已经完成了文本输入。"
"这种时候<classname>Gtk::Entry</classname>将会发出继承自<classname>Gtk::"
"Widget</classname>的<literal>focus_out_event</literal>信号提醒你。<link "
"linkend=\"sec-comboboxentry\">带有条目的组合框</link>小结包含了使用这些信号的"
"示例程序。"

#: C/index-in.docbook:1254
msgid ""
"If you pass <literal>true</literal> to the "
"<methodname>set_activates_default()</methodname> method, pressing "
"<keycap>Enter</keycap> in the <classname>Gtk::Entry</classname> will "
"activate the default widget for the window containing the <classname>Gtk::"
"Entry</classname>. This is especially useful in dialog boxes. The default "
"widget is usually one of the dialog buttons, which e.g. will close the "
"dialog box. To set a widget as the default widget, use <methodname>Gtk::"
"Widget::set_can_default()</methodname> and <methodname>Gtk::Widget::"
"grab_default()</methodname>."
msgstr ""
"如果你将<literal>true</literal>传递给<methodname>set_activates_default()</"
"methodname>方法，那么当你在<classname>Gtk::Entry</classname>中按下"
"<keycap>Enter</keycap>的时候包含这个<classname>Gtk::Entry</classname>的窗口将"
"会激活其默认部件。这在对话框中特别的有用。默认部件通常会是对话框的按钮之一，"
"例如对话框的关闭按钮。若你想主动的将某个部件设置为默认部件，请使用"
"<methodname>Gtk::Widget::set_can_default()</methodname>和<methodname>Gtk::"
"Widget::grab_default()</methodname>。"

#: C/index-in.docbook:1264
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Entry.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Entry.html"
"\">参考</ulink>"

#: C/index-in.docbook:1266
msgid "Simple Entry Example"
msgstr "简单的条目示例"

#: C/index-in.docbook:1267
msgid ""
"This example uses <classname>Gtk::Entry</classname>. It also has two "
"<classname>CheckButton</classname>s, with which you can toggle the editable "
"and visible flags."
msgstr ""
"本示例使用<classname>Gtk::Entry</classname>。他还有两个"
"<classname>CheckButton</classname>，你可以使用他们切换条目部件的可见性和可编"
"辑性标志。"

#: C/index-in.docbook:1280
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/simple\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/simple\">源代码</ulink>"

#: C/index-in.docbook:1287 C/index-in.docbook:1321
msgid "Entry Completion"
msgstr "条目补全(Entry Completion)"

#: C/index-in.docbook:1288
msgid ""
"An <classname>Entry</classname> widget can offer a drop-down list of pre-"
"existing choices based on the first few characters typed by the user. For "
"instance, a search dialog could suggest text from previous searches."
msgstr ""
"<classname>Entry</classname>条目组件可以通过用户输入的前几个字符提供预先准备"
"好选项的下拉列表。例如，在搜索对话框中提供以前输入过的文本作为建议。"

#: C/index-in.docbook:1293
msgid ""
"To enable this functionality, you must create an <classname>EntryCompletion</"
"classname> object, and provide it to the <classname>Entry</classname> widget "
"via the <methodname>set_completion()</methodname> method."
msgstr ""
"要启用此功能，你需要创建一个<classname>EntryCompletion</classname>对象，然后"
"使用<classname>Entry</classname>部件的<methodname>set_completion()</"
"methodname>方法将其提供给条目部件。"

#: C/index-in.docbook:1298
msgid ""
"The <classname>EntryCompletion</classname> may use a <classname>TreeModel</"
"classname> containing possible entries, specified with "
"<methodname>set_model()</methodname>. You should then call "
"<methodname>set_text_column()</methodname> to specify which of your model "
"columns should be used to match possible text entries."
msgstr ""
"<classname>EntryCompletion</classname>可以用<methodname>set_model()</"
"methodname>指定一个包含所有可能的条目的<classname>TreeModel</classname>。你应"
"该调用<methodname>set_text_column()</methodname>指定该模型的那一行用以匹配可"
"能的文本条目。"

#: C/index-in.docbook:1304
msgid ""
"Alternatively, if a complete list of possible entries would be too large or "
"too inconvenient to generate, a callback slot may instead be specified with "
"<methodname>set_match_func()</methodname>. This is also useful if you wish "
"to match on a part of the string other than the start."
msgstr ""
"或是在不方便生成补全条目列表的时候(太大或者生成太麻烦)，也可以使用"
"<methodname>set_match_func()</methodname>指定一个回调槽。这在你想匹配字符串中"
"开头以外的部分的时候这会很有用。"

#: C/index-in.docbook:1310
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1EntryCompletion.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1EntryCompletion.html\">参考</ulink>"

#: C/index-in.docbook:1312
msgid "Entry Completion Example"
msgstr "条目补全示例"

#: C/index-in.docbook:1313
msgid ""
"This example creates a <classname>Gtk::EntryCompletion</classname> and "
"associates it with a <classname>Gtk::Entry</classname> widget. The "
"completion uses a <classname>Gtk::TreeModel</classname> of possible entries, "
"and some additional actions."
msgstr ""
"这个示例创建一个<classname>Gtk::EntryCompletion</classname>并将其与"
"<classname>Gtk::Entry</classname>相关联。补全使用了一个包含了可能条目的"
"<classname>Gtk::TreeModel</classname>以及一些其他的额外的操作。"

#: C/index-in.docbook:1327
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/completion\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/completion\">源代码</ulink>"

#: C/index-in.docbook:1333
msgid "Entry Icons"
msgstr "条目图标"

#: C/index-in.docbook:1334
msgid ""
"An <classname>Entry</classname> widget can show an icon at the start or end "
"of the text area. The icon can be specifed by methods such as "
"<methodname>set_icon_from_pixbuf()</methodname> or "
"<methodname>set_icon_from_icon_name()</methodname>. An application can "
"respond to the user pressing the icon by handling the "
"<methodname>signal_icon_press</methodname> signal."
msgstr ""
"<classname>Entry</classname>部件可以在文本区域的开头或结尾显示一个图标。可以"
"使用<methodname>set_icon_from_pixbuf()</methodname>或"
"<methodname>set_icon_from_icon_name()</methodname>之类的方法指定要显示的图"
"标。应用程序可以通过响应<methodname>signal_icon_press</methodname>信号来处理"
"用户按下图标事件。"

#: C/index-in.docbook:1341
msgid "Entry Icon Example"
msgstr "条目图标示例"

#: C/index-in.docbook:1342
msgid ""
"This example shows a <classname>Gtk::Entry</classname> widget with a named "
"search icon, and prints text to the terminal when the icon is pressed."
msgstr ""
"这个示例显示带有具名搜索图标的<classname>Gtk::Entry</classname>部件，并且在按"
"下这个图标的时候将该名称打印到终端上。"

#: C/index-in.docbook:1348
msgid "Entry with Icon"
msgstr "带图标的条目"

#: C/index-in.docbook:1354
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/icon\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/icon\">源代码</ulink>"

#: C/index-in.docbook:1360
msgid "Entry Progress"
msgstr "条目进度"

#: C/index-in.docbook:1361
msgid ""
"An <classname>Entry</classname> widget can show a progress bar inside the "
"text area, under the entered text. The progress bar will be shown if the "
"<methodname>set_progress_fraction()</methodname> or "
"<methodname>set_progress_pulse_step()</methodname> methods are called."
msgstr ""
"<classname>Entry</classname>部件可以在输入的文本之下显示一个进度条。当部件的"
"<methodname>set_progress_fraction()</methodname>或"
"<methodname>set_progress_pulse_step()</methodname>方法被调用的时候进度条将显"
"示出来。"

#: C/index-in.docbook:1366
msgid "Entry Progress Example"
msgstr "条目进度示例"

#: C/index-in.docbook:1367
msgid ""
"This example shows a <classname>Gtk::Entry</classname> widget with a "
"progress bar."
msgstr "这个示例显示一个带有进度条的<classname>Gtk::Entry</classname>部件。"

#: C/index-in.docbook:1373
msgid "Entry with Progress Bar"
msgstr "带有进度条的条目"

#: C/index-in.docbook:1379
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/progress\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/entry/progress\">源代码</ulink>"

#: C/index-in.docbook:1387 C/index-in.docbook:1509
msgid "SpinButton"
msgstr "微调按钮(SpinButton)"

#: C/index-in.docbook:1389
msgid ""
"A <classname>SpinButton</classname> allows the user to select a value from a "
"range of numeric values. It has an <classname>Entry</classname> widget with "
"increment and decrement buttons at the side. Clicking the buttons causes the "
"value to 'spin' up and down across the range of possible values. The "
"<classname>Entry</classname> widget may also be used to enter a value "
"directly."
msgstr ""
"<classname>SpinButton</classname>允许用户从一个数值范围内选择一个值。它包含了"
"一个<classname>Entry</classname>部件在其侧边有递增和递减按钮。单击按钮会使得"
"值在可能的范围内“旋转”。你也可以直接在<classname>Entry</classname>部件中输入"
"一个值。"

#: C/index-in.docbook:1397
msgid ""
"The value can have an adjustable number of decimal places, and the step size "
"is configurable. <classname>SpinButton</classname>s have an 'auto-repeat' "
"feature as well: holding down the increment or decrement button can "
"optionally cause the value to change more quickly the longer the button is "
"held down."
msgstr ""
"这个值的小数位可以进行调整，步长也可以进行配置。<classname>SpinButton</"
"classname>具有“自动重复”功能：长按递增、递减按钮该值的变化速度会越来越快。"

#: C/index-in.docbook:1412
msgid "<literal>value</literal>: value for the Spin Button"
msgstr "<literal>value</literal>：微调按钮的值"

#: C/index-in.docbook:1418
msgid "<literal>lower</literal>: lower range value"
msgstr "<literal>lower</literal>：微调按钮允许的最小值"

#: C/index-in.docbook:1424
msgid "<literal>upper</literal>: upper range value"
msgstr "<literal>upper</literal>：微调按钮允许的最大值"

#: C/index-in.docbook:1429
msgid ""
"<literal>step_increment</literal>: value to increment/decrement when "
"pressing mouse button 1"
msgstr ""
"<literal>step_increment</literal>：鼠标键1(通常是左键)点击一下递增/递减的值"

#: C/index-in.docbook:1436
msgid ""
"<literal>page_increment</literal>: value to increment/decrement when "
"pressing mouse button 2"
msgstr ""
"<literal>page_increment</literal>：鼠标键2(通常是右键)点击一下递增/递减的值"

#: C/index-in.docbook:1443
msgid "<literal>page_size</literal>: unused"
msgstr "<literal>page_size</literal>：目前没作用"

#: C/index-in.docbook:1404
msgid ""
"<classname>SpinButton</classname>s use an <link linkend=\"chapter-adjustment"
"\">Adjustment</link> object to hold information about the range of values. "
"These Adjustment attributes are used by the Spin Button like so: <_:"
"itemizedlist-1/>"
msgstr ""
"<classname>SpinButton</classname>使用<link linkend=\"chapter-adjustment\">调"
"整(Adjustment)</link>对象保存值的范围信息。下述调整属性由微调按钮使用：<_:"
"itemizedlist-1/>"

#: C/index-in.docbook:1451
msgid ""
"Additionally, mouse button 3 can be used to jump directly to the "
"<literal>upper</literal> or <literal>lower</literal> values."
msgstr ""
"另外，鼠标键3(通常是中键)用于直接跳到<literal>upper</literal>或"
"<literal>lower</literal> values。"

#: C/index-in.docbook:1456
msgid ""
"The <classname>SpinButton</classname> can create a default "
"<classname>Adjustment</classname>, which you can access via the "
"<methodname>get_adjustment()</methodname> method, or you can specify an "
"existing <classname>Adjustment</classname> in the constructor."
msgstr ""
"<classname>SpinButton</classname>可以创建一个默认状态的"
"<classname>Adjustment</classname>，然后你可以调用"
"<methodname>get_adjustment()</methodname>方法访问这个<classname>Adjustment</"
"classname>，也可以通过<classname>SpinButton</classname>的构造函数直接使用一个"
"已经存在的<classname>Adjustment</classname>。"

#: C/index-in.docbook:1466
msgid ""
"The number of decimal places can be altered using the "
"<methodname>set_digits()</methodname> method."
msgstr ""
"数值的小数位可以使用<methodname>set_digits()</methodname>方法进行调整。"

#: C/index-in.docbook:1471
msgid ""
"You can set the spinbutton's value using the <methodname>set_value()</"
"methodname> method, and retrieve it with <methodname>get_value()</"
"methodname>."
msgstr ""
"你可以使用<methodname>set_value()</methodname>方法设置微调按钮的值，也可以使"
"用<methodname>get_value()</methodname>方法获得微调按钮的值。"

#: C/index-in.docbook:1476
msgid ""
"The <methodname>spin()</methodname> method 'spins' the "
"<classname>SpinButton</classname>, as if its increment or decrement button "
"had been clicked. You need to specify a <classname>Gtk::SpinType</classname> "
"to specify the direction or new position."
msgstr ""
"<methodname>spin()</methodname>方法的行为和手动点击递增/递减按钮一样。你需要"
"传递一个<classname>Gtk::SpinType</classname>对象给该方法以指定是递增还是递"
"减。"

#: C/index-in.docbook:1483
msgid ""
"To prevent the user from typing non-numeric characters into the entry box, "
"pass <literal>true</literal> to the <methodname>set_numeric()</methodname> "
"method."
msgstr ""
"将<literal>true</literal>传递给<methodname>set_numeric()</methodname>方法可以"
"阻止用户在条目框内输入非数字字符。"

#: C/index-in.docbook:1488
msgid ""
"To make the <classname>SpinButton</classname> 'wrap' between its upper and "
"lower bounds, use the <methodname>set_wrap()</methodname> method."
msgstr ""
"使用<methodname>set_wrap()</methodname>方法指定<classname>SpinButton</"
"classname>的值到达上下限的时候是否绕回。"

#: C/index-in.docbook:1493
msgid ""
"To force it to snap to the nearest <literal>step_increment</literal>, use "
"<methodname>set_snap_to_ticks()</methodname>."
msgstr ""
"使用<methodname>set_snap_to_ticks()</methodname>方法可以在向微调按钮设置了无"
"效值的时候强制校正到最接近<literal>step_increment</literal>策略可达到的有效"
"值。"

#: C/index-in.docbook:1498
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1SpinButton.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1SpinButton.html\">参考</ulink>"

#: C/index-in.docbook:1504
msgid "Here's an example of a <classname>SpinButton</classname> in action:"
msgstr "这是一个使用<classname>SpinButton</classname>的示例："

#: C/index-in.docbook:1515
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/spinbutton\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/spinbutton\">源代码</ulink>"

#: C/index-in.docbook:1522 C/index-in.docbook:1570
msgid "ProgressBar"
msgstr "进度条(ProgressBar)"

#: C/index-in.docbook:1524
msgid ""
"Progress bars are used to show the status of an ongoing operation. For "
"instance, a <classname>ProgressBar</classname> can show how much of a task "
"has been completed."
msgstr ""
"进度条用于显示正在进行的操作的状态。例如，<classname>ProgressBar</classname>"
"可以用于显示已经有多少任务被完成。"

#: C/index-in.docbook:1530
msgid ""
"To change the value shown, use the <methodname>set_fraction()</methodname> "
"method, passing a <type>double</type> between 0.0 and 1.0 to provide the new "
"fraction."
msgstr ""
"要修改显示的值，请调用<methodname>set_fraction()</methodname>方法，向该方法传"
"递一个0.0到1.0之间的<type>double</type>值。"

#: C/index-in.docbook:1535
msgid ""
"A <classname>ProgressBar</classname> is horizontal and left-to-right by "
"default, but you can change it to a vertical progress bar by using the "
"<methodname>set_orientation()</methodname> method."
msgstr ""
"<classname>ProgressBar</classname>默认是水平且从左向右的，但是你可以使用"
"<methodname>set_orientation()</methodname>方法来改变这个行为。"

#: C/index-in.docbook:1541
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ProgressBar.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ProgressBar.html\">参考</ulink>"

#: C/index-in.docbook:1544
msgid "Activity Mode"
msgstr "活动模式"

#: C/index-in.docbook:1545
msgid ""
"Besides indicating the amount of progress that has occured, the progress bar "
"can also be used to indicate that there is some activity; this is done by "
"placing the progress bar in <emphasis>activity mode</emphasis>. In this "
"mode, the progress bar displays a small rectangle which moves back and "
"forth. Activity mode is useful in situations where the progress of an "
"operation cannot be calculated as a value range (e.g., receiving a file of "
"unknown length)."
msgstr ""
"除了用于表示已经达成的进度，进度条还可以用于表示任务处于活动状态；只需要将进"
"度条的行为模式设置为<emphasis>activity mode</emphasis>即可。在这个模式下，进"
"度条显示一个小矩形，该矩形可以在进度条内前后移动。活动模式在无法确定操作的进"
"度的时候很有用（例如，接受一个长度未知的文件）。"

#: C/index-in.docbook:1555
msgid ""
"To do this, you need to call the <methodname>pulse()</methodname> method at "
"regular intervals. You can also choose the step size, with the "
"<methodname>set_pulse_step()</methodname> method."
msgstr ""
"为此，你还需要定时调用<methodname>pulse()</methodname>方法。你还可以使用"
"<methodname>set_pulse_step()</methodname>方法控制矩形的移动步长。"

#: C/index-in.docbook:1561
msgid ""
"The progress bar can also display a configurable text string next to the "
"bar, using the <methodname>set_text()</methodname> method."
msgstr ""
"进度条还可以使用<methodname>set_text()</methodname>方法来在其边上显示可配置的"
"文本字符串。"

#: C/index-in.docbook:1576
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/progressbar\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/progressbar\">源代码</ulink>"

#: C/index-in.docbook:1584 C/index-in.docbook:1594
msgid "InfoBar"
msgstr "信息栏(InfoBar)"

#: C/index-in.docbook:1586
msgid ""
"An <classname>InfoBar</classname> may show small items of information or ask "
"brief questions. Unlike a <classname>Dialog</classname>, it appears at the "
"top of the current window instead of opening a new window. Its API is very "
"similar to the <link linkend=\"chapter-dialogs\">Gtk::Dialog</link> API."
msgstr ""
"<classname>InfoBar</classname>可用于显示一些信息、小物品或者简短的问题。他显"
"示在窗口的顶部而不是和<classname>Dialog</classname>一样打开一个新的窗口。但是"
"他的API和<link linkend=\"chapter-dialogs\">Gtk::Dialog</link>的API十分相似。"

#: C/index-in.docbook:1589
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1InfoBar."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1InfoBar."
"html\">参考</ulink>"

#: C/index-in.docbook:1600
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/infobar\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/infobar\">源代码</ulink>"

#: C/index-in.docbook:1607
msgid "Tooltips"
msgstr "工具提示框(Tooltips)"

#: C/index-in.docbook:1609
msgid ""
"Tooltips are the little information windows that pop up when you leave your "
"pointer over a widget for a few seconds. Use <methodname>set_tooltip_text()</"
"methodname> to set a text string as a tooltip on any <classname>Widget</"
"classname>. <classname>Gtk::Tooltip</classname> is used for more advanced "
"tooltip usage, such as showing an image as well as text."
msgstr ""
"工具提示框是将鼠标悬停于部件上几秒后弹出的信息窗口。使用"
"<methodname>set_tooltip_text()</methodname>可以为任意的<classname>Widget</"
"classname>设置一个文本字符串作为提示。<classname>Gtk::Tooltip</classname>被用"
"作更高级的提示工具，例如显示图像和文本。"

#: C/index-in.docbook:1618
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Widget."
"html\">Widget Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Widget."
"html\">部件参考</ulink>"

#: C/index-in.docbook:1619
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Tooltip."
"html\">Tooltip Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Tooltip."
"html\">工具提示框参考</ulink>"

#: C/index-in.docbook:1624
msgid "Tooltip"
msgstr "工具提示框(Tooltip)"

#: C/index-in.docbook:1630
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/tooltips\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/tooltips\">源代码</ulink>"

#: C/index-in.docbook:1639
msgid "Container Widgets"
msgstr "容器(Container)部件"

#: C/index-in.docbook:1641
msgid ""
"Container widgets, like other widgets, derive from <classname>Gtk::Widget</"
"classname>. Some container widgets, such as <classname>Gtk::Grid</classname> "
"can hold many child widgets, so these typically have more complex "
"interfaces. Others, such as <classname>Gtk::Frame</classname> contain only "
"one child widget."
msgstr ""
"容器部件与其他部件一样都是从<classname>Gtk::Widget</classname>派生而来。一些"
"容器部件可以容纳多个子部件，例如<classname>Gtk::Grid</classname>，因此通常他"
"们具有更为复杂的接口。还有些容器部件只能容纳一个子部件，例如<classname>Gtk::"
"Frame</classname>"

#: C/index-in.docbook:1649
msgid "Single-item Containers"
msgstr "单项容器"

#: C/index-in.docbook:1651
msgid ""
"Most single-item container widgets have <methodname>set_child()</methodname> "
"and <methodname>unset_child()</methodname> methods for the child widget. "
"<classname>Gtk::Button</classname> and <classname>Gtk::Window</classname> "
"are technically single-item containers, but we have discussed them already "
"elsewhere."
msgstr ""
"大多数单项容器部件具有其子部件的<methodname>set_child()</methodname>和"
"<methodname>unset_child()</methodname>方法。<classname>Gtk::Button</"
"classname>和<classname>Gtk::Window</classname>从技术上来说是单项容器，但是我"
"们已经在其他地方讨论过它们。"

#: C/index-in.docbook:1658
msgid ""
"We also discuss the <classname>Gtk::Paned</classname> widget, which allows "
"you to divide a window into two separate \"panes\". This widget actually "
"contains two child widgets, but the number is fixed so it seems appropriate."
msgstr ""
"我们还讨论了<classname>Gtk::Paned</classname>部件，它允许你将窗口分为两个单独"
"的\"窗格\"，这个部件实际上可以包含两个子部件，但是他只能包含固定数量的部件，"
"因此也将其称为单项容器。"

#: C/index-in.docbook:1665 C/index-in.docbook:1679
msgid "Frame"
msgstr "框架(Frame)"

#: C/index-in.docbook:1667
msgid ""
"Frames can enclose one or a group of widgets within a box, optionally with a "
"title. For instance, you might place a group of <classname>ToggleButton</"
"classname>s or <classname>CheckButton</classname>s in a <classname>Frame</"
"classname>."
msgstr ""
"框架可以将一个或一组部件封装在一个框内，还可以为他们选择标题。例如你可以将一"
"组<classname>ToggleButton</classname>或者<classname>CheckButton</classname>放"
"入一个<classname>Frame</classname>中。"

#: C/index-in.docbook:1674
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Frame.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Frame.html"
"\">参考</ulink>"

#: C/index-in.docbook:1685
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/frame\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/frame\">源代码</ulink>"

#: C/index-in.docbook:1693 C/index-in.docbook:1719
msgid "Paned"
msgstr "窗格(Paned)"

#: C/index-in.docbook:1695
msgid ""
"Panes divide a widget into two halves, separated by a moveable divider. The "
"two halves (panes) can be oriented either horizontally (side by side) or "
"vertically (one above the other)."
msgstr ""
"窗格用一个可移动的分隔符将一个部件一分为二。其可以水平（使两个窗格并排）也可"
"以竖直（使两个窗格一个在另一个之上）的分隔部件。"

#: C/index-in.docbook:1701
msgid ""
"Unlike the other widgets in this section, pane widgets contain not one but "
"two child widgets, one in each pane. Therefore, you should use "
"<methodname>set_start_child()</methodname> and <methodname>set_end_child()</"
"methodname> instead of a <methodname>set_child()</methodname> method."
msgstr ""
"与本小节的其他小部件不一样的是，窗格部件包含两个子部件而不是一个部件（每个窗"
"格中一个）。因此你应该用<methodname>set_start_child()</methodname>和"
"<methodname>set_end_child()</methodname>替代<methodname>set_child()</"
"methodname>方法。"

#: C/index-in.docbook:1708
msgid ""
"You can adjust the position of the divider using the "
"<methodname>set_position()</methodname> method, and you will probably need "
"to do so."
msgstr ""
"如果你需要，你可以使用<methodname>set_position()</methodname>调整分割线的位"
"置。"

#: C/index-in.docbook:1714
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Paned.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Paned.html"
"\">参考</ulink>"

#: C/index-in.docbook:1725
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/paned\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/paned\">源代码</ulink>"

#: C/index-in.docbook:1732 C/index-in.docbook:1764
msgid "ScrolledWindow"
msgstr "滚动窗口"

#: C/index-in.docbook:1734
msgid ""
"<classname>ScrolledWindow</classname> widgets create a scrollable area. You "
"can insert any type of widget into a <classname>ScrolledWindow</classname>, "
"and it will be accessible regardless of its size by using the scrollbars. "
"Note that <classname>ScrolledWindow</classname> is not a <classname>Gtk::"
"Window</classname> despite the slightly misleading name."
msgstr ""
"<classname>ScrolledWindow</classname>部件会创建一个可以滚动的区域。你可以将任"
"何类型的部件插入到<classname>ScrolledWindow</classname>中，无论该部件有多大你"
"都可以通过滚动条来访问它。请注意虽然<classname>ScrolledWindow</classname>的名"
"称像是<classname>Gtk::Window</classname>的衍生部件，但其实不是。"

#: C/index-in.docbook:1743
msgid ""
"Scrolled windows have <emphasis>scrollbar policies</emphasis> which "
"determine whether the <classname>Scrollbar</classname>s will be displayed. "
"The policies can be set with the <methodname>set_policy()</methodname> "
"method. The policy may be for instance <literal>Gtk::PolicyType::AUTOMATIC</"
"literal> or <literal>Gtk::PolicyType::ALWAYS</literal>. <literal>Gtk::"
"PolicyType::AUTOMATIC</literal> will cause the scrolled window to display "
"the scrollbar only if the contained widget is larger than the visible area. "
"<literal>Gtk::PolicyType::ALWAYS</literal> will cause the scrollbar to be "
"displayed always."
msgstr ""
"滚动窗口具有用于确定是否要显示<classname>Scrollbar(滚动条)</classname>的"
"<emphasis>scrollbar policies(滚动条策略)</emphasis>。你可以使用"
"<methodname>set_policy()</methodname>方法来设置策略。例如设置策略为"
"<literal>Gtk::PolicyType::AUTOMATIC</literal>或是<literal>Gtk::PolicyType::"
"ALWAYS</literal>。当策略为<literal>Gtk::PolicyType::AUTOMATIC</literal>的时"
"候，只有在被包含的部件大于可见区域的时候滚动条才会被显示出来。而"
"<literal>Gtk::PolicyType::ALWAYS</literal>将使滚动条始终显示。"

#: C/index-in.docbook:1755
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ScrolledWindow.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ScrolledWindow.html\">参考</ulink>"

#: C/index-in.docbook:1759
msgid ""
"Here is a simple example that packs 100 toggle buttons into a "
"ScrolledWindow. Try resizing the window to see the scrollbars react."
msgstr ""
"这是一个简单的示例，其将100个开关按钮放入滚动窗口中。你可以尝试调整窗口的大"
"小，以查看滚动条的反应。"

#: C/index-in.docbook:1770
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/scrolledwindow\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/scrolledwindow\">源代码</ulink>"

#: C/index-in.docbook:1777 C/index-in.docbook:1799
msgid "AspectFrame"
msgstr "定比框架(AspectFrame)"

#: C/index-in.docbook:1779
msgid ""
"The <classname>AspectFrame</classname> widget looks like a <classname>Frame</"
"classname> widget, but it also enforces the <emphasis>aspect ratio</"
"emphasis> (the ratio of the width to the height) of the child widget, adding "
"extra space if necessary. For instance, this would allow you to display a "
"photograph without allowing the user to distort it horizontally or "
"vertically while resizing."
msgstr ""
"<classname>AspectFrame</classname>部件和<classname>Frame</classname>部件类"
"似，但它强制子部件的<emphasis>aspect ratio(长宽比)</emphasis>（长与宽的比例）"
"保持不变。并在有必要的时候添加额外的空间。例如，这将允许你显示照片并且无需在"
"用户调整窗口大小的时候对照片进行水平/垂直变形。"

#: C/index-in.docbook:1788
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1AspectFrame.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1AspectFrame.html\">参考</ulink>"

#: C/index-in.docbook:1792
msgid ""
"The following program uses a <classname>Gtk::AspectFrame</classname> to "
"present a drawing area whose aspect ratio will always be 2:1, no matter how "
"the user resizes the top-level window."
msgstr ""
"下面的程序使用<classname>Gtk::AspectFrame</classname>显示一个绘图区域，无论用"
"户如何调整顶层窗口大小宽高比依旧保持2:1。"

#: C/index-in.docbook:1805
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/aspectframe\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/aspectframe\">源代码</ulink>"

#: C/index-in.docbook:1812
msgid "Other Single-item Containers"
msgstr "其他单项容器"

#: C/index-in.docbook:1814
msgid ""
"There are other single-item containers. See the reference documentation for "
"a complete list. Here are links to some example programs that show "
"containers, which are not mentioned elsewhere in this tutorial."
msgstr ""
"还有其他的单项容器。请参阅参考文档获取完整列表。这里是一些本教程其他地方未曾"
"提及的显示容器的示例程序的链接。"

#: C/index-in.docbook:1820
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/expander\">Source Code, Expander</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/expander\">扩展器(Expander)源代码</ulink>"

#: C/index-in.docbook:1821
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/popover\">Source Code, Popover</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/popover\">气泡(Popover)源代码</ulink>"

#: C/index-in.docbook:1828
msgid "Multiple-item Containers"
msgstr "多项容器"

#: C/index-in.docbook:1830
msgid ""
"Multiple-item container widgets have other methods than "
"<methodname>set_child()</methodname> and <methodname>unset_child()</"
"methodname>. Different containers can have different methods for adding and "
"removing child widgets. For instance, <classname>Gtk::Box</classname> has "
"<methodname>append()</methodname> and <methodname>remove()</methodname> as "
"well as other methods. The <methodname>remove()</methodname> method for "
"multiple-item containers takes an argument, specifying which widget to "
"remove."
msgstr ""
"多项容器部件除<methodname>set_child()</methodname>和"
"<methodname>unset_child()</methodname>方法以外还有其他的方法。不同容器有不同"
"的添加/删除子部件的方法。例如<classname>Gtk::Box</classname>具有"
"<methodname>append()</methodname>和<methodname>remove()</methodname>以及其他"
"方法。多项容器的<methodname>remove()</methodname>方法需要传入一个用于指示需要"
"删除的部件的参数。"

#: C/index-in.docbook:1840
msgid "Packing"
msgstr "组装(Packing)"

#: C/index-in.docbook:1841
msgid ""
"You've probably noticed that <application>gtkmm</application> windows seem "
"\"elastic\" - they can usually be stretched in many different ways. This is "
"due to the <emphasis>widget packing</emphasis> system."
msgstr ""
"你可能已经注意到了<application>gtkmm</application>窗口看起来是“弹性”的 -他们"
"通常可以以不同方式进行拉伸。这是<emphasis>部件装填(widget packing)</emphasis>"
"系统在起作用。"

#: C/index-in.docbook:1846
msgid ""
"Many GUI toolkits require you to precisely place widgets in a window, using "
"absolute positioning, often using a visual editor. This leads to several "
"problems:"
msgstr ""
"许多GUI工具包使用可视化编辑器的时候都要求你使用部件相对于窗口的绝对位置。这将"
"导致以下几个问题："

#: C/index-in.docbook:1853
msgid ""
"The widgets don't rearrange themselves when the window is resized. Some "
"widgets are hidden when the window is made smaller, and lots of useless "
"space appears when the window is made larger."
msgstr ""
"在调整窗口大小的时候部件不会重新排布自己。窗口变小的时候一些部件会被隐藏窗口"
"变大的时候会出现很多无用的空间。"

#: C/index-in.docbook:1857
msgid ""
"It's impossible to predict the amount of space necessary for text after it "
"has been translated to other languages, or displayed in a different font. On "
"Unix it is also impossible to anticipate the effects of every theme and "
"window manager."
msgstr ""
"将文本翻译成其他语言或者用其他字体显示的时候，无法预测显示文本所需要的空间。"
"而在Unix上不可能预料在每个主题和窗口管理器下的显示效果。"

#: C/index-in.docbook:1861
msgid ""
"Changing the layout of a window \"on the fly\", to make some extra widgets "
"appear, for instance, is complex. It requires tedious recalculation of every "
"widget's position."
msgstr ""
"即时更改窗口布局以显示额外的部件将会很复杂，这需要对每个部件的位置进行繁琐的"
"重新计算。"

#: C/index-in.docbook:1867
msgid ""
"<application>gtkmm</application> uses the packing system to solve these "
"problems. Rather than specifying the position and size of each widget in the "
"window, you can arrange your widgets in rows, columns, and/or grids. "
"<application>gtkmm</application> can size your window automatically, based "
"on the sizes of the widgets it contains. And the sizes of the widgets are, "
"in turn, determined by the amount of text they contain, or the minimum and "
"maximum sizes that you specify, and/or how you have requested that the "
"available space should be shared between sets of widgets. You can perfect "
"your layout by specifying margins and centering values for each of your "
"widgets. <application>gtkmm</application> then uses all this information to "
"resize and reposition everything sensibly and smoothly when the user "
"manipulates the window."
msgstr ""
"<application>gtkmm</application>使用装填系统解决这些问题。无需为窗口中的每个"
"部件指定大小和位置，而是将部件放入行、列、和或网格中。<application>gtkmm</"
"application>可以基于包含的部件的大小自动调整你的窗口大小。部件的大小由它包含"
"的文本量、最大/小尺寸（由你指定的）、部件之间如何共享可用空间（你要求的方式）"
"共同决定。你可以通过为每个部件指定边距与居中值来完善布局。然后"
"<application>gtkmm</application>会使用以上的信息在用户操作窗口的时候合理、顺"
"畅的调整部件们的大小和位置。"

#: C/index-in.docbook:1876
msgid ""
"<application>gtkmm</application> arranges widgets hierarchically, using "
"<emphasis>containers</emphasis>. A container widget contains other widgets. "
"Most <application>gtkmm</application> widgets are containers. Windows, "
"Notebook tabs, and Buttons are all container widgets. There are two flavours "
"of containers: single-child containers and multiple-child containers. Most "
"container widgets in <application>gtkmm</application> are single-child "
"containers, including <classname>Gtk::Window</classname>."
msgstr ""
"<application>gtkmm</application>使用<emphasis>containers</emphasis>分层排布部"
"件。容器部件包含其他部件。大多数的<application>gtkmm</application>部件都是容"
"器部件。窗口(Windows)部件、笔记本选项卡(Notebook tabs)部件、按钮(Buttons)部件"
"都是容器部件。容器有两种类型：单项容器和多项容器。<application>gtkmm</"
"application>中包括<classname>Gtk::Window</classname>在内的多数容器部件都是单"
"项部件。"

#: C/index-in.docbook:1885
msgid ""
"Yes, that's correct: a Window can contain at most one widget. How, then, can "
"we use a window for anything useful? By placing a multiple-child container "
"in the window. The most useful container widgets are <classname>Gtk::Grid</"
"classname> and <classname>Gtk::Box</classname>."
msgstr ""
"对，没错，一个窗口最多只能包含一个部件。那么我们要如何将多个部件放于窗口中"
"呢？答案是通过向窗口放入一个多项容器实现。最合理的部件是<classname>Gtk::"
"Grid</classname>和<classname>Gtk::Box</classname>。"

#: C/index-in.docbook:1896
msgid ""
"<classname>Gtk::Grid</classname> arranges its child widgets in rows and "
"columns. Use <methodname>attach()</methodname> and "
"<methodname>attach_next_to()</methodname> to insert child widgets."
msgstr ""
"<classname>Gtk::Grid</classname>将其子部件按行和列排列。使用"
"<methodname>attach()</methodname>和<methodname>attach_next_to()</methodname>"
"方法向网格(Grid)部件中插入子部件。"

#: C/index-in.docbook:1904
msgid ""
"<classname>Gtk::Box</classname> arranges its child widgets vertically or "
"horizontally. Use <methodname>append()</methodname> to insert child widgets."
msgstr ""
"<classname>Gtk::Box</classname>将其子部件水平或垂直排列。使用"
"<methodname>append()</methodname>方法向盒(Box)部件插入子部件。"

#: C/index-in.docbook:1912
msgid "There are several other containers, which we will also discuss."
msgstr "还有几个容器我们将在之后讨论。"

#: C/index-in.docbook:1916
msgid ""
"If you've never used a packing toolkit before, it can take some getting used "
"to. You'll probably find, however, that you don't need to rely on visual "
"form editors quite as much as you might with other toolkits."
msgstr ""
"如果你之前从未使用组装工具包，那可能需要一段时间来适应它。然后你会发现你不需"
"要和使用其他工具包一样依赖可视化编辑工具。"

#: C/index-in.docbook:1926
msgid "An improved Hello World"
msgstr "改进后的Hello World"

#: C/index-in.docbook:1928
msgid ""
"Let's take a look at a slightly improved <literal>helloworld</literal>, "
"showing what we've learnt."
msgstr ""
"让我们看看改进后的<literal>helloworld</literal>，以展示我们所学到的内容。"

#: C/index-in.docbook:1933
msgid "Hello World 2"
msgstr "Hello World 2"

#: C/index-in.docbook:1939
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/helloworld2\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/helloworld2\">源代码</ulink>"

#: C/index-in.docbook:1941
msgid ""
"After building and running this program, try resizing the window to see the "
"behaviour. Also, try playing with <methodname>set_expand()</methodname>, "
"<methodname>set_hexpand()</methodname>, <methodname>set_vexpand()</"
"methodname>, <methodname>set_halign()</methodname> and "
"<methodname>set_valign()</methodname> while reading the <link linkend=\"sec-"
"boxes\">Boxes</link> section."
msgstr ""
"生成并运行这个程序后，请尝试调整窗口的大小查看其行为。此外在阅读<link "
"linkend=\"sec-boxes\">盒子(Boxes)</link>小节时请尝试使用"
"<methodname>set_expand()</methodname>、<methodname>set_hexpand()</"
"methodname>、<methodname>set_vexpand()</methodname>、"
"<methodname>set_halign()</methodname>和<methodname>set_valign()</methodname>"
"方法。"

#: C/index-in.docbook:1952
msgid "Boxes"
msgstr "盒子(Boxes)"

#: C/index-in.docbook:1954
msgid ""
"Most packing uses boxes as in the above example. These are invisible "
"containers into which we can pack our widgets. When packing widgets into a "
"horizontal box, the objects are inserted horizontally from left to right. In "
"a vertical box, widgets are packed from top to bottom. You may use any "
"combination of boxes inside or beside other boxes to create the desired "
"effect."
msgstr ""
"如上例所示，这些都是不可见容器我们可以将容器装入其中。将部件装填到水平盒中的"
"时候部件从左到右水平插入。将部件装填到垂直盒中的时候部件从上到下垂直插入。你"
"可以在盒中或盒侧组合使用盒以达到你所需的效果。"

#: C/index-in.docbook:1963
msgid "Adding widgets"
msgstr "添加部件"

#: C/index-in.docbook:1964
msgid "Per-child packing options"
msgstr "子部件装填选项"

#: C/index-in.docbook:1965
msgid ""
"The <methodname>append()</methodname> method places widgets inside these "
"containers. It will start at the top and work its way down in a "
"<classname>Box</classname> with vertical orientation, or pack left to right "
"in a <classname>Box</classname> with horizontal orientation. If it's "
"inconvenient to add widgets in this order, use "
"<methodname>insert_child_after()</methodname> or "
"<methodname>insert_child_at_start()</methodname>. We will use "
"<methodname>append()</methodname> in our examples."
msgstr ""
"<methodname>append()</methodname>方法将部件放置于这些容器中。它们将从顶部开"
"始。按<classname>Box</classname>的垂直方向向下移动，或者按<classname>Box</"
"classname>的水平方向从左向右移动。如果你不愿意按此顺序添加子部件，请使用"
"<methodname>insert_child_after()</methodname>或"
"<methodname>insert_child_at_start()</methodname>方法。我们将在示例中使用"
"<methodname>append()</methodname>。"

#: C/index-in.docbook:1975
msgid ""
"There are several options governing how widgets are to be packed, and this "
"can be confusing at first. You can modify the packing by using "
"<methodname>set_expand()</methodname>, <methodname>set_hexpand()</"
"methodname>, <methodname>set_vexpand()</methodname>, "
"<methodname>set_halign()</methodname>, <methodname>set_valign()</methodname> "
"and/or <methodname>set_margin()</methodname> on the child widgets. If you "
"have difficulties, then it is sometimes a good idea to play with the "
"<application>glade</application> GUI designer to see what is possible. You "
"might even decide to use the <classname>Gtk::Builder</classname> API to load "
"your GUI at runtime."
msgstr ""
"有几个选项可以控制部件的打包方式，但是初次使用可能会难以理清效果。你可以在子"
"部件上使用<methodname>set_expand()</methodname>、<methodname>set_hexpand()</"
"methodname>、<methodname>set_vexpand()</methodname>、"
"<methodname>set_halign()</methodname>、<methodname>set_valign()</methodname>"
"方法修改装填策略。如果你感到困难，可以试试<application>glade</application>GUI"
"设计器，看看能不能对你有所帮助。你甚至可以使用<classname>Gtk::Builder</"
"classname>API在运行时加载GUI。"

#: C/index-in.docbook:1987
msgid "There are basically five different styles, as shown in this picture:"
msgstr "如图所示，有五种不同的基本样式。"

#: C/index-in.docbook:1993
msgid "Box Packing 1"
msgstr "组装盒1"

#: C/index-in.docbook:1999
msgid ""
"Each line contains one horizontal <classname>Box</classname> with several "
"buttons. Each of the buttons on a line is packed into the <classname>Box</"
"classname> with the same arguments to the <methodname>set_hexpand()</"
"methodname>, <methodname>set_halign()</methodname>, "
"<methodname>set_margin_start()</methodname> and "
"<methodname>set_margin_end()</methodname> methods."
msgstr ""
"每一行包含一个有多个按钮的水平<classname>Box</classname>。行中的每一个按钮都"
"使用相同参数的<methodname>set_hexpand()</methodname>、"
"<methodname>set_halign()</methodname>、<methodname>set_margin_start()</"
"methodname>和<methodname>set_margin_end()</methodname>方法装入"
"<classname>Box</classname>。"

#: C/index-in.docbook:2008
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Box.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Box.html"
"\">参考</ulink>"

#: C/index-in.docbook:2012
msgid "Per-container packing options"
msgstr "容器装填选项"

#: C/index-in.docbook:2016
#, no-wrap
msgid ""
"Gtk::Box(Gtk::Orientation orientation = Gtk::Orientation::HORIZONTAL, int spacing = 0);\n"
"void set_orientation(Gtk::Orientation orientation);\n"
"void set_spacing(int spacing);\n"
"void set_homogeneous(bool homogeneous = true);"
msgstr ""
"Gtk::Box(Gtk::Orientation orientation = Gtk::Orientation::HORIZONTAL, int spacing = 0);\n"
"void set_orientation(Gtk::Orientation orientation);\n"
"void set_spacing(int spacing);\n"
"void set_homogeneous(bool homogeneous = true);"

#: C/index-in.docbook:2013
msgid ""
"Here's the constructor for the <classname>Box</classname> widget, and "
"methods that set per-container packing options: <_:programlisting-1/> "
"Passing <literal>true</literal> to <methodname>set_homogeneous()</"
"methodname> will cause all of the contained widgets to be the same size. "
"<parameter>spacing</parameter> is a (minimum) number of pixels to leave "
"between each widget."
msgstr ""
"这是<classname>Box</classname>部件的构造函数，以及设置每个容器的打包选项的方"
"法：<_:programlisting-1/> 将<literal>true</literal>传递给"
"<methodname>set_homogeneous()</methodname>方法将导致容器部件所包含的所有部件"
"都有一样的大小。<parameter>spacing</parameter>是每个部件之间要保留的最小像素"
"数。"

#: C/index-in.docbook:2026
msgid ""
"What's the difference between spacing (set when the box is created) and "
"margins (set separately for each child widget)? Spacing is added between "
"objects, and margins are added on one or more sides of a widget. The "
"following figure should make it clearer. The shown margins are the left and "
"right margins of each button in the row."
msgstr ""
"间距（创建盒的时候设置）与边距（为每个子部件分别设置）的区别是：在对象之间添"
"加间距，在部件的一侧或多侧添加边距。下图能使你更清楚的理解这一点。所显示的边"
"距是该行中每个按钮的左右边距。"

#: C/index-in.docbook:2035
msgid "Box Packing 2"
msgstr "组装盒2"

#: C/index-in.docbook:2045
msgid "Gtk::Application and command-line options"
msgstr "Gtk::Application和命令行选项"

#: C/index-in.docbook:2046
msgid ""
"The following example program requires a command-line option. The source "
"code shows two ways of handling command-line options in combination with "
"<classname>Gtk::Application</classname>."
msgstr ""
"下面的示例程序需要一个命令行选项。源代码展示了两种<classname>Gtk::"
"Application</classname>处理命令行选项的方式。"

#: C/index-in.docbook:2052
msgid ""
"Handle the options in <function>main()</function> and hide them from "
"<classname>Gtk::Application</classname> by setting <literal>argc = 1</"
"literal> in the call to <methodname>Gtk::Application::run()</methodname>."
msgstr ""
"在<function>main()</function>中处理选项并且通过设置<literal>argc = 1</"
"literal>将他们从<classname>Gtk::Application</classname>中隐藏，然后调用"
"<methodname>Gtk::Application::run()</methodname>。"

#: C/index-in.docbook:2058
msgid ""
"Give all command-line options to <methodname>Gtk::Application::run()</"
"methodname> and add the flag <literal>Gio::Application::Flags::"
"HANDLES_COMMAND_LINE</literal> to <methodname>Gtk::Application::create()</"
"methodname>. Connect a signal handler to the <literal>command_line</literal> "
"signal, and handle the command-line options in the signal handler."
msgstr ""
"将所有的命令行选项传递给<methodname>Gtk::Application::run()</methodname>并为"
"<methodname>Gtk::Application::create()</methodname>方法设置标志<literal>Gio::"
"Application::Flags::HANDLES_COMMAND_LINE</literal>。"

#: C/index-in.docbook:2065
msgid ""
"You must set the optional parameter <literal>after = false</literal> in the "
"call to <literal>signal_command_line().connect()</literal>, because your "
"signal handler must be called before the default signal handler. You must "
"also call <methodname>Gio::Application::activate()</methodname> in the "
"signal handler, unless you want your application to exit without showing its "
"main window. (<classname>Gio::Application</classname> is a base class of "
"<classname>Gtk::Application</classname>.)"
msgstr ""
"你必须在调用<literal>signal_command_line().connect()</literal>时设置可选参数"
"<literal>after = false</literal>，因为此时必须在默认的信号处理程序之前调用你"
"的信号处理程序。你还必须调用<methodname>Gio::Application::activate()</"
"methodname>处理程序，除非你希望你的应用程序不显示主窗口直接退出"
"（<classname>Gio::Application</classname>是<classname>Gtk::Application</"
"classname>的基类）。"

#: C/index-in.docbook:2078
msgid ""
"Here is the source code for the example that produced the screenshots above. "
"When you run this example, provide a number between 1 and 3 as a command-"
"line option, to see different packing options in use."
msgstr ""
"这是上述截图所运行示例的源代码。在运行此示例时请提供1到3之间的数字作为命令行"
"选项以查看正在使用不同装填选项的行为。"

#: C/index-in.docbook:2081
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/box\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/box\">源代码</ulink>"

#: C/index-in.docbook:2087 C/index-in.docbook:2116
msgid "Grid"
msgstr "网格(Grid)"

#: C/index-in.docbook:2089
msgid ""
"A <classname>Grid</classname> dynamically lays out child widgets in rows and "
"columns. The dimensions of the grid do not need to be specified in the "
"constructor."
msgstr ""
"<classname>Grid</classname>在行与列中动态的摆放他的子部件。不需要在其构造函数"
"当中指定维数。"

#: C/index-in.docbook:2094
msgid ""
"Child widgets can span multiple rows or columns, using <methodname>attach()</"
"methodname>, or added next to an existing widget inside the grid with "
"<methodname>attach_next_to()</methodname>. Individual rows and columns of "
"the grid can be set to have uniform height or width with "
"<methodname>set_row_homogeneous()</methodname> and "
"<methodname>set_column_homogeneous()</methodname>."
msgstr ""
"使用<methodname>attach()</methodname>方法可以跨越多行/列插入子部件，也可以使"
"用<methodname>attach_next_to()</methodname>将子部件插入已经存在于网格中的部件"
"的旁边。可以通过调用<methodname>set_row_homogeneous()</methodname>和"
"<methodname>set_column_homogeneous()</methodname>令网格中所有子部件具有一致的"
"高度或宽度。"

#: C/index-in.docbook:2101
msgid ""
"You can set the <emphasis>margin</emphasis> and <emphasis>expand</emphasis> "
"properties of the child <classname>Widget</classname>s to control their "
"spacing and their behaviour when the Grid is resized."
msgstr ""
"你可以设置子部件的<emphasis>margin</emphasis>和<emphasis>expand</emphasis>属"
"性用以控制调整网格大小时它们之间的间距。"

#: C/index-in.docbook:2105
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Grid.html"
"\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Grid.html"
"\">参考</ulink>"

#: C/index-in.docbook:2108
msgid ""
"This example creates a window with three buttons in a grid. The first two "
"buttons are in the upper row, from left to right. A third button is attached "
"underneath the first button, in a new lower row, spanning two columns."
msgstr ""
"本示例创建一个窗口其中具有一个包含三个按钮的网格。前两个按钮位于最上行并从左"
"向右排列。第三个按钮位于第一个按钮的下方，位于最下行并横跨两列。"

#: C/index-in.docbook:2122
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/grid\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/grid\">源代码</ulink>"

#: C/index-in.docbook:2129 C/index-in.docbook:2164
msgid "Notebook"
msgstr "笔记本(Notebook)"

#: C/index-in.docbook:2131
msgid ""
"A <classname>Notebook</classname> has a set of stacked <literal>pages</"
"literal>, each of which contains widgets. Labelled <literal>tabs</literal> "
"allow the user to select the pages. <classname>Notebook</classname>s allow "
"several sets of widgets to be placed in a small space, by only showing one "
"page at a time. For instance, they are often used in preferences dialogs."
msgstr ""
"<classname>Notebook</classname>有一组堆叠好的<literal>pages</literal>，每个页"
"面(page)包含一个部件。带标签的<literal>tabs</literal>允许用户选择页面。"
"<classname>Notebook</classname>一次只显示一页，这样可以将好几组部件放于很小的"
"空间当中。例如他们经常在首选项对话框中使用。"

#: C/index-in.docbook:2140
msgid ""
"Use the <methodname>append_page()</methodname>, <methodname>prepend_page()</"
"methodname> and <methodname>insert_page()</methodname> methods to add tabbed "
"pages to the <literal>Notebook</literal>, supplying the child widget and the "
"name for the tab."
msgstr ""
"使用<methodname>append_page()</methodname>、<methodname>prepend_page()</"
"methodname>和<methodname>insert_page()</methodname>方法可以添加带标签的页面到"
"<literal>Notebook</literal>中，你需要为这些方法提供子部件和标签名。"

#: C/index-in.docbook:2147
msgid ""
"To discover the currently visible page, use the "
"<methodname>get_current_page()</methodname> method. This returns the page "
"number, and then calling <methodname>get_nth_page()</methodname> with that "
"number will give you a pointer to the actual child widget."
msgstr ""
"如果你想知道当前可见的页面是那一个，可以使用<methodname>get_current_page()</"
"methodname>方法。该方法返回一个页码，你可以将页码传递给"
"<methodname>get_nth_page()</methodname>获取指向该页当前子部件的指针。"

#: C/index-in.docbook:2154
msgid ""
"To programmatically change the selected page, use the "
"<methodname>set_current_page()</methodname> method."
msgstr ""
"要以编程方式改变所选的页面，请使用<methodname>set_current_page()</methodname>"
"方法。"

#: C/index-in.docbook:2159
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Notebook."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Notebook."
"html\">参考</ulink>"

#: C/index-in.docbook:2170
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/notebook/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/notebook/\">源代码</ulink>"

#: C/index-in.docbook:2177 C/index-in.docbook:2204
msgid "Assistant"
msgstr "助手(Assistant)"

#: C/index-in.docbook:2179
msgid ""
"An <classname>Assistant</classname> splits a complex operation into steps. "
"Each step is a page, containing a header, a child widget and an action area. "
"The Assistant's action area has navigation buttons which update "
"automatically depending on the type of the page, set with "
"<methodname>set_page_type()</methodname>."
msgstr ""
"<classname>Assistant</classname>将一个复杂的操作切分为数个步骤。每个步骤都是"
"一个页面，包含一个标题、一个子部件和一个可操作区域。助手的操作区域有一个导航"
"按钮，这些按钮会根据页面的类型自动更新（使用<methodname>set_page_type()</"
"methodname>设置页面类型）。"

#: C/index-in.docbook:2183
msgid ""
"Use the <methodname>append_page()</methodname>, <methodname>prepend_page</"
"methodname> and <methodname>insert_page()</methodname> methods to add pages "
"to the <classname>Assistant</classname>, supplying the child widget for each "
"page."
msgstr ""
"使用<methodname>append_page()</methodname>、<methodname>prepend_page</"
"methodname>和<methodname>insert_page()</methodname>方法可以向"
"<classname>Assistant</classname>添加页面，你需要每个页面提供子部件。"

#: C/index-in.docbook:2187
msgid ""
"To determine the currently-visible page, use the "
"<methodname>get_current_page()</methodname> method, and pass the result to "
"<methodname>get_nth_page()</methodname>, which returns a pointer to the "
"actual widget. To programmatically change the current page, use the "
"<methodname>set_current_page()</methodname> method."
msgstr ""
"要确定当前可见的页面，请使用<methodname>get_current_page()</methodname>方法，"
"然后将返回值传递给<methodname>get_nth_page()</methodname>，其会返回一个指向实"
"际部件的指针。要想用编程的方式改变当前页，请使用"
"<methodname>set_current_page()</methodname>方法。"

#: C/index-in.docbook:2191
msgid ""
"To set the title of a page, use the <methodname>set_page_title()</"
"methodname> method."
msgstr ""
"要为页面设置标题，请使用<methodname>set_page_title()</methodname>方法。"

#: C/index-in.docbook:2195
msgid ""
"To add widgets to the action area, use the <methodname>add_action_widget()</"
"methodname> method. They will be packed alongside the default buttons. Use "
"the <methodname>remove_action_widget()</methodname> method to remove widgets."
msgstr ""
"要将部件添加到操作区域，请使用<methodname>add_action_widget()</methodname>方"
"法。他们将与默认按钮一并被装填。使用<methodname>remove_action_widget()</"
"methodname>方法可以删除部件。"

#: C/index-in.docbook:2199
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Assistant."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Assistant."
"html\">参考</ulink>"

#: C/index-in.docbook:2210
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/assistant/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/assistant/\">源代码</ulink>"

#: C/index-in.docbook:2217
msgid "Other Multi-item Containers"
msgstr "其他多项容器"

#: C/index-in.docbook:2219
msgid ""
"There are other multi-item containers. See the reference documentation for a "
"complete list. Here are links to some example programs that show containers, "
"which are not mentioned elsewhere in this tutorial."
msgstr ""
"还有其他多项容器。请参阅文档以获取完整列表。这里是一些本教程未提及的显示容器"
"的示例程序连接。"

#: C/index-in.docbook:2225
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/actionbar\">Source Code, ActionBar</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/actionbar\">动作条(ActionBar)源代码</ulink>"

#: C/index-in.docbook:2226
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/flowbox\">Source Code, FlowBox</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/flowbox\">流式盒(FlowBox)源代码</ulink>"

#: C/index-in.docbook:2227
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/iconview\">Source Code, IconView</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/iconview\">图标视图(IconView)源代码</ulink>"

#: C/index-in.docbook:2237
msgid "The TreeView widget"
msgstr "树形视图(TreeView)部件"

#: C/index-in.docbook:2238
msgid ""
"The <classname>Gtk::TreeView</classname> widget can contain lists or trees "
"of data, in columns."
msgstr ""
" <classname>Gtk::TreeView</classname>部件的每一行都可以包含数据列表或数据树。"

#: C/index-in.docbook:2244
msgid "The Model"
msgstr "模型(Model)"

#: C/index-in.docbook:2245
msgid ""
"Each <classname>Gtk::TreeView</classname> has an associated <classname>Gtk::"
"TreeModel</classname>, which contains the data displayed by the "
"<classname>TreeView</classname>. Each <classname>Gtk::TreeModel</classname> "
"can be used by more than one <classname>Gtk::TreeView</classname>. For "
"instance, this allows the same underlying data to be displayed and edited in "
"2 different ways at the same time. Or the 2 Views might display different "
"columns from the same Model data, in the same way that 2 SQL queries (or "
"\"views\") might show different fields from the same database table."
msgstr ""
"每一个<classname>Gtk::TreeView</classname>都有一个与之关联的<classname>Gtk::"
"TreeModel</classname>，模型中包含了<classname>TreeView</classname>将要显示的"
"数据。每个<classname>Gtk::TreeModel</classname>都可以被多个<classname>Gtk::"
"TreeView</classname>使用。例如，这将允许以多种不同的方式同时显示和编辑一致的"
"数据。也允许不同的视图显示同一个模型的不同列的数据，就像是多个SQL查询（或“视"
"图”）显示同一个数据库表的不同字段一样。"

#: C/index-in.docbook:2255
msgid ""
"Although you can theoretically implement your own Model, you will normally "
"use either the <classname>ListStore</classname> or <classname>TreeStore</"
"classname> model classes."
msgstr ""
"理论上你可以实现自己的模型，但通常情况直接使用<classname>ListStore</"
"classname>或<classname>TreeStore</classname>可以省略很多麻烦。"

#: C/index-in.docbook:2261
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModel."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeModel."
"html\">参考</ulink>"

#: C/index-in.docbook:2264
msgid "ListStore, for rows"
msgstr "列表储存(ListStore)的行"

#: C/index-in.docbook:2265
msgid ""
"The <classname>ListStore</classname> contains simple rows of data, and each "
"row has no children."
msgstr "<classname>ListStore</classname>包含简单的数据行，每个行都没有孩子。"

#: C/index-in.docbook:2271 C/index-in.docbook:2839
msgid "TreeView - ListStore"
msgstr "树形视图 - 列表储存"

#: C/index-in.docbook:2277
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ListStore."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ListStore."
"html\">参考</ulink>"

#: C/index-in.docbook:2282
msgid "TreeStore, for a hierarchy"
msgstr "具有层次的树状储存"

#: C/index-in.docbook:2283
msgid ""
"The <classname>TreeStore</classname> contains rows of data, and each row may "
"have child rows."
msgstr "<classname>TreeStore</classname>包含数据行，并且每一行都可能有子行。"

#: C/index-in.docbook:2289 C/index-in.docbook:2858
msgid "TreeView - TreeStore"
msgstr "树形视图 - 树状储存"

#: C/index-in.docbook:2295
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeStore."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeStore."
"html\">参考</ulink>"

#: C/index-in.docbook:2300
msgid "Model Columns"
msgstr "模型列"

#: C/index-in.docbook:2301
msgid ""
"The <classname>TreeModelColumnRecord</classname> class is used to keep track "
"of the columns and their data types. You add <classname>TreeModelColumn</"
"classname> instances to the <classname>ColumnRecord</classname> and then use "
"those <classname>TreeModelColumns</classname> when getting and setting the "
"data in model rows. You will probably find it convenient to derive a new "
"<classname>TreeModelColumnRecord</classname> which has your "
"<classname>TreeModelColumn</classname> instances as member data."
msgstr ""
"<classname>TreeModelColumnRecord</classname>用于跟踪列和它们的数据类型。你"
"<classname>TreeModelColumn</classname>实例添加到<classname>ColumnRecord</"
"classname>，然后使用那些<classname>TreeModelColumns</classname>获取和设置模型"
"列中的数据。你可能会发现，派生一个你自己的包含有<classname>TreeModelColumn</"
"classname>数据成员的<classname>TreeModelColumnRecord</classname>会更方便。"

#: C/index-in.docbook:2312
#, no-wrap
msgid ""
"class ModelColumns : public Gtk::TreeModelColumnRecord\n"
"{\n"
"public:\n"
"\n"
"  ModelColumns()\n"
"    { add(m_col_text); add(m_col_number); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_number;\n"
"};\n"
"\n"
"ModelColumns m_Columns;"
msgstr ""
"class ModelColumns : public Gtk::TreeModelColumnRecord\n"
"{\n"
"public:\n"
"\n"
"  ModelColumns()\n"
"    { add(m_col_text); add(m_col_number); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_number;\n"
"};\n"
"\n"
"ModelColumns m_Columns;"

#: C/index-in.docbook:2325
msgid ""
"You specify the <classname>ColumnRecord</classname> when creating the Model, "
"like so:"
msgstr ""
"你可以在创建模型的时候指定<classname>ColumnRecord</classname>，如下所示："

#: C/index-in.docbook:2329
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"
msgstr ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"

#: C/index-in.docbook:2331
msgid ""
"As a <classname>TreeModelColumnRecord</classname> describes structure, not "
"data, it can be shared among multiple models, and this is preferable for "
"efficiency. However, the instance (such as <varname>m_Columns</varname> "
"here) should usually not be static, because it often needs to be "
"instantiated after <application>glibmm</application> has been initialized. "
"The best solution is to make it a lazily instantiated singleton, so that it "
"will be constructed on-demand, whenever the first model accesses it."
msgstr ""
"<classname>TreeModelColumnRecord</classname>描述的是结构而不是数据，它可以在"
"多个模型之间共享，这样效率更高。但是实例（例如此处的<varname>m_Columns</"
"varname>）通常不是静态的，因为通常需要在<application>glibmm</application>初始"
"化后示例化它。最好的解决方案是使他成为惰性初始化的单例，以便在第一个模型访问"
"他的时候按需构造。"

#: C/index-in.docbook:2343
msgid "Adding Rows"
msgstr "添加行"

#: C/index-in.docbook:2344
msgid ""
"Add rows to the model with the <methodname>append()</methodname>, "
"<methodname>prepend()</methodname>, or <methodname>insert()</methodname> "
"methods."
msgstr ""
"使用<methodname>append()</methodname>、<methodname>prepend()</methodname>或"
"<methodname>insert()</methodname>方法可以向模型添加行。"

#: C/index-in.docbook:2348
#, no-wrap
msgid "auto iter = m_refListStore-&gt;append();"
msgstr "auto iter = m_refListStore-&gt;append();"

#: C/index-in.docbook:2349
msgid "You can dereference the iterator to get the Row:"
msgstr "你可以通过解引用迭代器获得行："

#: C/index-in.docbook:2351
#, no-wrap
msgid "auto row = *iter;"
msgstr "auto row = *iter;"

#: C/index-in.docbook:2352
msgid "Adding child rows"
msgstr "添加子行"

#: C/index-in.docbook:2353
msgid ""
"<classname>Gtk::TreeStore</classname> models can have child items. Add them "
"with the <methodname>append()</methodname>, <methodname>prepend()</"
"methodname>, or <methodname>insert()</methodname> methods, like so:"
msgstr ""
"<classname>Gtk::TreeStore</classname>模型可以存在子物件。可以通过"
"<methodname>append()</methodname>、<methodname>prepend()</methodname>或"
"<methodname>insert()</methodname>方法添加，如下所示："

#: C/index-in.docbook:2358
#, no-wrap
msgid ""
"auto iter_child =\n"
"    m_refTreeStore-&gt;append(row.children());"
msgstr ""
"auto iter_child =\n"
"    m_refTreeStore-&gt;append(row.children());"

#: C/index-in.docbook:2365
msgid "Setting values"
msgstr "设置值"

#: C/index-in.docbook:2366
msgid ""
"You can use the <methodname>operator[]</methodname> overload to set the data "
"for a particular column in the row, specifying the "
"<classname>TreeModelColumn</classname> used to create the model."
msgstr ""
"你可以使用<methodname>operator[]</methodname>重载设置行中的特定列的数据，你需"
"要使用创建模型时的<classname>TreeModelColumn</classname>指定列。"

#: C/index-in.docbook:2371
#, no-wrap
msgid "row[m_Columns.m_col_text] = \"sometext\";"
msgstr "row[m_Columns.m_col_text] = \"sometext\";"

#: C/index-in.docbook:2375
msgid "Getting values"
msgstr "获取值"

#: C/index-in.docbook:2376
msgid ""
"You can use the <methodname>operator[]</methodname> overload to get the data "
"in a particular column in a row, specifying the <classname>TreeModelColumn</"
"classname> used to create the model."
msgstr ""
"你可以使用<methodname>operator[]</methodname>重载获取行中特定列的数据，你需要"
"使用创建模型时的<classname>TreeModelColumn</classname>指定列。"

#: C/index-in.docbook:2381
#, no-wrap
msgid ""
"auto strText = row[m_Columns.m_col_text];\n"
"auto number = row[m_Columns.m_col_number];"
msgstr ""
"auto strText = row[m_Columns.m_col_text];\n"
"auto number = row[m_Columns.m_col_number];"

#: C/index-in.docbook:2383
msgid ""
"The compiler will complain if you use an inappropriate type. For instance, "
"this would generate a compiler error:"
msgstr ""
"如果你使用了不合适的类型，编译器会报错。例如，编译器将生成一个编译错误："

#: C/index-in.docbook:2387
#, no-wrap
msgid ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"
msgstr ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"

#: C/index-in.docbook:2392
msgid "\"Hidden\" Columns"
msgstr "“隐藏”列"

#: C/index-in.docbook:2393
msgid ""
"You might want to associate extra data with each row. If so, just add it as "
"a Model column, but don't add it to the View."
msgstr ""
"你可能想要将额外的数据和每一行关联。如果是这样，你只需要将其添加到模型的一个"
"行中而不将其添加到视图中即可。"

#: C/index-in.docbook:2402 C/index-in.docbook:3248
msgid "The View"
msgstr "视图"

#: C/index-in.docbook:2403
msgid ""
"The View is the actual widget (<classname>Gtk::TreeView</classname>) that "
"displays the model (<classname>Gtk::TreeModel</classname>) data and allows "
"the user to interact with it. The View can show all of the model's columns, "
"or just some, and it can show them in various ways."
msgstr ""
"视图实际上是一个用于显示模型(<classname>Gtk::TreeModel</classname>)数据并允许"
"用户与其交互的部件(<classname>Gtk::TreeView</classname>)。视图可以显示模型的"
"所有列也可以只显示一部分列还可以以不同的方式显示列。"

#: C/index-in.docbook:2410
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeView."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TreeView."
"html\">参考</ulink>"

#: C/index-in.docbook:2413
msgid "Using a Model"
msgstr "使用模型"

#: C/index-in.docbook:2414
msgid ""
"You can specify a <classname>Gtk::TreeModel</classname> when constructing "
"the <classname>Gtk::TreeView</classname>, or you can use the "
"<methodname>set_model()</methodname> method, like so:"
msgstr ""
"你可以在构造<classname>Gtk::TreeView</classname>的时候为其指定一个"
"<classname>Gtk::TreeModel</classname>，也可以构筑完成后使用"
"<methodname>set_model()</methodname>方法指定，如下所示："

#: C/index-in.docbook:2419
#, no-wrap
msgid "m_TreeView.set_model(m_refListStore);"
msgstr "m_TreeView.set_model(m_refListStore);"

#: C/index-in.docbook:2423
msgid "Adding View Columns"
msgstr "为视图添加列"

#: C/index-in.docbook:2424
msgid ""
"You can use the <methodname>append_column()</methodname> method to tell the "
"View that it should display certain Model columns, in a certain order, with "
"a certain column title."
msgstr ""
"你可以使用<methodname>append_column()</methodname>方法告知视图以一定的顺序于"
"某个列标题下显示模型的某个列。"

#: C/index-in.docbook:2429
#, no-wrap
msgid "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"
msgstr "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"

#: C/index-in.docbook:2430
msgid ""
"When using this simple <methodname>append_column()</methodname> overload, "
"the <classname>TreeView</classname> will display the model data with an "
"appropriate <classname>CellRenderer</classname>. For instance, strings and "
"numbers are shown in a simple <classname>Gtk::Entry</classname> widget, and "
"booleans are shown in a <classname>Gtk::CheckButton</classname>. This is "
"usually what you need. For other column types you must either connect a "
"callback that converts your type into a string representation, with "
"<methodname>TreeViewColumn::set_cell_data_func()</methodname>, or derive a "
"custom <classname>CellRenderer</classname>. Note that (unsigned) short is "
"not supported by default - You could use (unsigned) int or (unsigned) long "
"as the column type instead."
msgstr ""
"当使用这种简单的<methodname>append_column()</methodname>重载的时候，"
"<classname>TreeView</classname>将会使用适当的<classname>CellRenderer</"
"classname>显示模型数据。例如将字符串和数字显示在简单的<classname>Gtk::Entry</"
"classname>部件中，布尔量使用<classname>Gtk::CheckButton</classname>显示。这通"
"常是你所希望的行为。对于其他类型的行，你必须使用<methodname>TreeViewColumn::"
"set_cell_data_func()</methodname>连接一个将你的类型转换为字符串表示形式的回"
"调，或者是从<classname>CellRenderer</classname>派生一个合适的类。请注意，默认"
"情况下<literal>(unsigned) short</literal>不被支持 - 作为替代你可以使用"
"<literal>(unsigned) int</literal>或者<literal>(unsigned) long</literal>作为行"
"类型。"

#: C/index-in.docbook:2446
msgid "More than one Model Column per View Column"
msgstr "每个视图列不不止一个模型列"

#: C/index-in.docbook:2447
msgid ""
"To render more than one model column in a view column, you need to create "
"the <classname>TreeView::Column</classname> widget manually, and use "
"<methodname>pack_start()</methodname> to add the model columns to it."
msgstr ""
"要在一个视图列中呈现多个模型列，你需要手动创建<classname>TreeView::Column</"
"classname>部件，并使用<methodname>pack_start()</methodname>方法向其添加模型"
"列。"

#: C/index-in.docbook:2453
msgid ""
"Then use <methodname>append_column()</methodname> to add the view Column to "
"the View. Notice that <methodname>Gtk::TreeView::append_column()</"
"methodname> is overloaded to accept either a prebuilt <classname>Gtk::"
"TreeView::Column</classname> widget, or just the <classname>TreeModelColumn</"
"classname> from which it generates an appropriate <classname>Gtk::TreeView::"
"Column</classname> widget."
msgstr ""
"然后使用<methodname>append_column()</methodname>将视图列添加到视图中。请注"
"意，<methodname>Gtk::TreeView::append_column()</methodname>被重载为接受预建的"
"<classname>Gtk::TreeView::Column</classname>部件，或者只接受由"
"<classname>TreeModelColumn</classname>生成的合适的<classname>Gtk::TreeView::"
"Column</classname>部件。"

#: C/index-in.docbook:2460
msgid ""
"Here is some example code, which has a pixbuf icon and a text name in the "
"same column:"
msgstr "这是一些示例代码，在同一列中有一个像素缓冲区(pixbuf)图标和一个文本名："

#: C/index-in.docbook:2463
#, no-wrap
msgid ""
"\n"
"auto pColumn = Gtk::make_managed&lt;Gtk::TreeView::Column&gt;(\"Icon Name\");\n"
"\n"
"// m_columns.icon and m_columns.iconname are columns in the model.\n"
"// pColumn is the column in the TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);\n"
"pColumn-&gt;pack_start(m_columns.iconname);\n"
"\n"
"m_TreeView.append_column(*pColumn);"
msgstr ""
"\n"
"auto pColumn = Gtk::make_managed&lt;Gtk::TreeView::Column&gt;(\"Icon Name\");\n"
"\n"
"// m_columns.icon and m_columns.iconname are columns in the model.\n"
"// pColumn is the column in the TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);\n"
"pColumn-&gt;pack_start(m_columns.iconname);\n"
"\n"
"m_TreeView.append_column(*pColumn);"

#: C/index-in.docbook:2475
msgid "Specifying CellRenderer details"
msgstr "指定单元格渲染器(CellRenderer)详情"

#: C/index-in.docbook:2476
msgid ""
"The default <classname>CellRenderers</classname> and their default behaviour "
"will normally suffice, but you might occasionally need finer control. For "
"instance, this example code from <filename>gtkmm/demos/gtk-demo/"
"example_treeview_treestore.cc</filename>, appends a <classname>Gtk::"
"CellRenderer</classname> widget and instructs it to render the data from "
"various model columns through various aspects of its appearance."
msgstr ""
"默认的<classname>CellRenderers</classname>及其默认行为通常已经足够好了，但是"
"有时你需要更精细的控制它。例如来自<filename>gtkmm/demos/gtk-demo/"
"example_treeview_treestore.cc</filename>的示例代码，附加一个<classname>Gtk::"
"CellRenderer</classname>部件并指示其各个模型列的外观的各个方面来呈现数据。"

#: C/index-in.docbook:2484
#, no-wrap
msgid ""
"auto cols_count = m_TreeView.append_column_editable(\"Alex\", m_columns.alex);\n"
"auto pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  auto pRenderer = static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);"
msgstr ""
"auto cols_count = m_TreeView.append_column_editable(\"Alex\", m_columns.alex);\n"
"auto pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  auto pRenderer = static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);"

#: C/index-in.docbook:2492
msgid ""
"You can also connect to <classname>CellRenderer</classname> signals to "
"detect user actions. For instance:"
msgstr ""
"你还可以通过连接到<classname>CellRenderer</classname>的信号以检测用户的操作。"
"例如："

#: C/index-in.docbook:2496
#, no-wrap
msgid ""
"\n"
"auto pRenderer = Gtk::make_managed&lt;Gtk::CellRendererToggle&gt;();\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"
msgstr ""
"\n"
"auto pRenderer = Gtk::make_managed&lt;Gtk::CellRendererToggle&gt;();\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"

#: C/index-in.docbook:2505 C/index-in.docbook:2868
msgid "Editable Cells"
msgstr "可编辑单元格"

#: C/index-in.docbook:2508
msgid "Automatically-stored editable cells."
msgstr "自动储存的可编辑单元格"

#: C/index-in.docbook:2509
msgid ""
"Cells in a <classname>TreeView</classname> can be edited in-place by the "
"user. To allow this, use the <classname>Gtk::TreeView</classname> "
"<methodname>insert_column_editable()</methodname> and "
"<methodname>append_column_editable()</methodname> methods instead of "
"<methodname>insert_column()</methodname> and <methodname>append_column()</"
"methodname>. When these cells are edited the new values will be stored "
"immediately in the Model. Note that these methods are templates which can "
"only be instantiated for simple column types such as <classname>Glib::"
"ustring</classname>, int, and long."
msgstr ""
"用户可以就地编辑<classname>TreeView</classname>中的单元格。若要如此，请使用"
"<classname>Gtk::TreeView</classname>的<methodname>insert_column_editable()</"
"methodname>和<methodname>append_column_editable()</methodname>方法而不是"
"<methodname>insert_column()</methodname>和<methodname>append_column()</"
"methodname>方法。编辑单元格后新的值将立刻储存在模型中。请注意，这些方法是模"
"版，只能为简单的列类型实例化（例如，<classname>Glib::ustring</classname>、"
"<literal>int</literal>和<literal>long</literal>）。"

#: C/index-in.docbook:2523
msgid "Implementing custom logic for editable cells."
msgstr "为可编辑单元格实现自定义逻辑。"

#: C/index-in.docbook:2524
msgid ""
"However, you might not want the new values to be stored immediately. For "
"instance, maybe you want to restrict the input to certain characters or "
"ranges of values."
msgstr ""
"但是你可能不希望立刻储存新的值。例如你可能希望对输入进行检测，符合预期的范围"
"才储存。"

#: C/index-in.docbook:2529
msgid ""
"To achieve this, you should use the normal <classname>Gtk::TreeView</"
"classname> <methodname>insert_column()</methodname> and "
"<methodname>append_column()</methodname> methods, then use "
"<methodname>get_column_cell_renderer()</methodname> to get the "
"<classname>Gtk::CellRenderer</classname> used by that column."
msgstr ""
"为此，你应该使用常规的<methodname>Gtk::TreeView::insert_column()</methodname>"
"和<methodname>Gtk::TreeView::append_column()</methodname>方法，然后使用"
"<methodname>get_column_cell_renderer()</methodname>方法获取该列使用的"
"<classname>Gtk::CellRenderer</classname>。"

#: C/index-in.docbook:2535
msgid ""
"You should then cast that <classname>Gtk::CellRenderer*</classname> to the "
"specific <classname>CellRenderer</classname> that you expect, so you can use "
"specific API."
msgstr ""
"然后你应该讲<classname>Gtk::CellRenderer*</classname>转换为你期望的特定版本的"
"<classname>CellRenderer</classname>（例如转换为<classname>CellRendererText</"
"classname>，以便调用特定的API。"

#: C/index-in.docbook:2539
msgid ""
"For instance, for a CellRendererText, you would set the cell's "
"<emphasis>editable</emphasis> property to true, like so:"
msgstr ""
"例如，对于<classname>CellRendererText</classname>，你应该将单元格的"
"<emphasis>editable</emphasis>属性设置为<literal>true</literal>，如下所示："

#: C/index-in.docbook:2542
#, no-wrap
msgid "cell-&gt;property_editable() = true;"
msgstr "cell-&gt;property_editable() = true;"

#: C/index-in.docbook:2543
msgid ""
"For a CellRendererToggle, you would set the <emphasis>activatable</emphasis> "
"property instead."
msgstr ""
"对于<classname>CellRendererToggle</classname>，你应该改为设置"
"<emphasis>activatable</emphasis>属性。"

#: C/index-in.docbook:2547
msgid ""
"You can then connect to the appropriate \"edited\" signal. For instance, "
"connect to <methodname>Gtk::CellRendererText::signal_edited()</methodname>, "
"or <methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. If "
"the column contains more than one <classname>CellRenderer</classname> then "
"you will need to use <methodname>Gtk::TreeView::get_column()</methodname> "
"and then call <methodname>get_cells()</methodname> on that view Column."
msgstr ""
"你可以连接到适当的\"edited\"信号。例如，连接到<methodname>Gtk::"
"CellRendererText::signal_edited()</methodname>或者是<methodname>Gtk::"
"CellRendererToggle::signal_toggled()</methodname>。如果该列包含多个"
"<classname>CellRenderer</classname>，则你需要在视图上使用<methodname>Gtk::"
"TreeView::get_column()</methodname>方法然后再调用<methodname>get_cells()</"
"methodname>获取目标单元格。"

#: C/index-in.docbook:2555
msgid ""
"In your signal handler, you should examine the new value and then store it "
"in the Model if that is appropriate for your application."
msgstr ""
"在你的信号处理函数中，你应该检查新值如果其对于你的应用程序而言是合适的则将其"
"储存到你的模型中。"

#: C/index-in.docbook:2567
msgid "Iterating over Model Rows"
msgstr "遍历模型行"

#: C/index-in.docbook:2568
msgid ""
"<classname>Gtk::TreeModel</classname> provides a C++ Standard Library-style "
"container of its children, via the <methodname>children()</methodname> "
"method. You can use the familiar <methodname>begin()</methodname> and "
"<methodname>end()</methodname> methods iterator incrementing, like so:"
msgstr ""
"<classname>Gtk::TreeModel</classname>通过<methodname>children()</methodname>"
"方法提供了标准C++容器库风格的子代迭代器。你可以使用熟悉的"
"<methodname>begin()</methodname>和<methodname>end()</methodname>方法递增迭代"
"器，如下所示："

#: C/index-in.docbook:2574
#, no-wrap
msgid ""
"\n"
"auto children = refModel-&gt;children();\n"
"for (auto iter = children.begin(), end = children.end(); iter != end; ++iter)\n"
"{\n"
"  auto row = *iter;\n"
"  //Do something with the row - see above for set/get.\n"
"}"
msgstr ""
"\n"
"auto children = refModel-&gt;children();\n"
"for (auto iter = children.begin(), end = children.end(); iter != end; ++iter)\n"
"{\n"
"  auto row = *iter;\n"
"  //Do something with the row - see above for set/get.\n"
"}"

#: C/index-in.docbook:2581
msgid ""
"If you always want to iterate across the entire range, much more succinct "
"syntax is possible using C++'s range-based <literal>for</literal> loop:"
msgstr ""
"如果你总是想迭代整个范围，则可以使用C++基于范围的更简洁的<literal>for</"
"literal>循环语法："

#: C/index-in.docbook:2585
#, no-wrap
msgid ""
"\n"
"for (auto row: refModel-&gt;children())\n"
"{\n"
"  //Do something with the row - see above for set/get.\n"
"}"
msgstr ""
"\n"
"for (auto row: refModel-&gt;children())\n"
"{\n"
"  //Do something with the row - see above for set/get.\n"
"}"

#: C/index-in.docbook:2592
msgid "Row children"
msgstr "子行"

#: C/index-in.docbook:2597
#, no-wrap
msgid "Gtk::TreeModel::Children children = row.children();"
msgstr "Gtk::TreeModel::Children children = row.children();"

#: C/index-in.docbook:2593
msgid ""
"When using a <classname>Gtk::TreeStore</classname>, the rows can have child "
"rows, which can have their own children in turn. Use <methodname>Gtk::"
"TreeModel::Row::children()</methodname> to get the container of child "
"<classname>Row</classname>s: <_:programlisting-1/>"
msgstr ""
"在使用<classname>Gtk::TreeStore</classname>的时候，其行可以存在子行，子行也可"
"以存在子行。使用<methodname>Gtk::TreeModel::Row::children()</methodname>方法"
"可以获取<classname>Row</classname>的子行：<_:programlisting-1/>"

#: C/index-in.docbook:2604
msgid "The Selection"
msgstr "选择"

#: C/index-in.docbook:2605
msgid ""
"To find out what rows the user has selected, get the <classname>Gtk::"
"TreeView::Selection</classname> object from the <classname>TreeView</"
"classname>, like so:"
msgstr ""
"要找出用户选择了那些行，请从<classname>TreeView</classname>的<classname>Gtk::"
"TreeView::Selection</classname>对象获取。"

#: C/index-in.docbook:2610
#, no-wrap
msgid "auto refTreeSelection = m_TreeView.get_selection();"
msgstr "auto refTreeSelection = m_TreeView.get_selection();"

#: C/index-in.docbook:2613
msgid "Single or multiple selection"
msgstr "单选或多选"

#: C/index-in.docbook:2617
#, no-wrap
msgid "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"
msgstr "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"

#: C/index-in.docbook:2614
msgid ""
"By default, only single rows can be selected, but you can allow multiple "
"selection by setting the mode, like so: <_:programlisting-1/>"
msgstr ""
"默认情况下，只能选定一行，但是你可以通过设置选择模式选择多行，如下所示：<_:"
"programlisting-1/>"

#: C/index-in.docbook:2622
msgid "The selected rows"
msgstr "选定的行"

#: C/index-in.docbook:2623
msgid ""
"For single-selection, you can just call <methodname>get_selected()</"
"methodname>, like so:"
msgstr ""
"对于单选模式，你可以如下所示调用<methodname>get_selected()</methodname>："

#: C/index-in.docbook:2627
#, no-wrap
msgid ""
"auto iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) //If anything is selected\n"
"{\n"
"  auto row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""
"auto iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) //If anything is selected\n"
"{\n"
"  auto row = *iter;\n"
"  //Do something with the row.\n"
"}"

#: C/index-in.docbook:2634
msgid ""
"For multiple-selection, you need to call <methodname>get_selected_rows()</"
"methodname> or define a callback, and give it to "
"<methodname>selected_foreach()</methodname>, "
"<methodname>selected_foreach_path()</methodname>, or "
"<methodname>selected_foreach_iter()</methodname>, like so:"
msgstr ""
"对于多选模式，你需要调用<methodname>get_selected_rows()</methodname>或者定义"
"一个回调然后将其传递给<methodname>selected_foreach()</methodname>、"
"<methodname>selected_foreach_path()</methodname>或"
"<methodname>selected_foreach_iter()</methodname>，如下所示："

#: C/index-in.docbook:2641
#, no-wrap
msgid ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::const_iterator&amp; iter)\n"
"{\n"
"  auto row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::const_iterator&amp; iter)\n"
"{\n"
"  auto row = *iter;\n"
"  //Do something with the row.\n"
"}"

#: C/index-in.docbook:2654
msgid "The \"changed\" signal"
msgstr "\"changed\"信号"

#: C/index-in.docbook:2655
msgid ""
"To respond to the user clicking on a row or range of rows, connect to the "
"signal like so:"
msgstr "要响应用户单击某行或者某个范围的行，请按以下方式连接信号："

#: C/index-in.docbook:2659
#, no-wrap
msgid ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)\n"
");"
msgstr ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)\n"
");"

#: C/index-in.docbook:2665
msgid "Preventing row selection"
msgstr "防止行被选择"

#: C/index-in.docbook:2666
msgid ""
"Maybe the user should not be able to select every item in your list or tree. "
"For instance, in the gtk-demo, you can select a demo to see the source code, "
"but it doesn't make any sense to select a demo category."
msgstr ""
"或许用户不应该能选择列表或树中的每个项目。例如在gtk-demo中，你可以选择一个演"
"示来查看他的源代码，但是你选一个演示类别没有意义。"

#: C/index-in.docbook:2671
msgid ""
"To control which rows can be selected, use the "
"<methodname>set_select_function()</methodname> method, providing a "
"<classname>sigc::slot</classname> callback. For instance:"
msgstr ""
"要控制一个行是否能被选择，请使用<methodname>set_select_function()</"
"methodname>方法为其提供一个<classname>sigc::slot</classname>回调。例如："

#: C/index-in.docbook:2676
#, no-wrap
msgid ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"
msgstr ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"

#: C/index-in.docbook:2678
msgid "and then"
msgstr "接着"

#: C/index-in.docbook:2681
#, no-wrap
msgid ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const auto iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"
msgstr ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const auto iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"

#: C/index-in.docbook:2691
msgid "Changing the selection"
msgstr "修改选择"

#: C/index-in.docbook:2692
msgid ""
"To change the selection, specify a <classname>Gtk::TreeModel::iterator</"
"classname> or <classname>Gtk::TreeModel::Row</classname>, like so:"
msgstr ""
"要更改选择，请指定<classname>Gtk::TreeModel::iterator</classname>或"
"<classname>Gtk::TreeModel::Row</classname>，然后如下所示："

#: C/index-in.docbook:2697
#, no-wrap
msgid ""
"auto row = m_refModel-&gt;children()[5]; //The sixth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row.get_iter());"
msgstr ""
"auto row = m_refModel-&gt;children()[5]; //The sixth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row.get_iter());"

#: C/index-in.docbook:2700
msgid "or"
msgstr "或者"

#: C/index-in.docbook:2703
#, no-wrap
msgid ""
"auto iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"
msgstr ""
"auto iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"

#: C/index-in.docbook:2712
msgid "Sorting"
msgstr "排序"

#: C/index-in.docbook:2713
msgid ""
"The standard tree models (<classname>TreeStore</classname> and "
"<classname>ListStore</classname>) derive from <classname>TreeSortable</"
"classname>, so they offer sorting functionality. For instance, call "
"<methodname>set_sort_column()</methodname>, to sort the model by the "
"specified column. Or supply a callback function to "
"<methodname>set_sort_func()</methodname> to implement a more complicated "
"sorting algorithm."
msgstr ""
"标准树模型（<classname>TreeStore</classname>和<classname>ListStore</"
"classname>）派生自<classname>TreeSortable</classname>，因此它们提供了排序功"
"能。例如，调用<methodname>set_sort_column()</methodname>按指定的列对模型进行"
"排序。或者向<methodname>set_sort_func()</methodname>提供一个回调函数以实现更"
"复杂的排序算法。"

#: C/index-in.docbook:2717
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TreeSortable.html\">TreeSortable Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TreeSortable.html\">可排序树参考</ulink>"

#: C/index-in.docbook:2720
msgid "Sorting by clicking on columns"
msgstr "单击列进行排序"

#: C/index-in.docbook:2721
msgid ""
"So that a user can click on a <classname>TreeView</classname>'s column "
"header to sort the <classname>TreeView</classname>'s contents, call "
"<methodname>Gtk::TreeView::Column::set_sort_column()</methodname>, supplying "
"the model column on which model should be sorted when the header is clicked. "
"For instance:"
msgstr ""
"为了使用户可以点击<classname>TreeView</classname>的列标题以对"
"<classname>TreeView</classname>内容进行排序，请在需要此功能的列上调用"
"<methodname>Gtk::TreeView::Column::set_sort_column()</methodname>，以提供此功"
"能。如下所示："

#: C/index-in.docbook:2724
#, no-wrap
msgid ""
"auto pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"
msgstr ""
"auto pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"

#: C/index-in.docbook:2730
msgid "Independently sorted views of the same model"
msgstr "对同一模型进行独立排序的视图"

#: C/index-in.docbook:2731
msgid ""
"The <classname>TreeView</classname> already allows you to show the same "
"<classname>TreeModel</classname> in two <classname>TreeView</classname> "
"widgets. If you need one of these TreeViews to sort the model differently "
"than the other then you should use a <classname>TreeModelSort</classname> "
"instead of just, for instance, <methodname>Gtk::TreeViewColumn::"
"set_sort_column()</methodname>. <classname>TreeModelSort</classname> is a "
"model that contains another model, presenting a sorted version of that "
"model. For instance, you might add a sorted version of a model to a "
"<classname>TreeView</classname> like so:"
msgstr ""
"<classname>TreeView</classname>可以让你用两个<classname>TreeView</classname>"
"部件显示同一个<classname>TreeModel</classname>。如果你需要让这这些树形视图对"
"模型进行不同的排序，则你应该使用<classname>TreeModelSort</classname>而不仅仅"
"是使用<methodname>Gtk::TreeViewColumn::set_sort_column()</methodname>。"
"<classname>TreeModelSort</classname>是一个包含其他模型的模型，其提供了该模型"
"的将已排序版本。你可以如下所示的将已排序版本模型添加到<classname>TreeView</"
"classname>："

#: C/index-in.docbook:2739
#, no-wrap
msgid ""
"auto sorted_model = Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"
msgstr ""
"auto sorted_model = Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"

#: C/index-in.docbook:2743
msgid ""
"Note, however, that the TreeView will provide iterators to the sorted model. "
"You must convert them to iterators to the underlying child model in order to "
"perform actions on that model. For instance:"
msgstr ""
"请注意，这样做树形视图将会提供已排序模型的迭代器。你必须将其转换为基础的子模"
"型迭代器以便对这个模型进行操作。例如："

#: C/index-in.docbook:2745
#, no-wrap
msgid ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  auto refTreeSelection = m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    auto sorted_iter = m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      auto iter = m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"
msgstr ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  auto refTreeSelection = m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    auto sorted_iter = m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      auto iter = m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"

#: C/index-in.docbook:2759
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TreeModelSort.html\">TreeModelSort Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TreeModelSort.html\">树模型排序参考</ulink>"

#: C/index-in.docbook:2765 C/index-in.docbook:2887 C/index-in.docbook:4604
#: C/index-in.docbook:4757
msgid "Drag and Drop"
msgstr "拖放"

#: C/index-in.docbook:2766
msgid ""
"<classname>Gtk::TreeView</classname> already implements simple drag-and-drop "
"when used with the <classname>Gtk::ListStore</classname> or <classname>Gtk::"
"TreeStore</classname> models. If necessary, it also allows you to implement "
"more complex behaviour when items are dragged and dropped, using the normal "
"<link linkend=\"chapter-draganddrop\">Drag and Drop</link> API."
msgstr ""
"当使用<classname>Gtk::ListStore</classname>或者<classname>Gtk::TreeStore</"
"classname>模型时<classname>Gtk::TreeView</classname>已经实现了简单的拖放。如"
"果有必要，它还允许你使用常规的<link linkend=\"chapter-draganddrop\">拖放</"
"link>API实现更复杂的拖放行为。"

#: C/index-in.docbook:2775
msgid "Reorderable rows"
msgstr "可重排序的行"

#: C/index-in.docbook:2776
msgid ""
"If you call <methodname>Gtk::TreeView::set_reorderable()</methodname> then "
"your TreeView's items can be moved within the treeview itself. This is "
"demonstrated in the <classname>TreeStore</classname> example."
msgstr ""
"如果调用<methodname>Gtk::TreeView::set_reorderable()</methodname>则你可以在树"
"视图中移动其本身的项目。<classname>TreeStore</classname>的示例对此进行了演"
"示。"

#: C/index-in.docbook:2781
msgid ""
"However, this does not allow you any control of which items can be dragged, "
"and where they can be dropped. If you need that extra control then you might "
"create a derived <literal>Gtk::TreeModel</literal> from <literal>Gtk::"
"TreeStore</literal> or <literal>Gtk::ListStore</literal> and override the "
"<literal>Gtk::TreeDragSource::row_draggable_vfunc()</literal> and "
"<literal>Gtk::TreeDragDest::row_drop_possible_vfunc()</literal> virtual "
"methods. You can examine the <literal>Gtk::TreeModel::Path</literal>s "
"provided and allow or disallow dragging or dropping by returning "
"<literal>true</literal> or <literal>false</literal>."
msgstr ""
"但是，这不允许你控制哪些项目可以拖动以及可以将他们拖动到哪里。如果你想做到这"
"些，你需要从<literal>Gtk::TreeStore</literal>或<literal>Gtk::ListStore</"
"literal>创建派生的<literal>Gtk::TreeModel</literal>，然后覆盖<literal>Gtk::"
"TreeDragSource::row_draggable_vfunc()</literal>和<literal>Gtk::TreeDragDest::"
"row_drop_possible_vfunc()</literal>虚方法。你可以检查提供的<literal>Gtk::"
"TreeModel::Path</literal>并返回<literal>true</literal>或<literal>false</"
"literal>来允许或禁止拖放。"

#: C/index-in.docbook:2788
msgid "This is demonstrated in the drag_and_drop example."
msgstr "在drag_and_drop示例中对此进行了演示。"

#: C/index-in.docbook:2794 C/index-in.docbook:2909
msgid "Popup Context Menu"
msgstr "弹出上下文菜单"

#: C/index-in.docbook:2795
msgid ""
"Lots of people need to implement right-click context menus for "
"<classname>TreeView</classname>'s so we will explain how to do that here to "
"save you some time. Apart from one or two points, it's much the same as a "
"normal context menu, as described in the <link linkend=\"sec-menus-popup"
"\">menus chapter</link>."
msgstr ""
"很多人认为需要为<classname>TreeView</classname>实现右键单击上下文菜单，因此我"
"们在这里说明如何做到这个以节省你的时间。其与普通的上下文菜单只有一两点不同，"
"如<link linkend=\"sec-menus-popup\">菜单章节</link>所述。"

#: C/index-in.docbook:2804
msgid "Handling <literal>button_press_event</literal>"
msgstr "处理<literal>button_press_event</literal>"

#: C/index-in.docbook:2805
msgid ""
"To detect a click of the right mouse button, you need to handle the "
"<literal>button_press_event</literal> signal, and check exactly which button "
"was pressed. Because the <classname>TreeView</classname> normally handles "
"this signal completely, you need to either override the default signal "
"handler in a derived <classname>TreeView</classname> class, use "
"<methodname>connect_notify()</methodname> or use <methodname>connect(slot, /"
"* after= */ false)</methodname>. You probably also want to call the default "
"handler before doing anything else, so that the right-click will cause the "
"row to be selected first."
msgstr ""
"要检测鼠标右键的点击，你需要处理<literal>button_press_event</literal>信号，并"
"准确的检查按下了哪个按钮。因为<classname>TreeView</classname>通常会处理这个信"
"号，所以你需要使用<methodname>connect_notify()</methodname>或"
"<methodname>connect(slot, /* after= */ false)</methodname>在"
"<classname>TreeView</classname>的派生类中覆盖默认信号处理函数。你可能还想在执"
"行任何其他操作之前先调用默认信号处理函数，以便右键时先选择该行。"

#: C/index-in.docbook:2815
msgid "This is demonstrated in the Popup Context Menu example."
msgstr "Popup Context Menu示例中对此进行了演示。"

#: C/index-in.docbook:2820 C/index-in.docbook:3314 C/index-in.docbook:3618
#: C/index-in.docbook:4867
msgid "Examples"
msgstr "示例"

#: C/index-in.docbook:2822
msgid ""
"Some <classname>TreeView</classname> examples are shown here. There are more "
"examples in the <ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-"
"documentation/tree/master/examples/book/treeview/\">treeview directory</"
"ulink> in <application>gtkmm-documentation</application>'s examples."
msgstr ""
"这里显示了一些<classname>TreeView</classname>的示例。<application>gtkmm文档</"
"application>示例中的<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-"
"documentation/tree/master/examples/book/treeview/\">树形视图文件夹</ulink>还"
"有更多的示例。"

#: C/index-in.docbook:2826
msgid ""
"If neither <classname>ListStore</classname> nor <classname>TreeStore</"
"classname> is suitable for your application, look at the <ulink url="
"\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/examples/"
"book/treeview/custom_treemodel\">custom TreeModel</ulink> example. It shows "
"how you can make your own implementation of the <classname>TreeModel</"
"classname> interface."
msgstr ""
"如果<classname>ListStore</classname>和<classname>TreeStore</classname>都不适"
"合你的应用程序，请查看<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-"
"documentation/tree/master/examples/book/treeview/custom_treemodel\">自定义树"
"模型</ulink>示例。它向你展示了如何实现自己的<classname>TreeModel</classname>"
"接口"

#: C/index-in.docbook:2832
msgid "ListStore"
msgstr "列表储存(ListStore)"

#: C/index-in.docbook:2833
msgid ""
"This example has a <classname>Gtk::TreeView</classname> widget, with a "
"<classname>Gtk::ListStore</classname> model."
msgstr ""
"这个例子有一个使用<classname>Gtk::ListStore</classname>模型的<classname>Gtk::"
"TreeView</classname>部件。"

#: C/index-in.docbook:2845
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/list/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/list/\">源代码</ulink>"

#: C/index-in.docbook:2849
msgid "TreeStore"
msgstr "树储存(TreeStore)"

#: C/index-in.docbook:2851
msgid ""
"This example is very similar to the <classname>ListStore</classname> "
"example, but uses a <classname>Gtk::TreeStore</classname> model instead, and "
"adds children to the rows."
msgstr ""
"这个示例和<classname>ListStore</classname>示例非常的相似，但是使用的是"
"<classname>Gtk::TreeStore</classname>模型并且添加了子行。"

#: C/index-in.docbook:2864
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/tree/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/tree/\">源代码</ulink>"

#: C/index-in.docbook:2870
msgid ""
"This example is identical to the <classname>ListStore</classname> example, "
"but it uses <methodname>TreeView::append_column_editable()</methodname> "
"instead of <methodname>TreeView::append_column()</methodname>."
msgstr ""
"这个示例与<classname>ListStore</classname>示例相同，但是使用"
"<methodname>TreeView::append_column_editable()</methodname>代替"
"<methodname>TreeView::append_column()</methodname>。"

#: C/index-in.docbook:2877
msgid "TreeView - Editable Cells"
msgstr "树形视图 - 可编辑单元格"

#: C/index-in.docbook:2883
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/editable_cells/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/editable_cells/\">源代码</ulink>"

#: C/index-in.docbook:2889
msgid ""
"This example is much like the <classname>TreeStore</classname> example, but "
"has 2 extra columns to indicate whether the row can be dragged, and whether "
"it can receive drag-and-dropped rows. It uses a derived <classname>Gtk::"
"TreeStore</classname> which overrides the virtual functions as described in "
"the <link linkend=\"sec-treeview-draganddrop\">TreeView Drag and Drop</link> "
"section."
msgstr ""
"这个示例和<classname>TreeStore</classname>示例十分相似，但是额外有两个用于指"
"示行是否可以进行拖放和接受拖放的列。它通过从<classname>Gtk::TreeStore</"
"classname>来覆盖虚函数，如<link linkend=\"sec-treeview-draganddrop\">拖放树视"
"图</link>小节所述。"

#: C/index-in.docbook:2899
msgid "TreeView - Drag And Drop"
msgstr "树形视图 - 拖放"

#: C/index-in.docbook:2905
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/drag_and_drop/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/drag_and_drop/\">源代码</ulink>"

#: C/index-in.docbook:2911
msgid ""
"This example is much like the <classname>ListStore</classname> example, but "
"derives a custom <classname>TreeView</classname> in order to override the "
"<literal>button_press_event</literal>, and also to encapsulate the tree "
"model code in our derived class. See the <link linkend=\"sec-treeview-"
"contextmenu\">TreeView Popup Context Menu</link> section."
msgstr ""
"这个示例和<classname>ListStore</classname>示例十分相似，但是它牌手了一个自定"
"义的<classname>TreeView</classname>以覆盖<literal>button_press_event</"
"literal>，并将树模型代码封装在派生类代码中，请参阅<link linkend=\"sec-"
"treeview-contextmenu\">树形视图弹出上下文菜单</link>小节。"

#: C/index-in.docbook:2921
msgid "TreeView - Popup Context Menu"
msgstr "树形视图 - 弹出上下文菜单"

#: C/index-in.docbook:2927
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/popup/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/treeview/popup/\">源代码</ulink>"

#: C/index-in.docbook:2934
msgid "Combo Boxes"
msgstr "组合框(Combo Boxes)"

#: C/index-in.docbook:2936
msgid ""
"The <classname>ComboBox</classname> widget offers a list (or tree) of "
"choices in a dropdown menu. If appropriate, it can show extra information "
"about each item, such as text, a picture, a check button, or a progress bar. "
"The <classname>ComboBox</classname> widget usually restricts the user to the "
"available choices, but it can optionally have an <classname>Entry</"
"classname>, allowing the user to enter arbitrary text if none of the "
"available choices are suitable."
msgstr ""
"<classname>ComboBox</classname>部件在下拉菜单中提供了选项列表（或树）。如果需"
"要它可以为每个项目显示额外的信息，例如文本、图片、复选按钮或是进度条。"
"<classname>ComboBox</classname>部件通常将显示用户的可选项，但是它可以有一个"
"<classname>Entry</classname>以允许用户在没有合适的选项的时候输入任意文本。"

#: C/index-in.docbook:2939
msgid ""
"The list is provided via a <classname>TreeModel</classname>, and columns "
"from this model are added to the ComboBox's view with the "
"<methodname>ComboBox::pack_start()</methodname> method. This provides "
"flexibility and compile-time type-safety, but the <classname>ComboBoxText</"
"classname> class provides a simpler text-based specialization in case that "
"flexibility is not required."
msgstr ""
"这个列表通过<classname>TreeModel</classname>提供，这个模型的列通过"
"<methodname>ComboBox::pack_start()</methodname>方法添加到组合框的视图中。这提"
"供了灵活性和编译时的类型安全，在不需要灵活性的情况下，"
"<classname>ComboBoxText</classname>类提供了更简单的基于文本的特化支持。"

#: C/index-in.docbook:2942
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ComboBox."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1ComboBox."
"html\">参考</ulink>"

#: C/index-in.docbook:2945
msgid "The model"
msgstr "模型"

#: C/index-in.docbook:2946
msgid ""
"The model for a ComboBox can be defined and filled exactly as for a "
"<classname>TreeView</classname>. For instance, you might derive a ComboBox "
"class with one integer and one text column, like so:"
msgstr ""
"可以像<classname>TreeView</classname>一样定义和填充组合框的模型。你可以与如下"
"所示的一样派生具有一个整数行和一个文本行的组合框类："

#: C/index-in.docbook:2948
#, no-wrap
msgid ""
"class ModelColumns : public Gtk::TreeModel::ColumnRecord\n"
"{\n"
"public:\n"
"  ModelColumns()\n"
"  { add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"
msgstr ""
"class ModelColumns : public Gtk::TreeModel::ColumnRecord\n"
"{\n"
"public:\n"
"  ModelColumns()\n"
"  { add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"

#: C/index-in.docbook:2960
msgid ""
"After appending rows to this model, you should provide the model to the "
"<classname>ComboBox</classname> with the <methodname>set_model()</"
"methodname> method. Then use the <methodname>pack_start()</methodname> or "
"<methodname>pack_end()</methodname> methods to specify what columns will be "
"displayed in the ComboBox. As with the TreeView you may either use the "
"default cell renderer by passing the <classname>TreeModelColumn</classname> "
"to the pack methods, or you may instantiate a specific "
"<classname>CellRenderer</classname> and specify a particular mapping with "
"either <methodname>add_attribute()</methodname> or "
"<methodname>set_cell_data_func()</methodname>. Note that these methods are "
"in the <classname>CellLayout</classname> base class."
msgstr ""
"将行追加到此模型中后，你应该使用<methodname>set_model()</methodname>方法将模"
"型提供给<classname>ComboBox</classname>。然后使用<methodname>pack_start()</"
"methodname>或<methodname>pack_end()</methodname>方法指定哪个行将要被组合框显"
"示。和树状视图一样，你可以通过将<classname>TreeModelColumn</classname>传递给"
"pack方法来使用默认的单元格渲染器，也可以实例化一个特定的"
"<classname>CellRenderer</classname>并使用<methodname>add_attribute()</"
"methodname>或<methodname>set_cell_data_func()</methodname>指定具体映射到哪"
"行。请注意这些方法在<classname>CellLayout</classname>基类中。"

#: C/index-in.docbook:2964
msgid "The chosen item"
msgstr "所选项"

#: C/index-in.docbook:2965
msgid ""
"To discover what item, if any, the user has chosen from the ComboBox, call "
"<methodname>ComboBox::get_active()</methodname>. This returns a "
"<classname>TreeModel::iterator</classname> that you can dereference to a "
"<classname>Row</classname> in order to read the values in your columns. For "
"instance, you might read an integer ID value from the model, even though you "
"have chosen only to show the human-readable description in the ComboBox. For "
"instance:"
msgstr ""
"要了解用户从组合框中选择了哪一项可以调用<methodname>ComboBox::get_active()</"
"methodname>。这将返回一个<classname>TreeModel::iterator</classname>，你可以解"
"引用它得到一个<classname>Row</classname>，然后从其中读取该列的值。例如，你可"
"以在组合框中只显示人类可读的描述，然后你可以读取模型中储存于该行的整数ID值"
"（于并未被显示的列）。例如："

#: C/index-in.docbook:2967
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  auto row = *iter;\n"
"\n"
"  //Get the data for the selected row, using our knowledge\n"
"  //of the tree model:\n"
"  auto id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); //Your own function.\n"
"}\n"
"else\n"
"  set_nothing_chosen(); //Your own function."
msgstr ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  auto row = *iter;\n"
"\n"
"  //Get the data for the selected row, using our knowledge\n"
"  //of the tree model:\n"
"  auto id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); //Your own function.\n"
"}\n"
"else\n"
"  set_nothing_chosen(); //Your own function."

#: C/index-in.docbook:2982 C/index-in.docbook:3038
msgid "Responding to changes"
msgstr "响应变更"

#: C/index-in.docbook:2983
msgid ""
"You might need to react to every change of selection in the ComboBox, for "
"instance to update other widgets. To do so, you should handle the "
"<literal>changed</literal> signal. For instance:"
msgstr ""
"你可能需要对组合框中每个选择的变更进行响应，例如更新其他的部件。为此你应该处"
"理<literal>changed</literal>。例如："

#: C/index-in.docbook:2986
#, no-wrap
msgid ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"
msgstr ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"

#: C/index-in.docbook:2990 C/index-in.docbook:3071
msgid "Full Example"
msgstr "完整例子"

#: C/index-in.docbook:2993
msgid "ComboBox"
msgstr "组合框(ComboBox)"

#: C/index-in.docbook:2999
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/complex\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/complex\">源代码</ulink>"

#: C/index-in.docbook:3003 C/index-in.docbook:3084
msgid "Simple Text Example"
msgstr "简单文字示例"

#: C/index-in.docbook:3006
msgid "ComboBoxText"
msgstr "文本组合框(ComboBoxText)"

#: C/index-in.docbook:3012
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/text\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/text\">源代码</ulink>"

#: C/index-in.docbook:3017
msgid "ComboBox with an Entry"
msgstr "带有条目的组合框"

#: C/index-in.docbook:3019
msgid ""
"A <classname>ComboBox</classname> may contain an <classname>Entry</"
"classname> widget for entering of arbitrary text, by specifying "
"<literal>true</literal> for the constructor's <literal>has_entry</literal> "
"parameter."
msgstr ""
"通过指定<classname>ComboBox</classname>构造函数的<literal>has_entry</literal>"
"参数为<literal>true</literal>，可以令其包含一个<classname>Entry</classname>部"
"件用以输入任意文本。"

#: C/index-in.docbook:3022
msgid "The text column"
msgstr "文本列"

#: C/index-in.docbook:3024
#, no-wrap
msgid "m_combo.set_entry_text_column(m_columns.m_col_name);"
msgstr "m_combo.set_entry_text_column(m_columns.m_col_name);"

#: C/index-in.docbook:3023
msgid ""
"So that the <classname>Entry</classname> can interact with the drop-down "
"list of choices, you must specify which of your model columns is the text "
"column, with <methodname>set_entry_text_column()</methodname>. For instance: "
"<_:programlisting-1/>"
msgstr ""
"为了使<classname>Entry</classname>可以与下拉列表的选项进行交互，你必须使用"
"<methodname>set_entry_text_column()</methodname>指定哪些模型列是文本列。例"
"如：<_:programlisting-1/>"

#: C/index-in.docbook:3026
msgid ""
"When you select a choice from the drop-down menu, the value from this column "
"will be placed in the <classname>Entry</classname>."
msgstr ""
"当你从下拉菜单中选择一个选项的时候，该列的值将被放于<classname>Entry</"
"classname>中。"

#: C/index-in.docbook:3032
msgid "The entry"
msgstr "条目"

#: C/index-in.docbook:3033
msgid ""
"Because the user may enter arbitrary text, an active model row isn't enough "
"to tell us what text the user has entered. Therefore, you should retrieve "
"the <classname>Entry</classname> widget with the <methodname>ComboBox::"
"get_entry()</methodname> method and call <methodname>get_text()</methodname> "
"on that."
msgstr ""
"由于用户可以输入任意文本，被使用中的模型行可能不足以告诉我们用户输入了什么，"
"因此，你应该使用<methodname>ComboBox::get_entry()</methodname>方法检索组合框"
"中的<classname>Entry</classname>部件并在其上调用<methodname>get_text()</"
"methodname>。"

#: C/index-in.docbook:3047
#, no-wrap
msgid ""
"auto entry = m_Combo.get_entry();\n"
"if (entry)\n"
"{\n"
"  // Alternatively you can connect to m_Combo.signal_changed().\n"
"  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_changed) );\n"
"\n"
"  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_activate) );\n"
"\n"
"  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_focus_out_event) );\n"
"}"
msgstr ""
"auto entry = m_Combo.get_entry();\n"
"if (entry)\n"
"{\n"
"  // Alternatively you can connect to m_Combo.signal_changed().\n"
"  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_changed) );\n"
"\n"
"  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_activate) );\n"
"\n"
"  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_focus_out_event) );\n"
"}"

#: C/index-in.docbook:3039
msgid ""
"When the user enters arbitrary text, it may not be enough to connect to the "
"<literal>changed</literal> signal, which is emitted for every typed "
"character. It is not emitted when the user presses the <keycap>Enter</"
"keycap> key. Pressing the <keycap>Enter</keycap> key or moving the keyboard "
"focus to another widget may signal that the user has finished entering text. "
"To be notified of these events, connect to the <classname>Entry</"
"classname>'s <literal>activate</literal> and <literal>focus_out_event</"
"literal> signals, like so <_:programlisting-1/> The <literal>changed</"
"literal> signals of <classname>ComboBox</classname> and <classname>Entry</"
"classname> are both emitted for every change. It doesn't matter which one "
"you connect to. But only <classname>Entry</classname>'s "
"<literal>focus_out_event</literal> signal is useful here."
msgstr ""
"当用户输入任意文本时，只连接到为每个键入字符而发出的<literal>changed</"
"literal>信号可能是不够的。当用户按下<keycap>Enter</keycap>键的时候，这个信号"
"不会被发出。而按下<keycap>Enter</keycap>或是键盘焦点被移动到另一个部件的时"
"候，可以表示用户已经完成了输入。为了收到这些事件的通知，你需要连接到"
"<classname>Entry</classname>的<literal>activate</literal>和"
"<literal>focus_out_event</literal>信号像是这样<_:programlisting-1/> 每次更改"
"<classname>ComboBox</classname>和<classname>Entry</classname>都会发出"
"<literal>changed</literal>信号，你可以连接它们中的任意一个。但是在这里只有"
"<classname>Entry</classname>的<literal>focus_out_event</literal>信号才有用。"

#: C/index-in.docbook:3065
msgid ""
"X events are described in more detail in the <link linkend=\"sec-"
"xeventsignals\">X Event signals</link> section in the appendix."
msgstr ""
"X事件在附录的<link linkend=\"sec-xeventsignals\">X事件信号</link>小节有更详细"
"的描述。"

#: C/index-in.docbook:3074
msgid "ComboBox with Entry"
msgstr "带条目的组合框"

#: C/index-in.docbook:3080
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/entry_complex\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/entry_complex\">源代码</ulink>"

#: C/index-in.docbook:3087
msgid "ComboBoxText with Entry"
msgstr "带条目的文本组合框"

#: C/index-in.docbook:3093
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/entry_text\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/combobox/entry_text\">源代码</ulink>"

#: C/index-in.docbook:3106 C/index-in.docbook:3319
msgid "TextView"
msgstr "文本视图(TextView)"

#: C/index-in.docbook:3107
msgid ""
"The <classname>TextView</classname> widget can be used to display and edit "
"large amounts of formatted text. Like the <classname>TreeView</classname>, "
"it has a model/view design. In this case the <classname>TextBuffer</"
"classname> is the model."
msgstr ""
"<classname>TextView</classname>部件可以用于显示和编辑大量的格式化文本。与"
"<classname>TreeView</classname>一样，它具有模型/视图设计。"
"<classname>TextBuffer</classname>是它预期的模型。"

#: C/index-in.docbook:3115
msgid "The Buffer"
msgstr "缓冲区"

#: C/index-in.docbook:3116
msgid ""
"<classname>Gtk::TextBuffer</classname> is a model containing the data for "
"the <classname>Gtk::TextView</classname>, like the <classname>Gtk::"
"TreeModel</classname> used by <classname>Gtk::TreeView</classname>. This "
"allows two or more <classname>Gtk::TextView</classname>s to share the same "
"<classname>TextBuffer</classname>, and allows those TextBuffers to be "
"displayed slightly differently. Or you could maintain several "
"<classname>Gtk::TextBuffer</classname>s and choose to display each one at "
"different times in the same <classname>Gtk::TextView</classname> widget."
msgstr ""
"<classname>Gtk::TextBuffer</classname>是一个包含<classname>Gtk::TextView</"
"classname>数据的模型，和<classname>Gtk::TreeView</classname>所使用的"
"<classname>Gtk::TreeModel</classname>类似。这允许复数个<classname>Gtk::"
"TextView</classname>共享同一个<classname>TextBuffer</classname>，并允许以不同"
"方式显示文本缓冲区。你也可以维护多个<classname>Gtk::TextBuffer</classname>并"
"让同一个<classname>Gtk::TextView</classname>部件于不同时候分别显示它们。"

#: C/index-in.docbook:3126
msgid ""
"The <classname>TextView</classname> creates its own default "
"<classname>TextBuffer</classname>, which you can access via the "
"<methodname>get_buffer()</methodname> method."
msgstr ""
"<classname>TextView</classname>会创建一个由它拥有的默认"
"<classname>TextBuffer</classname>，你可以通过<methodname>get_buffer()</"
"methodname>方法访问这个缓冲区。"

#: C/index-in.docbook:3132
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TextBuffer.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TextBuffer.html\">参考</ulink>"

#: C/index-in.docbook:3135
msgid "Iterators"
msgstr "迭代器"

#: C/index-in.docbook:3136
msgid ""
"A <classname>Gtk::TextBuffer::iterator</classname> and a <classname>Gtk::"
"TextBuffer::const_iterator</classname> represent a position between two "
"characters in the text buffer. Whenever the buffer is modified in a way that "
"affects the number of characters in the buffer, all outstanding iterators "
"become invalid. Because of this, iterators can't be used to preserve "
"positions across buffer modifications. To preserve a position, use "
"<classname>Gtk::TextBuffer::Mark</classname>."
msgstr ""
"<classname>Gtk::TextBuffer::iterator</classname>和<classname>Gtk::"
"TextBuffer::const_iterator</classname>表示文本缓冲区中两个字符之间的位置。只"
"要以影响缓冲区中字符数量的方式修改了缓冲区，所有越过修改范围的迭代器都将失"
"效。因此，迭代器不能用于保存越过缓冲区被修改部分的位置。如果想保存位置，请使"
"用<classname>Gtk::TextBuffer::Mark</classname>。"

#: C/index-in.docbook:3143
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextIter."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextIter."
"html\">参考</ulink>"

#: C/index-in.docbook:3147
msgid "Tags and Formatting"
msgstr "标签和格式"

#: C/index-in.docbook:3150
msgid "Tags"
msgstr "标签(Tags)"

#: C/index-in.docbook:3151
msgid ""
"To specify that some text in the buffer should have specific formatting, you "
"must define a tag to hold that formatting information, and then apply that "
"tag to the region of text. For instance, to define the tag and its "
"properties:"
msgstr ""
"要指定缓冲区中的一些文本具有特定的格式，你需要定义一个标签来保存格式信息，并"
"将该标签应用于文本区域。例如，定义标签及其属性："

#: C/index-in.docbook:3154
#, no-wrap
msgid ""
"auto refTagMatch = Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"
msgstr ""
"auto refTagMatch = Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"

#: C/index-in.docbook:3156
msgid ""
"You can specify a name for the <classname>Tag</classname> when using the "
"<methodname>create()</methodname> method, but it is not necessary."
msgstr ""
"你可以在使用<classname>Tag</classname>的<methodname>create()</methodname>方法"
"时为其指定一个名称，但这不是必须的。"

#: C/index-in.docbook:3161
msgid "The <classname>Tag</classname> class has many other properties."
msgstr "<classname>Tag</classname>类还有许多其他的特性。"

#: C/index-in.docbook:3165
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTag."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextTag."
"html\">参考</ulink>"

#: C/index-in.docbook:3170
msgid "TagTable"
msgstr "标签表(TagTable)"

#: C/index-in.docbook:3172
msgid ""
"Each <classname>Gtk::TextBuffer</classname> uses a <classname>Gtk::"
"TextBuffer::TagTable</classname>, which contains the <classname>Tag</"
"classname>s for that buffer. 2 or more <classname>TextBuffer</classname>s "
"may share the same <classname>TagTable</classname>. When you create "
"<classname>Tag</classname>s you should add them to the <classname>TagTable</"
"classname>. For instance:"
msgstr ""
"每个<classname>Gtk::TextBuffer</classname>使用一个<classname>Gtk::"
"TextBuffer::TagTable</classname>，其中包含了该缓冲区的<classname>Tag</"
"classname>。复数个<classname>TextBuffer</classname>可以共享一个"
"<classname>TagTable</classname>。当你创建<classname>Tag</classname>的时候，你"
"应该将其加入<classname>TagTable</classname>。例如："

#: C/index-in.docbook:3180
#, no-wrap
msgid ""
"auto refTagTable = Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,\n"
"//for use after creation of the buffer.\n"
"auto refBuffer = Gtk::TextBuffer::create(refTagTable);"
msgstr ""
"auto refTagTable = Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,\n"
"//for use after creation of the buffer.\n"
"auto refBuffer = Gtk::TextBuffer::create(refTagTable);"

#: C/index-in.docbook:3186
msgid ""
"You can also use <methodname>get_tag_table()</methodname> to get, and maybe "
"modify, the <classname>TextBuffer</classname>'s default <classname>TagTable</"
"classname> instead of creating one explicitly."
msgstr ""
"你也可以使用<methodname>get_tag_table()</methodname>获取并修改"
"<classname>TextBuffer</classname>的默认<classname>TagTable</classname>，而不"
"是显示创建一个。"

#: C/index-in.docbook:3192
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TextTagTable.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TextTagTable.html\">参考</ulink>"

#: C/index-in.docbook:3197
msgid "Applying Tags"
msgstr "应用标签"

#: C/index-in.docbook:3198
msgid ""
"If you have created a <classname>Tag</classname> and added it to the "
"<classname>TagTable</classname>, you may apply that tag to part of the "
"<classname>TextBuffer</classname> so that some of the text is displayed with "
"that formatting. You define the start and end of the range of text by "
"specifying <classname>Gtk::TextBuffer::iterator</classname>s. For instance:"
msgstr ""
"如果你创建了一个<classname>Tag</classname>并将其加入到<classname>TagTable</"
"classname>，则可以将其应用于<classname>TextBuffer</classname>的一部分，以便使"
"用该格式显示某些文本。你可以通过使用<classname>Gtk::TextBuffer::iterator</"
"classname>指示文本的开始和结束范围。例如："

#: C/index-in.docbook:3205
#, no-wrap
msgid "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"
msgstr "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"

#: C/index-in.docbook:3208
#, no-wrap
msgid "refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"
msgstr "refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"

#: C/index-in.docbook:3206
msgid ""
"Or you could specify the tag when first inserting the text: <_:"
"programlisting-1/>"
msgstr "或者你可以在首次插入文本的时候指定标签：<_:programlisting-1/>"

#: C/index-in.docbook:3211
msgid ""
"You can apply more than one <classname>Tag</classname> to the same text, by "
"using <methodname>apply_tag()</methodname> more than once, or by using "
"<methodname>insert_with_tags()</methodname>. The <classname>Tag</classname>s "
"might specify different values for the same properties, but you can resolve "
"these conflicts by using <methodname>Tag::set_priority()</methodname>."
msgstr ""
"你可以多次使用<methodname>apply_tag()</methodname>或"
"<methodname>insert_with_tags()</methodname>将不同的<classname>Tag</classname>"
"应用于同一文本。<classname>Tag</classname>可能会为同一属性指定不同的值，但你"
"可以使用<methodname>Tag::set_priority()</methodname>解决这些冲突。"

#: C/index-in.docbook:3223
msgid "Marks"
msgstr "标记(Marks)"

#: C/index-in.docbook:3224
msgid ""
"<classname>TextBuffer</classname> iterators are generally invalidated when "
"the text changes, but you can use a <classname>Gtk::TextBuffer::Mark</"
"classname> to remember a position in these situations. For instance,"
msgstr ""
"当文本发生更改的时候<classname>TextBuffer</classname>迭代器通常会失效，但是你"
"可以使用<classname>Gtk::TextBuffer::Mark</classname>记住位置，例如："

#: C/index-in.docbook:3229
#, no-wrap
msgid "auto refMark = refBuffer-&gt;create_mark(iter);"
msgstr "auto refMark = refBuffer-&gt;create_mark(iter);"

#: C/index-in.docbook:3231
msgid ""
"You can then use the <methodname>get_iter()</methodname> method later to "
"create an iterator for the <classname>Mark</classname>'s new position."
msgstr ""
"你可以在之后使用<methodname>get_iter()</methodname>方法为<classname>Mark</"
"classname>的新位置创建迭代器。"

#: C/index-in.docbook:3236
msgid ""
"There are two built-in <classname>Mark</classname>s - <literal>insert</"
"literal> and <literal>selection_bound</literal>, which you can access with "
"<classname>TextBuffer</classname>'s <methodname>get_insert()</methodname> "
"and <methodname>get_selection_bound()</methodname> methods."
msgstr ""
"有两个内置的<classname>Mark</classname> - <literal>insert</literal>和"
"<literal>selection_bound</literal>，你可以使用<classname>TextBuffer</"
"classname>的<methodname>get_insert()</methodname>和"
"<methodname>get_selection_bound()</methodname>方法访问它们。"

#: C/index-in.docbook:3243
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextMark."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextMark."
"html\">参考</ulink>"

#: C/index-in.docbook:3249
msgid ""
"As mentioned above, each <classname>TextView</classname> has a "
"<classname>TextBuffer</classname>, and one or more <classname>TextView</"
"classname>s can share the same <classname>TextBuffer</classname>."
msgstr ""
"如上所述，每个<classname>TextView</classname>都有一个<classname>TextBuffer</"
"classname>，并且多个<classname>TextView</classname>可以共享同一个"
"<classname>TextBuffer</classname>。"

#: C/index-in.docbook:3256
msgid ""
"Like the <classname>TreeView</classname>, you should probably put your "
"<classname>TextView</classname> inside a <classname>ScrolledWindow</"
"classname> to allow the user to see and move around the whole text area with "
"scrollbars."
msgstr ""
"和<classname>TreeView</classname>一样，你可以将<classname>TextView</"
"classname>放入<classname>ScrolledWindow</classname>中以允许用户使用滚动条查看"
"并在整个文本区域中移动。"

#: C/index-in.docbook:3263
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextView."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1TextView."
"html\">参考</ulink>"

#: C/index-in.docbook:3266
msgid "Default formatting"
msgstr "默认格式"

#: C/index-in.docbook:3267
msgid ""
"<classname>TextView</classname> has various methods which allow you to "
"change the presentation of the buffer for this particular view. Some of "
"these may be overridden by the <classname>Gtk::TextTag</classname>s in the "
"buffer, if they specify the same things. For instance, "
"<methodname>set_left_margin()</methodname>, <methodname>set_right_margin()</"
"methodname>, <methodname>set_indent()</methodname>, etc."
msgstr ""
"<classname>TextView</classname>具有多种可以让你修改特定视图中缓冲区的显示方式"
"的方法。如果它们指定同一区域，则其中一些可能会覆写缓冲区中的<classname>Gtk::"
"TextTag</classname>。例如：<methodname>set_left_margin()</methodname>、"
"<methodname>set_right_margin()</methodname>、<methodname>set_indent()</"
"methodname>等。"

#: C/index-in.docbook:3278
msgid "Scrolling"
msgstr "滚动"

#: C/index-in.docbook:3279
msgid ""
"<classname>Gtk::TextView</classname> has various <methodname>scroll_to()</"
"methodname> methods. These allow you to ensure that a particular part of the "
"text buffer is visible. For instance, your application's Find feature might "
"use <methodname>Gtk::TextView::scroll_to()</methodname> to show the found "
"text."
msgstr ""
"<classname>Gtk::TextView</classname>有多种<methodname>scroll_to()</"
"methodname>方法。这些可以确保你能看到缓冲区中的特定部分。例如你的应用程序可能"
"会使用<methodname>Gtk::TextView::scroll_to()</methodname>方法显示找到的文本。"

#: C/index-in.docbook:3294
msgid "Widgets and ChildAnchors"
msgstr "部件和子锚(ChildAnchors)"

#: C/index-in.docbook:3295
msgid ""
"You can embed widgets, such as <classname>Gtk::Button</classname>s, in the "
"text. Each such child widget needs a <classname>ChildAnchor</classname>. "
"ChildAnchors are associated with <classname>iterators</classname>. For "
"instance, to create a child anchor at a particular position, use "
"<methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:"
msgstr ""
"你可以在文本中嵌入小部件，例如<classname>Gtk::Button</classname>。每一个这样"
"的子部件都需要一个<classname>ChildAnchor</classname>。子锚与迭代器相关联。例"
"如，使用<methodname>Gtk::TextBuffer::create_child_anchor()</methodname>于特定"
"位置创建子锚："

#: C/index-in.docbook:3302
#, no-wrap
msgid "auto refAnchor = refBuffer-&gt;create_child_anchor(iter);"
msgstr "auto refAnchor = refBuffer-&gt;create_child_anchor(iter);"

#: C/index-in.docbook:3304
msgid ""
"Then, to add a widget at that position, use <methodname>Gtk::TextView::"
"add_child_at_anchor()</methodname>:"
msgstr ""
"然后使用<methodname>Gtk::TextView::add_child_at_anchor()</methodname>将部件添"
"加到该位置："

#: C/index-in.docbook:3308
#, no-wrap
msgid "m_TextView.add_child_at_anchor(m_Button, refAnchor);"
msgstr "m_TextView.add_child_at_anchor(m_Button, refAnchor);"

#: C/index-in.docbook:3310
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TextChildAnchor.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1TextChildAnchor.html\">参考</ulink>"

#: C/index-in.docbook:3325
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/textview/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/textview/\">源代码</ulink>"

#: C/index-in.docbook:3334
msgid "Menus and Toolbars"
msgstr "菜单和工具栏"

#: C/index-in.docbook:3336
msgid ""
"There are specific APIs for menus and toolbars, but you should usually deal "
"with them together, creating <classname>Gio::SimpleAction</classname>s that "
"you can refer to in both menus and toolbars. In this way you can handle "
"activation of the action instead of responding to the menu and toolbar items "
"separately. And you can enable or disable both the menu and toolbar item via "
"the action. <classname>Gtk::Builder</classname> can create menus and "
"toolbars."
msgstr ""
"菜单和工具栏都有特有的API，但是通常你应该创建在菜单和工具栏都可以引用的"
"<classname>Gio::SimpleAction</classname>以便一并处理它们。这样你可以响应动作"
"被激活而不需要分别响应菜单和工具栏。你可以通过动作启用或者禁用菜单和工具栏"
"项。<classname>Gtk::Builder</classname>可以创建菜单和工具栏。"

#: C/index-in.docbook:3344
msgid ""
"This involves the use of the <classname>Gio::SimpleActionGroup</classname>, "
"<classname>Gio::SimpleAction</classname> and <classname>Gtk::Builder</"
"classname> classes, all of which should be instantiated via their "
"<methodname>create()</methodname> methods, which return <classname>RefPtr</"
"classname>s."
msgstr ""
"这涉及到了<classname>Gio::SimpleActionGroup</classname>、<classname>Gio::"
"SimpleAction</classname>和<classname>Gtk::Builder</classname>类的使用，所有的"
"这些类都需要通过返回<classname>RefPtr</classname>的<methodname>create()</"
"methodname>方法进行实例化。"

#: C/index-in.docbook:3352
msgid "Actions"
msgstr "动作(Actions)"

#: C/index-in.docbook:3353
msgid ""
"First create the <classname>Gio::SimpleAction</classname>s and add them to a "
"<classname>Gio::SimpleActionGroup</classname>, with <methodname>Gio::"
"ActionMap::add_action()</methodname>. (<classname>Gio::ActionMap</classname> "
"is a base class of <classname>Gio::SimpleActionGroup</classname>.) Then add "
"the action group to your window with <methodname>Gtk::Widget::"
"insert_action_group()</methodname>."
msgstr ""
"首先创建<classname>Gio::SimpleAction</classname>并使用<methodname>Gio::"
"ActionMap::add_action()</methodname>方法将其加入<classname>Gio::"
"SimpleActionGroup</classname>中（<classname>Gio::ActionMap</classname>是"
"<classname>Gio::SimpleActionGroup</classname>的基类。）。然后将动作组使用"
"<methodname>Gtk::Widget::insert_action_group()</methodname>加入到你的窗口中。"

#: C/index-in.docbook:3361
msgid ""
"The arguments to <methodname>add_action()</methodname> specify the action's "
"name, which is used in the menu items and toolbar buttons. You can also "
"specify a signal handler when calling <methodname>add_action()</methodname>. "
"This signal handler will be called when the action is activated via either a "
"menu item or a toolbar button."
msgstr ""
"<methodname>add_action()</methodname>的参数用于指定动作名，该名称由菜单项和工"
"具栏按钮使用。你还可以在调用<methodname>add_action()</methodname>时指定信号处"
"理函数。在菜单项或工具栏按钮被激活的时候此信号处理函数被调用。"

#: C/index-in.docbook:3369 C/index-in.docbook:3495
msgid "For instance:"
msgstr "例如："

#: C/index-in.docbook:3371
#, no-wrap
msgid ""
"\n"
"m_refActionGroup = Gio::SimpleActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add_action(\"new\", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new));\n"
"m_refActionGroup-&gt;add_action(\"open\", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open));\n"
"m_refActionGroup-&gt;add_action(\"quit\", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit));\n"
"\n"
"insert_action_group(\"example\", m_refActionGroup);\n"
msgstr ""
"\n"
"m_refActionGroup = Gio::SimpleActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add_action(\"new\", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new));\n"
"m_refActionGroup-&gt;add_action(\"open\", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open));\n"
"m_refActionGroup-&gt;add_action(\"quit\", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit));\n"
"\n"
"insert_action_group(\"example\", m_refActionGroup);\n"

#: C/index-in.docbook:3381
msgid ""
"If you use an <classname>Gtk::ApplicationWindow</classname>, you don't have "
"to create your own action group. <classname>Gio::ActionGroup</classname> and "
"<classname>Gio::ActionMap</classname> are base classes of <classname>Gtk::"
"ApplicationWindow</classname>."
msgstr ""
"如果你使用<classname>Gtk::ApplicationWindow</classname>，则你不需要自己创建动"
"作组。因为<classname>Gio::ActionGroup</classname>和<classname>Gio::"
"ActionMap</classname>是<classname>Gtk::ApplicationWindow</classname>的基类。"

#: C/index-in.docbook:3392
msgid "Menubar and Toolbar"
msgstr "菜单和工具栏"

#: C/index-in.docbook:3393
msgid ""
"Next you should create a <classname>Gtk::Builder</classname>. At this point "
"is also a good idea to tell the application to respond to keyboard "
"shortcuts, by using <methodname>Gtk::Application::set_accel_for_action()</"
"methodname>."
msgstr ""
"接下来你应该创建一个<classname>Gtk::Builder</classname>。此时使用"
"<methodname>Gtk::Application::set_accel_for_action()</methodname>告诉应用程序"
"响应键盘快捷键也是一个好主意。"

#: C/index-in.docbook:3399
msgid "For instance,"
msgstr "例如："

#: C/index-in.docbook:3401
#, no-wrap
msgid ""
"\n"
"m_refBuilder = Gtk::Builder::create();\n"
"\n"
"app-&gt;set_accel_for_action(\"example.new\", \"&lt;Primary&gt;n\");\n"
"app-&gt;set_accel_for_action(\"example.quit\", \"&lt;Primary&gt;q\");\n"
"app-&gt;set_accel_for_action(\"example.copy\", \"&lt;Primary&gt;c\");\n"
"app-&gt;set_accel_for_action(\"example.paste\", \"&lt;Primary&gt;v\");\n"
msgstr ""
"\n"
"m_refBuilder = Gtk::Builder::create();\n"
"\n"
"app-&gt;set_accel_for_action(\"example.new\", \"&lt;Primary&gt;n\");\n"
"app-&gt;set_accel_for_action(\"example.quit\", \"&lt;Primary&gt;q\");\n"
"app-&gt;set_accel_for_action(\"example.copy\", \"&lt;Primary&gt;c\");\n"
"app-&gt;set_accel_for_action(\"example.paste\", \"&lt;Primary&gt;v\");\n"

#: C/index-in.docbook:3409
msgid ""
"If your main window is derived from <classname>ApplicationWindow</classname> "
"and you instantiate your menubar with <methodname>Gtk::Application::"
"set_menubar()</methodname>, then you don't have to call "
"<methodname>set_accel_for_action()</methodname>. See <link linkend=\"menu-"
"example-main\">Application Menu and Main Menu example</link> for an example."
msgstr ""
"如果你的主窗口是由<classname>ApplicationWindow</classname>派生而来的，并且你"
"使用<methodname>Gtk::Application::set_menubar()</methodname>实例化了菜单栏，"
"则你不需要调用<methodname>set_accel_for_action()</methodname>。有关示例参见："
"<link linkend=\"menu-example-main\">应用程序菜单和主菜单示例</link>。"

#: C/index-in.docbook:3417
msgid ""
"Then, you can define the actual visible layout of the menus and toolbars, "
"and add the UI layout to the <classname>Builder</classname>. This \"ui string"
"\" uses an XML format, in which you should mention the names of the actions "
"that you have already created. For instance:"
msgstr ""
"然后，你可以定义菜单和工具栏的实际可见布局，并将这个UI布局添加到"
"<classname>Builder</classname>。这个\"UI字符串\"使用XML格式，你应该在其中使用"
"你已经创建的动作的名称。例如："

#: C/index-in.docbook:3423
#, no-wrap
msgid ""
"\n"
"Glib::ustring ui_info =\n"
"  \"&lt;interface&gt;\"\n"
"  \"  &lt;menu id='menubar'&gt;\"\n"
"  \"    &lt;submenu&gt;\"\n"
"  \"      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;\"\n"
"  \"      &lt;section&gt;\"\n"
"  \"        &lt;item&gt;\"\n"
"  \"          &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;n&lt;/attribute&gt;\"\n"
"  \"        &lt;/item&gt;\"\n"
"  \"      &lt;/section&gt;\"\n"
"  \"      &lt;section&gt;\"\n"
"  \"        &lt;item&gt;\"\n"
"  \"          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;q&lt;/attribute&gt;\"\n"
"  \"        &lt;/item&gt;\"\n"
"  \"      &lt;/section&gt;\"\n"
"  \"    &lt;/submenu&gt;\"\n"
"  \"    &lt;submenu&gt;\"\n"
"  \"      &lt;attribute name='label' translatable='yes'&gt;_Edit&lt;/attribute&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;_Copy&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;example.copy&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;c&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;_Paste&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;example.paste&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;v&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"    &lt;/submenu&gt;\"\n"
"  \"  &lt;/menu&gt;\"\n"
"  \"&lt;/interface&gt;\";\n"
"\n"
"m_refBuilder-&gt;add_from_string(ui_info);\n"
"m_refBuilder-&gt;add_from_resource(\"/toolbar/toolbar.glade\");\n"
msgstr ""
"\n"
"Glib::ustring ui_info =\n"
"  \"&lt;interface&gt;\"\n"
"  \"  &lt;menu id='menubar'&gt;\"\n"
"  \"    &lt;submenu&gt;\"\n"
"  \"      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;\"\n"
"  \"      &lt;section&gt;\"\n"
"  \"        &lt;item&gt;\"\n"
"  \"          &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;n&lt;/attribute&gt;\"\n"
"  \"        &lt;/item&gt;\"\n"
"  \"      &lt;/section&gt;\"\n"
"  \"      &lt;section&gt;\"\n"
"  \"        &lt;item&gt;\"\n"
"  \"          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;\"\n"
"  \"          &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;q&lt;/attribute&gt;\"\n"
"  \"        &lt;/item&gt;\"\n"
"  \"      &lt;/section&gt;\"\n"
"  \"    &lt;/submenu&gt;\"\n"
"  \"    &lt;submenu&gt;\"\n"
"  \"      &lt;attribute name='label' translatable='yes'&gt;_Edit&lt;/attribute&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;_Copy&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;example.copy&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;c&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;_Paste&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;example.paste&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='accel'&gt;&amp;lt;Primary&amp;gt;v&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"    &lt;/submenu&gt;\"\n"
"  \"  &lt;/menu&gt;\"\n"
"  \"&lt;/interface&gt;\";\n"
"\n"
"m_refBuilder-&gt;add_from_string(ui_info);\n"
"m_refBuilder-&gt;add_from_resource(\"/toolbar/toolbar.glade\");\n"

#: C/index-in.docbook:3464
msgid ""
"This is where we specify the names of the menu items as they will be seen by "
"users in the menu. Therefore, this is where you should make strings "
"translatable, by adding <literal>translatable='yes'</literal>."
msgstr ""
"这里我们指定菜单项的名称，因为用户可以在菜单中看到它们。因此你应该添加"
"<literal>translatable='yes'</literal>使这些的字符串可以被翻译。"

#: C/index-in.docbook:3468
msgid ""
"To instantiate a <classname>Gtk::MenuBar</classname> and <classname>Gtk::"
"Toolbar</classname> which you can actually show, you should use the "
"<methodname>Builder::get_object()</methodname> and <methodname>Builder::"
"get_widget()</methodname> methods, and then add the widgets to a container. "
"For instance:"
msgstr ""
"要实例化<classname>Gtk::MenuBar</classname>和<classname>Gtk::Toolbar</"
"classname>并可以实际显示他们，应该使用<methodname>Builder::get_object()</"
"methodname>和<methodname>Builder::get_widget()</methodname>方法，然后将部件加"
"入容器中。例如："

#: C/index-in.docbook:3475
#, no-wrap
msgid ""
"\n"
"auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;(\"menubar\");\n"
"auto pMenuBar = Gtk::make_managed&lt;Gtk::MenuBar&gt;(gmenu);\n"
"m_Box.append(*pMenuBar);\n"
"\n"
"auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Toolbar&gt;(\"toolbar\");\n"
"m_Box.append(*toolbar);\n"
msgstr ""
"\n"
"auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;(\"menubar\");\n"
"auto pMenuBar = Gtk::make_managed&lt;Gtk::MenuBar&gt;(gmenu);\n"
"m_Box.append(*pMenuBar);\n"
"\n"
"auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Toolbar&gt;(\"toolbar\");\n"
"m_Box.append(*toolbar);\n"

#: C/index-in.docbook:3487
msgid "Popup Menus"
msgstr "弹出菜单"

#: C/index-in.docbook:3488
msgid ""
"<classname>Menus</classname> are normally just added to a window, but they "
"can also be displayed temporarily as the result of a mouse button click. For "
"instance, a context menu might be displayed when the user clicks their right "
"mouse button."
msgstr ""
"<classname>Menus</classname>通常将直接被加入到窗口中，但也可以通过鼠标单击来"
"临时显示他们。例如当用户单击鼠标右键的时候，可能需要显示上下文菜单。"

#: C/index-in.docbook:3497
#, no-wrap
msgid ""
"\n"
"Glib::ustring ui_info =\n"
"  \"&lt;interface&gt;\"\n"
"  \"  &lt;menu id='menu-examplepopup'&gt;\"\n"
"  \"    &lt;section&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;Edit&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;examplepopup.edit&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;Process&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;examplepopup.process&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;Remove&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;examplepopup.remove&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"    &lt;/section&gt;\"\n"
"  \"  &lt;/menu&gt;\"\n"
"  \"&lt;/interface&gt;\";\n"
"\n"
"m_refBuilder-&gt;add_from_string(ui_info);\n"
"\n"
"auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;(\"menu-examplepopup\");\n"
"m_pMenuPopup = std::make_unique&lt;Gtk::Menu&gt;(gmenu);\n"
msgstr ""
"\n"
"Glib::ustring ui_info =\n"
"  \"&lt;interface&gt;\"\n"
"  \"  &lt;menu id='menu-examplepopup'&gt;\"\n"
"  \"    &lt;section&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;Edit&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;examplepopup.edit&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;Process&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;examplepopup.process&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"      &lt;item&gt;\"\n"
"  \"        &lt;attribute name='label' translatable='yes'&gt;Remove&lt;/attribute&gt;\"\n"
"  \"        &lt;attribute name='action'&gt;examplepopup.remove&lt;/attribute&gt;\"\n"
"  \"      &lt;/item&gt;\"\n"
"  \"    &lt;/section&gt;\"\n"
"  \"  &lt;/menu&gt;\"\n"
"  \"&lt;/interface&gt;\";\n"
"\n"
"m_refBuilder-&gt;add_from_string(ui_info);\n"
"\n"
"auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;(\"menu-examplepopup\");\n"
"m_pMenuPopup = std::make_unique&lt;Gtk::Menu&gt;(gmenu);\n"

#: C/index-in.docbook:3524
msgid ""
"To show the popup menu, use <classname>Gtk::Menu</classname>'s "
"<methodname>popup()</methodname> method, providing the button identifier and "
"the time of activation, as provided by the <literal>button_press_event</"
"literal> signal, which you will need to handle anyway. For instance:"
msgstr ""
"要显示弹出菜单，请使用<classname>Gtk::Menu</classname>的<methodname>popup()</"
"methodname>方法，无论如何你都需要处理由<literal>button_press_event</literal>"
"信号提供的激活时机（鼠标单双三击、按下还是释放）和按钮标识（哪个鼠标按键）。"
"例如："

#: C/index-in.docbook:3530
#, no-wrap
msgid ""
"\n"
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) )\n"
"  {\n"
"    if(!m_pMenuPopup-&gt;get_attach_widget())\n"
"      m_pMenuPopup-&gt;attach_to_widget(*this);\n"
"\n"
"    m_pMenuPopup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; //It has been handled.\n"
"  }\n"
"  else\n"
"    return false;\n"
"}\n"
msgstr ""
"\n"
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp; (event-&gt;button == 3) )\n"
"  {\n"
"    if(!m_pMenuPopup-&gt;get_attach_widget())\n"
"      m_pMenuPopup-&gt;attach_to_widget(*this);\n"
"\n"
"    m_pMenuPopup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; //It has been handled.\n"
"  }\n"
"  else\n"
"    return false;\n"
"}\n"

#: C/index-in.docbook:3549
msgid "Gio::Resource and glib-compile-resources"
msgstr "Gio::Resource和glib-compile-resources"

#: C/index-in.docbook:3551
msgid ""
"Applications and libraries often contain binary or textual data that is "
"really part of the application, rather than user data. For instance "
"<classname>Gtk::Builder</classname> <filename class=\"extension\">.glade</"
"filename> files, splashscreen images, <classname>Gio::Menu</classname> "
"markup xml, CSS files, icons, etc. These are often shipped as files in "
"<filename class=\"directory\">$datadir/appname</filename>, or manually "
"included as literal strings in the code."
msgstr ""
"应用程序和库经常包含是应用程序的一部分的二进制或文本数据，而不是用户数据。例"
"如<classname>Gtk::Builder</classname>使用的<filename class=\"extension\">."
"glade</filename>文件、启动画面、<classname>Gio::Menu</classname>标记XML、CSS"
"文件、图标等。这些通常这些文件放于<filename class=\"directory\">$datadir/"
"appname</filename>目录下，也可以将其转换为文本字面量手动包含在代码中。"

#: C/index-in.docbook:3559
msgid ""
"The <classname>Gio::Resource</classname> API and the <application>glib-"
"compile-resources</application> program provide a convenient and efficient "
"alternative to this, which has some nice properties. You maintain the files "
"as normal files, so it's easy to edit them, but during the build the files "
"are combined into a binary bundle that is linked into the executable. This "
"means that loading the resource files is efficient (as they are already in "
"memory, shared with other instances) and simple (no need to check for things "
"like I/O errors or locate the files in the filesystem). It also makes it "
"easier to create relocatable applications."
msgstr ""
"<classname>Gio::Resource</classname>API和<application>glib-compile-"
"resources</application>程序提供了一个方便且有效的替代方案，这个方案有一些良好"
"的性质。你可以将这些文件作为普通文件进行维护，因此你可以轻松的编辑它们，在构"
"建过程中，这些文件将会被组合成一个二进制捆绑包，并将其链接到可执行文件中。这"
"意味着加载资源文件会很高效（因为他们在启动时已经被加载到了内存中，并与其他实"
"例共享）且很简单（无需对IO错误进行检查和在文件系统中查找文件）。这也使得创建"
"可重定位应用程序变得更为简单。"

#: C/index-in.docbook:3568
msgid ""
"Resource bundles are created by the <ulink url=\"https://developer.gnome.org/"
"gio/stable/glib-compile-resources.html\">glib-compile-resources</ulink> "
"program which takes an xml file that describes the bundle, and a set of "
"files that the xml references. These are combined into a binary resource "
"bundle."
msgstr ""
"资源包是由<ulink url=\"https://developer.gnome.org/gio/stable/glib-compile-"
"resources.html\">glib-compile-resources</ulink>程序创建的，该程序使用一个XML"
"文件描述资源包并由该XML文件指示资源包引用了那些文件。被引用的文件和XML文件将"
"被组合为一个二进制的资源包。"

#: C/index-in.docbook:3574
msgid ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/classGio_1_1Resource."
"html\">Gio::Resource Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/classGio_1_1Resource."
"html\">Gio::Resource参考</ulink>"

#: C/index-in.docbook:3577
#, no-wrap
msgid ""
"\n"
"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"
"&lt;gresources&gt;\n"
"  &lt;gresource prefix=\"/toolbar\"&gt;\n"
"    &lt;file preprocess=\"xml-stripblanks\"&gt;toolbar.glade&lt;/file&gt;\n"
"    &lt;file&gt;rain.png&lt;/file&gt;\n"
"  &lt;/gresource&gt;\n"
"&lt;/gresources&gt;\n"
msgstr ""
"\n"
"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"
"&lt;gresources&gt;\n"
"  &lt;gresource prefix=\"/toolbar\"&gt;\n"
"    &lt;file preprocess=\"xml-stripblanks\"&gt;toolbar.glade&lt;/file&gt;\n"
"    &lt;file&gt;rain.png&lt;/file&gt;\n"
"  &lt;/gresource&gt;\n"
"&lt;/gresources&gt;\n"

#: C/index-in.docbook:3588
msgid "<filename>/toolbar/toolbar.glade</filename>"
msgstr "<filename>/toolbar/toolbar.glade</filename>"

#: C/index-in.docbook:3589
msgid "<filename>/toolbar/rain.png</filename>"
msgstr "<filename>/toolbar/rain.png</filename>"

#: C/index-in.docbook:3575
msgid ""
"An example: <_:programlisting-1/> This will create a resource bundle with "
"the files <_:itemizedlist-2/>"
msgstr ""
"一个示例：<_:programlisting-1/> 这将创建一个包含以下文件的资源包:<_:"
"itemizedlist-2/>"

#: C/index-in.docbook:3597
#, no-wrap
msgid "$ glib-compile-resources --target=resources.c --generate-source toolbar.gresource.xml"
msgstr "$ glib-compile-resources --target=resources.c --generate-source toolbar.gresource.xml"

#: C/index-in.docbook:3592
msgid ""
"You can then use <application>glib-compile-resources</application> to "
"compile the xml to a binary bundle that you can load with <methodname>Gio::"
"Resource::create_from_file()</methodname>. However, it's more common to use "
"the <parameter class=\"command\">--generate-source</parameter> argument to "
"create a C source file to link directly into your application. E.g. <_:"
"screen-1/>"
msgstr ""
"然后你可以使用<application>glib-compile-resources</application>将XML编译为可"
"以用<methodname>Gio::Resource::create_from_file()</methodname>加载的二进制"
"包。但是使用--generate-source生成C源文件直接链接到你的应用程序更为常见。例"
"如：<_:screen-1/>"

#: C/index-in.docbook:3599
msgid ""
"Once a <classname>Gio::Resource</classname> has been created and registered "
"all the data in it can be accessed globally in the process by using API "
"calls like <methodname>Gio::Resource::open_stream_from_global_resources()</"
"methodname> to stream the data or <methodname>Gio::Resource::"
"lookup_data_in_global_resources()</methodname> to get a direct pointer to "
"the data. You can also use URIs like <uri>resource:///toolbar/rain.png</uri> "
"with <classname>Gio::File</classname> to access the resource data."
msgstr ""
"一旦创建并注册了<classname>Gio::Resource</classname>，就可以使用API调用（例"
"如：<methodname>Gio::Resource::open_stream_from_global_resources()</"
"methodname>流式获取数据或是<methodname>Gio::Resource::"
"lookup_data_in_global_resources()</methodname>直接获取指向数据的指针）在进程"
"的全局访问数据。你还可以使用类似于<uri>resource:///toolbar/rain.png</uri>的"
"URI通过<classname>Gio::File</classname>访问资源数据。"

#: C/index-in.docbook:3607
msgid ""
"Often you don't need a <classname>Gio::Resource</classname> instance, "
"because resource data can be loaded with methods such as <methodname>Gdk::"
"Pixbuf::create_from_resource()</methodname>, <methodname>Gtk::Builder::"
"add_from_resource()</methodname> and <methodname>Gtk::Image::"
"set_from_resource()</methodname>."
msgstr ""
"通常你不需要<classname>Gio::Resource</classname>实例，因为可以使用"
"<methodname>Gdk::Pixbuf::create_from_resource()</methodname>、"
"<methodname>Gtk::Builder::add_from_resource()</methodname>和<methodname>Gtk::"
"Image::set_from_resource()</methodname>直接加载资源数据。"

#: C/index-in.docbook:3620
msgid "Application Menu and Main Menu example"
msgstr "应用程序菜单和主菜单实例"

#: C/index-in.docbook:3621
msgid ""
"This program contains an application menu, a menubar and a toolbar. Classes "
"are derived from <classname>Gtk::Application</classname> and <classname>Gtk::"
"ApplicationWindow</classname>."
msgstr ""
"该程序拥有一个应用程序菜单，一个菜单栏和一个工具栏。这个类是自"
"<classname>Gtk::Application</classname>和<classname>Gtk::ApplicationWindow</"
"classname>派生而来的。"

#: C/index-in.docbook:3628
msgid "App and Main Menu"
msgstr "应用程序和主菜单"

#: C/index-in.docbook:3634
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/menus/main_menu/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/menus/main_menu/\">源代码</ulink>"

#: C/index-in.docbook:3638
msgid "Main Menu example"
msgstr "主菜单示例"

#: C/index-in.docbook:3639
msgid ""
"This program contains a menubar and a toolbar. A class is derived from "
"<classname>Gtk::Window</classname>."
msgstr ""
"该程序包含一个菜单栏和一个工具栏。一个从<classname>Gtk::Window</classname>派"
"生的类。"

#: C/index-in.docbook:3645
msgid "Main Menu"
msgstr "主菜单"

#: C/index-in.docbook:3651
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/menus_and_toolbars\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/menus_and_toolbars\">源代码</ulink>"

#: C/index-in.docbook:3655
msgid "Popup Menu example"
msgstr "弹出菜单示例"

#: C/index-in.docbook:3658
msgid "Popup Menu"
msgstr "弹出菜单"

#: C/index-in.docbook:3664
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/menus/popup/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/menus/popup/\">源代码</ulink>"

#: C/index-in.docbook:3673
msgid "Adjustments"
msgstr "调整(Adjustments)"

#: C/index-in.docbook:3675
msgid ""
"<application>gtkmm</application> has various widgets that can be visually "
"adjusted using the mouse or the keyboard, such as the <classname>Range</"
"classname> widgets (described in the <link linkend=\"chapter-range-widgets"
"\">Range Widgets</link> section). There are also a few widgets that display "
"some adjustable part of a larger area, such as the <classname>Viewport</"
"classname> widget. These widgets have <classname>Gtk::Adjustment</classname> "
"objects that express this common part of their API."
msgstr ""
"<application>gtkmm</application>有各种可以使用鼠标和键盘进行视觉上的调整的部"
"件，例如<classname>Range</classname>部件（在<link linkend=\"chapter-range-"
"widgets\">范围部件</link>小节介绍）。还有些部件显示较大区域的可调整部分，例如"
"<classname>Viewport</classname>部件。这些部件的<classname>Gtk::Adjustment</"
"classname>对象表达了它的共有部分的API。"

#: C/index-in.docbook:3685
msgid ""
"So that applications can react to changes, for instance when a user moves a "
"scrollbar, <classname>Gtk::Adjustment</classname> has a "
"<literal>value_changed</literal> signal. You can then use the "
"<methodname>get_value()</methodname> method to discover the new value."
msgstr ""
"如此一来，应用程序可以对更改做出反应。例如当用户移动滚动条的时候"
"<classname>Gtk::Adjustment</classname>发出<literal>value_changed</literal>信"
"号。你可以在信号处理函数中使用<methodname>get_value()</methodname>方法获取新"
"的值。"

#: C/index-in.docbook:3693
msgid "Creating an Adjustment"
msgstr "创建调整"

#: C/index-in.docbook:3695
msgid ""
"The <classname>Gtk::Adjustment</classname> is created by its "
"<methodname>create()</methodname> method which is as follows:"
msgstr ""
"<classname>Gtk::Adjustment</classname>由它的<methodname>create()</methodname>"
"方法创建，该方法的声明如下："

#: C/index-in.docbook:3700
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(\n"
"  double value,\n"
"  double lower,\n"
"  double upper,\n"
"  double step_increment = 1,\n"
"  double page_increment = 10,\n"
"  double page_size = 0);"
msgstr ""
"Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(\n"
"  double value,\n"
"  double lower,\n"
"  double upper,\n"
"  double step_increment = 1,\n"
"  double page_increment = 10,\n"
"  double page_size = 0);"

#: C/index-in.docbook:3708
msgid ""
"The <parameter>value</parameter> argument is the initial value of the "
"adjustment, usually corresponding to the topmost or leftmost position of an "
"adjustable widget. The <parameter>lower</parameter> and <parameter>upper</"
"parameter> arguments specify the possible range of values which the "
"adjustment can hold. The <parameter>step_increment</parameter> argument "
"specifies the smaller of the two increments by which the user can change the "
"value, while the <parameter>page_increment</parameter> is the larger one. "
"The <parameter>page_size</parameter> argument usually corresponds somehow to "
"the visible area of a panning widget. The <parameter>upper</parameter> "
"argument is used to represent the bottommost or rightmost coordinate in a "
"panning widget's child."
msgstr ""
"其中<parameter>value</parameter>参数是调整的初始值，通常对应于可调整部件的最"
"上边或者最左边。<parameter>lower</parameter>和<parameter>upper</parameter>参"
"数指定调整可以容纳的值的范围。<parameter>step_increment</parameter>和"
"<parameter>page_increment</parameter>指定了一小一大两个增量，增量控制用户在更"
"改调整值的时候一次可以改变的量。<parameter>page_size</parameter>参数通常以某"
"种方式与平移部件能见到的区域大小。<parameter>upper</parameter>参数被用于表示"
"平移子部件最底端或最右端的坐标。"

#: C/index-in.docbook:3727
msgid "Using Adjustments the Easy Way"
msgstr "轻松使用调整"

#: C/index-in.docbook:3729
msgid ""
"The adjustable widgets can be roughly divided into those which use and "
"require specific units for these values, and those which treat them as "
"arbitrary numbers."
msgstr ""
"可调整部件大致可以分为使用并要求这些值使用特定单位的和将它们视作任意数字的。"

#: C/index-in.docbook:3734
msgid ""
"The group which treats the values as arbitrary numbers includes the "
"<classname>Range</classname> widgets (<classname>Scrollbar</classname> and "
"<classname>Scale</classname>), the <classname>ScaleButton</classname> "
"widget, and the <classname>SpinButton</classname> widget. These widgets are "
"typically \"adjusted\" directly by the user with the mouse or keyboard. They "
"will treat the <parameter>lower</parameter> and <parameter>upper</parameter> "
"values of an adjustment as a range within which the user can manipulate the "
"adjustment's <parameter>value</parameter>. By default, they will only modify "
"the <parameter>value</parameter> of an adjustment."
msgstr ""
"将<parameter>value</parameter>视作任意数的部件组包括<classname>Range</"
"classname>（<classname>Scrollbar</classname>和<classname>Scale</"
"classname>）、<classname>ScaleButton</classname>、<classname>SpinButton</"
"classname>。这些部件通常由用户使用鼠标和键盘直接进行\"调整\"。他们会将"
"<parameter>lower</parameter>和<parameter>upper</parameter>视为用户可以操纵调"
"整的<parameter>value</parameter>的范围。默认情况下它们只会修改调整的"
"<parameter>value</parameter>。"

#: C/index-in.docbook:3746
msgid ""
"The other group includes the <classname>Viewport</classname> widget and the "
"<classname>ScrolledWindow</classname> widget. All of these widgets use pixel "
"values for their adjustments. These are also typically adjusted indirectly "
"using scrollbars. While all widgets which use adjustments can either create "
"their own adjustments or use ones you supply, you'll generally want to let "
"this particular category of widgets create its own adjustments."
msgstr ""
"另一组部件包括<classname>Viewport</classname>和<classname>ScrolledWindow</"
"classname>。所有的这些部件都将调整的值视作像素值。通常你也可以使用滚动条间接"
"的修改调整的值。虽然所有使用调整的部件都可以创建自己的调整也可以使用你提供的"
"调整，但是通常情况下你都会希望使用这些部件自行创建的调整。"

#: C/index-in.docbook:3755
msgid ""
"If you share an adjustment object between a Scrollbar and a TextView widget, "
"manipulating the scrollbar will automagically adjust the TextView widget. "
"You can set it up like this:"
msgstr ""
"如果你使滚动条和文本视图部件共享一个调整对象，则你操纵滚动条的时候文本视图将"
"被自动调整。你可以这样设置："

#: C/index-in.docbook:3760
#, no-wrap
msgid ""
"// creates its own adjustments\n"
"Gtk::TextView textview;\n"
"// uses the newly-created adjustment for the scrollbar as well\n"
"Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);"
msgstr ""
"// creates its own adjustments\n"
"Gtk::TextView textview;\n"
"// uses the newly-created adjustment for the scrollbar as well\n"
"Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);"

#: C/index-in.docbook:3768
msgid "Adjustment Internals"
msgstr "调整的内部"

#: C/index-in.docbook:3770
msgid ""
"OK, you say, that's nice, but what if I want to create my own handlers to "
"respond when the user adjusts a <classname>Range</classname> widget or a "
"<classname>SpinButton</classname>. To access the value of a <classname>Gtk::"
"Adjustment</classname>, you can use the <methodname>get_value()</methodname> "
"and <methodname>set_value()</methodname> methods:"
msgstr ""
"如果你想要创建一个自己的处理函数以响应用户对<classname>Range</classname>或"
"<classname>SpinButton</classname>部件的调整。你可以使用<classname>Gtk::"
"Adjustment</classname>的<methodname>get_value()</methodname>和"
"<methodname>set_value()</methodname>方法访问其值："

#: C/index-in.docbook:3778
msgid ""
"As mentioned earlier, <classname>Gtk::Adjustment</classname> can emit "
"signals. This is, of course, how updates happen automatically when you share "
"an <classname>Adjustment</classname> object between a <classname>Scrollbar</"
"classname> and another adjustable widget; all adjustable widgets connect "
"signal handlers to their adjustment's <literal>value_changed</literal> "
"signal, as can your program."
msgstr ""
"如前所述，<classname>Gtk::Adjustment</classname>可以发射信号。而所有可调整部"
"件都会将信号处理函数连接到其调整对象的<literal>value_changed</literal>信号你"
"的程序也可以如此。这使得当<classname>Scrollbar</classname>和其他可调整部件共"
"享一个<classname>Adjustment</classname>对象时，如果你操纵滚动条与其共享调整对"
"象的其他可调整部件将会自动更新。"

#: C/index-in.docbook:3787
msgid ""
"So, for example, if you have a <classname>Scale</classname> widget, and you "
"want to change the rotation of a picture whenever its value changes, you "
"would create a signal handler like this:"
msgstr ""
"因此，例如，如果你有一个<classname>Scale</classname>部件并且你想要当调整值变"
"更以后更改图片的旋转角度，你可以创建一个如下所示的信号处理函数："

#: C/index-in.docbook:3792
#, no-wrap
msgid ""
"void cb_rotate_picture (MyPicture* picture)\n"
"{\n"
"  picture-&gt;set_rotation(adj-&gt;get_value());\n"
"..."
msgstr ""
"void cb_rotate_picture (MyPicture* picture)\n"
"{\n"
"  picture-&gt;set_rotation(adj-&gt;get_value());\n"
"..."

#: C/index-in.docbook:3796
msgid "and connect it to the scale widget's adjustment like this:"
msgstr "并且将其连接到比例部件的调整对象上，如下所示："

#: C/index-in.docbook:3799
#, no-wrap
msgid ""
"adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"
msgstr ""
"adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"

#: C/index-in.docbook:3802
msgid ""
"What if a widget reconfigures the <parameter>upper</parameter> or "
"<parameter>lower</parameter> fields of its <classname>Adjustment</"
"classname>, such as when a user adds more text to a text widget? In this "
"case, it emits the <literal>changed</literal> signal."
msgstr ""
"如果一个部件重新配置其<classname>Adjustment</classname>的<parameter>upper</"
"parameter>和<parameter>lower</parameter>字段（例如：用户向文本部件添加了更多"
"的文本），那么它将发出<literal>changed</literal>信号。"

#: C/index-in.docbook:3809
msgid ""
"<classname>Range</classname> widgets typically connect a handler to this "
"signal, which changes their appearance to reflect the change - for example, "
"the size of the slider in a scrollbar will grow or shrink in inverse "
"proportion to the difference between the <parameter>lower</parameter> and "
"<parameter>upper</parameter> values of its <classname>Adjustment</classname>."
msgstr ""
"<classname>Range</classname>部件通常会将处理程序连接到此信号，并更改其外观响"
"应变更 - 例如：滚动条中的滑块将随着<classname>Adjustment</classname>中"
"<parameter>lower</parameter>与<parameter>upper</parameter>的差值的增大逐渐变"
"小，反之则逐渐增大。"

#: C/index-in.docbook:3818
msgid ""
"You probably won't ever need to attach a handler to this signal, unless "
"you're writing a new type of range widget."
msgstr ""
"除非你正在编写新的范围部件，否则你可能永远不需要将处理程序连接到这个信号。"

#: C/index-in.docbook:3822
#, no-wrap
msgid "adjustment-&gt;signal_changed();"
msgstr "adjustment-&gt;signal_changed();"

#: C/index-in.docbook:3829
msgid "Dialogs"
msgstr "对话框(Dialogs)"

#: C/index-in.docbook:3831
msgid ""
"Dialogs are used as secondary windows, to provide specific information or to "
"ask questions. <classname>Gtk::Dialog</classname> windows contain a few pre-"
"packed widgets to ensure consistency, and a <methodname>run()</methodname> "
"method which blocks until the user dismisses the dialog."
msgstr ""
"对话框被用作辅助窗口，以提供特定的信息或者提出问题。<classname>Gtk::Dialog</"
"classname>窗口包含了一些预装部件以确保一致性，且有一个<methodname>run()</"
"methodname>方法可以阻塞到用户关闭对话框。"

#: C/index-in.docbook:3838
msgid ""
"There are several derived <classname>Dialog</classname> classes which you "
"might find useful. <classname>Gtk::MessageDialog</classname> is used for "
"most simple notifications. But at other times you might need to derive your "
"own dialog class to provide more complex functionality."
msgstr ""
"有几个派生自<classname>Dialog</classname>的类可能对你而言很有用。"
"<classname>Gtk::MessageDialog</classname>多被用于简单的通知。但有时候你也需要"
"派生自己的对话框类以提供更为复杂的功能。"

#: C/index-in.docbook:3845
msgid ""
"To pack widgets into a custom dialog, you should pack them into the "
"<classname>Gtk::Box</classname>, available via "
"<methodname>get_content_area()</methodname>. To just add a "
"<classname>Button</classname> to the bottom of the <classname>Dialog</"
"classname>, you could use the <methodname>add_button()</methodname> method."
msgstr ""
"若要将部件添加到自定义的对话框中，你需要将其装入通过"
"<methodname>get_content_area()</methodname>获得的<classname>Gtk::Box</"
"classname>中。如果你只需要向<classname>Dialog</classname>的底部添加一个"
"<classname>Button</classname>，那么你可以直接使用<methodname>add_button()</"
"methodname>方法。"

#: C/index-in.docbook:3853
msgid ""
"The <methodname>run()</methodname> method returns an <literal>int</literal>. "
"This may be a value from the <literal>Gtk::ResponseType</literal> if the "
"user closed the dialog by clicking a standard button, or it could be the "
"custom response value that you specified when using "
"<methodname>add_button()</methodname>."
msgstr ""
"<methodname>run()</methodname>方法返回一个<literal>int</literal>。如果用户是"
"通过单击标准按钮关闭的对话框，则该值可能是<literal>Gtk::ResponseType</"
"literal>中的一个也可能是使用<methodname>add_button()</methodname>时你所指定的"
"值。"

#: C/index-in.docbook:3860
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Dialog."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Dialog."
"html\">参考</ulink>"

#: C/index-in.docbook:3862 C/index-in.docbook:3877
msgid "MessageDialog"
msgstr "消息对话框(MessageDialog)"

#: C/index-in.docbook:3863
msgid ""
"<classname>MessageDialog</classname> is a convenience class, used to create "
"simple, standard message dialogs, with a message, an icon, and buttons for "
"user response. You can specify the type of message and the text in the "
"constructor, as well as specifying standard buttons via the <literal>Gtk::"
"ButtonsType</literal> enum."
msgstr ""
"<classname>MessageDialog</classname>是一个便利类，用于创建包含消息、图标、以"
"及便于用户响应的按钮的简易标准消息对话框。你可以在其构造函数中指定消息类型和"
"消息文本，也可以通过<literal>Gtk::ButtonsType</literal>枚举指定其包含的标准按"
"钮。"

#: C/index-in.docbook:3871
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1MessageDialog.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1MessageDialog.html\">参考</ulink>"

#: C/index-in.docbook:3883
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/messagedialog\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/messagedialog\">源代码</ulink>"

#: C/index-in.docbook:3888
msgid "FileChooserDialog"
msgstr "文件选择对话框(FileChooserDialog)"

#: C/index-in.docbook:3889
msgid ""
"The <classname>FileChooserDialog</classname> is suitable for use with \"Open"
"\" or \"Save\" menu items."
msgstr ""
"<classname>FileChooserDialog</classname>通常被用于\"打开\"或\"保存\"菜单项。"

#: C/index-in.docbook:3893
msgid ""
"Most of the useful member methods for this class are actually in the "
"<classname>Gtk::FileChooser</classname> base class."
msgstr ""
"该类的大部分有用的成员函数都在其基类<classname>Gtk::FileChooser</classname>"
"中。"

#: C/index-in.docbook:3898
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1FileChooserDialog.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1FileChooserDialog.html\">参考</ulink>"

#: C/index-in.docbook:3904 C/index-in.docbook:5437
msgid "FileChooser"
msgstr "文件选择器(FileChooser)"

#: C/index-in.docbook:3910
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/filechooserdialog\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/filechooserdialog\">源代码</ulink>"

#: C/index-in.docbook:3914 C/index-in.docbook:3927
msgid "ColorChooserDialog"
msgstr "颜色选择器对话框(ColorChooserDialog)"

#: C/index-in.docbook:3915
msgid ""
"The <classname>ColorChooserDialog</classname> allows the user to choose a "
"color. The <classname>ColorButton</classname> opens a color selection dialog "
"when it is clicked."
msgstr ""
"<classname>ColorChooserDialog</classname>允许用户选择一个颜色。当"
"<classname>ColorButton</classname>被点击的时会打开一个颜色选择对话框。"

#: C/index-in.docbook:3921
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ColorChooserDialog.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ColorChooserDialog.html\">参考</ulink>"

#: C/index-in.docbook:3933
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/colorchooserdialog\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/colorchooserdialog\">源代码</ulink>"

#: C/index-in.docbook:3938 C/index-in.docbook:3951
msgid "FontChooserDialog"
msgstr "字体选择器对话框(FontChooserDialog)"

#: C/index-in.docbook:3939
msgid ""
"The <classname>FontChooserDialog</classname> allows the user to choose a "
"font. The <classname>FontButton</classname> opens a font chooser dialog when "
"it is clicked."
msgstr ""
"<classname>FontChooserDialog</classname>允许用户选择一个字体。当"
"<classname>FontButton</classname>被点击时将打开一个字体选择对话框。"

#: C/index-in.docbook:3945
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1FontChooserDialog.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1FontChooserDialog.html\">参考</ulink>"

#: C/index-in.docbook:3957
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/fontchooserdialog\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/fontchooserdialog\">源代码</ulink>"

#: C/index-in.docbook:3962
msgid "Non-modal AboutDialog"
msgstr "非模态关于对话框(AboutDialog)"

#: C/index-in.docbook:3963
msgid ""
"The <classname>AboutDialog</classname> offers a simple way to display "
"information about a program, like its logo, name, copyright, website and "
"license."
msgstr ""
"<classname>AboutDialog</classname>提供了一个简单的显示程序有关信息（例如标"
"志、名称、版权、网站、许可证）的方式。"

#: C/index-in.docbook:3967
msgid ""
"Most dialogs in this chapter are modal, that is, they freeze the rest of the "
"application while they are shown. It's also possible to create a non-modal "
"dialog, which does not freeze other windows in the application. The "
"following example shows a non-modal <classname>AboutDialog</classname>. This "
"is perhaps not the kind of dialog you would normally make non-modal, but non-"
"modal dialogs can be useful in other cases. E.g. <application>gedit</"
"application>'s search-and-replace dialog is non-modal."
msgstr ""
"本章中的大部分对话框都是模态的，也就是说在显示它们的时候应用程序的其他部分是"
"被冻结的。你也可以创建一个非模态的对话框，这样的对话框不会冻结应用程序的其他"
"窗口。下面的示例显示了一个非模态的<classname>AboutDialog</classname>。通常你"
"不会想要将该对话框做成非模态，但这不表示非模态对话框在其它情况下没有用。例"
"如：在<application>gedit</application>中搜索和替换对话框就是非模态的。"

#: C/index-in.docbook:3977
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1AboutDialog.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1AboutDialog.html\">参考</ulink>"

#: C/index-in.docbook:3983
msgid "AboutDialog"
msgstr "关于对话框"

#: C/index-in.docbook:3989
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/aboutdialog\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/dialogs/aboutdialog\">源代码</ulink>"

#: C/index-in.docbook:3997
msgid "The DrawingArea Widget"
msgstr "绘图区域部件(DrawingArea Widget)"

#: C/index-in.docbook:3998
msgid ""
"The <classname>DrawingArea</classname> widget is a blank window that gives "
"you the freedom to create any graphic you desire. Along with that freedom "
"comes the responsibility to draw on the widget. When a widget is first "
"shown, or when it is covered and then uncovered again it needs to redraw "
"itself. Most widgets have code to do this, but the <classname>DrawingArea</"
"classname> does not, allowing you to write your own draw function to "
"determine how the contents of the widget will be drawn. This is done by "
"setting a draw function with a call to the <methodname>set_draw_func()</"
"methodname> member function."
msgstr ""
"<classname>DrawingArea</classname>部件是一个空白的窗口，让你可以自由的创造任"
"何你想要的图形。伴随着这种自由而来的是绘制这个部件的责任。在部件第一次显示或"
"者部件被覆盖后又露出的时候它需要重绘自己。大多数部件都包含执行此操作的代码，"
"但是<classname>DrawingArea</classname>并没有。因此你可以编写自己的绘图函数来"
"确定如何绘制绘部件的内容。你可以调用<methodname>set_draw_func()</methodname>"
"成员函数来设置绘图函数。"

#: C/index-in.docbook:4010
msgid ""
"GTK uses the <ulink url=\"http://cairographics.org\">Cairo</ulink> drawing "
"API. With <application>gtkmm</application>, you may use the <ulink url="
"\"http://www.cairographics.org/cairomm/\">cairomm</ulink> C++ API for cairo."
msgstr ""
"GTK使用<ulink url=\"http://cairographics.org\">开罗</ulink>绘图API。而在"
"<application>gtkmm</application>中你可以使用由<ulink url=\"http://www."
"cairographics.org/cairomm/\">cairomm</ulink>提供的开罗C++ API。"

#: C/index-in.docbook:4015
msgid ""
"You can draw very sophisticated shapes using Cairo, but the methods to do so "
"are quite basic. Cairo provides methods for drawing straight lines, curved "
"lines, and arcs (including circles). These basic shapes can be combined to "
"create more complex shapes and paths which can be filled with solid colors, "
"gradients, patterns, and other things. In addition, Cairo can perform "
"complex transformations, do compositing of images, and render antialiased "
"text."
msgstr ""
"你可以使用开罗绘制非常复杂的形状，但你只有一些很基本的方法可用。开罗提供了绘"
"制直线、曲线、圆弧（包括圆）的方法。你可以通过对这些图形进行组合从而创建更为"
"复杂的形状和路径，然后用纯色、渐变、模式等进行填充。除此之外，开罗还可以进行"
"复杂的转换、合成图像和渲染抗锯齿文本等。"

#: C/index-in.docbook:4025
msgid "Cairo and Pango"
msgstr "开罗和Pango"

#: C/index-in.docbook:4026
msgid ""
"Although Cairo can render text, it's not meant to be a replacement for "
"Pango. Pango is a better choice if you need to perform more advanced text "
"rendering such as wrapping or ellipsizing text. Drawing text with Cairo "
"should only be done if the text is part of a graphic."
msgstr ""
"虽然开罗可以用于渲染文本，但不意味着它能替代Pango。如果你需要进行更高级的文本"
"渲染（例如环绕和省略文本）则Pango会是更好的选择。只有当文本是图形的一部分的时"
"候才应该使用开罗绘制文本。"

#: C/index-in.docbook:4031
msgid ""
"In this section of the tutorial, we'll cover the basic Cairo drawing model, "
"describe each of the basic drawing elements in some detail (with examples), "
"and then present a simple application that uses Cairo to draw a custom clock "
"widget."
msgstr ""
"在本教程的这一部分中，我们将介绍开罗的基本绘图模型，详细描述每个基本绘制元素"
"（包括示例），然后介绍一个使用开罗绘制自定义时钟部件的简单应用程序。"

#: C/index-in.docbook:4038
msgid "The Cairo Drawing Model"
msgstr "开罗绘制模型"

#: C/index-in.docbook:4039
msgid ""
"The basic concept of drawing in Cairo involves defining 'invisible' paths "
"and then stroking or filling them to make them visible."
msgstr ""
"开罗的基本概念包括定义'不可见'路径然后描绘(stroking)或者填充(filling)它们使其"
"可见。"

#: C/index-in.docbook:4043
msgid ""
"To do any drawing in <application>gtkmm</application> with Cairo, you must "
"first get a <classname>Cairo::Context</classname> object. This class holds "
"all of the graphics state parameters that describe how drawing is to be "
"done. This includes information such as line width, color, the surface to "
"draw to, and many other things. This allows the actual drawing functions to "
"take fewer arguments to simplify the interface. Usually, you use the "
"<classname>Cairo::Context</classname> that you get as input data to the draw "
"function that you set with the call to <methodname>set_draw_func()</"
"methodname>. It's also possible to create a <classname>Cairo::Context</"
"classname> by calling the <methodname>Gdk::Surface::create_cairo_context()</"
"methodname> and <methodname>Gdk::CairoContext::cairo_create()</methodname> "
"functions. Since Cairo contexts are reference-counted objects, "
"<methodname>cairo_create()</methodname> returns a <classname>Cairo::"
"RefPtr&lt;Cairo::Context&gt;</classname> object. (Note the difference "
"between <classname>Gdk::CairoContext</classname> and <classname>Cairo::"
"Context</classname>.)"
msgstr ""
"要在<application>gtkmm</application>中使用开罗进行绘制，必须先获取"
"<classname>Cairo::Context</classname>对象。这个类保存了所有描述如何进行绘制的"
"图形状态参数。状态参数包含了诸如线宽、颜色、要绘制的表面和许多其他内容的信"
"息。这允许实际上的绘图函数只需要使用较少的参数从而简化接口。通常你使用"
"<methodname>set_draw_func()</methodname>设置的绘图函数将<classname>Cairo::"
"Context</classname>作为输入数据。也可以通过调用<methodname>Gdk::Surface::"
"create_cairo_context()</methodname>和<methodname>Gdk::CairoContext::"
"cairo_create()</methodname>函数创建一个<classname>Cairo::Context</"
"classname>。由于<classname>Cairo::Context</classname>是一个使用引用计数的对"
"象，因此<methodname>cairo_create()</methodname>返回<classname>Cairo::"
"RefPtr&lt;Cairo::Context&gt;</classname>对象（请注意区分<classname>Gdk::"
"CairoContext</classname>与<classname>Cairo::Context</classname>。）。"

#: C/index-in.docbook:4060
msgid ""
"The following example shows how to set up a Cairo context with a foreground "
"color of red and a width of 2. Any drawing functions that use this context "
"will use these settings."
msgstr ""
"以下示例显示如何设置一个开罗上下文(Cairo Context)的前景色为红色且宽度为2。任"
"何使用该上下文的绘图函数都将使用这些设置。"

#: C/index-in.docbook:4065
#, no-wrap
msgid ""
"\n"
"Gtk::DrawingArea myArea;\n"
"auto gdkCairoContext = myArea.get_surface()-&gt;create_cairo_context();\n"
"auto myContext = gdkCairoContext-&gt;cairo_create();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);\n"
"    "
msgstr ""
"\n"
"Gtk::DrawingArea myArea;\n"
"auto gdkCairoContext = myArea.get_surface()-&gt;create_cairo_context();\n"
"auto myContext = gdkCairoContext-&gt;cairo_create();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);\n"
"    "

#: C/index-in.docbook:4072
msgid ""
"Each <classname>Cairo::Context</classname> is associated with a particular "
"<classname>Gdk::Surface</classname>, so the first line of the above example "
"creates a <classname>Gtk::DrawingArea</classname> widget and the next two "
"lines use its associated <classname>Gdk::Surface</classname> to create a "
"<classname>Cairo::Context</classname> object. The final two lines change the "
"graphics state of the context."
msgstr ""
"每一个<classname>Cairo::Context</classname>都有一个特定的<classname>Gdk::"
"Surface</classname>与之相关联，因此上面示例的第一行创建了一个<classname>Gtk::"
"DrawingArea</classname>部件，接下来两行使用与其相关联的<classname>Gdk::"
"Surface</classname>创建一个<classname>Cairo::Context</classname>对象。最后两"
"行更改上下文的图形状态。"

#: C/index-in.docbook:4080
msgid ""
"There are a number of graphics state variables that can be set for a Cairo "
"context. The most common context attributes are color (using "
"<methodname>set_source_rgb()</methodname> or <methodname>set_source_rgba()</"
"methodname> for translucent colors), line width (using "
"<methodname>set_line_width()</methodname>), line dash pattern (using "
"<methodname>set_dash()</methodname>), line cap style (using "
"<methodname>set_line_cap()</methodname>), and line join style (using "
"<methodname>set_line_join()</methodname>), and font styles (using "
"<methodname>set_font_size()</methodname>, <methodname>set_font_face()</"
"methodname> and others). There are many other settings as well, such as "
"transformation matrices, fill rules, whether to perform antialiasing, and "
"others. For further information, see the <ulink url=\"http://www."
"cairographics.org/cairomm/\">cairomm</ulink> API documentation."
msgstr ""
"可以为开罗上下文设置许多的图形状态。最常见的上下文属性是颜色（使用"
"<methodname>set_source_rgb()</methodname>或需要半透明颜色的时候用"
"<methodname>set_source_rgba()</methodname>）、线宽（使用"
"<methodname>set_line_width()</methodname>）、虚线模式（使用"
"<methodname>set_dash()</methodname>）、线帽样式（使用"
"<methodname>set_line_cap()</methodname>）、线条连接样式（使用"
"<methodname>set_line_join()</methodname>）以及字体样式（使用"
"<methodname>set_font_size()</methodname>）。还有许多其他设置，例如变换矩阵、"
"填充规则、是否执行抗锯齿规则等。更多详情请参阅<ulink url=\"http://www."
"cairographics.org/cairomm/\">cairomm</ulink>API文档。"

#: C/index-in.docbook:4112
msgid ""
"It is good practice to put all modifications to the graphics state between "
"<methodname>save()</methodname>/<methodname>restore()</methodname> function "
"calls. For example, if you have a function that takes a <classname>Cairo::"
"Context</classname> reference as an argument, you might implement it as "
"follows:"
msgstr ""
"好的做法是在一组<methodname>save()</methodname>/<methodname>restore()</"
"methodname>调用之间进行所有对图形状态的更改。例如，如果你有一个将"
"<classname>Cairo::Context</classname>的引用作为参数的函数，你可以这样实现它："

#: C/index-in.docbook:4118
#, no-wrap
msgid ""
"void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // change graphics state\n"
"    // perform drawing operations\n"
"    context-&gt;restore();\n"
"}"
msgstr ""
"void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // change graphics state\n"
"    // perform drawing operations\n"
"    context-&gt;restore();\n"
"}"

#: C/index-in.docbook:4095
msgid ""
"The current state of a <classname>Cairo::Context</classname> can be saved to "
"an internal stack of saved states and later be restored to the state it was "
"in when you saved it. To do this, use the <methodname>save()</methodname> "
"method and the <methodname>restore()</methodname> method. This can be useful "
"if you need to temporarily change the line width and color (or any other "
"graphics setting) in order to draw something and then return to the previous "
"settings. In this situation, you could call <methodname>Cairo::Context::"
"save()</methodname>, change the graphics settings, draw the lines, and then "
"call <methodname>Cairo::Context::restore()</methodname> to restore the "
"original graphics state. Multiple calls to <methodname>save()</methodname> "
"and <methodname>restore()</methodname> can be nested; each call to "
"<methodname>restore()</methodname> restores the state from the matching "
"paired <methodname>save()</methodname>. <_:tip-1/>"
msgstr ""
"可以将<classname>Cairo::Context</classname>当前的状态保存到其内部用于保存状态"
"的栈中，并在之后将状态还原为保存时的状态。要做到这个请调用"
"<methodname>save()</methodname>和<methodname>restore()</methodname>方法。当你"
"需要临时更改某些图形设置（例如线宽和颜色）以绘制某些内容然后又退回到之前的状"
"态时这将很有用。在这种情况下，你可以先调用<methodname>Cairo::Context::"
"save()</methodname>，然后修改图形设置并绘制图形，再调用<methodname>Cairo::"
"Context::restore()</methodname>恢复之前的图形状态。你可以多次嵌套调用"
"<methodname>save()</methodname>和<methodname>restore()</methodname>；每次"
"<methodname>restore()</methodname>调用都会将恢复状态到与之相对应的"
"<methodname>save()</methodname>所保存的状态。 <_:tip-1/>"

#: C/index-in.docbook:4127
msgid ""
"The draw function that you set with a call to <methodname>set_draw_func()</"
"methodname> is called with a Cairo context that you shall use for drawing in "
"the <classname>Gtk::DrawingArea</classname> widget. It is not necessary to "
"save and restore this Cairo context in the draw function."
msgstr ""
"你通过调用<methodname>set_draw_func()</methodname>所设置的绘图函数是由你要绘"
"制的<classname>Gtk::DrawingArea</classname>部件用开罗上下文调用的。所以你不需"
"要在绘图函数中对此开罗上下文进行保存和恢复（部件会在调用绘图函数时做保存与恢"
"复）。"

#: C/index-in.docbook:4135
msgid "Drawing Straight Lines"
msgstr "画直线"

#: C/index-in.docbook:4144
msgid ""
"Since the Cairo graphics library was written with support for multiple "
"output targets (the X window system, PNG images, OpenGL, etc), there is a "
"distinction between user-space and device-space coordinates. The mapping "
"between these two coordinate systems defaults to one-to-one so that integer "
"values map roughly to pixels on the screen, but this setting can be adjusted "
"if desired. Sometimes it may be useful to scale the coordinates so that the "
"full width and height of a window both range from 0 to 1 (the 'unit square') "
"or some other mapping that works for your application. This can be done with "
"the <methodname>Cairo::Context::scale()</methodname> function."
msgstr ""
"由于开罗图形库是为了支持多个输出目标（X window系统、PNG图片、OpenGL等）编写"
"的，因此用户空间坐标和设备空间坐标存在一些区别。默认情况下这两个坐标系是一对"
"一的，这样可以将整数值大致映射为屏幕上的像素值，不过有需要时可以通过"
"<methodname>Cairo::Context::scale()</methodname>函数对此行为进行调整。例如："
"你可能会需要使一个窗口的宽和高在调整比例后的坐标系中取值范围均处于0到1之间"
"（单位正方形）。"

#: C/index-in.docbook:4136
msgid ""
"Now that we understand the basics of the Cairo graphics library, we're "
"almost ready to start drawing. We'll start with the simplest of drawing "
"elements: the straight line. But first you need to know a little bit about "
"Cairo's coordinate system. The origin of the Cairo coordinate system is "
"located in the upper-left corner of the window with positive x values to the "
"right and positive y values going down. <_:tip-1/>"
msgstr ""
"现在我们已经了解了开罗图形库的基本知识，是时候开始画图了。我们将从画最简单的"
"元素：直线 开始。但是在此之前你需要对开罗的坐标系有所了解。开罗的坐标系原点在"
"窗口的左上角，从左向右X的值逐渐增大，从上往下Y的值逐渐增大。 <_:tip-1/>"

#: C/index-in.docbook:4159
msgid ""
"In this example, we'll construct a small but fully functional "
"<application>gtkmm</application> program and draw some lines into the "
"window. The lines are drawn by creating a path and then stroking it. A path "
"is created using the functions <methodname>Cairo::Context::move_to()</"
"methodname> and <methodname>Cairo::Context::line_to()</methodname>. The "
"function <methodname>move_to()</methodname> is similar to the act of lifting "
"your pen off of the paper and placing it somewhere else -- no line is drawn "
"between the point you were at and the point you moved to. To draw a line "
"between two points, use the <methodname>line_to()</methodname> function."
msgstr ""
"在这个示例中，我们将构建一个很小但功能齐全的<application>gtkmm</application>"
"程序，并将一些线绘制到窗口中。使用函数<methodname>Cairo::Context::move_to()</"
"methodname>和<methodname>Cairo::Context::line_to()</methodname>创建一个路径。"
"<methodname>move_to()</methodname>函数的行为类似于将笔从纸上抬起并放到其他地"
"方 -- 在你移动到的点和你之前所在的点直接不会画出一条线。使用"
"<methodname>line_to()</methodname>函数可以在两点之间画线。"

#: C/index-in.docbook:4171
msgid ""
"After you've finished creating your path, you still haven't drawn anything "
"visible yet. To make the path visible, you must use the function "
"<methodname>stroke()</methodname> which will stroke the current path with "
"the line width and style specified in your <classname>Cairo::Context</"
"classname> object. After stroking, the current path will be cleared so that "
"you can start on your next path."
msgstr ""
"创建完你的路径以后。你依旧没有画任何看得见的东西。要想让路径可见，你需要使用"
"<methodname>stroke()</methodname>函数，该函数将使用你的<classname>Cairo::"
"Context</classname>对象中保存的线宽与样式绘制当前的路径。描绘完成后，当前路径"
"将被清除，以便你可以从下一个路径开始。"

#: C/index-in.docbook:4180
msgid ""
"Many Cairo drawing functions have a <methodname>_preserve()</methodname> "
"variant. Normally drawing functions such as <methodname>clip()</methodname>, "
"<methodname>fill()</methodname>, or <methodname>stroke()</methodname> will "
"clear the current path. If you use the <methodname>_preserve()</methodname> "
"variant, the current path will be retained so that you can use the same path "
"with the next drawing function."
msgstr ""
"多数的开罗绘图函数都拥有一个<methodname>_preserve()</methodname>变体。通常情"
"况下<methodname>clip()</methodname>、<methodname>fill()</methodname>、"
"<methodname>stroke()</methodname>函数会清除当前的路径。如果你使用他们的"
"<methodname>_preserve()</methodname>变体，则当前路径会被保留，以便下一个绘图"
"函数能继续在一样的路径上绘制。"

#: C/index-in.docbook:4190 C/index-in.docbook:4310
msgid "Drawing Area - Lines"
msgstr "绘图区域 - 线"

#: C/index-in.docbook:4196
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/simple\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/simple\">源代码</ulink>"

#: C/index-in.docbook:4198
msgid ""
"This program contains a single class, <classname>MyArea</classname>, which "
"is a subclass of <classname>Gtk::DrawingArea</classname> and contains an "
"<methodname>on_draw()</methodname> member function. This function becomes "
"the draw function by a call to <methodname>set_draw_func()</methodname> in "
"<classname>MyArea</classname>'s constructor. <methodname>on_draw()</"
"methodname> is then called whenever the image in the drawing area needs to "
"be redrawn. It is passed a <classname>Cairo::RefPtr</classname> pointer to a "
"<classname>Cairo::Context</classname> that we use for the drawing. The "
"actual drawing code sets the color we want to use for drawing by using "
"<methodname>set_source_rgb()</methodname> which takes arguments defining the "
"Red, Green, and Blue components of the desired color (valid values are "
"between 0 and 1). After setting the color, we created a new path using the "
"functions <methodname>move_to()</methodname> and <methodname>line_to()</"
"methodname>, and then stroked this path with <methodname>stroke()</"
"methodname>."
msgstr ""
"这个程序包含一个<classname>MyArea</classname>类，它是<classname>Gtk::"
"DrawingArea</classname>的子类，并且包含<methodname>on_draw()</methodname>成员"
"函数。通过在<classname>MyArea</classname>的构造函数中调用"
"<methodname>set_draw_func()</methodname>使其变成绘制函数。每当需要重绘绘图区"
"域的图像的时候，<methodname>on_draw()</methodname>就会被调用。这将会向我们的"
"绘制函数传递一个指向<classname>Cairo::Context</classname>的<classname>Cairo::"
"RefPtr</classname>指针。实际进行绘图的代码使用<methodname>set_source_rgb()</"
"methodname>设置我们将用于绘图的颜色，这个函数接受定义颜色所需的红色、绿色、蓝"
"色分量作为参数（参数的有效值介于0到1之间）。设置完颜色后，我们使用"
"<methodname>move_to()</methodname>和<methodname>line_to()</methodname>函数创"
"建一个新的路径，然后使用<methodname>stroke()</methodname>绘制了这个路径。"

#: C/index-in.docbook:4217
msgid "Drawing with relative coordinates"
msgstr "使用相对坐标绘图"

#: C/index-in.docbook:4218
msgid ""
"In the example above we drew everything using absolute coordinates. You can "
"also draw using relative coordinates. For a straight line, this is done with "
"the function <methodname>Cairo::Context::rel_line_to()</methodname>."
msgstr ""
"在上面的例子中，我们使用绝对坐标进行绘图。你也可以使用相对坐标进行绘图。对于"
"直线而言，你可以通过<methodname>Cairo::Context::rel_line_to()</methodname>完"
"成用相对坐标绘图。"

#: C/index-in.docbook:4224
msgid "Line styles"
msgstr "线型"

#: C/index-in.docbook:4225
msgid ""
"In addition to drawing basic straight lines, there are a number of things "
"that you can customize about a line. You've already seen examples of setting "
"a line's color and width, but there are others as well."
msgstr ""
"除了绘制基本直线以外，你还可以对线条进行很多自定义。你已经看到了对线条颜色和"
"线条宽度的示例，但还有其他示例。"

#: C/index-in.docbook:4231
msgid ""
"If you've drawn a series of lines that form a path, you may want them to "
"join together in a certain way. Cairo offers three different ways to join "
"lines together: Miter, Bevel, and Round. These are show below:"
msgstr ""
"如果你于一个路径绘制了一系列的线条，你可能希望它们以某种方式被连接起来。开罗"
"提供了三种不同的连接线条的方式：斜接(Miter)、斜切(Bevel)、圆(Round)。这些连接"
"方式的示意图如下："

#: C/index-in.docbook:4238
msgid "Different join types in Cairo"
msgstr "开罗的不同连接类型"

#: C/index-in.docbook:4243
msgid ""
"The line join style is set using the function <methodname>Cairo::Context::"
"set_line_join()</methodname>."
msgstr ""
"线条连接样式由<methodname>Cairo::Context::set_line_join()</methodname>函数进"
"行设置。"

#: C/index-in.docbook:4247
msgid ""
"Line ends can have different styles as well. The default style is for the "
"line to start and stop exactly at the destination points of the line. This "
"is called a Butt cap. The other options are Round (uses a round ending, with "
"the center of the circle at the end point) or Square (uses a squared ending, "
"with the center of the square at the end point). This setting is set using "
"the function <methodname>Cairo::Context::set_line_cap()</methodname>."
msgstr ""
"线尾也有不同的样式。默认样式是从线条的开始到结尾准确的停止。这被叫做平端。其"
"他的可选性有圆（使用圆形结束，以终点为圆心）和方（使用正方形结束，以终点为正"
"方形的中心）。这可以使用<methodname>Cairo::Context::set_line_cap()</"
"methodname>函数使用。"

#: C/index-in.docbook:4257
msgid ""
"There are other things you can customize as well, including creating dashed "
"lines and other things. For more information, see the Cairo API "
"documentation."
msgstr ""
"你还可以自定义其他内容，比如创建虚线等。更多有关信息请参阅开罗API文档。"

#: C/index-in.docbook:4264
msgid "Drawing thin lines"
msgstr "画细线"

#: C/index-in.docbook:4265
msgid ""
"If you try to draw one pixel wide lines, you may notice that the line "
"sometimes comes up blurred and wider than it ought to be. This happens "
"because Cairo will try to draw from the selected position, to both sides "
"(half to each), so if you're positioned right on the intersection of the "
"pixels, and want a one pixel wide line, Cairo will try to use half of each "
"adjacent pixel, which isn't possible (a pixel is the smallest unit "
"possible). This happens when the width of the line is an odd number of "
"pixels (not just one pixel)."
msgstr ""
"如果你尝试画一条宽度为一个像素的线条，你可能会注意到这条线有时会变得模糊并且"
"比应有的宽度更宽。发生这种情况的原因是开若尝试在所选位置向两边绘制（一边一"
"半），因此如果你如果正好位于像素交点上，还想绘制一个像素宽度的线条，那是不可"
"能做到的（像素是最小的单位）。所以当像素的宽度是奇数的时候就会出现这种情况"
"（不只是一个像素的时候）。"

#: C/index-in.docbook:4275
msgid ""
"The trick is to position in the middle of the pixel where you want the line "
"to be drawn, and thus guaranteeing you get the desired results. See <ulink "
"url=\"http://cairographics.org/FAQ/#sharp_lines\">Cairo FAQ</ulink>."
msgstr ""
"解决问题的诀窍是将像素放于要绘制的线条的中间，从而确保获得所需的结果。请参阅"
"<ulink url=\"http://cairographics.org/FAQ/#sharp_lines\">开罗常见问题</"
"ulink>。"

#: C/index-in.docbook:4282
msgid "Drawing Area - Thin Lines"
msgstr "绘图区域 - 细线"

#: C/index-in.docbook:4288
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/thin_lines\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/thin_lines\">源代码</ulink>"

#: C/index-in.docbook:4293
msgid "Drawing Curved Lines"
msgstr "画曲线"

#: C/index-in.docbook:4294
msgid ""
"In addition to drawing straight lines Cairo allows you to easily draw curved "
"lines (technically a cubic Bézier spline) using the <methodname>Cairo::"
"Context::curve_to()</methodname> and <methodname>Cairo::Context::"
"rel_curve_to()</methodname> functions. These functions take coordinates for "
"a destination point as well as coordinates for two 'control' points. This is "
"best explained using an example, so let's dive in."
msgstr ""
"除了绘制直线以外，开罗还允许你用<methodname>Cairo::Context::curve_to()</"
"methodname>和<methodname>Cairo::Context::rel_curve_to()</methodname>函数轻松"
"的绘制曲线（从技术上而言是三次贝塞尔曲线）。这些函数需要一个目标点的坐标和两"
"个'控制'点的坐标。这最好用一个示例来解释，所以让我们开始吧。"

#: C/index-in.docbook:4305
msgid ""
"This simple application draws a curve with Cairo and displays the control "
"points for each end of the curve."
msgstr "这个简单的示例程序使用开罗绘制了一条曲线并显示了曲线两端的控制点。"

#: C/index-in.docbook:4316
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/curve\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/curve\">源代码</ulink>"

#: C/index-in.docbook:4317
msgid ""
"The only difference between this example and the straight line example is in "
"the <methodname>on_draw()</methodname> function, but there are a few new "
"concepts and functions introduced here, so let's examine them briefly."
msgstr ""
"这个示例与绘制直线示例的唯一区别在它们的<methodname>on_draw()</methodname>函"
"数，不过这里引入了一些新的概念和函数，所以让我们简要的介绍一下它们。"

#: C/index-in.docbook:4323
msgid ""
"We make a call to <methodname>Cairo::Context::scale()</methodname>, passing "
"in the width and height of the drawing area. This scales the user-space "
"coordinate system such that the width and height of the widget are both "
"equal to 1.0 'units'. There's no particular reason to scale the coordinate "
"system in this case, but sometimes it can make drawing operations easier."
msgstr ""
"我们调用<methodname>Cairo::Context::scale()</methodname>并传入绘图区域的宽和"
"高，这将使用户空间坐标系被缩放为\"1个单位\"（宽高的范围变成[0.0,1.0]）。在这"
"其实并没有什么特别的要对坐标系进行缩放的理由，只是为了使绘图操作有时候更易"
"用。"

#: C/index-in.docbook:4332
msgid ""
"The call to <methodname>Cairo::Context::curve_to()</methodname> should be "
"fairly self-explanatory. The first pair of coordinates define the control "
"point for the beginning of the curve. The second set of coordinates define "
"the control point for the end of the curve, and the last set of coordinates "
"define the destination point. To make the concept of control points a bit "
"easier to visualize, a line has been drawn from each control point to the "
"end-point on the curve that it is associated with. Note that these control "
"point lines are both translucent. This is achieved with a variant of "
"<methodname>set_source_rgb()</methodname> called "
"<methodname>set_source_rgba()</methodname>. This function takes a fourth "
"argument specifying the alpha value of the color (valid values are between 0 "
"and 1)."
msgstr ""
"对<methodname>Cairo::Context::curve_to()</methodname>的调用应该是不言自明的。"
"第一组坐标定义了曲线起点的控制点。第二组坐标定义了曲线终点的控制点，而最后一"
"组坐标定义了目标点。为了使控制点的概念更容易被看清，从每个控制点到与之关联的"
"曲线上的端点上都画了一条线。请注意，这些控制点线都是半透明的。这是通过调用"
"<methodname>set_source_rgb()</methodname>的变体函数"
"<methodname>set_source_rgba()</methodname>实现的。这个函数使用第四个参数来接"
"受指定颜色的alpha值（值的有效区间为0到1）。"

#: C/index-in.docbook:4350
msgid "Drawing Arcs and Circles"
msgstr "画圆弧和圆"

#: C/index-in.docbook:4351
msgid ""
"With Cairo, the same function is used to draw arcs, circles, or ellipses: "
"<methodname>Cairo::Context::arc()</methodname>. This function takes five "
"arguments. The first two are the coordinates of the center point of the arc, "
"the third argument is the radius of the arc, and the final two arguments "
"define the start and end angle of the arc. All angles are defined in "
"radians, so drawing a circle is the same as drawing an arc from 0 to 2 * "
"M_PI radians. An angle of 0 is in the direction of the positive X axis (in "
"user-space). An angle of M_PI/2 radians (90 degrees) is in the direction of "
"the positive Y axis (in user-space). Angles increase in the direction from "
"the positive X axis toward the positive Y axis. So with the default "
"transformation matrix, angles increase in a clockwise direction. (Remember "
"that the positive Y axis points downwards.)"
msgstr ""
"在开罗中，画圆弧、圆、椭圆使用的是同一个函数：<methodname>Cairo::Context::"
"arc()</methodname>。这个函数有五个参数。前两个参数是圆弧中心点的坐标，第三个"
"参数是圆弧的半径，最后两个参数是圆弧的起点和终点。所有的角度都使用弧度制，所"
"以画圆和画一个弧度为0到2*M_PI的圆弧是一样的。角度0沿着X轴的正方向（对于用户空"
"间而言）。角度M_PI/2（角度制的90°）沿着Y轴的正方向（对于用户空间而言）。角度"
"沿着X轴的正方向向Y轴的正方向逐渐增加。所以使用默认的变换矩阵的时候，角度沿着"
"顺时针方向增加（请记住Y轴的正方向指向下方）。"

#: C/index-in.docbook:4372
#, no-wrap
msgid ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"
msgstr ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"

#: C/index-in.docbook:4366
msgid ""
"To draw an ellipse, you can scale the current transformation matrix by "
"different amounts in the X and Y directions. For example, to draw an ellipse "
"with center at <varname>x</varname>, <varname>y</varname> and size "
"<varname>width</varname>, <varname>height</varname>: <_:programlisting-1/>"
msgstr ""
"想要绘制椭圆的话，你可以在X和Y方向用不同的量缩放当前的变换矩阵。例如，如果你"
"想要绘制一个以<varname>x</varname>，<varname>y</varname>为中心，大小为"
"<varname>width</varname>，<varname>height</varname>的椭圆： <_:"
"programlisting-1/>"

#: C/index-in.docbook:4380
msgid ""
"Here's an example of a simple program that draws an arc, a circle and an "
"ellipse into a drawing area."
msgstr "这是一个简单的示例程序，它在绘图区域绘制了一个圆弧、一个圆和一个椭圆。"

#: C/index-in.docbook:4385
msgid "Drawing Area - Arcs"
msgstr "绘图区域 - 圆弧"

#: C/index-in.docbook:4392
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/arcs\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/arcs\">源代码</ulink>"

#: C/index-in.docbook:4394
msgid ""
"There are a couple of things to note about this example code. Again, the "
"only real difference between this example and the previous ones is the "
"<methodname>on_draw()</methodname> function, so we'll limit our focus to "
"that function. In addition, the first part of the function is nearly "
"identical to the previous examples, so we'll skip that portion."
msgstr ""
"关于这个示例代码有几件事需要注意。首先这个示例与之前的示例的区别也只在"
"<methodname>on_draw()</methodname>函数中，因此我们重点接受这个函数。另外，函"
"数的第一部分与之前的也几乎一样，所以我们将会跳过该部分。"

#: C/index-in.docbook:4402
msgid ""
"Note that in this case, we've expressed nearly everything in terms of the "
"height and width of the window, including the width of the lines. Because of "
"this, when you resize the window, everything scales with the window. Also "
"note that there are three drawing sections in the function and each is "
"wrapped with a <methodname>save()</methodname>/<methodname>restore()</"
"methodname> pair so that we're back at a known state after each drawing."
msgstr ""
"请注意，在这个情况下我们几乎使用窗口的宽和高表示了包括线条宽度在内的所有的内"
"容（通过缩放用户坐标系）。所以当我们调整窗口大小的时候，所有的内容都会随着窗"
"口一同缩放。还请注意，函数中有三个进行绘图的部分都用一组<methodname>save()</"
"methodname>/<methodname>restore()</methodname>包裹，以便我们在每次绘完图都能"
"返回已知状态。"

#: C/index-in.docbook:4411
msgid ""
"The section for drawing an arc introduces one new function, "
"<methodname>close_path()</methodname>. This function will in effect draw a "
"straight line from the current point back to the first point in the path. "
"There is a significant difference between calling <methodname>close_path()</"
"methodname> and manually drawing a line back to the starting point, however. "
"If you use <methodname>close_path()</methodname>, the lines will be nicely "
"joined together. If you use <methodname>line_to()</methodname> instead, the "
"lines will end at the same point, but Cairo won't do any special joining."
msgstr ""
"在绘制圆弧的部分介绍了一个新的函数：<methodname>close_path()</methodname>。这"
"个函数的效果实际上就是在当前点和路径的第一个点之间画一条直线。但调用"
"<methodname>close_path()</methodname>所绘制的线条和使用"
"<methodname>line_to()</methodname>手工绘制一条回到起点的线条会有很大的不同。"
"如果你使用<methodname>close_path()</methodname>，则这些线将会很好的连接到一"
"起。如果你改用<methodname>line_to()</methodname>，那么这些线将在同一个点结束"
"但是开罗不会对此做任何特殊的连接。"

#: C/index-in.docbook:4424
msgid "Drawing counter-clockwise"
msgstr "逆时针绘图"

#: C/index-in.docbook:4425
msgid ""
"The function <methodname>Cairo::Context::arc_negative()</methodname> is "
"exactly the same as <methodname>Cairo::Context::arc()</methodname> but the "
"angles go the opposite direction."
msgstr ""
"函数<methodname>Cairo::Context::arc_negative()</methodname>的功能与"
"<methodname>Cairo::Context::arc()</methodname>函数完全一致，但是他们的绘制方"
"向是相反的。"

#: C/index-in.docbook:4437
msgid "Drawing Text"
msgstr "绘制文本"

#: C/index-in.docbook:4439
msgid "Drawing Text with Pango"
msgstr "使用Pango绘制文本"

#: C/index-in.docbook:4440
msgid ""
"Text is drawn via Pango Layouts. The easiest way to create a "
"<classname>Pango::Layout</classname> is to use <methodname>Gtk::Widget::"
"create_pango_layout()</methodname>. Once created, the layout can be "
"manipulated in various ways, including changing the text, font, etc. "
"Finally, the layout can be rendered using the <methodname>Pango::Layout::"
"show_in_cairo_context()</methodname> method."
msgstr ""
"通过Pango布局绘制文本。创建一个<classname>Pango::Layout</classname>最简单的方"
"法是使用<methodname>Gtk::Widget::create_pango_layout()</methodname>。创建布局"
"以后，可以通过各种方式操纵布局，包括更改文本、字体等。然后可以使用"
"<methodname>Pango::Layout::show_in_cairo_context()</methodname>方法渲染布局。"

#: C/index-in.docbook:4452
msgid ""
"Here is an example of a program that draws some text, some of it upside-"
"down. The Printing chapter contains another <link linkend=\"sec-printing-"
"example\">example</link> of drawing text."
msgstr ""
"这是一个绘制一些文本的示例程序，其中的一些文本上下颠倒。打印一章包含了另一个"
"绘制文本的<link linkend=\"sec-printing-example\">示例</link>。"

#: C/index-in.docbook:4458
msgid "Drawing Area - Text"
msgstr "绘图区域 - 文本"

#: C/index-in.docbook:4464
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/pango_text\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/pango_text\">源代码</ulink>"

#: C/index-in.docbook:4475
msgid "Drawing Images"
msgstr "绘制图片"

#: C/index-in.docbook:4476
msgid ""
"There is a method for drawing from a <classname>Gdk::Pixbuf</classname> to a "
"<classname>Cairo::Context</classname>. A <classname>Gdk::Pixbuf</classname> "
"buffer is a useful wrapper around a collection of pixels, which can be read "
"from files, and manipulated in various ways."
msgstr ""
"有一个方法可以将<classname>Gdk::Pixbuf</classname>绘制到<classname>Cairo::"
"Context</classname>。<classname>Gdk::Pixbuf</classname>缓冲区是对像素集合的有"
"效封装，它提供了从文件读取以及各种操纵像素的方式。"

#: C/index-in.docbook:4483
msgid ""
"Probably the most common way of creating <classname>Gdk::Pixbuf</classname>s "
"is to use <methodname>Gdk::Pixbuf::create_from_file()</methodname> or "
"<methodname>Gdk::Pixbuf::create_from_resource()</methodname>, which can read "
"an image file, such as a png file into a pixbuf ready for rendering."
msgstr ""
"最常见的<classname>Gdk::Pixbuf</classname>创建方法是用<methodname>Gdk::"
"Pixbuf::create_from_file()</methodname>或<methodname>Gdk::Pixbuf::"
"create_from_resource()</methodname>，它们可以将图像文件（例如png文件）读取到"
"pixbuf中用于渲染。"

#: C/index-in.docbook:4491
msgid ""
"The <classname>Gdk::Pixbuf</classname> can be rendered by setting it as the "
"source pattern of the Cairo context with <methodname>Gdk::Cairo::"
"set_source_pixbuf()</methodname>. Then draw the image with either "
"<methodname>Cairo::Context::paint()</methodname> (to draw the whole image), "
"or <methodname>Cairo::Context::rectangle()</methodname> and "
"<methodname>Cairo::Context::fill()</methodname> (to fill the specified "
"rectangle). <methodname>set_source_pixbuf()</methodname> is not a member of "
"<classname>Cairo::Context</classname>. It takes a <classname>Cairo::Context</"
"classname> as its first parameter."
msgstr ""
"通过使用<methodname>Gdk::Cairo::set_source_pixbuf()</methodname>将"
"<classname>Gdk::Pixbuf</classname>设置为开罗上下文的源模式使其可以被渲染。然"
"后使用<methodname>Cairo::Context::paint()</methodname>（画整个图像），或者使"
"用<methodname>Cairo::Context::rectangle()</methodname>和<methodname>Cairo::"
"Context::fill()</methodname>（用图像填充整个矩形）。"
"<methodname>set_source_pixbuf()</methodname>不是<classname>Cairo::Context</"
"classname>的成员函数。<classname>Cairo::Context</classname>是它的第一个参数。"

#: C/index-in.docbook:4502
msgid ""
"Here is a small bit of code to tie it all together: (Note that usually you "
"wouldn't load the image every time in the draw signal handler! It's just "
"shown here to keep it all together.)"
msgstr ""
"这是一小段将他们结合在一起的代码（请注意，通常你不应该在每次调用绘制信号处理"
"函数的时候都加载一次图片）："

#: C/index-in.docbook:4507
#, no-wrap
msgid ""
"void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)\n"
"{\n"
"  auto image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"  // Draw the image at 110, 90, except for the outermost 10 pixels.\n"
"  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);\n"
"  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);\n"
"  cr-&gt;fill();\n"
"}"
msgstr ""
"void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)\n"
"{\n"
"  auto image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"  // Draw the image at 110, 90, except for the outermost 10 pixels.\n"
"  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);\n"
"  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);\n"
"  cr-&gt;fill();\n"
"}"

#: C/index-in.docbook:4524
#, no-wrap
msgid "$ glib-compile-resources --target=resources.c --generate-source image.gresource.xml"
msgstr "$ glib-compile-resources --target=resources.c --generate-source image.gresource.xml"

#: C/index-in.docbook:4517
msgid ""
"Here is an example of a simple program that draws an image. The program "
"loads the image from a resource file. See the <link linkend=\"sec-gio-"
"resource\">Gio::Resource and glib-compile-resources</link> section. Use "
"<application>glib-compile-resources</application> to compile the resources "
"into a C source file that can be compiled and linked with the C++ code. E.g. "
"<_:screen-1/>"
msgstr ""
"这是一个绘制图像的简单示例程序。该程序从资源文件加载图像。请参阅<link "
"linkend=\"sec-gio-resource\">Gio::Resource和glib-compile-resources</link>小"
"节。使用<application>glib-compile-resources</application>将资源文件编译为C源"
"文件，然后将该源文件与C++代码一起编译链接。例如：<_:screen-1/>"

#: C/index-in.docbook:4527
msgid "Drawing Area - Image"
msgstr "绘图区域 - 图像"

#: C/index-in.docbook:4533
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/image\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/image\">源代码</ulink>"

#: C/index-in.docbook:4547
msgid "Example Application: Creating a Clock with Cairo"
msgstr "示例程序：使用开罗创建时钟"

#: C/index-in.docbook:4548
msgid ""
"Now that we've covered the basics of drawing with Cairo, let's try to put it "
"all together and create a simple application that actually does something. "
"The following example uses Cairo to create a custom <classname>Clock</"
"classname> widget. The clock has a second hand, a minute hand, and an hour "
"hand, and updates itself every second."
msgstr ""
"既然我们已经将使用开罗画图的基础知识介绍完了，那么现在让我们尝试将所有的内容"
"放在一起，创建一个可以执行某些操作的简单应用程序。以下示例使用开罗创建一个自"
"定义的<classname>Clock</classname>部件。这个时钟有秒针、分针、时针，并且每一"
"秒更新一次。"

#: C/index-in.docbook:4559
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/clock\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drawingarea/clock\">源代码</ulink>"

#: C/index-in.docbook:4560
msgid ""
"As before, almost all of the interesting stuff is done in the draw function "
"<methodname>on_draw()</methodname>. Before we dig into the draw function, "
"notice that the constructor for the <classname>Clock</classname> widget "
"connects a handler function <methodname>on_timeout()</methodname> to a timer "
"with a timeout period of 1000 milliseconds (1 second). This means that "
"<methodname>on_timeout()</methodname> will get called once per second. The "
"sole responsibility of this function is to invalidate the window so that "
"<application>gtkmm</application> will be forced to redraw it."
msgstr ""
"和之前一样，所有有趣的东西都在绘图函数<methodname>on_draw()</methodname>中完"
"成。在深入研究绘图函数之前，请注意在<classname>Clock</classname>部件的构造函"
"数中将处理函数<methodname>on_timeout()</methodname>连接到了用计时器上，该计时"
"器的超时时间为1000毫秒（1秒）。这意味着<methodname>on_timeout()</methodname>"
"将每秒被调用一次。这个函数的唯一任务就是使窗口无效，以便<application>gtkmm</"
"application>强制重绘它。"

#: C/index-in.docbook:4571
msgid ""
"Now let's take a look at the code that performs the actual drawing. The "
"first section of <methodname>on_draw()</methodname> should be pretty "
"familiar by now. This example again scales the coordinate system to be a "
"unit square so that it's easier to draw the clock as a percentage of window "
"size so that it will automatically scale when the window size is adjusted. "
"Furthermore, the coordinate system is scaled over and down so that the (0, "
"0) coordinate is in the very center of the window."
msgstr ""
"现在让我们研究实际执行绘图的函数。到现在<methodname>on_draw()</methodname>函"
"数的第一部分你应该很熟悉了。此示例再次将坐标系缩放为单位正方形，以便更轻松的"
"按窗口大小的百分比绘制时钟。此外坐标系是按比例缩放的，所以(0,0)坐标位于窗口的"
"正中央。"

#: C/index-in.docbook:4581
msgid ""
"The function <methodname>Cairo::Context::paint()</methodname> is used here "
"to set the background color of the window. This function takes no arguments "
"and fills the current surface (or the clipped portion of the surface) with "
"the source color currently active. After setting the background color of the "
"window, we draw a circle for the clock outline, fill it with white, and then "
"stroke the outline in black. Notice that both of these actions use the "
"<methodname>_preserve</methodname> variant to preserve the current path, and "
"then this same path is clipped to make sure that our next lines don't go "
"outside the outline of the clock."
msgstr ""
"<methodname>Cairo::Context::paint()</methodname>方法用于设置窗口的背景色。这"
"个函数不接受任何参数，并使用处于活跃状态的源颜色填充当前表面（或表面裁剪的一"
"部分）。设置背景色以后，我们画一个圆作为时钟的轮廓，用白色填充它然后用黑色进"
"行描边。请注意，这两个操作都用<methodname>_preserve</methodname>变体以保留当"
"前路径，然后对相同的路径进行剪辑以确保我们下一行不会超过时钟的轮廓。"

#: C/index-in.docbook:4593
msgid ""
"After drawing the outline, we go around the clock and draw ticks for every "
"hour, with a larger tick at 12, 3, 6, and 9. Now we're finally ready to "
"implement the time-keeping functionality of the clock, which simply involves "
"getting the current values for hours, minutes and seconds, and drawing the "
"hands at the correct angles."
msgstr ""
"绘制轮廓后，我们围绕时钟为每个小时绘制可读线并为12、3、6、9绘制相对更大的刻度"
"线。接着我们就可以实现时钟的计时功能了 -- 获取当前时间的时、分、秒然后以正确"
"的角度将指针绘制出来。"

#: C/index-in.docbook:4605
msgid ""
"<classname>Gtk::Widget</classname> has several methods and signals which are "
"prefixed with \"drag_\". These are used for Drag and Drop."
msgstr ""
"<classname>Gtk::Widget</classname>提供了几个带有\"drag_\"前缀的方法和信号用以"
"支持拖放。"

#: C/index-in.docbook:4610
msgid "Sources and Destinations"
msgstr "源与目的地"

#: C/index-in.docbook:4611
msgid ""
"Things are dragged from <literal>sources</literal> to be dropped on "
"<literal>destinations</literal>. Each source and destination has information "
"about the data formats that it can send or receive, provided by "
"<classname>Gdk::ContentFormats</classname>. A drop destination will only "
"accept a dragged item if they both share a compatible format. Appropriate "
"signals will then be emitted, telling the signal handlers which format was "
"used."
msgstr ""
"物件从<literal>sources</literal>被拖放到<literal>destinations</literal>。每个"
"源与目的地都拥有由<classname>Gdk::ContentFormats</classname>提供的它们所能发"
"送或接受的数据格式的相关信息。放置目的地只会在拖动项与其具有共同的兼容类型时"
"才会接受它们。然后将会发出适当的信号，告诉信号处理函数使用了那种格式。"

#: C/index-in.docbook:4619
msgid ""
"<classname>Gdk::ContentFormats</classname> objects contain information about "
"available <type>GType</type>s and mime types (media types)."
msgstr ""
"<classname>Gdk::ContentFormats</classname>对象包含了可用的<type>GType</type>"
"和MIME类型（媒体类型）的相关信息。"

#: C/index-in.docbook:4628
msgid ""
"<classname>Widget</classname>s can be identified as sources or destinations "
"using these <classname>Gtk::Widget</classname> methods:"
msgstr ""
"<classname>Gtk::Widget</classname>的以下方法可以将<classname>Widget</"
"classname>作为源或者目标："

#: C/index-in.docbook:4632
#, no-wrap
msgid ""
"void drag_source_set(const Glib::RefPtr&lt;Gdk::ContentFormats&gt;&amp; targets,\n"
"      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);"
msgstr ""
"void drag_source_set(const Glib::RefPtr&lt;Gdk::ContentFormats&gt;&amp; targets,\n"
"      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);"

#: C/index-in.docbook:4637
msgid ""
"<literal>targets</literal> is a <classname>Gdk::ContentFormats</classname> "
"object."
msgstr ""
"<literal>targets</literal>是一个<classname>Gdk::ContentFormats</classname>对"
"象。"

#: C/index-in.docbook:4642
msgid ""
"<literal>start_button_mask</literal> is an ORed combination of values, which "
"specify which modifier key or mouse button must be pressed to start the drag."
msgstr ""
"<literal>start_button_mask</literal>是一组值异或后的结果，用于指定按下哪个组"
"合键或鼠标按键才能开始拖动。"

#: C/index-in.docbook:4649
msgid ""
"<literal>actions</literal> is an ORed combination of values, which specify "
"which Drag and Drop operations will be possible from this source - for "
"instance, copy, move, or link. The user can choose between the actions by "
"using modifier keys, such as <keycap>Shift</keycap> to change from "
"<literal>copy</literal> to <literal>move</literal>, and this will be shown "
"by a different cursor."
msgstr ""
"<literal>actions</literal>是一组值异或后的结果，用于指定可以对该源进行的拖放"
"操作 - 例如复制、移动或链接。用户可以通过修饰键选择动作，比如通过按下"
"<keycap>Shift</keycap>键将动作从<literal>copy</literal>改变为<literal>move</"
"literal>，这还会使光标显示不同的样式。"

#: C/index-in.docbook:4660
#, no-wrap
msgid ""
"void drag_dest_set(const Glib::RefPtr&lt;Gdk::ContentFormats&gt;&amp; targets,\n"
"    Gtk::DestDefaults flags, Gdk::DragAction actions);"
msgstr ""
"void drag_dest_set(const Glib::RefPtr&lt;Gdk::ContentFormats&gt;&amp; targets,\n"
"    Gtk::DestDefaults flags, Gdk::DragAction actions);"

#: C/index-in.docbook:4665
msgid ""
"<literal>flags</literal> is an ORed combination of values which indicates "
"how the widget will respond visually to Drag and Drop items."
msgstr "是一组值异或后的结果，用于表示部件在视觉上如何响应拖放项。"

#: C/index-in.docbook:4671
msgid ""
"<literal>actions</literal> indicates the Drag and Drop actions which this "
"destination can receive - see the description above."
msgstr ""
"<literal>actions</literal>指示此目的地可以接受的拖放动作 - 请参阅上面的描述。"

#: C/index-in.docbook:4680
msgid "<methodname>drag_source_add_text_targets()</methodname>"
msgstr "<methodname>drag_source_add_text_targets()</methodname>"

#: C/index-in.docbook:4681
msgid "<methodname>drag_source_add_image_targets()</methodname>"
msgstr "<methodname>drag_source_add_image_targets()</methodname>"

#: C/index-in.docbook:4682
msgid "<methodname>drag_dest_add_text_targets()</methodname>"
msgstr "<methodname>drag_dest_add_text_targets()</methodname>"

#: C/index-in.docbook:4683
msgid "<methodname>drag_dest_add_image_targets()</methodname>"
msgstr "<methodname>drag_dest_add_image_targets()</methodname>"

#: C/index-in.docbook:4677
msgid ""
"There are several methods to add source formats and destination formats. "
"Examples: <_:itemizedlist-1/>"
msgstr "有些添加源格式和目的地格式的方法。例如：<_:itemizedlist-1/>"

#: C/index-in.docbook:4690
msgid ""
"When a drop destination has accepted a dragged item, certain signals will be "
"emitted, depending on what action has been selected. For instance, the user "
"might have held down the <keycap>Shift</keycap> key to specify a "
"<literal>move</literal> rather than a <literal>copy</literal>. Remember that "
"the user can only select the actions which you have specified in your calls "
"to <methodname>drag_dest_set()</methodname> and "
"<methodname>drag_source_set()</methodname>."
msgstr ""
"当一个放置目的地接受了拖动项，根据被选择的动作，将发出响应的信号。例如，用户"
"可能按住<keycap>Shift</keycap>键指定进行<literal>move</literal>而不是"
"<literal>copy</literal>。请注意，用户只能选择你在调用"
"<methodname>drag_dest_set()</methodname>和<methodname>drag_source_set()</"
"methodname>时所指定的动作。"

#: C/index-in.docbook:4701 C/index-in.docbook:4822
msgid "Copy"
msgstr "复制"

#: C/index-in.docbook:4705
msgid ""
"<literal>drag_begin</literal>: Provides a <classname>Gdk::Drag</classname>."
msgstr ""
"<literal>drag_begin</literal>：提供一个<classname>Gdk::Drag</classname>。"

#: C/index-in.docbook:4706
msgid ""
"<literal>drag_data_get</literal>: Provides a <classname>Gdk::Drag</"
"classname>, and a <classname>Gtk::SelectionData</classname> object, in which "
"you should put the requested data."
msgstr ""
"<literal>drag_data_get</literal>：提供一个<classname>Gdk::Drag</classname>和"
"一个<classname>Gtk::SelectionData</classname>对象，你应该在其中放入所请求的数"
"据。"

#: C/index-in.docbook:4708
msgid ""
"<literal>drag_end</literal>: Provides a <classname>Gdk::Drag</classname>."
msgstr ""
"<literal>drag_end</literal>：提供一个<classname>Gdk::Drag</classname>。"

#: C/index-in.docbook:4702
msgid ""
"The source widget will emit these signals, in this order: <_:itemizedlist-1/>"
msgstr "源部件将按以下顺序发出这些信号：<_:itemizedlist-1/>"

#: C/index-in.docbook:4714
msgid ""
"<literal>drag_motion</literal>: Provides a <classname>Gdk::Drop</classname> "
"and coordinates. You can call the <methodname>status()</methodname> method "
"of the <classname>Gdk::Drop</classname> to indicate which action will be "
"accepted."
msgstr ""
"<literal>drag_motion</literal>：提供一个<classname>Gdk::Drop</classname>以及"
"坐标。你可以调用<classname>Gdk::Drop</classname>的<methodname>status()</"
"methodname>方法来指示要接受的动作。"

#: C/index-in.docbook:4717
msgid ""
"<literal>drag_drop</literal>: Provides a <classname>Gdk::Drop</classname> "
"and coordinates. You can call <methodname>drag_get_data()</methodname>, "
"which triggers the <literal>drag_data_get</literal> signal in the source "
"widget, and then the <literal>drag_data_received</literal> signal in the "
"destination widget."
msgstr ""
"<literal>drag_drop</literal>：提供一个<classname>Gdk::Drop</classname>以及坐"
"标。你可以调用<methodname>drag_get_data()</methodname>，这将触发源部件的"
"<literal>drag_data_get</literal>信号，并在之后触发目的地部件的"
"<literal>drag_data_received</literal>信号。"

#: C/index-in.docbook:4722
msgid ""
"<literal>drag_data_received</literal>: Provides a <classname>Gdk::Drop</"
"classname>, and a <methodname>Gtk::SelectionData</methodname> object which "
"contains the dropped data. You should call the <methodname>finish()</"
"methodname> or <methodname>failed()</methodname> method of the "
"<classname>Gdk::Drop</classname> to indicate whether the operation was "
"successful."
msgstr ""
"<literal>drag_data_received</literal>：提供一个<classname>Gdk::Drop</"
"classname>和一个包含要放置的数据的<methodname>Gtk::SelectionData</methodname>"
"对象。你应该调用<classname>Gdk::Drop</classname>的<methodname>finish()</"
"methodname>或<methodname>failed()</methodname>方法来指示操作是否成功。"

#: C/index-in.docbook:4711
msgid ""
"The destination widget will emit these signals, in this order: <_:"
"itemizedlist-1/>"
msgstr "目的地部件将按以下顺序发出这些信号：<_:itemizedlist-1/>"

#: C/index-in.docbook:4736
msgid "Move"
msgstr "移动"

#: C/index-in.docbook:4739
msgid ""
"<literal>drag_data_delete</literal>: Gives the source the opportunity to "
"delete the original data if that's appropriate."
msgstr "<literal>drag_data_delete</literal>：给源删除原始数据的合适时机。"

#: C/index-in.docbook:4737
msgid ""
"During a <literal>move</literal>, the source widget will also emit this "
"signal: <_:itemizedlist-1/>"
msgstr ""
"在<literal>move</literal>的过程中，源部件还将会发出以下信号：<_:"
"itemizedlist-1/>"

#: C/index-in.docbook:4754
msgid ""
"Here is a very simple example, demonstrating a drag and drop <literal>Copy</"
"literal> operation:"
msgstr "这是一个非常简单的示例，演示了拖放的<literal>Copy</literal>操作："

#: C/index-in.docbook:4763
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drag_and_drop\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/drag_and_drop\">源代码</ulink>"

#: C/index-in.docbook:4765
msgid "There is a more complex example in examples/others/dnd."
msgstr "在examples/others/dnd中有一个更复杂的示例。"

#: C/index-in.docbook:4774
msgid "The Clipboard"
msgstr "剪切板(Clipboard)"

#: C/index-in.docbook:4775
msgid ""
"Simple text copy-paste functionality is provided for free by widgets such as "
"<classname>Gtk::Entry</classname> and <classname>Gtk::TextView</classname>, "
"but you might need special code to deal with your own data formats. For "
"instance, a drawing program would need special code to allow copy and paste "
"within a view, or between documents."
msgstr ""
"<classname>Gtk::Entry</classname>和<classname>Gtk::TextView</classname>之类的"
"部件提供了简单的文本复制粘贴功能，但如果你有自己的数据格式需要处理则需要为此"
"编写特定的代码。例如，绘图程序需要编写特定的代码以支持在视图内或文档之间进行"
"复制粘贴。"

#: C/index-in.docbook:4781
msgid ""
"You can get a clipboard instance with <methodname>Gtk::Widget::"
"get_clipboard()</methodname> or <methodname>Gdk::Display::get_clipboard()</"
"methodname>."
msgstr ""
"你可以使用<methodname>Gtk::Widget::get_clipboard()</methodname>或"
"<methodname>Gdk::Display::get_clipboard()</methodname>获取剪切板实例。"

#: C/index-in.docbook:4786
msgid ""
"Your application doesn't need to wait for clipboard operations, particularly "
"between the time when the user chooses Copy and then later chooses Paste. "
"Many <classname>Gdk::Clipboard</classname> methods take <classname>sigc::"
"slot</classname>s which specify callback methods. When <classname>Gdk::"
"Clipboard</classname> is ready, it will call these methods, providing the "
"requested data."
msgstr ""
"你的应用程序不需要等待剪切板操作，特别是用户选择复制然后选择粘贴的期间。"
"<classname>Gdk::Clipboard</classname>的多数方法使用<classname>sigc::slot</"
"classname>，它们指定了回调函数。当<classname>Gdk::Clipboard</classname>准备就"
"绪时，它将会调用这些回调函数，并向其提供所请求的数据。"

#: C/index-in.docbook:4794
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGdk_1_1Clipboard."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGdk_1_1Clipboard."
"html\">参考</ulink>"

#: C/index-in.docbook:4797
msgid "Formats"
msgstr "格式"

#: C/index-in.docbook:4798
msgid ""
"Different applications contain different types of data, and they might make "
"that data available in a variety of formats. <application>gtkmm</"
"application> calls these data types <literal>format</literal>s."
msgstr ""
"不同的应用程序包含不同类型的数据，并且它们可能使用多种可用格式提供数据。"
"<application>gtkmm</application>称这些数据类型为<literal>format</literal>。"

#: C/index-in.docbook:4802
msgid ""
"For instance, <application>gedit</application> can supply and receive the "
"<literal>text/plain</literal> mime type, so you can paste data into "
"<application>gedit</application> from any application that supplies that "
"format. Or two different image editing applications might supply and receive "
"a variety of image formats. As long as one application can receive one of "
"the formats that the other supplies then you will be able to copy data from "
"one to the other."
msgstr ""
"例如，<application>gedit</application>可以提供和接收<literal>text/plain</"
"literal>MIME类型，所以你可以从任何提供该格式的应用程序中将复制粘贴给"
"<application>gedit</application>。或者两个不同的图像编辑程序可能会提供和接收"
"各种图像格式。只要其中一个应用程序可以接收其他应用程序提供的一种格式，那么你"
"就可以将数据从一个复制到另一个。"

#: C/index-in.docbook:4810
msgid ""
"Clipboard data can be in a variety of binary formats. This chapter, and the "
"examples, assume that the data is 8-bit text. This would allow us to use an "
"XML format for the clipboard data. However this would probably not be "
"appropriate for binary data such as images."
msgstr ""
"剪切板数据可以使用多种二进制格式。本章和示例程序假定数据是8位文本。这将使我们"
"可以对剪切板数据使用XML格式。但这可能不适合二进制数据（例如图像）。"

#: C/index-in.docbook:4817
msgid ""
"The <link linkend=\"chapter-draganddrop\">Drag and Drop</link> API uses the "
"same mechanism. You should probably use the same data formats for both "
"Clipboard and Drag and Drop operations."
msgstr ""
"<link linkend=\"chapter-draganddrop\">拖放</link>API使用一样的机制。剪切板和"
"拖放操作都应该使用一样的数据格式。"

#: C/index-in.docbook:4823
msgid ""
"When the user asks to copy some data, you should copy the data to the "
"<classname>Clipboard</classname>. For instance,"
msgstr ""
"当用户要复制某些数据的时候，你应该将数据复制到<classname>Clipboard</"
"classname>。例如："

#: C/index-in.docbook:4827
#, no-wrap
msgid ""
"void ExampleWindow::on_button_copy()\n"
"{\n"
"  get_clipboard()-&gt;set_text(\"example_custom_target\");\n"
"}"
msgstr ""
"void ExampleWindow::on_button_copy()\n"
"{\n"
"  get_clipboard()-&gt;set_text(\"example_custom_target\");\n"
"}"

#: C/index-in.docbook:4835
msgid "Paste"
msgstr "粘贴"

#: C/index-in.docbook:4836
msgid ""
"When the user asks to paste data from the <classname>Clipboard</classname>, "
"you should request a specific format and provide a callback method which "
"will be called with the actual data. For instance:"
msgstr ""
"当用户要从<classname>Clipboard</classname>中粘贴数据时，你应该请求一种特定的"
"格式并提供一个回调函数，该回调函数将与实际数据一并被调用。例如："

#: C/index-in.docbook:4841
#, no-wrap
msgid ""
"void ExampleWindow::on_button_paste()\n"
"{\n"
"  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,\n"
"              &amp;ExampleWindow::on_clipboard_received));\n"
"}"
msgstr ""
"void ExampleWindow::on_button_paste()\n"
"{\n"
"  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,\n"
"              &amp;ExampleWindow::on_clipboard_received));\n"
"}"

#: C/index-in.docbook:4847
msgid "Here is an example callback method:"
msgstr "这是一个回调函数的示例："

#: C/index-in.docbook:4849
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)\n"
"{\n"
"  auto text = get_clipboard()-&gt;read_text_finish(result);\n"
"  //Do something with the pasted data.\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)\n"
"{\n"
"  auto text = get_clipboard()-&gt;read_text_finish(result);\n"
"  //Do something with the pasted data.\n"
"}"

#: C/index-in.docbook:4856
msgid "Discovering the available formats"
msgstr "发现可用格式"

#: C/index-in.docbook:4857
msgid ""
"To find out what formats are currently available on the "
"<classname>Clipboard</classname> for pasting, call the "
"<methodname>get_formats()</methodname> method. Then call a <classname>Gdk::"
"ContentFormats</classname> method to find out if a format that your "
"application supports is available."
msgstr ""
"要找出当前<classname>Clipboard</classname>可以用于粘贴的格式，请调用"
"<methodname>get_formats()</methodname>方法。然后调用<classname>Gdk::"
"ContentFormats</classname>方法来确定你的应用程序所支持的格式是否可用。"

#: C/index-in.docbook:4869 C/index-in.docbook:5260
msgid "Simple"
msgstr "简单"

#: C/index-in.docbook:4870
msgid ""
"This example allows copy and pasting of application-specific data, using the "
"standard text format. Although this is simple, it's not ideal because it "
"does not identify the <classname>Clipboard</classname> data as being of a "
"particular type."
msgstr ""
"这个示例允许使用标准文本格式复制粘贴应用程序指定的数据。尽管着很简单，但是它"
"并不够理想，因为他不能将<classname>Clipboard</classname>的数据标识为特定的类"
"型。"

#: C/index-in.docbook:4878
msgid "Clipboard - Simple"
msgstr "剪切板 - 简单"

#: C/index-in.docbook:4884
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/clipboard/simple/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/clipboard/simple/\">源代码</ulink>"

#: C/index-in.docbook:4888
msgid "Ideal"
msgstr "理想"

#: C/index-in.docbook:4891
msgid "Defines a custom clipboard target, though the format is still text."
msgstr "定义了一个自定义剪切板目标，尽管格式依旧是文本。"

#: C/index-in.docbook:4892
msgid ""
"It uses the <methodname>Gdk::ContentFormats::signal_changed()</methodname> "
"signal and disables the Paste button if it can't use anything on the "
"clipboard."
msgstr ""
"它使用<methodname>Gdk::ContentFormats::signal_changed()</methodname>信号并在"
"剪切板不可用的时候禁用粘贴按钮。"

#: C/index-in.docbook:4889
msgid "This is like the simple example, but it <_:orderedlist-1/>"
msgstr "这个与简单示例类型，但是它<_:orderedlist-1/>"

#: C/index-in.docbook:4898
msgid "Clipboard - Ideal"
msgstr "剪切板 - 理想"

#: C/index-in.docbook:4904
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/clipboard/ideal/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/clipboard/ideal/\">源代码</ulink>"

#: C/index-in.docbook:4914
msgid "Printing"
msgstr "打印"

#: C/index-in.docbook:4916
msgid ""
"At the application development level, <application>gtkmm</application>'s "
"printing API provides dialogs that are consistent across applications and "
"allows use of Cairo's common drawing API, with Pango-driven text rendering. "
"In the implementation of this common API, platform-specific backends and "
"printer-specific drivers are used."
msgstr ""
"在应用程序级开发，<application>gtkmm</application>的打印API提供了跨应用程序兼"
"容的对话框，并允许使用开罗通用绘制API和Pango驱动的文本渲染。在此通用API实现"
"中，使用了特定平台的后端和特定打印机的驱动。"

#: C/index-in.docbook:4922
msgid "PrintOperation"
msgstr "打印操作"

#: C/index-in.docbook:4924
msgid ""
"The primary object is <classname>Gtk::PrintOperation</classname>, allocated "
"for each print operation. To handle page drawing connect to its signals, or "
"inherit from it and override the default virtual signal handlers. "
"<classname>PrintOperation</classname> automatically handles all the settings "
"affecting the print loop."
msgstr ""
"主要对象是分配给每个打印操作的<classname>Gtk::PrintOperation</classname>。要"
"处理绘制页请连接到它的信号，或从其继承并覆盖默认的虚信号处理函数。"
"<classname>PrintOperation</classname>将自动处理所有影响打印循环的设置。"

#: C/index-in.docbook:4941
msgid ""
"<literal>begin_print</literal>: You must handle this signal, because this is "
"where you create and set up a <classname>Pango::Layout</classname> using the "
"provided <classname>Gtk::PrintContext</classname>, and break up your "
"printing output into pages."
msgstr ""
"<literal>begin_print</literal>：你必须处理该信号，因为这是你使用提供的"
"<classname>Gtk::PrintContext</classname>创建和设置<classname>Pango::Layout</"
"classname>的地方，以及对你的打印输出进行分页的地方。"

#: C/index-in.docbook:4951
msgid ""
"<literal>paginate</literal>: Pagination is potentially slow so if you need "
"to monitor it you can call the <methodname>PrintOperation::"
"set_show_progress()</methodname> method and handle this signal."
msgstr ""
"<literal>paginate</literal>：分页可能很慢，所以如果需要监视它，你可以调用"
"<methodname>PrintOperation::set_show_progress()</methodname>方法并处理此信"
"号。"

#: C/index-in.docbook:4965
msgid ""
"<literal>request_page_setup</literal>: Provides a <classname>PrintContext</"
"classname>, page number and <classname>Gtk::PageSetup</classname>. Handle "
"this signal if you need to modify page setup on a per-page basis."
msgstr ""
"<literal>request_page_setup</literal>：提供一个<classname>PrintContext</"
"classname>、页码和<classname>Gtk::PageSetup</classname>。如果你需要逐页的修改"
"页面设置，请处理此信号。"

#: C/index-in.docbook:4974
msgid ""
"<literal>draw_page</literal>: You must handle this signal, which provides a "
"<classname>PrintContext</classname> and a page number. The "
"<classname>PrintContext</classname> should be used to create a "
"<classname>Cairo::Context</classname> into which the provided page should be "
"drawn. To render text, iterate over the <classname>Pango::Layout</classname> "
"you created in the <literal>begin_print</literal> handler."
msgstr ""
"<literal>draw_page</literal>：你必须处理此信号，该信号提供一个"
"<classname>PrintContext</classname>和页码。你应该使用"
"<classname>PrintContext</classname>创建一个<classname>Cairo::Context</"
"classname>，并将提供的页面绘制到其中。要渲染文本，请遍历你在"
"<literal>begin_print</literal>处理程序中创建的<classname>Pango::Layout</"
"classname>。"

#: C/index-in.docbook:4960
msgid ""
"For each page that needs to be rendered, the following signals are emitted: "
"<_:itemizedlist-1/>"
msgstr "对于每个要渲染的页面，都会发出以下信号：<_:itemizedlist-1/>"

#: C/index-in.docbook:4989
msgid ""
"<literal>end_print</literal>: A handler for it is a safe place to free any "
"resources related to a <classname>PrintOperation</classname>. If you have "
"your custom class that inherits from <classname>PrintOperation</classname>, "
"it is naturally simpler to do it in the destructor."
msgstr ""
"<literal>end_print</literal>：它的处理程序是用于释放与"
"<classname>PrintOperation</classname>相关的所有资源的安全场所。如果你通过继承"
"<classname>PrintOperation</classname>创建了自定义类，则直接在自定义类的析构函"
"数中进行此操作会更简单。"

#: C/index-in.docbook:4999
msgid ""
"<literal>done</literal>: This signal is emitted when printing is finished, "
"meaning when the print data is spooled. Note that the provided <literal>Gtk::"
"PrintOperationResult</literal> may indicate that an error occurred. In any "
"case you probably want to notify the user about the final status."
msgstr ""
"<literal>done</literal>：该信号于打印完成时（当打印数据假脱机）被发出。请注"
"意，所提供的<literal>Gtk::PrintOperationResult</literal>可能表明发生了错误。"
"无论如何你都应该让用户知道最终的状态。"

#: C/index-in.docbook:5009
msgid ""
"<literal>status_changed</literal>: Emitted whenever a print job's status "
"changes, until it is finished. Call the <methodname>PrintOperation::"
"set_track_print_status()</methodname> method to monitor the job status after "
"spooling. To see the status, use <methodname>get_status()</methodname> or "
"<methodname>get_status_string()</methodname>."
msgstr ""
"<literal>status_changed</literal>: 直到打印作业完成，只要打印作业状态发生了更"
"改就会发出此信号。假脱机后可以调用<methodname>PrintOperation::"
"set_track_print_status()</methodname>监视作业状态。要查看状态请调用"
"<methodname>get_status()</methodname>或<methodname>get_status_string()</"
"methodname>。"

#: C/index-in.docbook:4935
msgid ""
"The <methodname>PrintOperation::run()</methodname> method starts the print "
"loop, during which various signals are emitted: <_:itemizedlist-1/>"
msgstr ""
"<methodname>PrintOperation::run()</methodname>方法启动打印循环，在此期间会发"
"出以下信号：<_:itemizedlist-1/>"

#: C/index-in.docbook:5022
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1PrintOperation.html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1PrintOperation.html\">参考</ulink>"

#: C/index-in.docbook:5031
msgid "Page setup"
msgstr "页面设置"

#: C/index-in.docbook:5033
msgid ""
"The <classname>PrintOperation</classname> class has a method called "
"<methodname>set_default_page_setup()</methodname> which selects the default "
"paper size, orientation and margins. To show a page setup dialog from your "
"application, use the <methodname>Gtk::run_page_setup_dialog()</methodname> "
"method, which returns a <classname>Gtk::PageSetup</classname> object with "
"the chosen settings. Use this object to update a <classname>PrintOperation</"
"classname> and to access the selected <classname>Gtk::PaperSize</classname>, "
"<literal>Gtk::PageOrientation</literal> and printer-specific margins."
msgstr ""
"<classname>PrintOperation</classname>类有一个叫做"
"<methodname>set_default_page_setup()</methodname>的方法，其用于选择默认的纸张"
"尺寸、方向和页边距。要在你的应用程序中显示页面设置对话框，请使用"
"<methodname>Gtk::run_page_setup_dialog()</methodname>方法，该方法返回一个"
"<classname>Gtk::PageSetup</classname>对象，这个对象保存了所选的设置。使用这个"
"对象更新<classname>PrintOperation</classname>并访问所选的<classname>Gtk::"
"PaperSize</classname>、<literal>Gtk::PageOrientation</literal>和特定打印机的"
"边距。"

#: C/index-in.docbook:5043
msgid ""
"You should save the chosen <classname>Gtk::PageSetup</classname> so you can "
"use it again if the page setup dialog is shown again."
msgstr ""
"你应该保存所选的<classname>Gtk::PageSetup</classname>以便在下次打开页面设置对"
"话框的时候使用。"

#: C/index-in.docbook:5047
#, no-wrap
msgid ""
"\n"
"//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...\n"
"auto new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"
msgstr ""
"\n"
"//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...\n"
"auto new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"

#: C/index-in.docbook:5046 C/index-in.docbook:5111 C/index-in.docbook:10636
msgid "For instance, <_:programlisting-1/>"
msgstr "例如：<_:programlisting-1/>"

#: C/index-in.docbook:5054
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PageSetup."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1PageSetup."
"html\">参考</ulink>"

#: C/index-in.docbook:5058
msgid ""
"The Cairo coordinate system, in the <literal>draw_page</literal> handler, is "
"automatically rotated to the current page orientation. It is normally within "
"the printer margins, but you can change that via the "
"<methodname>PrintOperation::set_use_full_page()</methodname> method. The "
"default measurement unit is device pixels. To select other units, use the "
"<methodname>PrintOperation::set_unit()</methodname> method."
msgstr ""
"在<literal>draw_page</literal>处理程序中，开罗坐标系会自动旋转到当前页的方"
"向。它通常在打印机的页边距之内，不过你可以使用<methodname>PrintOperation::"
"set_use_full_page()</methodname>方法来更改它。默认的度量单位是设备像素。要选"
"择其他单位请使用<methodname>PrintOperation::set_unit()</methodname>方法。"

#: C/index-in.docbook:5070
msgid "Rendering text"
msgstr "渲染文本"

#: C/index-in.docbook:5072
msgid ""
"Text rendering is done using Pango. The <classname>Pango::Layout</classname> "
"object for printing should be created by calling the "
"<methodname>PrintContext::create_pango_layout()</methodname> method. The "
"<classname>PrintContext</classname> object also provides the page metrics, "
"via <methodname>get_width()</methodname> and <methodname>get_height()</"
"methodname>. The number of pages can be set with <methodname>PrintOperation::"
"set_n_pages()</methodname>. To actually render the Pango text in "
"<literal>on_draw_page</literal>, get a <classname>Cairo::Context</classname> "
"with <methodname>PrintContext::get_cairo_context()</methodname> and show the "
"<classname>Pango::LayoutLine</classname>s that appear within the requested "
"page number."
msgstr ""
"文本渲染是使用Pango完成的。<classname>Pango::Layout</classname>对象应通过调用"
"<methodname>PrintContext::create_pango_layout()</methodname>方法来创建。"
"<classname>PrintContext</classname>对象还通过<methodname>get_width()</"
"methodname>和<methodname>get_height()</methodname>方法提供了页面范围。页数可"
"以通过调用<methodname>PrintOperation::set_n_pages()</methodname>进行设置。要"
"在<literal>on_draw_page</literal>中渲染文本，请使用<methodname>PrintContext::"
"get_cairo_context()</methodname>获取<classname>Cairo::Context</classname>并显"
"示在请求的页码中出现的<classname>Pango::LayoutLine</classname>。"

#: C/index-in.docbook:5087
msgid ""
"See <link linkend=\"sec-printing-example-simple\">an example</link> of "
"exactly how this can be done."
msgstr ""
"请看<link linkend=\"sec-printing-example-simple\">具体示例</link>如何做到这"
"点。"

#: C/index-in.docbook:5095
msgid "Asynchronous operations"
msgstr "异步操作"

#: C/index-in.docbook:5097
msgid ""
"By default, <methodname>PrintOperation::run()</methodname> returns when a "
"print operation is completed. If you need to run a non-blocking print "
"operation, call <methodname>PrintOperation::set_allow_async()</methodname>. "
"Note that <methodname>set_allow_async()</methodname> is not supported on all "
"platforms, however the <literal>done</literal> signal will still be emitted."
msgstr ""
"在默认情况下，<methodname>PrintOperation::run()</methodname>在打印操作完成时"
"返回。如果你需要运行非阻塞的打印操作，请调用<methodname>PrintOperation::"
"set_allow_async()</methodname>。请注意，并非所有平台都支持"
"<methodname>set_allow_async()</methodname>，但<literal>done</literal>信号仍然"
"会被发出。"

#: C/index-in.docbook:5104
msgid ""
"<methodname>run()</methodname> may return "
"<literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>. To track status and "
"handle the result or error you need to implement signal handlers for the "
"<literal>done</literal> and <literal>status_changed</literal> signals:"
msgstr ""
"<methodname>run()</methodname>可能会返回"
"<literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>。要跟踪状态并处理结果或"
"错误，你需要实现<literal>done</literal>和<literal>status_changed</literal>信"
"号的信号处理函数。"

#: C/index-in.docbook:5112
#, no-wrap
msgid ""
"\n"
"// in class ExampleWindow's method...\n"
"auto op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// run the op\n"
msgstr ""
"\n"
"// in class ExampleWindow's method...\n"
"auto op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// run the op\n"

#: C/index-in.docbook:5122
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    //notify user\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    //Update PrintSettings with the ones used in this PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"
msgstr ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    //notify user\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    //Update PrintSettings with the ones used in this PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"

#: C/index-in.docbook:5121
msgid ""
"Second, check for an error and connect to the <literal>status_changed</"
"literal> signal. For instance: <_:programlisting-1/>"
msgstr ""
"然后，检查错误并连接到<literal>status_changed</literal>信号，例如：<_:"
"programlisting-1/>"

#: C/index-in.docbook:5137
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    //the print job is finished\n"
"  else\n"
"    //get the status with get_status() or get_status_string()\n"
"\n"
"  //update UI\n"
"}\n"
msgstr ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    //the print job is finished\n"
"  else\n"
"    //get the status with get_status() or get_status_string()\n"
"\n"
"  //update UI\n"
"}\n"

#: C/index-in.docbook:5136
msgid "Finally, check the status. For instance, <_:programlisting-1/>"
msgstr "最后检查状态。例如：<_:programlisting-1/>"

#: C/index-in.docbook:5153
msgid "Export to PDF"
msgstr "导出为PDF"

#: C/index-in.docbook:5157
#, no-wrap
msgid ""
"\n"
"auto op = Gtk::PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"auto res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"
msgstr ""
"\n"
"auto op = Gtk::PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"auto res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"

#: C/index-in.docbook:5154
msgid ""
"The 'Print to file' option is available in the print dialog, without the "
"need for extra implementation. However, it is sometimes useful to generate a "
"pdf file directly from code. For instance, <_:programlisting-1/>"
msgstr ""
"\"打印到文件\"选项在打印对话框可用，不需要额外实现。但是有时候从代码直接生成"
"PDF文件会很有用。例如：<_:programlisting-1/>"

#: C/index-in.docbook:5169
msgid "Extending the print dialog"
msgstr "扩展打印对话框"

#: C/index-in.docbook:5176
msgid ""
"Set the title of the tab via <methodname>PrintOperation::"
"set_custom_tab_label()</methodname>, create a new widget and return it from "
"the <literal>create_custom_widget</literal> signal handler. You'll probably "
"want this to be a container widget, packed with some others."
msgstr ""
"通过<methodname>PrintOperation::set_custom_tab_label()</methodname>设置标签的"
"标题，创建一个新的部件然后从<literal>create_custom_widget</literal>的信号处理"
"函数中返回它。你可能希望它是一个容器部件，在其中包含一些其他部件。"

#: C/index-in.docbook:5186
msgid ""
"Get the data from the widgets in the <literal>custom_widget_apply</literal> "
"signal handler."
msgstr ""
"从部件的<literal>custom_widget_apply</literal>的信号处理函数中获取数据。"

#: C/index-in.docbook:5171
msgid "You may add a custom tab to the print dialog: <_:itemizedlist-1/>"
msgstr "你可以在打印对话框中添加自定义标签： <_:itemizedlist-1/>"

#: C/index-in.docbook:5201
#, no-wrap
msgid ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  auto hbox = new Gtk::Box(Gtk::Orientation::HORIZONTAL, 8);\n"
"  hbox-&gt;set_margin(6);\n"
"\n"
"  auto label = Gtk::make_managed&lt;Gtk::Label&gt;(\"Enter some text: \");\n"
"  hbox-&gt;append(*label);\n"
"\n"
"  hbox-&gt;append(m_Entry);\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  auto user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"
msgstr ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  auto hbox = new Gtk::Box(Gtk::Orientation::HORIZONTAL, 8);\n"
"  hbox-&gt;set_margin(6);\n"
"\n"
"  auto label = Gtk::make_managed&lt;Gtk::Label&gt;(\"Enter some text: \");\n"
"  hbox-&gt;append(*label);\n"
"\n"
"  hbox-&gt;append(m_Entry);\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  auto user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"

#: C/index-in.docbook:5194
msgid ""
"Although the <literal>custom_widget_apply</literal> signal provides the "
"widget you previously created, to simplify things you can keep the widgets "
"you expect to contain some user input as class members. For example, let's "
"say you have a <classname>Gtk::Entry</classname> called <literal>m_Entry</"
"literal> as a member of your <classname>CustomPrintOperation</classname> "
"class: <_:programlisting-1/>"
msgstr ""
"尽管<literal>custom_widget_apply</literal>信号提供了你之前创建的部件，但是为"
"了简化操作，你可以保存一些用户输入作为部件类的成员。例如，你可能希望你有一个"
"叫做<literal>m_Entry</literal>的<classname>Gtk::Entry</classname>拥有"
"<classname>CustomPrintOperation</classname>作为类成员：<_:programlisting-1/>"

#: C/index-in.docbook:5226
msgid "The example in examples/book/printing/advanced demonstrates this."
msgstr "examples/book/printing/advanced示例对此进行了演示。"

#: C/index-in.docbook:5233
msgid "Preview"
msgstr "预览"

#: C/index-in.docbook:5239
#, no-wrap
msgid ""
"\n"
"// in a class that inherits from Gtk::Window...\n"
"auto op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"
msgstr ""
"\n"
"// in a class that inherits from Gtk::Window...\n"
"auto op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"

#: C/index-in.docbook:5235
msgid ""
"The native GTK print dialog has a preview button, but you may also start a "
"preview directly from an application: <_:programlisting-1/>"
msgstr ""
"原生的GTK打印对话框有一个预览按钮，但是你也可以自己从应用程序开始预览：<_:"
"programlisting-1/>"

#: C/index-in.docbook:5247
msgid ""
"On Unix, the default preview handler uses an external viewer program. On "
"Windows, the native preview dialog will be shown. If necessary you may "
"override this behaviour and provide a custom preview dialog. See the example "
"located in /examples/book/printing/advanced."
msgstr ""
"在Unix上，默认的预览处理程序将使用外部查看器程序。在Windows上将显示原生预览对"
"话框。如果有必要，你可以覆盖此默认行为并为此提供一个自定义的预览对话框。请参"
"阅位于/examples/book/printing/advanced的示例。"

#: C/index-in.docbook:5262
msgid ""
"The following example demonstrates how to print some input from a user "
"interface. It shows how to implement <literal>on_begin_print</literal> and "
"<literal>on_draw_page</literal>, as well as how to track print status and "
"update the print settings."
msgstr ""
"以下示例演示了如何从用户界面打印一些输出。它显示了如何实现"
"<literal>on_begin_print</literal>和<literal>on_draw_page</literal>，以及如何"
"跟踪打印状态和更新打印设置。"

#: C/index-in.docbook:5270
msgid "Printing - Simple"
msgstr "打印 - 简单"

#: C/index-in.docbook:5276
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/printing/simple/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/printing/simple/\">源代码</ulink>"

#: C/index-in.docbook:5285
msgid "Recently Used Documents"
msgstr "最近使用过的文件"

#: C/index-in.docbook:5287
msgid ""
"<application>gtkmm</application> provides an easy way to manage recently "
"used documents. This functionality is implemented in the <classname>Gtk::"
"RecentManager</classname> class."
msgstr ""
"<application>gtkmm</application>提供了一种管理最近使用文件的简便方法。该功能"
"在<classname>Gtk::RecentManager</classname>类中实现。"

#: C/index-in.docbook:5291
msgid ""
"Each item in the list of recently used files is identified by its URI, and "
"can have associated metadata. The metadata can be used to specify how the "
"file should be displayed, a description of the file, its mime type, which "
"application registered it, whether it's private to the registering "
"application, and several other things."
msgstr ""
"最近使用文件列表中的每一项都由其URI进行标识，并可以具有相关的元数据。元数据可"
"以用于指定如何显示文件、如何描述文件、及其它的MIME类型、哪个应用程序注册了"
"它、对于注册的应用程序是不是私有的等。"

#: C/index-in.docbook:5299
msgid "RecentManager"
msgstr "最近管理器(RecentManager)"

#: C/index-in.docbook:5300
msgid ""
"<classname>RecentManager</classname> acts as a database of recently used "
"files. You use this class to register new files, remove files from the list, "
"or look up recently used files. There is one list of recently used files per "
"user."
msgstr ""
"<classname>RecentManager</classname>充当最近使用文件的数据库。你可以使用此类"
"注册新文件、从列表中删除文件、查找最近使用文件。每个用户都拥有一个最近使用的"
"文件列表。"

#: C/index-in.docbook:5306
msgid ""
"You can create a new <classname>RecentManager</classname>, but you'll most "
"likely just want to use the default one. You can get a reference to the "
"default <classname>RecentManager</classname> with <methodname>get_default()</"
"methodname>."
msgstr ""
"你可以创建一个新的<classname>RecentManager</classname>，但你可能只想用默认的"
"那个。你可以通过<methodname>get_default()</methodname>获取默认"
"<classname>RecentManager</classname>的引用。"

#: C/index-in.docbook:5313
msgid "Adding Items to the List of Recent Files"
msgstr "将项目添加到最近文件列表"

#: C/index-in.docbook:5314
msgid ""
"To add a new file to the list of recent documents, in the simplest case, you "
"only need to provide the URI. For example:"
msgstr ""
"在最简单的情况下，要添加项目到最近文件列表只需要提供一个URI即可。例如："

#: C/index-in.docbook:5318
#, no-wrap
msgid ""
"auto recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"
msgstr ""
"auto recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"

#: C/index-in.docbook:5320
msgid ""
"If you want to register a file with metadata, you can pass a "
"<classname>RecentManager::Data</classname> parameter to "
"<methodname>add_item()</methodname>. The metadata that can be set on a "
"particular file item is as follows:"
msgstr ""
"如果你想要使用元数据注册一个文件，你可以将<classname>RecentManager::Data</"
"classname>参数传递给<methodname>add_item()</methodname>。可以在特定的文件项上"
"设置的元数据如下所示："

#: C/index-in.docbook:5328
msgid ""
"<varname>app_exec</varname>: The command line to be used to launch this "
"resource. This string may contain the \"f\" and \"u\" escape characters "
"which will be expanded to the resource file path and URI respectively"
msgstr ""
"<varname>app_exec</varname>：用于启动此资源的命令行。此字符串可以包含\"f\"和"
"\"u\"转义字符，它们将分别扩展为资源文件路径和URI"

#: C/index-in.docbook:5334
msgid ""
"<varname>app_name</varname>: The name of the application that registered the "
"resource"
msgstr "<varname>app_name</varname>：此资源注册的应用程序名"

#: C/index-in.docbook:5338
msgid ""
"<varname>description</varname>: A short description of the resource as a "
"UTF-8 encoded string"
msgstr "<varname>description</varname>：资源的简单描述（UTF-8编码字符串）"

#: C/index-in.docbook:5342
msgid ""
"<varname>display_name</varname>: The name of the resource to be used for "
"display as a UTF-8 encoded string"
msgstr "<varname>display_name</varname>：用于显示的资源名（UTF-8编码字符串）"

#: C/index-in.docbook:5346
msgid ""
"<varname>groups</varname>: A list of groups associated with this item. "
"Groups are essentially arbitrary strings associated with a particular "
"resource. They can be thought of as 'categories' (such as \"email\", "
"\"graphics\", etc) or tags for the resource."
msgstr ""
"<varname>groups</varname>：与该项相关联的组列表。组本质上是与特定资源相关联的"
"任意字符串。可以将它们视为资源的类别（例如：电子邮件、图形等）或标签"

#: C/index-in.docbook:5352
msgid ""
"<varname>is_private</varname>: Whether this resource should be visible only "
"to applications that have registered it or not"
msgstr ""
"<varname>is_private</varname>：此资源是否仅对已注册该资源的应用程序可见"

#: C/index-in.docbook:5356
msgid "<varname>mime_type</varname>: The MIME type of the resource"
msgstr "<varname>mime_type</varname>：此资源的MIME类型"

#: C/index-in.docbook:5359
msgid ""
"In addition to adding items to the list, you can also look up items from the "
"list and modify or remove items."
msgstr "除了向列表中添加项目以外，你还可以从列表项中删除、修改、查找项目。"

#: C/index-in.docbook:5365
msgid "Looking up Items in the List of Recent Files"
msgstr "在最近文件列表中查找项目"

#: C/index-in.docbook:5366
msgid ""
"To look up recently used files, <classname>RecentManager</classname> "
"provides several functions. To look up a specific item by its URI, you can "
"use the <methodname>lookup_item()</methodname> function, which will return a "
"<classname>RecentInfo</classname> class. If the specified URI did not exist "
"in the list of recent files, <methodname>lookup_item()</methodname> throws a "
"<classname>RecentManagerError</classname> exception. For example:"
msgstr ""
"<classname>RecentManager</classname>提供了几个函数用以查找最近使用过的文件。"
"你可以使用<methodname>lookup_item()</methodname>函数通过URI来查找特定项目，该"
"函数将返回一个<classname>RecentInfo</classname>类对象。如果指定的URI于最近文"
"件列表中不存在，则<methodname>lookup_item()</methodname>将抛出一个"
"<classname>RecentManagerError</classname>异常。例如："

#: C/index-in.docbook:5375
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;\n"
"try\n"
"{\n"
"  info = recent_manager-&gt;lookup_item(uri);\n"
"}\n"
"catch(const Gtk::RecentManagerError&amp; ex)\n"
"{\n"
"  std::cerr &lt;&lt; \"RecentManagerError: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n"
"}\n"
"if (info)\n"
"{\n"
"  // item was found\n"
"}"
msgstr ""
"Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;\n"
"try\n"
"{\n"
"  info = recent_manager-&gt;lookup_item(uri);\n"
"}\n"
"catch(const Gtk::RecentManagerError&amp; ex)\n"
"{\n"
"  std::cerr &lt;&lt; \"RecentManagerError: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n"
"}\n"
"if (info)\n"
"{\n"
"  // item was found\n"
"}"

#: C/index-in.docbook:5388
msgid ""
"A <classname>RecentInfo</classname> object is essentially an object "
"containing all of the metadata about a single recently-used file. You can "
"use this object to look up any of the properties listed <link linkend=\"list-"
"file-metadata\">above</link>."
msgstr ""
"本质上，<classname>RecentInfo</classname>是个包含了一个最近使用文件的所有元数"
"据的对象。你可以使用该对象查找<link linkend=\"list-file-metadata\">这里</"
"link>所列出的任何属性。"

#: C/index-in.docbook:5394
msgid ""
"If you don't want to look for a specific URI, but instead want to get a list "
"of all recently used items, <classname>RecentManager</classname> provides "
"the <methodname>get_items()</methodname> function. The return value of this "
"function is a <classname>std::vector</classname> of all recently used files. "
"The following code demonstrates how you might get a list of recently used "
"files:"
msgstr ""
"如果你不想要查找一个特定的URI，而是想获取整个最近使用的项目列表，"
"<classname>RecentManager</classname>为此提供了<methodname>get_items()</"
"methodname>函数。这个函数返回值是一个<classname>std::vector</classname>，其包"
"含了所有最近使用的文件。以下代码演示了你该如何获取最近使用文件列表："

#: C/index-in.docbook:5402
#, no-wrap
msgid "auto info_list = recent_manager-&gt;get_items();"
msgstr "auto info_list = recent_manager-&gt;get_items();"

#: C/index-in.docbook:5403
msgid ""
"The maximum age of items in the recently used files list can be set with "
"<methodname>Gtk::Settings::property_gtk_recent_files_max_age()</methodname>. "
"Default value: 30 days."
msgstr ""
"可以使用<methodname>Gtk::Settings::property_gtk_recent_files_max_age()</"
"methodname>设置最近使用文件列表中项目的最长使用期限。默认时长是：30天。"

#: C/index-in.docbook:5410
msgid "Modifying the List of Recent Files"
msgstr "修改最近使用文件列表"

#: C/index-in.docbook:5411
msgid ""
"There may be times when you need to modify the list of recent files. For "
"instance, if a file is moved or renamed, you may need to update the file's "
"location in the recent files list so that it doesn't point to an incorrect "
"location. You can update an item's location by using "
"<methodname>move_item()</methodname>."
msgstr ""
"有时候你会需要修改最近使用文件列表。例如，当一个文件被移动或重命名，你需要更"
"新该文件在最近使用文件列表中的位置，以使其不会指向错误的位置。你可以使用"
"<methodname>move_item()</methodname>来更新项目的位置。"

#: C/index-in.docbook:5418
msgid ""
"In addition to changing a file's URI, you can also remove items from the "
"list, either one at a time or by clearing them all at once. The former is "
"accomplished with <methodname>remove_item()</methodname>, the latter with "
"<methodname>purge_items()</methodname>."
msgstr ""
"除了更改文件的URI以外，你还可以从列表中删除项目或是一次性清除所有项目。前者使"
"用<methodname>remove_item()</methodname>，后者使用<methodname>purge_items()</"
"methodname>。"

#: C/index-in.docbook:5425
msgid ""
"The functions <methodname>move_item()</methodname>, "
"<methodname>remove_item()</methodname> and <methodname>purge_items()</"
"methodname> have no effect on the actual files that are referred to by the "
"URIs, they only modify the list of recent files."
msgstr ""
"<methodname>move_item()</methodname>、<methodname>remove_item()</methodname>"
"和<methodname>purge_items()</methodname>并不影响URI所引用的真实文件，它们只是"
"对最近文件列表进行修改。"

#: C/index-in.docbook:5438
msgid ""
"<classname>FileChooser</classname> is an interface that can be implemented "
"by widgets displaying a list of files. <application>gtkmm</application> "
"provides three built-in implementations for choosing recent files or other "
"files: <classname>FileChooserWidget</classname>, "
"<classname>FileChooserDialog</classname>, and <classname>FileChooserNative</"
"classname>."
msgstr ""
"<classname>FileChooser</classname>是一个可以由用于显示文件列表的部件实现的接"
"口。<application>gtkmm</application>提供了三种用于选择最近文件或其他文件的内"
"置实现：<classname>FileChooserWidget</classname>、"
"<classname>FileChooserDialog</classname>、<classname>FileChooserNative</"
"classname>。"

#: C/index-in.docbook:5447
msgid ""
"<classname>FileChooserWidget</classname> is a simple widget for displaying a "
"list of recently used files or other files. <classname>FileChooserWidget</"
"classname> is the basic building block for <classname>FileChooserDialog</"
"classname>, but you can embed it into your user interface if you want to."
msgstr ""
"<classname>FileChooserWidget</classname>是一个用于显示最近使用文件列表或其他"
"文件的简单部件。<classname>FileChooserWidget</classname>是"
"<classname>FileChooserDialog</classname>的基本构建块，但是你根据需要可以将其"
"嵌入到用户界面中。"

#: C/index-in.docbook:5455
msgid "Simple FileChooserDialog example"
msgstr "简单的文件选择对话框示例"

#: C/index-in.docbook:5456
msgid ""
"Shown below is a simple example of how to use the "
"<classname>FileChooserDialog</classname> class in a program. This simple "
"program has a menubar with a <guimenuitem>File Chooser Dialog</guimenuitem> "
"menu item. When you select this menu item, a dialog pops up showing a list "
"of files. If you select <guimenuitem>Recent</guimenuitem> in the sidebar, "
"the list of recently used files is shown."
msgstr ""
"下面显示的是一个如何在程序中使用<classname>FileChooserDialog</classname>类的"
"简单示例。这个简单示例程序有一个带有<guimenuitem>File Chooser Dialog</"
"guimenuitem>菜单项的菜单栏。选择此菜单项时，将弹出一个显示文件列表的对话框。"
"如果你选中侧边栏的<guimenuitem>Recent</guimenuitem>，则对话框将显示最近使用文"
"件列表。"

#: C/index-in.docbook:5466
msgid ""
"If this is the first time you're using a program that uses the Recent Files "
"framework, the dialog may be empty at first. Otherwise it should show the "
"list of recently used documents registered by other applications."
msgstr ""
"如果这是你第一次使用使用了最近文件框架的应用程序，那么对话框最初可能是空的。"
"否则它应该显示其他应用程序注册的最近使用文件列表。"

#: C/index-in.docbook:5473
msgid ""
"After selecting the <guimenuitem>File Chooser Dialog</guimenuitem> menu item "
"and the <guimenuitem>Recent</guimenuitem> sidebar item, you should see "
"something similar to the following window."
msgstr ""
"选择<guimenuitem>File Chooser Dialog</guimenuitem>菜单项和"
"<guimenuitem>Recent</guimenuitem>侧边项后，你将看到与下方窗口类似的内容。"

#: C/index-in.docbook:5481
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/recent_files\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/recent_files\">源代码</ulink>"

#: C/index-in.docbook:5482
msgid ""
"The constructor for <classname>ExampleWindow</classname> creates the menu "
"and the toolbar using <classname>Builder</classname> (see <xref linkend="
"\"chapter-menus-and-toolbars\"/> for more information). It then adds the "
"menu and the toolbar to the window."
msgstr ""
"<classname>ExampleWindow</classname>的构造函数使用<classname>Builder</"
"classname>创建菜单和工具栏（更多有关信息请参阅<xref linkend=\"chapter-menus-"
"and-toolbars\"/>）。然后将菜单和工具栏添加到窗口中。"

#: C/index-in.docbook:5490
msgid "Filtering Files"
msgstr "筛选文件"

#: C/index-in.docbook:5491
msgid ""
"For any of the <classname>FileChooser</classname> classes, if you don't wish "
"to display all of the items in the list of files, you can filter the list to "
"show only those that you want. You can filter the list with the help of the "
"<classname>FileFilter</classname> class. This class allows you to filter "
"files by their name (<methodname>add_pattern()</methodname>), or their mime "
"type (<methodname>add_mime_type()</methodname>)."
msgstr ""
"对于任意<classname>FileChooser</classname>类，如果你不想显示文件列表中的所有"
"项目，你可以筛选列表以仅显示所需的项目。你可以使用<classname>FileFilter</"
"classname>帮助你对列表进行筛选。这个类允许你按文件名"
"（<methodname>add_pattern()</methodname>）或MIME类型"
"（<methodname>add_mime_type()</methodname>）筛选文件。"

#: C/index-in.docbook:5500
msgid ""
"After you've created and set up the filter to match only the items you want, "
"you can apply a filter to a chooser widget with the <methodname>FileChooser::"
"add_filter()</methodname> function."
msgstr ""
"创建并设置筛选器以使其只匹配你所需项目之后，你可以使用"
"<methodname>FileChooser::add_filter()</methodname>函数将筛选器应用于你所选的"
"部件。"

#: C/index-in.docbook:5510
msgid "Keyboard Events"
msgstr "键盘事件"

#: C/index-in.docbook:5511
msgid ""
"X events differ in some ways from other signals. These differences are "
"described in the <link linkend=\"sec-xeventsignals\">X Event signals</link> "
"section in the appendix. Here we will use keyboard events to show how X "
"events can be used in a program."
msgstr ""
"X事件与其他信号在某些方面有所不同。这些差异在附录的<link linkend=\"sec-"
"xeventsignals\">X事件信号</link>小节中说明。在这，我们将使用键盘事件说明如何"
"在程序中使用X事件。"

#: C/index-in.docbook:5518
msgid "Overview"
msgstr "总览"

#: C/index-in.docbook:5519
msgid ""
"Whenever you press or release a key, an event is emitted. You can connect a "
"signal handler to handle such events."
msgstr ""
"每当你按下或放开一个按键，就会发出一个事件。你可以连接到信号处理函数来处理此"
"类事件。"

#: C/index-in.docbook:5523
msgid ""
"The event signal handler will receive an argument that depends on the type "
"of event. For keyboard events it's a <type>GdkEventKey*</type>. As discribed "
"in the <link linkend=\"sec-xeventsignals\">appendix</link>, the event signal "
"handler returns a <type>bool</type> value, to indicate that the signal is "
"fully handled (<literal>true</literal>) or allow event propagation "
"(<literal>false</literal>)."
msgstr ""
"事件处理函数接受的参数取决于事件的类型。对于键盘事件，它接受一个"
"<type>GdkEventKey*</type>参数。如<link linkend=\"sec-xeventsignals\">附录</"
"link>中所述，事件处理函数返回一个<type>bool</type>值，以表示信号已经被完全处"
"理（返回<literal>true</literal>）或允许事件传播（<literal>false</literal>）。"

#: C/index-in.docbook:5532
msgid ""
"To determine which key was pressed or released, you read the value of "
"<varname>GdkEventKey::keyval</varname> and compare it with a constant in the "
"<filename>&lt;gdk/gdkkeysyms.h&gt;</filename> header file. The states of "
"modifier keys (shift, ctrl, etc.) are available as bit-flags in "
"<varname>GdkEventKey::state</varname>."
msgstr ""
"要确定哪个键被按下或放开，你需要读取<varname>GdkEventKey::keyval</varname>的"
"值并将其与头文件<filename>&lt;gdk/gdkkeysyms.h&gt;</filename>中的常量进行比"
"较。<varname>GdkEventKey::state</varname>的位标志可以用作表示修饰键（shift、"
"ctrl等）的状态。"

#: C/index-in.docbook:5541
#, no-wrap
msgid ""
"\n"
"bool on_key_press_or_release_event(GdkEventKey* event)\n"
"{\n"
"  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;\n"
"    event-&gt;keyval == GDK_KEY_1 &amp;&amp;\n"
"    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)\n"
"  {\n"
"    handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key\n"
"    return true;\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"Gtk::Entry m_entry; // in a class definition\n"
"\n"
"// in the class constructor\n"
"m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
msgstr ""
"\n"
"bool on_key_press_or_release_event(GdkEventKey* event)\n"
"{\n"
"  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;\n"
"    event-&gt;keyval == GDK_KEY_1 &amp;&amp;\n"
"    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)\n"
"  {\n"
"    handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key\n"
"    return true;\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"Gtk::Entry m_entry; // in a class definition\n"
"\n"
"// in the class constructor\n"
"m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"

#: C/index-in.docbook:5539 C/index-in.docbook:8443
msgid "Here's a simple example: <_:programlisting-1/>"
msgstr "这是一个简单的例子：<_:programlisting-1/>"

#: C/index-in.docbook:5564
msgid ""
"In this example there are three keyboard shortcuts: <keycap>Alt</keycap>"
"+<keycap>1</keycap> selects the first radio button, <keycap>Alt</keycap>"
"+<keycap>2</keycap> selects the second one, and the <keycap>Esc</keycap> key "
"hides (closes) the window. The default event signal handler is overridden, "
"as described in the <link linkend=\"sec-overriding-default-signal-handlers"
"\">Overriding default signal handlers</link> section in the appendix."
msgstr ""
"在此示例中，有三个键盘快捷键：<keycap>Alt</keycap>+<keycap>1</keycap>选择第一"
"个单选按钮、<keycap>Alt</keycap>+<keycap>2</keycap>选择第二个单选按钮、"
"<keycap>Esc</keycap>隐藏（关闭）窗口。默认信号处理程序被覆盖如附录中<link "
"linkend=\"sec-overriding-default-signal-handlers\">覆盖默认信号处理程序</"
"link>小节所述。"

#: C/index-in.docbook:5575
msgid "Keyboard Events - Simple"
msgstr "键盘事件 - 简单"

#: C/index-in.docbook:5581
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/keyboard_events/simple/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/keyboard_events/simple/\">源代码</ulink>"

#: C/index-in.docbook:5586
msgid "Event Propagation"
msgstr "事件传播"

#: C/index-in.docbook:5587
msgid ""
"Event propagation means that, when an event is emitted on a particular "
"widget, it can be passed to its parent widget (and that widget can pass it "
"to its parent, and so on) and, if the parent has an event handler, that "
"handler will be called."
msgstr ""
"事件传播意味着，当事件在特定的部件中发出时，它可以被传递到该部件的父部件（这"
"个部件又可以将信号传递给它的父部件，以此类推），如果父部件有对该事件的事件处"
"理程序，该处理程序将被调用。"

#: C/index-in.docbook:5593
msgid ""
"Contrary to other events, keyboard events are first sent to the toplevel "
"window (<classname>Gtk::Window</classname>), where it will be checked for "
"any keyboard shortcuts that may be set (accelerator keys and mnemonics, used "
"for selecting menu items from the keyboard). After this (and assuming the "
"event wasn't handled), it is sent to the widget which has focus, and the "
"propagation begins from there."
msgstr ""
"与其他事件相反，键盘事件首先被发送到顶级窗口（<classname>Gtk::Window</"
"classname>），在此检查任何可能被设置的键盘快捷键（用于从键盘选择菜单项的快捷"
"键、助记符）。然后（假设事件没有被处理）将其发送到焦点部件，然后从此部件开始"
"传播。"

#: C/index-in.docbook:5601
msgid ""
"The event will propagate until it reaches the top-level widget, or until you "
"stop the propagation by returning <literal>true</literal> from an event "
"handler."
msgstr ""
"事件将一直传播直到顶级窗口为止或直到你通过事件处理程序返回<literal>true</"
"literal>为止。"

#: C/index-in.docbook:5606
msgid ""
"Notice, that after canceling an event, no other function will be called "
"(even if it is from the same widget)."
msgstr "请注意，取消事件之后，不再会调用其他函数（哪怕它来自同一个部件）。"

#: C/index-in.docbook:5613
msgid ""
"In this example there are three event handlers that are called after "
"<classname>Gtk::Window</classname>'s default event handler, one in the "
"<classname>Gtk::Entry</classname>, one in the <classname>Gtk::Grid</"
"classname> and one in the <classname>Gtk::Window</classname>."
msgstr ""
"在此示例中，<classname>Gtk::Window</classname>在默认事件处理程序之后调用了三"
"个事件处理程序，一个在<classname>Gtk::Entry</classname>中、一个在"
"<classname>Gtk::Grid</classname>中、一个在<classname>Gtk::Window</classname>"
"中。"

#: C/index-in.docbook:5619
msgid ""
"In the <classname>Gtk::Window</classname>, we have also the default handler "
"overridden (<methodname>on_key_release_event()</methodname>), and another "
"handler being called before the default handler "
"(<methodname>windowKeyReleaseBefore()</methodname>)."
msgstr ""
"在<classname>Gtk::Window</classname>中我们还覆盖了默认处理程序"
"（<methodname>on_key_release_event()</methodname>），并在调用默认处理程序之前"
"调用了另一个处理程序（<methodname>windowKeyReleaseBefore()</methodname>）。"

#: C/index-in.docbook:5625
msgid ""
"The purpose of this example is to show the steps the event takes when it is "
"emitted."
msgstr "本示例的目的是显示事件发出时进行的步骤。"

#: C/index-in.docbook:5628
msgid ""
"When you write in the entry, a key release event will be emitted, which will "
"go first to the toplevel window (<classname>Gtk::Window</classname>), since "
"we have one event handler set to be called before, that's what is called "
"first (<methodname>windowKeyReleaseBefore()</methodname>). Then the default "
"handler is called (which we have overridden), and after that the event is "
"sent to the widget that has focus, the <classname>Entry</classname> in our "
"example and, depending on whether we let it propagate, it can reach the "
"<classname>Grid</classname>'s and the <classname>Window</classname>'s event "
"handlers. If it propagates, the text you're writing will appear in the "
"<classname>Label</classname> above the <classname>Entry</classname>."
msgstr ""
"当你在条目中写入的时候，将发出一个按键放开事件，该事件将先进入顶层窗口"
"（<classname>Gtk::Window</classname>），因为我们之前设置了一个事件处理程序，"
"所以<methodname>windowKeyReleaseBefore()</methodname>将先被调用。然后调用已被"
"覆盖的默认信号处理程序，然后将事件传播到具有焦点的部件，也就是示例中的"
"<classname>Entry</classname>，根据事件处理程序的返回值，该事件可以被传播到"
"<classname>Grid</classname>和<classname>Window</classname>。如果该事件被传"
"播，你写入的文本将出现在<classname>Entry</classname>上方的<classname>Label</"
"classname>中。"

#: C/index-in.docbook:5643
msgid "Keyboard Events - Event Propagation"
msgstr "键盘事件 - 事件传播"

#: C/index-in.docbook:5649
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/keyboard_events/propagation/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/keyboard_events/propagation/\">源代码</ulink>"

#: C/index-in.docbook:5655
msgid "Timeouts, I/O and Idle Functions"
msgstr "超时，I/O和空闲函数"

#: C/index-in.docbook:5658
msgid "Timeouts"
msgstr "超时"

#: C/index-in.docbook:5660
msgid ""
"You may be wondering how to make <application>gtkmm</application> do useful "
"work while it's idling along. Happily, you have several options. Using the "
"following methods you can create a timeout method that will be called every "
"few milliseconds."
msgstr ""
"你可能想知道如何使<application>gtkmm</application>在空闲的时候做一些有用的工"
"作。幸运的是你有几种选择。你可以创建一个每几毫秒就调用的超时方法。"

#: C/index-in.docbook:5667
#, no-wrap
msgid ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool()&gt;&amp; slot,\n"
"                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool()&gt;&amp; slot,\n"
"                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"

#: C/index-in.docbook:5673
msgid ""
"The first argument is a <classname>slot</classname> you wish to have called "
"when the timeout occurs. The second argument is the number of milliseconds "
"between calls to that method. You receive a <classname>sigc::connection</"
"classname> object that can be used to deactivate the connection using its "
"<methodname>disconnect()</methodname> method:"
msgstr ""
"第一个参数是超时时你希望被调用的<classname>slot</classname>。第二个参数是调用"
"该方法的时间间隔（多少毫秒）。你将收到一个<classname>sigc::connection</"
"classname>对象，可以在该对象上调用<methodname>disconnect()</methodname>方法断"
"开连接。"

#: C/index-in.docbook:5683
#, no-wrap
msgid ""
"\n"
"my_connection.disconnect();\n"
msgstr ""
"\n"
"my_connection.disconnect();\n"

#: C/index-in.docbook:5695
#, no-wrap
msgid ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n\" &lt;&lt; std::endl; return true; }\n"
msgstr ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n\" &lt;&lt; std::endl; return true; }\n"

#: C/index-in.docbook:5688
msgid ""
"Another way of destroying the connection is your signal handler. It has to "
"be of the type <classname>sigc::slot&lt;bool()&gt;</classname>. As you see "
"from the definition your signal handler has to return a value of the type "
"<literal>bool</literal>. A definition of a sample method might look like "
"this: <_:programlisting-1/>"
msgstr ""
"破坏连接的另一种方法是通过你的信号处理函数的返回值。其类型必须是"
"<classname>sigc::slot&lt;bool()&gt;</classname>。从定义可以看出信号处理函数必"
"须返回一个<literal>bool</literal>类型的值。示例方法的定义可能如下所示：<_:"
"programlisting-1/>"

#: C/index-in.docbook:5701
msgid ""
"You can stop the timeout method by returning <literal>false</literal> from "
"your signal handler. Therefore, if you want your method to be called "
"repeatedly, it should return <literal>true</literal>."
msgstr ""
"你可以通过让你的信号处理函数返回<literal>false</literal>以停止此超时方法。因"
"此，如果你还想重复调用此方法，则你需要让信号处理函数返回<literal>true</"
"literal>。"

#: C/index-in.docbook:5707
msgid "Here's an example of this technique:"
msgstr "这是此技术的示例："

#: C/index-in.docbook:5711
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/timeout/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/timeout/\">源代码</ulink>"

#: C/index-in.docbook:5716
msgid "Monitoring I/O"
msgstr "监视I/O"

#: C/index-in.docbook:5718
msgid ""
"A nifty feature of Glib (one of the libraries underlying <application>gtkmm</"
"application>) is the ability to have it check for data on a file descriptor "
"for you. This is especially useful for networking applications. The "
"following method is used to do this:"
msgstr ""
"Glib（<application>gtkmm</application>的底层库之一）有一个很好的特性是它具有"
"帮你检查文件描述符中的数据的能力。这对于需要联网的应用程序十分的有用。使用以"
"下方法来执行此操作："

#: C/index-in.docbook:5726
#, no-wrap
msgid ""
"\n"
"sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool(Glib::IOCondition)&gt;&amp; slot,\n"
"                                 Glib::PollFD::fd_t fd, Glib::IOCondition condition,\n"
"                                 int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""
"\n"
"sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool(Glib::IOCondition)&gt;&amp; slot,\n"
"                                 Glib::PollFD::fd_t fd, Glib::IOCondition condition,\n"
"                                 int priority = Glib::PRIORITY_DEFAULT);\n"

#: C/index-in.docbook:5733
msgid ""
"The first argument is a slot you wish to have called when the specified "
"event (see argument 3) occurs on the file descriptor you specify using "
"argument two. Argument three may be one or more (using <literal>|</literal>) "
"of:"
msgstr ""
"第一个参数是你希望在第二个参数指定的文件描述符上发生指定事件（见第三个参数的"
"描述）时被调用的槽。第三个参数可能是一下的一项或多项（若想是多项则对以下多个"
"使用<literal>|</literal>，例如：<literal>Glib::IO_IN | Glib::IO_OUT | Glib::"
"IO_PRI</literal>）："

#: C/index-in.docbook:5743
msgid ""
"Glib::IO_IN - Call your method when there is data ready for reading on your "
"file descriptor."
msgstr "Glib::IO_IN - 当你提供的文件描述符有数据准备好被读取时调用你的方法。"

#: C/index-in.docbook:5751
msgid ""
"Glib::IO_OUT - Call your method when the file descriptor is ready for "
"writing."
msgstr "Glib::IO_OUT - 当提供的文件描述符准备好被写入时调用你的方法。"

#: C/index-in.docbook:5759
msgid ""
"Glib::IO_PRI - Call your method when the file descriptor has urgent data to "
"be read."
msgstr "Glib::IO_PRI - 当提供的文件描述符有紧急数据要读取时调用你的方法。"

#: C/index-in.docbook:5766
msgid ""
"Glib::IO_ERR - Call your method when an error has occurred on the file "
"descriptor."
msgstr "Glib::IO_ERR - 当提供的文件描述符上发生错误的时候调用你的方法。"

#: C/index-in.docbook:5773
msgid ""
"Glib::IO_HUP - Call your method when hung up (the connection has been broken "
"usually for pipes and sockets)."
msgstr "Glib::IO_HUP - 挂起时（常见于管道和套接字的连接被断开）调用你的方法。"

#: C/index-in.docbook:5780
msgid ""
"The return value is a <classname>sigc::connection</classname> that may be "
"used to stop monitoring this file descriptor using its "
"<methodname>disconnect()</methodname> method. The <parameter>slot</"
"parameter> signal handler should be declared as follows:"
msgstr ""
"返回值是一个<classname>sigc::connection</classname>对象，你可以在其上调用"
"<methodname>disconnect()</methodname>方法以停止对该文件描述符的监视。信号处理"
"函数<parameter>slot</parameter>应声明如下："

#: C/index-in.docbook:5787
#, no-wrap
msgid ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"
msgstr ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"

#: C/index-in.docbook:5792
msgid ""
"where <parameter>condition</parameter> is as specified above. As usual the "
"slot is created with <function>sigc::mem_fun()</function> (for a member "
"method of an object), or <function>sigc::ptr_fun()</function> (for a "
"function)."
msgstr ""
"参数<parameter>condition</parameter>如上所述。通常使用<function>sigc::"
"mem_fun()</function>（通过一个对象的成员函数创建）或<function>sigc::"
"ptr_fun()</function>（通过一个普通函数创建）函数创建槽。"

#: C/index-in.docbook:5799
msgid ""
"A little example follows. To use the example just execute it from a "
"terminal; it doesn't create a window. It will create a pipe named "
"<literal>testfifo</literal> in the current directory. Then start another "
"shell and execute <literal>echo \"Hello\" &gt; testfifo</literal>. The "
"example will print each line you enter until you execute <literal>echo \"Q\" "
"&gt; testfifo</literal>."
msgstr ""
"下面是个示例。要使用该示例，只需要在终端上执行它即可；它不会创建一个窗口。它"
"将在当前目录创建一个名为<literal>testfifo</literal>的具名管道。然后启动另一个"
"shell并执行<literal>echo \"Hello\" &gt; testfifo</literal>。该示例将打印你输"
"入的每一行直到你执行<literal>echo \"Q\" &gt; testfifo</literal>"

#: C/index-in.docbook:5808
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/input/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/input/\">源代码</ulink>"

#: C/index-in.docbook:5813
msgid "Idle Functions"
msgstr "空闲函数"

#: C/index-in.docbook:5815
msgid ""
"If you want to specify a method that gets called when nothing else is "
"happening, use the following:"
msgstr "如果你想要指定一个在无事发生时调用的方法，请使用以下函数："

#: C/index-in.docbook:5820
#, no-wrap
msgid ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool()&gt;&amp; slot,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"
msgstr ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool()&gt;&amp; slot,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"

#: C/index-in.docbook:5826
msgid ""
"This causes <application>gtkmm</application> to call the specified method "
"whenever nothing else is happening. You can add a priority (lower numbers "
"are higher priorities). There are two ways to remove the signal handler: "
"calling <methodname>disconnect()</methodname> on the <classname>sigc::"
"connection</classname> object, or returning <literal>false</literal> in the "
"signal handler, which should be declared as follows:"
msgstr ""
"这会导致<application>gtkmm</application>在无事发生时调用指定的方法。你可以为"
"其添加优先级（数字越小优先级越高）。删除该信号处理程序的方法有两个：在"
"<classname>sigc::connection</classname>对象上调用<methodname>disconnect()</"
"methodname>、在信号处理程序中返回<literal>false</literal>，信号处理程序的声明"
"应如下所示："

#: C/index-in.docbook:5836
#, no-wrap
msgid ""
"\n"
"bool idleFunc();\n"
msgstr ""
"\n"
"bool idleFunc();\n"

#: C/index-in.docbook:5841
msgid ""
"Since this is very similar to the methods above this explanation should be "
"sufficient to understand what's going on. However, here's a little example:"
msgstr ""
"这与前一小节的方法极其类似，所以在此不再进行过多的解释。以下是个小例子："

#: C/index-in.docbook:5846
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/idle/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/idle/\">源代码</ulink>"

#: C/index-in.docbook:5848
msgid ""
"This example points out the difference of idle and timeout methods a little. "
"If you need methods that are called periodically, and speed is not very "
"important, then you want timeout methods. If you want methods that are "
"called as often as possible (like calculating a fractal in background), then "
"use idle methods."
msgstr ""
"这个例子指出了空闲与超时方法的微小区别。如果你需要定期调用，并且速度并不重要"
"则你应该使用超时方法。如果你需要尽可能多的调用方法（例如在后台计算分形）那你"
"应该使用空闲方法。"

#: C/index-in.docbook:5856
msgid ""
"Try executing the example and increasing the system load. The upper progress "
"bar will increase steadily; the lower one will slow down."
msgstr ""
"尝试执行此示例并逐渐增加系统的负载。上方的进度条将稳定的逐渐增加；下方的则会"
"增加的越来越慢。"

#: C/index-in.docbook:5866
msgid "Memory management"
msgstr "内存管理"

#: C/index-in.docbook:5872
msgid "Normal C++ memory management"
msgstr "标准C++内存管理"

#: C/index-in.docbook:5874
msgid ""
"<application>gtkmm</application> allows the programmer to control the "
"lifetime (that is, the construction and destruction) of any widget in the "
"same manner as any other C++ object. This flexibility allows you to use "
"<literal>new</literal> and <literal>delete</literal> to create and destroy "
"objects dynamically or to use regular class members (that are destroyed "
"automatically when the class is destroyed) or to use local instances (that "
"are destroyed when the instance goes out of scope). This flexibility is not "
"present in some C++ GUI toolkits, which restrict the programmer to only a "
"subset of C++'s memory management features."
msgstr ""
"<application>gtkmm</application>允许程序员像管理任意其他C++对象一样对任意部件"
"的生命周期（即构造和析构）进行控制。这种灵活性使你可以用<literal>new</"
"literal>和<literal>delete</literal>动态创建和销毁对象，或使用常规的类成员（销"
"毁类时部件将被自动销毁），或使用局部实例（当实例超出其作用域时被销毁）。这种"
"灵活性在某些C++ GUI工具包中不存在，这些工具包限制程序员只能使用C++内存管理特"
"性中的一部分。"

#: C/index-in.docbook:5886
msgid "Here are some examples of normal C++ memory management:"
msgstr "以下是一些使用标准C++进行内存管理的示例："

#: C/index-in.docbook:5889
msgid "Class Scope widgets"
msgstr "类作用域部件"

#: C/index-in.docbook:5891
msgid ""
"If a programmer does not need dynamic memory allocation, automatic widgets "
"in class scope may be used. One advantage of automatic widgets in class "
"scope is that memory management is grouped in one place. The programmer does "
"not risk memory leaks from failing to <literal>delete</literal> a widget."
msgstr ""
"如果程序员不需要动态分配内存，则可以在类作用域中使用具有自动储存期的部件。在"
"类作用域中使用自动储存期的部件的优点之一是内存管理被集中在一个地方。程序员不"
"需要承担因<literal>delete</literal>部件出现差错而导致内存泄漏的风险。"

#: C/index-in.docbook:5898
msgid ""
"The primary disadvantage of using class scope widgets is revealing the class "
"implementation rather than the class interface in the class header."
msgstr ""
"使用类作用域部件的主要缺点是在包含类声明的头文件中展示了类的实现而不只是类的"
"接口。"

#: C/index-in.docbook:5904
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"#include &lt;gtkmm/window.h&gt;\n"
"class Foo : public Gtk::Window\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // will be destroyed when the Foo object is destroyed\n"
"};\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"#include &lt;gtkmm/window.h&gt;\n"
"class Foo : public Gtk::Window\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // will be destroyed when the Foo object is destroyed\n"
"};\n"

#: C/index-in.docbook:5918
msgid "Function scope widgets"
msgstr "函数作用域部件"

#: C/index-in.docbook:5924
#, no-wrap
msgid ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  app-&gt;run();\n"
"}\n"

#: C/index-in.docbook:5920
msgid ""
"If a programmer does not need a class scope widget, a function scope widget "
"may also be used. The advantages to function scope over class scope are the "
"increased data hiding and reduced dependencies. <_:programlisting-1/>"
msgstr ""
"如果程序员不需要类作用域部件，那么也可以使用函数作用域部件。函数作用域相比于"
"类作用域的优点是增加了数据的隐蔽性和隐藏了依赖。<_:programlisting-1/>"

#: C/index-in.docbook:5936
msgid "Dynamic allocation with new and delete"
msgstr "使用new和delete进行动态分配"

#: C/index-in.docbook:5946
#, no-wrap
msgid ""
"\n"
"auto pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// do something useful with pButton\n"
"\n"
"delete pButton;\n"
msgstr ""
"\n"
"auto pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// do something useful with pButton\n"
"\n"
"delete pButton;\n"

#: C/index-in.docbook:5938
msgid ""
"Usually, the programmer will prefer to allow containers to automatically "
"destroy their children by creating them using <function>Gtk::make_managed()</"
"function> (see below). This is not strictly required, as the <literal>new</"
"literal> and <literal>delete</literal> operators may also be used, but "
"modern C++ style discourages those in favour of safer models of memory "
"management, so it is better to create widgets using <function>Gtk::"
"make_managed()</function> and let their parent destroy them, than to "
"manually perform dynamic allocation. <_:programlisting-1/> Here, the "
"programmer deletes <varname>pButton</varname> to prevent a memory leak."
msgstr ""
"通常，程序员更喜欢使用<function>Gtk::make_managed()</function>（参见下文）创"
"建允许容器自动销毁的子部件。这并非强制性的要求，你也可以使用<literal>new</"
"literal>和<literal>delete</literal>操作符，但是现代C++风格鼓励使用更安全的内"
"存管理模型，因此最好使用<function>Gtk::make_managed()</function>创建部件，并"
"让他们的父部件销毁它们，而不是手动执行动态内存分配。<_:programlisting-1/> 在"
"这，程序员删除<varname>pButton</varname>以防止内存泄漏。"

#: C/index-in.docbook:5960
msgid "Managed Widgets"
msgstr "托管部件"

#: C/index-in.docbook:5962
msgid ""
"Alternatively, you can let a widget's container control when the widget is "
"destroyed. In most cases, you want a widget to last only as long as the "
"container it is in. To delegate the management of a widget's lifetime to its "
"container, create it with <function>Gtk::make_managed()</function> and then "
"pack it into its container with <methodname>Gtk::Box::append()</methodname> "
"or a similar method. Now the widget will be destroyed whenever its container "
"is destroyed."
msgstr ""
"另外，你可以让部件的容器控制部件被销毁的时机。多数情况下你会希望部件的生存周"
"期与包含它的容器的生命周期一样长。要将部件的生命周期管理委托给其容器，请使用"
"<function>Gtk::make_managed()</function>创建部件，然后使用诸如"
"<methodname>Gtk::Box::append()</methodname>这类的方法将其装入容器中。这样部件"
"就会随着容器一并销毁。"

#: C/index-in.docbook:5972
msgid "Dynamic allocation with make_managed() and append()"
msgstr "使用make_managed()和append()进行动态分配"

#: C/index-in.docbook:5974
msgid ""
"<application>gtkmm</application> provides ways including the "
"<function>make_managed()</function> function and <methodname>Gtk::Box::"
"append()</methodname> method to simplify creation and destruction of widgets "
"whose lifetime can be managed by a parent."
msgstr ""
"<application>gtkmm</application>提供了包括<function>make_managed()</function>"
"函数和<methodname>Gtk::Box::append()</methodname>方法在内的用于简化创建和销毁"
"部件的很多方法。这些部件的生命周期可以由其父部件进行管理。"

#: C/index-in.docbook:5980
msgid ""
"Every widget except a top-level window must be added to a parent container "
"in order to be displayed. The <function>manage()</function> function marks a "
"widget so that when that widget is added to a parent container, said "
"container becomes responsible for deleting the widget, meaning the user no "
"longer needs to do so. The original way to create widgets whose lifetime is "
"managed by their parent in this way was to call <function>manage()</"
"function>, passing in the result of a <literal>new</literal> expression that "
"created a dynamically allocated widget."
msgstr ""
"除了顶级窗口以外的任何部件都需要添加到一个父容器中才能够被显示。"
"<function>manage()</function>函数对部件进行标记，以便将该部件添加到父容器时，"
"由其父容器负责删除该部件，这意味着用户不需要如此做。创建生命周期由其父部件进"
"行管理的部件的原始方法是调用<function>manage()</function>，并将向其传入使用"
"<literal>new</literal>表达式创建的动态分配的部件。"

#: C/index-in.docbook:5990
msgid ""
"However, usually, when you create such a widget, you will already know that "
"its parent container should be responsible for destroying it, In addition, "
"modern C++ style discourages use of the <literal>new</literal> operator, "
"which was required when passing a newly created widget to "
"<function>manage()</function>. Therefore, <application>gtkmm</application> "
"has added <function>make_managed()</function>, which combines creation and "
"marking with <function>manage()</function> into a single step. This avoids "
"you having to write <literal>new</literal>, which is discouraged in modern C+"
"+ style, and more clearly expresses intent to create a managed widget."
msgstr ""
"但是通常当你创建这样的部件时，你已经知道其父部件应该负责销毁它。此外现代C++风"
"格不推荐使用<literal>new</literal>操作符，而将新创建的部件传递给"
"<function>manage()</function>时需要使用<literal>new</literal>。因此，"
"<application>gtkmm</application>添加了<function>make_managed()</function>函"
"数，这个函数将两个步骤合并到了一起。这避免了让你编写现代C++风格不建议的带有"
"<literal>new</literal>的代码，并更清楚的表达了创建托管部件的意图。"

#: C/index-in.docbook:6002
#, no-wrap
msgid ""
"\n"
"MyContainer::MyContainer()\n"
"{\n"
"  auto pButton = Gtk::make_managed&lt;Gtk::Button&gt;(\"Test\");\n"
"  append(*pButton); //add *pButton to MyContainer\n"
"}\n"
msgstr ""
"\n"
"MyContainer::MyContainer()\n"
"{\n"
"  auto pButton = Gtk::make_managed&lt;Gtk::Button&gt;(\"Test\");\n"
"  append(*pButton); //add *pButton to MyContainer\n"
"}\n"

#: C/index-in.docbook:6001
msgid ""
"<_:programlisting-1/> Now, when objects of type <classname>MyContainer</"
"classname> are destroyed, the button will also be deleted. It is no longer "
"necessary to delete <varname>pButton</varname> to free the button's memory; "
"its deletion has been delegated to the <classname>MyContainer</classname> "
"object."
msgstr ""
"<_:programlisting-1/> 现在，当你销毁<classname>MyContainer</classname>类型对"
"象时，该按钮也被销毁。不再需要主动<literal>delete</literal><varname>pButton</"
"varname>以释放其内存；对其的删除操作委托给了<classname>MyContainer</"
"classname>对象。"

#: C/index-in.docbook:6015
msgid ""
"Note that if you never added the widget to any parent container, or you did "
"but later <methodname>Gtk::Container::remove()</methodname>d it from said "
"parent, <application>gtkmm</application> restores the widget’s lifetime "
"management to whatever state it had before <function>manage()</function> was "
"called, which typically means that the responsibility for <literal>delete</"
"literal>ing the widget returns to the user."
msgstr ""
"请注意，如果你从未将该部件添加到任何父容器中，或者你添加后在其父容器调用了"
"<methodname>Gtk::Container::remove()</methodname>将其从父容器中删除了，"
"<application>gtkmm</application>将会使部件的生命周期管理恢复到调用"
"<function>manage()</function>之前的状态，这通常意味着删除部件的责任被归还给了"
"用户。"

#: C/index-in.docbook:6023
msgid ""
"Of course, a top-level container will not be added to another container. The "
"programmer is responsible for destroying the top-level container using one "
"of the traditional C++ techniques. For instance, your top-level Window might "
"just be an instance in your <function>main()</function> function."
msgstr ""
"当然，顶级容器不会被添加到另一个容器中。程序员负责使用一种传统的C++技术销毁顶"
"级容器。例如，你的顶级窗口可能只是<function>main()</function>函数中的一个实"
"例。"

#: C/index-in.docbook:6035
msgid "Shared resources"
msgstr "共享资源"

#: C/index-in.docbook:6037
msgid ""
"Some objects, such as <classname>Gdk::Pixbuf</classname>s and "
"<classname>Pango::Font</classname>s, are obtained from a shared store. "
"Therefore you cannot instantiate your own instances. These classes typically "
"inherit from <classname>Glib::Object</classname>. Rather than requiring you "
"to reference and unreference these objects, <application>gtkmm</application> "
"uses the <classname>Glib::RefPtr&lt;&gt;</classname> smartpointer. Cairomm "
"has its own smartpointer, <classname>Cairo::RefPtr&lt;&gt;</classname>."
msgstr ""
"一些对象是从共享储存中获取的，例如<classname>Gdk::Pixbuf</classname>和"
"<classname>Pango::Font</classname>。因此你无法实例化自己的实例。这些类通常继"
"承自<classname>Glib::Object</classname>。<application>gtkmm</application>使用"
"智能指针<classname>Glib::RefPtr&lt;&gt;</classname>而不是要求你引用和解引用这"
"些对象。开罗有自己的智能指针：<classname>Cairo::RefPtr&lt;&gt;</classname>。"

#: C/index-in.docbook:6050
#, no-wrap
msgid ""
"\n"
"auto pixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
msgstr ""
"\n"
"auto pixbuf = Gdk::Pixbuf::create_from_file(filename);\n"

#: C/index-in.docbook:6047
msgid ""
"Objects such as <classname>Gdk::Pixbuf</classname> can only be instantiated "
"with a <methodname>create()</methodname> function. For instance, <_:"
"programlisting-1/>"
msgstr ""
"诸如<classname>Gdk::Pixbuf</classname>之类的对象只能通过"
"<methodname>create()</methodname>函数进行实例化。例如：<_:programlisting-1/>"

#: C/index-in.docbook:6059
#, no-wrap
msgid ""
"\n"
"auto width = 0;\n"
"if(pixbuf)\n"
"{\n"
"  width = pixbuf-&gt;get_width();\n"
"}\n"
msgstr ""
"\n"
"auto width = 0;\n"
"if(pixbuf)\n"
"{\n"
"  width = pixbuf-&gt;get_width();\n"
"}\n"

#: C/index-in.docbook:6055
msgid ""
"You have no way of getting a bare <classname>Gdk::Pixbuf</classname>. In the "
"example, <varname>pixbuf</varname> is a smart pointer, so you can do this, "
"much like a normal pointer: <_:programlisting-1/>"
msgstr ""
"你无法暴露<classname>Gdk::Pixbuf</classname>对象。在示例中，<varname>pixbuf</"
"varname>是一个智能指针，因此可以像正常指针一样执行此操作：<_:"
"programlisting-1/>"

#: C/index-in.docbook:6068
msgid ""
"When <varname>pixbuf</varname> goes out of scope an <methodname>unref()</"
"methodname> will happen in the background and you don't need to worry about "
"it anymore. There's no <literal>new</literal> so there's no <literal>delete</"
"literal>."
msgstr ""
"当<varname>pixbuf</varname>超出作用域时，将在后台调用<methodname>unref()</"
"methodname>，你无需为它担心。没有进行<literal>new</literal>因此也不需要进行"
"<literal>delete</literal>。"

#: C/index-in.docbook:6076
#, no-wrap
msgid ""
"\n"
"auto pixbuf2 = pixbuf;\n"
msgstr ""
"\n"
"auto pixbuf2 = pixbuf;\n"

#: C/index-in.docbook:6074
msgid ""
"If you copy a <classname>RefPtr</classname>, for instance <_:"
"programlisting-1/> , or if you pass it as a method argument or a return "
"type, then <classname>RefPtr</classname> will do any necessary referencing "
"to ensure that the instance will not be destroyed until the last "
"<classname>RefPtr</classname> has gone out of scope."
msgstr ""
"如果你复制一个<classname>RefPtr</classname>，例如：<_:programlisting-1/>，或"
"者你将其作为一个方法的参数或返回类型进行传递，<classname>RefPtr</classname>将"
"做必要的引用以确保在最后一个<classname>RefPtr</classname>超出作用域之前该实例"
"不会被销毁。"

#: C/index-in.docbook:6084
msgid ""
"See the <link linkend=\"chapter-refptr\">appendix</link> for detailed "
"information about RefPtr."
msgstr ""
"更多与RefPtr有关的信息，请参见<link linkend=\"chapter-refptr\">附录</link>。"

#: C/index-in.docbook:6089
msgid ""
"Bjarne Stroustrup, \"The C++ Programming Language\" Forth Edition - section "
"34.3"
msgstr "Bjarne Stroustrup,《C++编程语言》第四版 第34章第3小节"

#: C/index-in.docbook:6092
msgid "Nicolai M. Josuttis, \"The C++ Standard Library\" - section 4.2"
msgstr "Nicolai M. Josuttis,《C++标准库》第4章第2节"

#: C/index-in.docbook:6085
msgid ""
"If you wish to learn more about smartpointers, you might look in these "
"books: <_:itemizedlist-1/>"
msgstr ""
"如果你想了解与智能指针更多的有关信息，请阅读以下书籍：<_:itemizedlist-1/>"

#: C/index-in.docbook:6103
msgid "Glade and Gtk::Builder"
msgstr "Glade和Gtk::Builder"

#: C/index-in.docbook:6104
msgid ""
"Although you can use C++ code to instantiate and arrange widgets, this can "
"soon become tedious and repetitive. And it requires a recompilation to show "
"changes. The <application>Glade</application> application allows you to "
"layout widgets on screen and then save an XML description of the "
"arrangement. Your application can then use the <application>Gtk::Builder</"
"application> API to load that XML file at runtime and obtain a pointer to "
"specifically named widget instances."
msgstr ""
"尽管你可以使用C++代码对部件进行实例化和排列，但是这很快就会变得枯燥且重复。并"
"且需要重新编译才能显示更改。<application>Glade</application>应用程序允许你在"
"屏幕上布局部件并然后将布局保存为XML描述。你的应用程序可以在之后使用"
"<application>Gtk::Builder</application>API在运行时加载该XML文件，并获取特定名"
"称部件实例的指针。"

#: C/index-in.docbook:6117
msgid "Less C++ code is required."
msgstr "需要的C++代码更少。"

#: C/index-in.docbook:6118
msgid "UI changes can be seen more quickly, so UIs are able to improve."
msgstr "可以更快的看到UI的更改，更便于改进UI。"

#: C/index-in.docbook:6119
msgid "Designers without programming skills can create and edit UIs."
msgstr "没有编程技能的设计人员可以创建和编辑UI。"

#: C/index-in.docbook:6114
msgid "This has the following advantages: <_:orderedlist-1/>"
msgstr "这具有以下优点：<_:orderedlist-1/>"

#: C/index-in.docbook:6123
msgid ""
"You still need C++ code to deal with User Interface changes triggered by "
"user actions, but using <application>Gtk::Builder</application> for the "
"widget layout allows you to focus on implementing that functionality."
msgstr ""
"你仍然需要编写C++代码以处理由用户操作触发的UI更改，但是将<application>Gtk::"
"Builder</application>用于部件布局允许你更专注的实现该功能。"

#: C/index-in.docbook:6130
msgid "Loading the .glade file"
msgstr "加载.glade文件"

#: C/index-in.docbook:6135
#, no-wrap
msgid ""
"\n"
"auto builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"
msgstr ""
"\n"
"auto builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"

#: C/index-in.docbook:6131
msgid ""
"<classname>Gtk::Builder</classname> must be used via a <classname>Glib::"
"RefPtr</classname>. Like all such classes, you need to use a "
"<methodname>create()</methodname> method to instantiate it. For instance, <_:"
"programlisting-1/> This will instantiate the windows defined in the "
"<filename>.glade</filename> file."
msgstr ""
"<classname>Gtk::Builder</classname>必须通过<classname>Glib::RefPtr</"
"classname>来使用。与所有此类类一样，你需要通过使用<methodname>create()</"
"methodname>方法实例化它。例如：<_:programlisting-1/>这将实例化<filename>."
"glade</filename>文件中定义的窗口。"

#: C/index-in.docbook:6142
#, no-wrap
msgid ""
"\n"
"auto builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"
msgstr ""
"\n"
"auto builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"

#: C/index-in.docbook:6141
msgid ""
"To instantiate just one window, or just one of the child widgets, you can "
"specify the name of a widget as the second parameter. For instance, <_:"
"programlisting-1/>"
msgstr ""
"如果只想实例化一个窗口或实例化一个子部件，你可以将部件的名称指定为第二个参"
"数。例如：<_:programlisting-1/>"

#: C/index-in.docbook:6150
msgid "Accessing widgets"
msgstr "访问部件"

#: C/index-in.docbook:6158
#, no-wrap
msgid ""
"\n"
"auto pDialog = builder-&gt;get_widget&lt;Gtk::Dialog&gt;(\"DialogBasic\");\n"
msgstr ""
"\n"
"auto pDialog = builder-&gt;get_widget&lt;Gtk::Dialog&gt;(\"DialogBasic\");\n"

#: C/index-in.docbook:6152
msgid ""
"To access a widget, for instance to <methodname>show()</methodname> a "
"dialog, use the <methodname>get_widget()</methodname> method, providing the "
"widget's name. This name should be specified in the <application>Glade</"
"application> Properties window. If the widget could not be found, or is of "
"the wrong type, then the pointer will be set to nullptr. <_:programlisting-1/"
">"
msgstr ""
"要访问部件，例如<methodname>show()</methodname>一个对话框，请使用"
"<methodname>get_widget()</methodname>方法，并向其提供一个部件名。这个名称应该"
"在<application>Glade</application>的窗口属性中指定。如果找不到该部件或是部件"
"的类型不对，则指针将被设为<literal>nullptr</literal>。<_:programlisting-1/>"

#: C/index-in.docbook:6163
msgid ""
"<application>Gtk::Builder</application> checks for a null pointer, and "
"checks that the widget is of the expected type, and will show warnings on "
"the command line about these."
msgstr ""
"<application>Gtk::Builder</application>会进行空指针和部件类型检查，并在命令行"
"上显示相关的警告。"

#: C/index-in.docbook:6169
msgid ""
"Remember that you are not instantiating a widget with "
"<methodname>get_widget()</methodname>, you are just obtaining a pointer to "
"one that already exists. You will always receive a pointer to the same "
"instance when you call <methodname>get_widget()</methodname> on the same "
"<classname>Gtk::Builder</classname>, with the same widget name. The widgets "
"are instantiated during <methodname>Gtk::Builder::create_from_file()</"
"methodname>."
msgstr ""
"请注意，你并没有使用<methodname>get_widget()</methodname>实例化部件，你只是获"
"得了指向已经存在的部件的指针。当你在同一个<classname>Gtk::Builder</classname>"
"上用同一个名称调用<methodname>get_widget()</methodname>你总是会得到指向同一实"
"例的指针。部件在函数<methodname>Gtk::Builder::create_from_file()</methodname>"
"执行期间被实例化。"

#: C/index-in.docbook:6178
msgid ""
"<methodname>get_widget()</methodname> returns child widgets that are "
"<function>manage()</function>ed (see the <link linkend=\"chapter-memory"
"\">Memory Management</link> chapter), so they will be deleted when their "
"parent container is deleted. <classname>Windows</classname> (such as "
"<classname>Dialogs</classname>) cannot be managed because they have no "
"parent container, so you must delete them at some point. The documentation "
"of <classname>Gtk::Builder</classname> has more to say about the memory "
"management of different kinds of objects."
msgstr ""
"<methodname>get_widget()</methodname>返回一个经<function>manage()</function>"
"处理的子部件（参阅<link linkend=\"chapter-memory\">内存管理</link>章节），因"
"此在删除其父部件时它们将被一并删除。无法管理<classname>Windows</"
"classname>（例如<classname>Dialogs</classname>）因为它们没有父容器，所以你必"
"须在某个时候删除它们。<classname>Gtk::Builder</classname>的文档中有更多关于对"
"不同类型的对象如何进行内存管理的介绍。"

#: C/index-in.docbook:6188
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Builder."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Builder."
"html\">参考</ulink>"

#: C/index-in.docbook:6192
msgid ""
"This simple example shows how to load a <application>Glade</application> "
"file at runtime and access the widgets with <application>Gtk::Builder</"
"application>."
msgstr ""
"这个简单示例展示了如何在运行时加载<application>Glade</application>文件并使用"
"<application>Gtk::Builder</application>访问部件。"

#: C/index-in.docbook:6197
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/builder/basic\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/builder/basic\">源代码</ulink>"

#: C/index-in.docbook:6204
msgid "Using derived widgets"
msgstr "使用派生部件"

#: C/index-in.docbook:6205
msgid ""
"You can use <classname>Gtk::Builder</classname> and <application>Glade</"
"application> to layout your own custom widgets derived from "
"<application>gtkmm</application> widget classes. This keeps your code "
"organized and encapsulated, separating declarative presentation from "
"business logic, avoiding having most of your source just be setting "
"properties and packing in containers."
msgstr ""
"你可以使用<classname>Gtk::Builder</classname>和<application>Glade</"
"application>布局你从<application>gtkmm</application>部件类派生的自定义部件。"
"这使得你的代码保持有序和封装性，将声明式表述与业务逻辑分离开来，避免你的大多"
"数源代码都是在设置属性和装填容器。"

#: C/index-in.docbook:6214
#, no-wrap
msgid ""
"\n"
"auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, \"DialogDerived\");\n"
msgstr ""
"\n"
"auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, \"DialogDerived\");\n"

#: C/index-in.docbook:6213
msgid ""
"Use <methodname>Gtk::Builder::get_widget_derived()</methodname> like so: <_:"
"programlisting-1/>"
msgstr ""
"像这样用<methodname>Gtk::Builder::get_widget_derived()</methodname>：<_:"
"programlisting-1/>"

#: C/index-in.docbook:6219
msgid ""
"Your derived class must have a constructor that takes a pointer to the "
"underlying C type, and the <classname>Gtk::Builder</classname> instance. All "
"relevant classes of <application>gtkmm</application> typedef their "
"underlying C type as <classname>BaseObjectType</classname> (<classname>Gtk::"
"Dialog</classname> typedefs <classname>BaseObjectType</classname> as "
"<type>GtkDialog</type>, for instance)."
msgstr ""
"你的派生类必须有一个将指向底层C类型的指针和<classname>Gtk::Builder</"
"classname>实例作为参数的构造函数。所有与<application>gtkmm</application>相关"
"的类的都将其的底层C类型别名(typedef)为<classname>BaseObjectType</"
"classname>（例如：<classname>Gtk::Dialog</classname>将<type>GtkDialog</type>"
"别名为<classname>BaseObjectType</classname>）。"

#: C/index-in.docbook:6229
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"

#: C/index-in.docbook:6226
msgid ""
"You must call the base class's constructor in the initialization list, "
"providing the C pointer. For instance, <_:programlisting-1/>"
msgstr ""
"你必须在初始化列表中调用基类的构造函数，并提供C指针。例如：<_:"
"programlisting-1/>"

#: C/index-in.docbook:6241
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  //Get the Glade-instantiated Button, and connect a signal handler:\n"
"  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;(\"quit_button\"))\n"
"{\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  //Get the Glade-instantiated Button, and connect a signal handler:\n"
"  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;(\"quit_button\"))\n"
"{\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"

#: C/index-in.docbook:6237
msgid ""
"You could then encapsulate the manipulation of the child widgets in the "
"constructor of the derived class, maybe using <methodname>get_widget()</"
"methodname> or <methodname>get_widget_derived()</methodname> again. For "
"instance, <_:programlisting-1/>"
msgstr ""
"然后你可以将对子部件的操作封装于派生类的构造函数中，可以在构造函数中再次使用"
"<methodname>get_widget()</methodname>或<methodname>get_widget_derived()</"
"methodname>。例如：<_:programlisting-1/>"

#: C/index-in.docbook:6260
#, no-wrap
msgid ""
"\n"
"auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, \"DialogDerived\", true);\n"
msgstr ""
"\n"
"auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, \"DialogDerived\", true);\n"

#: C/index-in.docbook:6264
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder, bool warning)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;(\"quit_button\"))\n"
"{\n"
"  // ....\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder, bool warning)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;(\"quit_button\"))\n"
"{\n"
"  // ....\n"
"}\n"

#: C/index-in.docbook:6256
msgid ""
"It's possible to pass additional arguments from "
"<methodname>get_widget_derived()</methodname> to the constructor of the "
"derived widget. For instance, this call to <methodname>get_widget_derived()</"
"methodname> <_:programlisting-1/> can invoke this constructor <_:"
"programlisting-2/>"
msgstr ""
"可以传递额外的参数给<methodname>get_widget_derived()</methodname>，他们将被转"
"发给派生部件的构造函数。例如这样调用<methodname>get_widget_derived()</"
"methodname>：<_:programlisting-1/>可以调用此构造函数：<_:programlisting-2/>"

#: C/index-in.docbook:6276
msgid "Gtk::Builder and Glib::Property"
msgstr "Gtk::Builder和Glib::Property"

#: C/index-in.docbook:6287
#, no-wrap
msgid ""
"\n"
"DerivedButton::DerivedButton(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Glib::ObjectBase(\"MyButton\"), // The GType name will be gtkmm__CustomObject_MyButton.\n"
"  Gtk::Button(cobject),\n"
"  prop_ustring(*this, \"button-ustring\"),\n"
"  prop_int(*this, \"button-int\", 10)\n"
"{\n"
"  // ....\n"
"}\n"
msgstr ""
"\n"
"DerivedButton::DerivedButton(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Glib::ObjectBase(\"MyButton\"), // The GType name will be gtkmm__CustomObject_MyButton.\n"
"  Gtk::Button(cobject),\n"
"  prop_ustring(*this, \"button-ustring\"),\n"
"  prop_int(*this, \"button-int\", 10)\n"
"{\n"
"  // ....\n"
"}\n"

#: C/index-in.docbook:6277
msgid ""
"If your derived widget uses <classname>Glib::Property</classname>, it "
"becomes slightly more complicated. A derived widget that contains "
"<classname>Glib::Property</classname> members must be registered with its "
"own name in the <type>GType</type> system. It must be registered before any "
"of the <methodname>create_from_*()</methodname> or <methodname>add_from_*()</"
"methodname> methods are called, meaning that you may have to create an "
"instance of your derived widget just to have its class registered. Your "
"derived widget must have a constructor that has the parameters required by "
"<methodname>get_widget_derived()</methodname> and calls the <classname>Glib::"
"ObjectBase</classname> constructor to register the <type>GType</type>. <_:"
"programlisting-1/>"
msgstr ""
"如果你派生的部件使用了<classname>Glib::Property</classname>，它将变得更复杂了"
"一些。包涵<classname>Glib::Property</classname>成员的派生部件必须在"
"<type>GType</type>系统中用自己的名称进行注册。必须在调用任何"
"<methodname>create_from_*()</methodname>或<methodname>add_from_*()</"
"methodname>方法之前进行注册，这意味着你可能需要完成对该类的注册才能创建派生部"
"件的实例。你派生的部件必须有一个具有<methodname>get_widget_derived()</"
"methodname>所需的所有参数以及调用<classname>Glib::ObjectBase</classname>构造"
"函数以注册<type>GType</type>的构造函数。<_:programlisting-1/>"

#: C/index-in.docbook:6298
msgid ""
"When using <application>gtkmm</application> with a version of "
"<application>glibmm</application> from 2.62 onwards, it is possible also to "
"specify properties of derived widgets, declared in C++ using "
"<application>gtkmm</application>, within <filename>.glade</filename> files "
"and load/set these using <classname>Gtk::Builder</classname>. See the "
"documentation of <classname>Gtk::Builder</classname> for more details on how "
"to achieve this. Glade won’t recognise such properties as-is, but it should "
"be able to through use of <ulink url=\"https://developer.gnome.org/gladeui/"
"stable/properties.html\"> property class definitions</ulink> and a catalog "
"declaring those new properties."
msgstr ""
"如果将<application>gtkmm</application>与<application>glibmm</application>2.62"
"以上的版本一起使用，则还可以在<filename>.glade</filename>文件中指定使用"
"<application>gtkmm</application>在C++代码中声明的派生部件的属性，并使用"
"<classname>Gtk::Builder</classname>加载/设置这些属性。更多实现此功能的详细信"
"息请参阅<classname>Gtk::Builder</classname>的文档。Glade不会按原样识别这些属"
"性，但这应该能通过使用<ulink url=\"https://developer.gnome.org/gladeui/"
"stable/properties.html\">属性类定义</ulink>和声明一个新属性目录来实现。"

#: C/index-in.docbook:6312
msgid ""
"This example shows how to load a <application>Glade</application> file at "
"runtime and access the widgets via derived classes."
msgstr ""
"本示例展示了如何在运行时加载<application>Glade</application>文件以及如何通过"
"派生类访问部件。"

#: C/index-in.docbook:6316
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/builder/derived\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/builder/derived\">源代码</ulink>"

#: C/index-in.docbook:6325
msgid "Internationalization and Localization"
msgstr "国际化和本地化"

#: C/index-in.docbook:6327
msgid ""
"<application>gtkmm</application> applications can easily support multiple "
"languages, including non-European languages such as Chinese and right-to-"
"left languages such as Arabic. An appropriately-written and translated "
"<application>gtkmm</application> application will use the appropriate "
"language at runtime based on the user's environment."
msgstr ""
"<application>gtkmm</application>应用程序可以很轻松的支持包括非欧洲语言（如中"
"文）和从右向左语言（如阿拉伯语）在内的多种语言。正确编写且进行翻译的"
"<application>gtkmm</application>应用程序可以在运行时根据用户环境使用合适的语"
"言。"

#: C/index-in.docbook:6333
msgid ""
"You might not anticipate the need to support additional languages, but you "
"can never rule it out. And it's easier to develop the application properly "
"in the first place rather than retrofitting later."
msgstr ""
"你可能没有预料到需要支持其他语言，但你永远不能排除这种可能性。而且事先准备好"
"支持多语言比后来改进要容易的多。"

#: C/index-in.docbook:6339
msgid ""
"The process of writing source code that allows for translation is called "
"<literal>internationalization</literal>, often abbreviated to <literal>i18n</"
"literal>. The <literal>Localization</literal> process, sometimes abbreviated "
"as <literal>l10n</literal>, provides translated text for other languages, "
"based on that source code."
msgstr ""
"编写允许进行翻译的源代码的过程被称为<literal>internationalization</literal>，"
"通常被缩写为<literal>i18n</literal>。而根据该源代码提供其他语言的翻译文本的过"
"程<literal>Localization</literal>通常被简写为<literal>l10n</literal>。"

#: C/index-in.docbook:6347
msgid ""
"The main activity in the internationalization process is finding strings "
"seen by users and marking them for translation. You do not need to do it all "
"at once - if you set up the necessary project infrastructure correctly then "
"your application will work normally regardless of how many strings you've "
"covered."
msgstr ""
"国际化过程中的主要活动是查找用户能看到的字符串并将其标记为需要可翻译。你不需"
"要一次性完成所有的操作 - 只要你的项目准备好了进行国际化无论你有多少个字符串被"
"标记为可翻译都不会影响程序的正常运行。"

#: C/index-in.docbook:6355
msgid ""
"String literals should be typed in the source code in English, but "
"surrounded by a macro. The <application>gettext</application> (or intltool) "
"utility can then extract the marked strings for translation, and substitute "
"the translated text at runtime."
msgstr ""
"源代码中的字符串字面量应该以英文键入，但要使用宏包围。<application>gettext</"
"application>（或intltool）实用程序可以提取被标记的字符串进行翻译，并在运行时"
"将其替换为翻译后的文本。"

#: C/index-in.docbook:6363
msgid "Preparing your project"
msgstr "准备你的项目"

#: C/index-in.docbook:6366
msgid ""
"In the instructions below we will assume that you will not be using "
"<application>gettext</application> directly, but <application>intltool</"
"application>, which was written specifically for <literal>GNOME</literal>. "
"<application>intltool</application> uses <function>gettext()</function>, "
"which extracts strings from source code, but <application>intltool</"
"application> can also combine strings from other files, for example from "
"desktop menu details, and GUI resource files such as <application>Glade</"
"application> files, into standard <application>gettext</application> "
"<filename>.pot/.po</filename> files."
msgstr ""
"在下面的说明中我们假定你不直接使用<application>gettext</application>，而是使"
"用专门为<literal>GNOME</literal>编写的<application>intltool</application>。"
"<application>intltool</application>使用<function>gettext()</function>从源代码"
"中提取字符串，但是<application>intltool</application>也从其他文件（例如桌面菜"
"单详情、glade的GUI资源文件）中提取字符串写入到标准的<application>gettext</"
"application><filename>.pot/.po</filename>文件中。"

#: C/index-in.docbook:6377
msgid ""
"We also assume that you are using autotools (e.g. <application>automake</"
"application> and <application>autoconf</application>) to build your project, "
"and that you are using <ulink url=\"https://gitlab.gnome.org/GNOME/gnome-"
"common/blob/master/autogen.sh\"> <literal>./autogen.sh</literal> from "
"<application>gnome-common</application></ulink> or a similar "
"<literal>autogen.sh</literal> file, which, among other things, takes care of "
"some <application>intltool</application> initialization."
msgstr ""
"我们还假设你正在使用自动构建工具（例如：<application>automake</application>和"
"<application>autoconf</application>）构建你的项目，并且你正在使用<ulink url="
"\"https://gitlab.gnome.org/GNOME/gnome-common/blob/master/autogen.sh\">来自"
"<application>gnome-common</application>的<literal>./autogen.sh</literal></"
"ulink>或与之类似的<literal>autogen.sh</literal>文件，在这里它负责初始化"
"<application>intltool</application>。"

#: C/index-in.docbook:6391
msgid ""
"An alternative to <application>gnome-common</application>'s <literal>autogen."
"sh</literal> may look like this:"
msgstr ""
"<application>gnome-common</application>的<literal>autogen.sh</literal>的替代"
"方案可能如下所示："

#: C/index-in.docbook:6395
#, no-wrap
msgid ""
"#! /bin/sh -e\n"
"test -n \"$srcdir\" || srcdir=`dirname \"$0\"`\n"
"test -n \"$srcdir\" || srcdir=.\n"
"\n"
"autoreconf --force --install --verbose --warnings=all \"$srcdir\"\n"
"echo \"Running intltoolize --copy --force --automake\"\n"
"intltoolize --copy --force --automake\n"
"test -n \"$NOCONFIGURE\" || \"$srcdir/configure\" \"$@\""
msgstr ""
"#! /bin/sh -e\n"
"test -n \"$srcdir\" || srcdir=`dirname \"$0\"`\n"
"test -n \"$srcdir\" || srcdir=.\n"
"\n"
"autoreconf --force --install --verbose --warnings=all \"$srcdir\"\n"
"echo \"Running intltoolize --copy --force --automake\"\n"
"intltoolize --copy --force --automake\n"
"test -n \"$NOCONFIGURE\" || \"$srcdir/configure\" \"$@\""

#: C/index-in.docbook:6404
msgid ""
"Create a sub-directory named <literal>po</literal> in your project's root "
"directory. This directory will eventually contain all of your translations. "
"Within it, create a file named <literal>LINGUAS</literal> and a file named "
"<literal>POTFILES.in</literal>. It is common practice to also create a "
"<literal>ChangeLog</literal> file in the <literal>po</literal> directory so "
"that translators can keep track of translation changes."
msgstr ""
"在你项目的根目录下创建一个名称为<literal>po</literal>的子文件夹。该目录将包含"
"你的所有翻译。在其中创建一个名为<literal>LINGUAS</literal>和一个名为"
"<literal>POTFILES.in</literal>的文件。通常做法是在<literal>po</literal>文件夹"
"再创建一个<literal>ChangeLog</literal>文件以便翻译人员跟踪翻译更改。"

#: C/index-in.docbook:6414
msgid ""
"<literal>LINGUAS</literal> contains an alphabetically sorted list of codes "
"identifying the languages for which your program is translated (comment "
"lines starting with a <literal>#</literal> are ignored). Each language code "
"listed in the <literal>LINGUAS</literal> file must have a corresponding "
"<literal>.po</literal> file. So, if your program has German and Japanese "
"translations, your <literal>LINGUAS</literal> file would look like this:"
msgstr ""
"<literal>LINGUAS</literal>包含按字母顺序排列的代码列表，这些代码标识程序已翻"
"译的语言（以<literal>#</literal>开头的行是注释将被忽略）。<literal>LINGUAS</"
"literal>文件中每个位于代码列表中语言都需要有与之对应的<literal>.po</literal>"
"文件。因此如果你的程序有德语和日语翻译，你的<literal>LINGUAS</literal>应如下"
"所示："

#: C/index-in.docbook:6423
#, no-wrap
msgid ""
"# keep this file sorted alphabetically, one language code per line\n"
"de\n"
"ja"
msgstr ""
"# keep this file sorted alphabetically, one language code per line\n"
"de\n"
"ja"

#: C/index-in.docbook:6426
msgid ""
"(In addition, you'd have the files <literal>ja.po</literal> and <literal>de."
"po</literal> in your <literal>po</literal> directory which contain the "
"German and Japanese translations, respectively.)"
msgstr ""
"（此外，你的<literal>po</literal>文件夹必须有包含德语和日语翻译的<literal>ja."
"po</literal>和<literal>de.po</literal>文件）"

#: C/index-in.docbook:6433
msgid ""
"<literal>POTFILES.in</literal> is a list of paths to all files which contain "
"strings marked up for translation, starting from the project root directory. "
"So for example, if your project sources were located in a subdirectory named "
"<literal>src</literal>, and you had two files that contained strings that "
"should be translated, your <literal>POTFILES.in</literal> file might look "
"like this:"
msgstr ""
"<literal>POTFILES.in</literal>是一个开始于项目根目录，包含所有被标记为需要翻"
"译字符串的文件路径列表。例如你的项目源代码位于<literal>src</literal>子目录"
"中，其中有两个文件包含有需要被翻译的字符串，则你的<literal>POTFILES.in</"
"literal>可能如下所示："

#: C/index-in.docbook:6442
#, no-wrap
msgid ""
"src/main.cc\n"
"src/other.cc"
msgstr ""
"src/main.cc\n"
"src/other.cc"

#: C/index-in.docbook:6445
msgid ""
"If you are using <application>gettext</application> directly, you can only "
"mark strings for translation if they are in source code file. However, if "
"you use <application>intltool</application>, you can mark strings for "
"translation in a variety of other file formats, including "
"<application>Glade</application> UI files, xml, <ulink url=\"http://"
"standards.freedesktop.org/desktop-entry-spec/latest/\">.desktop files</"
"ulink> and several more. So, if you have designed some of the application UI "
"in <application>Glade</application> then also add your <filename>.glade</"
"filename> files to the list in <literal>POTFILES.in</literal>."
msgstr ""
"如果你直接使用<application>gettext</application>，则你只能标记源代码文件中的"
"字符串为需要被翻译。如果你使用<application>intltool</application>，则可以对多"
"种格式的文件中的字符串进行标记，如<application>Glade</application>UI文件、"
"XML、<ulink url=\"http://standards.freedesktop.org/desktop-entry-spec/latest/"
"\">.desktop文件</ulink>等。因此如果你使用<application>Glade</application>设计"
"了应用程序UI，则你还需要将<filename>.glade</filename>添加到你的"
"<literal>POTFILES.in</literal>列表中。"

#: C/index-in.docbook:6458
msgid ""
"Now that there is a place to put your translations, you need to initialize "
"<application>intltool</application> and <application>gettext</application>. "
"Add the following code to your <literal>configure.ac</literal>, substituting "
"'programname' with the name of your program:"
msgstr ""
"现在已经有了放置翻译的地方，你需要初始化<application>intltool</application>和"
"<application>gettext</application>。将一下代码添加到你的<literal>configure."
"ac</literal>，将\"programname\"替换为你的程序的名称："

#: C/index-in.docbook:6465
#, no-wrap
msgid ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=programname\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [The domain to use with gettext])\n"
"AM_GNU_GETTEXT([external])\n"
"AM_GNU_GETTEXT_VERSION([0.17])\n"
"\n"
"PROGRAMNAME_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(PROGRAMNAME_LOCALEDIR)"
msgstr ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=programname\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [The domain to use with gettext])\n"
"AM_GNU_GETTEXT([external])\n"
"AM_GNU_GETTEXT_VERSION([0.17])\n"
"\n"
"PROGRAMNAME_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(PROGRAMNAME_LOCALEDIR)"

#: C/index-in.docbook:6477
msgid ""
"This <varname>PROGRAMNAME_LOCALEDIR</varname> variable will be used later in "
"the <literal>Makefile.am</literal> file, to define a macro that will be used "
"when you initialize <application>gettext</application> in your source code."
msgstr ""
"<varname>PROGRAMNAME_LOCALEDIR</varname>将在稍后被<literal>Makefile.am</"
"literal>文件使用。以定义在源代码中初始化<application>gettext</application>时"
"将用到的宏。"

#: C/index-in.docbook:6484
msgid ""
"<literal>AM_GLIB_GNU_GETTEXT</literal> has been an alternative to "
"<literal>AM_GNU_GETTEXT</literal> and <literal>AM_GNU_GETTEXT_VERSION</"
"literal>, but <literal>AM_GLIB_GNU_GETTEXT</literal> is now deprecated, and "
"shall not be used in new code."
msgstr ""
"<literal>AM_GLIB_GNU_GETTEXT</literal>已由<literal>AM_GNU_GETTEXT</literal>和"
"<literal>AM_GNU_GETTEXT_VERSION</literal>替代，且"
"<literal>AM_GLIB_GNU_GETTEXT</literal>已被弃用，不应在任何新代码中使用。"

#: C/index-in.docbook:6495
msgid ""
"Add <literal>po</literal> to the <literal>SUBDIRS</literal> variable. "
"Without this, your translations won't get built and installed when you build "
"the program"
msgstr ""
"将<literal>po</literal>添加到<literal>SUBDIRS</literal>变量中。如果没有这个，"
"在构建程序时不会生成和安装翻译。"

#: C/index-in.docbook:6502
#, no-wrap
msgid ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"
msgstr ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"

#: C/index-in.docbook:6500
msgid "Define <literal>INTLTOOL_FILES</literal> as: <_:programlisting-1/>"
msgstr "定义<literal>INTLTOOL_FILES</literal>为：<_:programlisting-1/>"

#: C/index-in.docbook:6508
msgid ""
"Add <literal>INTLTOOL_FILES</literal> to the <literal>EXTRA_DIST</literal> "
"list of files. This ensures that when you do a <command>make dist</command>, "
"these files will be included in the source tarball."
msgstr ""
"将<literal>INTLTOOL_FILES</literal>添加到<literal>EXTRA_DIST</literal>文件列"
"表。这样可以确保执行<command>make dist</command>时这些文件包含在源压缩包中。"

#: C/index-in.docbook:6518
#, no-wrap
msgid ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"
msgstr ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"

#: C/index-in.docbook:6516
msgid "Update your <literal>DISTCLEANFILES</literal>: <_:programlisting-1/>"
msgstr "更新你的<literal>DISTCLEANFILES</literal>：<_:programlisting-1/>"

#: C/index-in.docbook:6528
#, no-wrap
msgid ""
"desktopdir = $(datadir)/applications\n"
"desktop_in_files = programname.desktop.in\n"
"desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)\n"
"@INTLTOOL_DESKTOP_RULE@"
msgstr ""
"desktopdir = $(datadir)/applications\n"
"desktop_in_files = programname.desktop.in\n"
"desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)\n"
"@INTLTOOL_DESKTOP_RULE@"

#: C/index-in.docbook:6525
msgid ""
"Depending on the types of files that contain translatable strings, add code "
"such as <_:programlisting-1/>"
msgstr "根据包含可翻译字符串的文件类型，添加以下代码：<_:programlisting-1/>"

#: C/index-in.docbook:6491
msgid "In the top-level Makefile.am: <_:itemizedlist-1/>"
msgstr "在顶层<literal>Makefile.am</literal>中：<_:itemizedlist-1/>"

#: C/index-in.docbook:6537
msgid ""
"In your <literal>src/Makefile.am</literal>, update your "
"<literal>AM_CPPFLAGS</literal> to add the following preprocessor macro "
"definition:"
msgstr ""
"在你的<literal>src/Makefile.am</literal>中，更新你的<literal>AM_CPPFLAGS</"
"literal>以添加以下预处理宏定义："

#: C/index-in.docbook:6542
#, no-wrap
msgid "AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\\"${PROGRAMNAME_LOCALEDIR}\\\""
msgstr "AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\\"${PROGRAMNAME_LOCALEDIR}\\\""

#: C/index-in.docbook:6543
msgid ""
"This macro will be used when you initialize <literal>gettext</literal> in "
"your source code."
msgstr "在你的源代码中初始化<literal>gettext</literal>时将使用这个宏。"

#: C/index-in.docbook:6550
msgid "Marking strings for translation"
msgstr "标记要翻译的字符串"

#: C/index-in.docbook:6552
msgid ""
"String literals should be typed in the source code in English, but they "
"should be surrounded by a call to the <function>gettext()</function> "
"function. These strings will be extracted for translation and the "
"translations may be used at runtime instead of the original English strings."
msgstr ""
"源代码中的字符串字面量应该以英文键入，但应将其包含在对<function>gettext()</"
"function>函数的调用中。这些字符串将被提取以进行翻译，并且在运行时翻译可以替代"
"原始的英文字符串。"

#: C/index-in.docbook:6560
msgid ""
"The <application>GNU gettext</application> package allows you to mark "
"strings in source code, extract those strings for translation, and use the "
"translated strings in your application."
msgstr ""
"<application>GNU gettext</application>允许你标记源代码中的字符串，提取这些字"
"符串进行翻译，并在你的应用程序中使用翻译好的字符串。"

#: C/index-in.docbook:6572
#, no-wrap
msgid "display_message(\"Getting ready for i18n.\");"
msgstr "display_message(\"Getting ready for i18n.\");"

#: C/index-in.docbook:6574
#, no-wrap
msgid "display_message(_(\"Getting ready for i18n.\"));"
msgstr "display_message(_(\"Getting ready for i18n.\"));"

#: C/index-in.docbook:6566
msgid ""
"However, <application>Glib</application> defines <function>gettext()</"
"function> support macros which are shorter wrappers in an easy-to-use form. "
"To use these macros, include <literal>&lt;glibmm/i18n.h&gt;</literal>, and "
"then, for example, substitute: <_:programlisting-1/> with: <_:"
"programlisting-2/>"
msgstr ""
"<application>Glib</application>定义了<function>gettext()</function>支持宏，这"
"些宏更为简单易用，要使用这些宏请<literal>#include &lt;glibmm/i18n.h&gt;</"
"literal>然后将：<_:programlisting-1/>替换为：<_:programlisting-2/>"

#: C/index-in.docbook:6585
#, no-wrap
msgid "xgettext -a -o my-strings --omit-header *.cc *.h"
msgstr "xgettext -a -o my-strings --omit-header *.cc *.h"

#: C/index-in.docbook:6577
msgid ""
"For reference, it is possible to generate a file which contains all strings "
"which appear in your code, even if they are not marked for translation, "
"together with file name and line number references. To generate such a file "
"named <literal>my-strings</literal>, execute the following command, within "
"the source code directory: <_:programlisting-1/>"
msgstr ""
"可以生成一个包含代码中出现的所有字符串（即使没有被标记为需要翻译）以及其文件"
"名与行号引用的文件作为参考。要生成名为<literal>my-strings</literal>的文件，请"
"在源代码目录执行以下命令：<_:programlisting-1/>"

#: C/index-in.docbook:6592
#, no-wrap
msgid ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"
msgstr ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"

#: C/index-in.docbook:6588
msgid ""
"Finally, to let your program use the translation for the current locale, add "
"this code to the beginning of your <filename>main.cc</filename> file, to "
"initialize gettext. <_:programlisting-1/>"
msgstr ""
"最后，要让你的程序使用当前环境的翻译，请将以下代码添加到你的<filename>main."
"cc</filename>文件的开头，以初始化<function>gettext()</function>。<_:"
"programlisting-1/>"

#: C/index-in.docbook:6598
msgid "How gettext works"
msgstr "gettext如何工作"

#: C/index-in.docbook:6600
msgid ""
"The <application>intltool-update</application> or <application>xgettext</"
"application> script extracts the strings and puts them in a "
"<filename>mypackage.pot</filename> file. The translators of your application "
"create their translations by first copying this <filename>.pot</filename> "
"file to a <filename>localename.po</filename> file. A locale identifies a "
"language and an encoding for that language, including date and numerical "
"formats. Later, when the text in your source code has changed, the "
"<application>msgmerge</application> or <application>intltool-update</"
"application> script is used to update the <filename>localename.po</filename> "
"files from the regenerated <filename>.pot</filename> file."
msgstr ""
"<application>intltool-update</application>或<application>xgettext</"
"application>脚本提取字符串并将其放入<filename>mypackage.pot</filename>文件"
"中。应用程序的翻译人员首先将此<filename>.pot</filename>文件复制到"
"<filename>localename.po</filename>中以创建翻译。语言环境标识一种语言和该语言"
"使用的编码，包括日期和数字使用的格式。在之后，当源代码中的文本更改时，使用"
"<application>msgmerge</application>或<application>intltool-update</"
"application>脚本重新生成的<filename>.pot</filename>文件更新"
"<filename>localename.po</filename>文件。"

#: C/index-in.docbook:6614
msgid ""
"At install time, the <filename>.po</filename> files are converted to a "
"binary format (with the extension <filename>.mo</filename>) and placed in a "
"system-wide directory for locale files, for example <filename>/usr/share/"
"locale/</filename>."
msgstr ""
"在安装时，<filename>.po</filename>将被转换为二进制格式（扩展名为<filename>."
"mo</filename>），并将其放置于系统所有的区域设置文件夹中，例如<filename>/usr/"
"share/locale/</filename>。"

#: C/index-in.docbook:6621
msgid ""
"When the application runs, the <application>gettext</application> library "
"checks the system-wide directory to see if there is a <filename>.mo</"
"filename> file for the user's locale environment (you can set the locale "
"with, for instance, \"export LANG=de_DE.UTF-8\" from a bash console). Later, "
"when the program reaches a <literal>gettext</literal> call, it looks for a "
"translation of a particular string. If none is found, the original string is "
"used."
msgstr ""
"当应用程序运行时，<application>gettext</application>将检查系统目录是否存在与"
"用户语言环境对应的<filename>.mo</filename>文件（你可以使用以下命令指定语言环"
"境，例如：在bash控制台上输入<command>export LANG=de_DE.UTF-8</command>）。稍"
"后在程序到达<literal>gettext</literal>调用时，它将从中寻找特定字符串的翻译，"
"如果未找到则使用原始字符串。"

#: C/index-in.docbook:6633
msgid "Testing and adding translations"
msgstr "测试和添加翻译"

#: C/index-in.docbook:6640
#, no-wrap
msgid "intltool-update --pot"
msgstr "intltool-update --pot"

#: C/index-in.docbook:6635
msgid ""
"To convince yourself that you've done well, you may wish to add a "
"translation for a new locale. In order to do that, go to the <filename>po</"
"filename> subdirectory of your project and execute the following command: <_:"
"programlisting-1/>"
msgstr ""
"为了说服自己做得很好，你可能希望为新的语言环境添加翻译。为此请转到项目的"
"<filename>po</filename>子文件夹并执行以下命令：<_:programlisting-1/>"

#: C/index-in.docbook:6643
msgid ""
"That will create a file named <filename>programname.pot</filename>. Now copy "
"that file to <filename>languagecode.po</filename>, such as <filename>de.po</"
"filename> or <filename>hu.po</filename>. Also add that language code to "
"<literal>LINGUAS</literal>. The <filename>.po</filename> file contains a "
"header and a list of English strings, with space for the translated strings "
"to be entered. Make sure you set the encoding of the <filename>.po</"
"filename> file (specified in the header, but also as content) to "
"<literal>UTF-8</literal>."
msgstr ""
"这将创建一个名为<filename>programname.pot</filename>的文件。现在将该文件复制"
"到<filename>languagecode.po</filename>，例如<filename>de.po</filename>或"
"<filename>hu.po</filename>。接着将该语言代码添加到<literal>LINGUAS</literal>"
"文件中。<filename>.po</filename>文件包含标头和英语字符串列表，并为翻译文本预"
"留了空间。请确保将<filename>.po</filename>文件的编码设置（在标头中指定，但也"
"指定其内容的编码）为了<literal>UTF-8</literal>。"

#: C/index-in.docbook:6656
msgid ""
"It's possible that certain strings will be marked as <literal>fuzzy</"
"literal> in the <filename>.po</filename> file. These translations will not "
"substitute the original string. To make them appear, simply remove the "
"<literal>fuzzy</literal> tag."
msgstr ""
"<filename>.po</filename>文件中有些字符串可能被标记为<literal>fuzzy</"
"literal>。这些翻译将不会替代原始字符串。如果要使其显示，只需要将"
"<literal>fuzzy</literal>标记删除即可（通常该标记意味着翻译需要更新，不检查翻"
"译直接删除标记是不对的）。"

#: C/index-in.docbook:6666
msgid "Resources"
msgstr "资源"

#: C/index-in.docbook:6674
msgid ""
"<ulink url=\"https://wiki.gnome.org/TranslationProject/DevGuidelines\"> L10N "
"Guidelines for Developers</ulink>"
msgstr ""
"<ulink url=\"https://wiki.gnome.org/TranslationProject/DevGuidelines\">本地化"
"开发人员指南</ulink>"

#: C/index-in.docbook:6681
msgid ""
"<ulink url=\"http://bazaar.launchpad.net/~intltool/intltool/trunk/view/head:/"
"README\">Intltool README</ulink>"
msgstr ""
"<ulink url=\"http://bazaar.launchpad.net/~intltool/intltool/trunk/view/head:/"
"README\">Intltool自述文件</ulink>"

#: C/index-in.docbook:6687
msgid ""
"<ulink url=\"https://wiki.gnome.org/TranslationProject/GitHowTo\">How to use "
"Git for GNOME translators</ulink>"
msgstr ""
"<ulink url=\"https://wiki.gnome.org/TranslationProject/GitHowTo\">GNOME译者如"
"何使用Git</ulink>"

#: C/index-in.docbook:6693
msgid ""
"<ulink url=\"http://www.gnu.org/software/gettext/manual/gettext.html"
"\">gettext manual</ulink>"
msgstr ""
"<ulink url=\"http://www.gnu.org/software/gettext/manual/gettext.html"
"\">gettext手册</ulink>"

#: C/index-in.docbook:6699
msgid ""
"<ulink url=\"http://ftp.gnome.org/pub/GNOME/sources/gtkmm_hello/"
"\"><literal>gtkmm_hello</literal> example package</ulink>"
msgstr ""
"<ulink url=\"http://ftp.gnome.org/pub/GNOME/sources/gtkmm_hello/"
"\"><literal>gtkmm_hello</literal>示例包</ulink>"

#: C/index-in.docbook:6705
msgid ""
"<ulink url=\"http://ftp.gnome.org/pub/GNOME/sources/gnomemm_hello/"
"\"><literal>gnomemm_hello</literal> example package</ulink>"
msgstr ""
"<ulink url=\"http://ftp.gnome.org/pub/GNOME/sources/gnomemm_hello/"
"\"><literal>gnomemm_hello</literal>示例包</ulink>"

#: C/index-in.docbook:6668
msgid ""
"More information about what lies behind the internationalization and "
"localization process is presented and demonstrated in: <_:itemizedlist-1/>"
msgstr "更多与国际化与本地化有关的信息，请参阅以下内容：<_:itemizedlist-1/>"

#: C/index-in.docbook:6716
msgid "Expecting UTF8"
msgstr "期望使用UTF8"

#: C/index-in.docbook:6717
msgid ""
"A properly internationalized application will not make assumptions about the "
"number of bytes in a character. That means that you shouldn't use pointer "
"arithmetic to step through the characters in a string, and it means you "
"shouldn't use <classname>std::string</classname> or standard C functions "
"such as <function>strlen()</function> because they make the same assumption."
msgstr ""
"好的国际化应用程序不会假设字符中的字节数。这意味着你不应该使用指针算数遍历字"
"符串中的字符，也意味着你不应该使用<classname>std::string</classname>以及像"
"<function>strlen()</function>这样的与字符串有关的标准C函数，因为他们都对字符"
"的字节数做了假设。"

#: C/index-in.docbook:6724
msgid ""
"However, you probably already avoid bare char* arrays and pointer arithmetic "
"by using <classname>std::string</classname>, so you just need to start using "
"<classname>Glib::ustring</classname> instead. See the <link linkend=\"sec-"
"basics-ustring\">Basics</link> chapter about <classname>Glib::ustring</"
"classname>."
msgstr ""
"你可能已经通过使用<classname>std::string</classname>避免了使用原始的"
"<literal>char*</literal>和<literal>char[]</literal>进行指针算数。那么你只需要"
"换成使用<classname>Glib::ustring</classname>即可。更多详情请参阅<link "
"linkend=\"sec-basics-ustring\">Glib::ustring基础</link>章节。"

#: C/index-in.docbook:6733
msgid "Glib::ustring and std::iostreams"
msgstr "Glib::ustring和std::iostreams"

#: C/index-in.docbook:6750
#, no-wrap
msgid ""
"std::locale::global(std::locale(\"\")); // Set the global locale to the user's preferred locale.\n"
"                                      // Usually unnecessary here, because Glib::init()\n"
"                                      // or Gtk::Application::create() does it for you.\n"
"std::ostringstream output;\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"
msgstr ""
"std::locale::global(std::locale(\"\")); // Set the global locale to the user's preferred locale.\n"
"                                      // Usually unnecessary here, because Glib::init()\n"
"                                      // or Gtk::Application::create() does it for you.\n"
"std::ostringstream output;\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"

#: C/index-in.docbook:6735
msgid ""
"Unfortunately, the integration with the standard iostreams is not completely "
"foolproof. <application>gtkmm</application> converts <classname>Glib::"
"ustring</classname>s to a locale-specific encoding (which usually is not "
"UTF-8) if you output them to an <classname>ostream</classname> with "
"<function>operator&lt;&lt;</function>. Likewise, retrieving <classname>Glib::"
"ustring</classname>s from <classname>istream</classname> with "
"<function>operator&gt;&gt;</function> causes a conversion in the opposite "
"direction. But this scheme breaks down if you go through a <classname>std::"
"string</classname>, e.g. by inputting text from a stream to a "
"<classname>std::string</classname> and then implicitly converting it to a "
"<classname>Glib::ustring</classname>. If the string contained non-ASCII "
"characters and the current locale is not UTF-8 encoded, the result is a "
"corrupted <classname>Glib::ustring</classname>. You can work around this "
"with a manual conversion. For instance, to retrieve the <classname>std::"
"string</classname> from a <classname>ostringstream</classname>: <_:"
"programlisting-1/>"
msgstr ""
"不幸的是，与标准<classname>iostreams</classname>的集成并非绝对安全的。如果你"
"将<classname>Glib::ustring</classname>使用<function>operator&lt;&lt;</"
"function>输出到<classname>ostream</classname>中，则<application>gtkmm</"
"application>会将<classname>Glib::ustring</classname>转换为使用特定语言编码"
"（通常不会是UTF-8编码）。而使用<function>operator&gt;&gt;</function>将"
"<classname>istream</classname>输入到<classname>Glib::ustring</classname>会发"
"生相反的转换。但是如果你通过<classname>std::string</classname>进行则该方案会"
"失效，例如，从文本输入流转换成<classname>std::string</classname>再隐式转换为"
"<classname>Glib::ustring</classname>。如果该字符串中包含非ASCII字符且当前的语"
"言环境不使用UTF-8编码，则得到的结果是一个损坏的<classname>Glib::ustring</"
"classname>。你可以通过手动转换编码解决此问题。例如，若要从"
"<classname>ostringstream</classname>中接受<classname>std::string</"
"classname>：<_:programlisting-1/>"

#: C/index-in.docbook:6762
msgid "Pitfalls"
msgstr "陷阱"

#: C/index-in.docbook:6764
msgid ""
"There are a few common mistakes that you would discover eventually yourself. "
"But this section might help you to avoid them."
msgstr "有几个你最终会自己发现的错误。但本小节可能能帮助你避免它们。"

#: C/index-in.docbook:6767
msgid "Same strings, different semantics"
msgstr "不同语义的同一字符串。"

#: C/index-in.docbook:6769
msgid ""
"Sometimes two English strings are identical but have different meanings in "
"different contexts, so they would probably not be identical when translated. "
"Since the English strings are used as look-up keys, this causes problems."
msgstr ""
"有时，两个英文字符串是相同的但是在不同的上下文中有不同的含义，因此他们的译文"
"不一定相同。此时用英文字符串作为查找键会引起问题。"

#: C/index-in.docbook:6773
msgid ""
"In these cases, you should add extra characters to the strings. For "
"instance, use <literal>\"jumps[noun]\"</literal> and <literal>"
"\"jumps[verb]\"</literal> instead of just <literal>\"jumps\"</literal> and "
"strip them again outside the <function>gettext</function> call. If you add "
"extra characters you should also add a comment for the translators before "
"the <function>gettext</function> call. Such comments will be shown in the "
"<filename>.po</filename> files. For instance:"
msgstr ""
"在这个情况下，你应该在字符串中添加额外的字符。例如，使用<literal>"
"\"jumps[noun]\"</literal>和<literal>\"jumps[verb]\"</literal>而不是用"
"<literal>\"jumps\"</literal>并在调用<function>gettext</function>后将它们剥"
"离。如果你添加了额外的字符，你还应该在调用<function>gettext</function>之前为"
"译者添加注释。这样的注释将被显示于<filename>.po</filename>中。例如："

#: C/index-in.docbook:6782
#, no-wrap
msgid ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"
msgstr ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"

#: C/index-in.docbook:6786
msgid ""
"If you use <application>Glib</application>'s support macros, it's easier. "
"Use <function>C_()</function> instead of <function>_()</function>. For "
"instance:"
msgstr ""
"如果你使用<application>Glib</application>宏，将会更为方便。你只需要使用"
"<function>C_()</function>替换<function>_()</function>。例如："

#: C/index-in.docbook:6790
#, no-wrap
msgid "GLib::ustring text(C_(\"noun\", \"jumps\"));"
msgstr "GLib::ustring text(C_(\"noun\", \"jumps\"));"

#: C/index-in.docbook:6795
msgid "Composition of strings"
msgstr "合成字符串"

#: C/index-in.docbook:6797
msgid ""
"C programmers use <function>sprintf()</function> to compose and concatenate "
"strings. C++ favours streams, but unfortunately, this approach makes "
"translation difficult, because each fragment of text is translated "
"separately, without allowing the translators to rearrange them according to "
"the grammar of the language."
msgstr ""
"C程序员使用<function>sprintf()</function>合成和拼接字符串。而C++支持流，不幸"
"的是，使用这种方法生成的字符串将给翻译带来困难，因为文本被分成了多个片段，译"
"者必须分开翻译多个片段而不能进行重新排列，这会导致很多字符串无法被正确翻译。"

#: C/index-in.docbook:6804
msgid "For instance, this code would be problematic:"
msgstr "例如，此代码将会出现问题："

#: C/index-in.docbook:6806
#, no-wrap
msgid ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"
msgstr ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"

#: C/index-in.docbook:6815
#, no-wrap
msgid ""
"std::cout &lt;&lt; Glib::ustring::compose(\n"
"             _(\"Current amount: %1 Future: %2\"), amount, future) &lt;&lt; std::endl;\n"
"\n"
"label.set_text(Glib::ustring::compose(_(\"Really delete %1 now?\"), filename));"
msgstr ""
"std::cout &lt;&lt; Glib::ustring::compose(\n"
"             _(\"Current amount: %1 Future: %2\"), amount, future) &lt;&lt; std::endl;\n"
"\n"
"label.set_text(Glib::ustring::compose(_(\"Really delete %1 now?\"), filename));"

#: C/index-in.docbook:6811
msgid ""
"So you should either avoid this situation or use <ulink url=\"http://"
"developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html"
"\"><function>Glib::ustring::compose()</function></ulink> which supports "
"syntax such as: <_:programlisting-1/>"
msgstr ""
"因此你应该避免这种情况的出现或者使用<ulink url=\"http://developer.gnome.org/"
"glibmm/unstable/classGlib_1_1ustring.html\"><function>Glib::ustring::"
"compose()</function></ulink>以支持如下所示的语法：<_:programlisting-1/>"

#: C/index-in.docbook:6823
msgid "Assuming the displayed size of strings"
msgstr "假设显示字符串所需的空间"

#: C/index-in.docbook:6825
msgid ""
"You never know how much space a string will take on screen when translated. "
"It might very possibly be twice the size of the original English string. "
"Luckily, most <application>gtkmm</application> widgets will expand at "
"runtime to the required size."
msgstr ""
"你永远不知道一个字符串被翻译后要在屏幕上显示它需要消耗多少空间。它可能是原始"
"英文字符串的两倍甚至更多。幸运的是 <application>gtkmm</application>的多数部件"
"都能在运行时自动扩展到需要的尺寸。"

#: C/index-in.docbook:6829
msgid "Unusual words"
msgstr "\"黑话\""

#: C/index-in.docbook:6831
msgid ""
"You should avoid cryptic abbreviations, slang, or jargon. They are usually "
"difficult to translate, and are often difficult for even native speakers to "
"understand. For instance, prefer \"application\" to \"app\""
msgstr ""
"你应该避免使用不常见的用于例如缩写、俚语、行话。通常它们对于译者来说很难翻"
"译，甚至将该语言作为母语的译者也无法理解。例如，最好使用\"application\"而不是"
"\"app\""

#: C/index-in.docbook:6837
msgid "Using non-ASCII characters in strings"
msgstr "在字符串中使用非ASCII字符"

#: C/index-in.docbook:6839
msgid ""
"Currently, <application>gettext</application> does not support non-ASCII "
"characters (i.e. any characters with a code above 127) in source code. For "
"instance, you cannot use the copyright sign (©)."
msgstr ""
"当前，<application>gettext</application>并不支持在源代码中使用非ASCII字符。例"
"如，你不能使用版权标志（©）"

#: C/index-in.docbook:6845
msgid ""
"To work around this, you could write a comment in the source code just "
"before the string, telling the translators to use the special character if "
"it is available in their languages. For English, you could then make an "
"American English <filename>en_US.po</filename> translation which used that "
"special character."
msgstr ""
"要解决这个问题你可以使用注释提醒译者可以使用他们语言中可用的特殊字符。对于英"
"语用户你可以在美国英语<filename>en_US.po</filename>翻译中使用特殊字符。"

#: C/index-in.docbook:6853
msgid "Getting help with translations"
msgstr "获取翻译帮助"

#: C/index-in.docbook:6855
msgid ""
"If your program is free software, there is a whole <literal>GNOME</literal> "
"subproject devoted to helping you make translations, the <ulink url="
"\"https://wiki.gnome.org/TranslationProject/\"><literal>GNOME</literal> "
"Translation Project</ulink>."
msgstr ""
"如果你的程序是免费软件，有一个致力于帮助你制作翻译的<literal>GNOME</literal>"
"子项目：<ulink url=\"https://wiki.gnome.org/TranslationProject/"
"\"><literal>GNOME</literal>翻译项目</ulink>。"

#: C/index-in.docbook:6860
msgid ""
"The way it works is that you upload your source code to a git repository "
"where translators can access it, then contact the gnome-i18n mailing list "
"and ask to have your program added to the <ulink url=\"http://l10n.gnome.org/"
"module/\">list of modules to translate</ulink>."
msgstr ""
"它的工作方式是将你的源代码上传到git储存库，以便翻译人员可以访问它，然后联系"
"gnome-i18n请求将你的程序添加到<ulink url=\"http://l10n.gnome.org/module/\">待"
"翻译模块列表</ulink>中。"

#: C/index-in.docbook:6865
msgid ""
"Then you make sure you update the file <filename>POTFILES.in</filename> in "
"the <filename>po/</filename> subdirectory (<command>intltool-update -m</"
"command> can help with this) so that the translators always access updated "
"<filename>myprogram.pot</filename> files, and simply freeze the strings at "
"least a couple of days before you make a new release, announcing it on gnome-"
"i18n. Depending on the number of strings your program contains and how "
"popular it is, the translations will then start to tick in as "
"<filename>languagename.po</filename> files."
msgstr ""
"然后请确保更新<filename>po/</filename>子目录下的<filename>POTFILES.in</"
"filename>（<command>intltool-update -m</command>可以提供帮助），以便译者始终"
"可以访问更新好的<filename>myprogram.pot</filename>文件，并在发布新版本之前的"
"两三天在gnome-i18n邮件列表上宣布冻结字符串更改。根据程序所包含的字符串数数量"
"以及程序的受欢迎程度，译者将逐渐向你提交<filename>languagename.po</filename>"
"文件。"

#: C/index-in.docbook:6877
msgid ""
"Note that most language teams only consist of 1-3 persons, so if your "
"program contains a lot of strings, it might last a while before anyone has "
"the time to look at it. Also, most translators do not want to waste their "
"time (translating is a very time-consuming task) so if they do not assess "
"your project as being really serious (in the sense that it is polished and "
"being maintained) they may decide to spend their time on some other project."
msgstr ""
"请注意，大多数语言的翻译团队仅有1-3位成员，所以如果你的程序包含了很多的字符"
"串，则可能需要很长时间才有译者查看它。此外，大多数译者都不想浪费时间，因此如"
"果他们认为你的项目质量很低，他们可能不会想为你提供翻译。"

#: C/index-in.docbook:6889 C/index-in.docbook:6960
msgid "Custom Widgets"
msgstr "自定义部件"

#: C/index-in.docbook:6891
msgid ""
"<application>gtkmm</application> makes it very easy to derive new widgets by "
"inheriting from an existing widget class, either by deriving from a "
"container and adding child widgets, or by deriving from a single-item "
"widget, and changing its behaviour. But you might occasionally find that no "
"suitable starting point already exists. In this case, you can implement a "
"widget from scratch."
msgstr ""
"<application>gtkmm</application>可以很轻松的通过继承现有部件类、从容器派生并"
"向其中添加子部件、从单项部件派生并修改其行为等手段派生新的部件。但有时你会发"
"现找不到合适的起点。在这种情况下你可以从头实现部件。"

#: C/index-in.docbook:6898
msgid "Custom Containers"
msgstr "自定义容器"

#: C/index-in.docbook:6902
msgid ""
"<methodname>get_request_mode_vfunc()</methodname>: Return what <literal>Gtk::"
"SizeRequestMode</literal> is preferred by the container."
msgstr ""
"<methodname>get_request_mode_vfunc()</methodname>：返回容器的<literal>Gtk::"
"SizeRequestMode</literal>偏好。"

#: C/index-in.docbook:6903
msgid ""
"<methodname>measure_vfunc()</methodname>: Calculate the minimum and natural "
"width or height of the container."
msgstr ""
"<methodname>measure_vfunc()</methodname>：返回容器的最小自然宽度或高度。"

#: C/index-in.docbook:6904
msgid ""
"<methodname>on_size_allocate()</methodname>: Position the child widgets, "
"given the height and width that the container has actually been given."
msgstr ""
"<methodname>on_size_allocate()</methodname>：根据容器实际宽度和高度定位子部"
"件。"

#: C/index-in.docbook:6899
msgid ""
"When deriving a custom container widget directly from <classname>Gtk::"
"Widget</classname>, you should override the following virtual methods: <_:"
"itemizedlist-1/>"
msgstr ""
"直接从<classname>Gtk::Widget</classname>派生自定义容器部件时，应重写一下虚方"
"法：<_:itemizedlist-1/>"

#: C/index-in.docbook:6908
msgid ""
"The <methodname>get_request_mode_vfunc()</methodname>, "
"<methodname>measure_vfunc()</methodname>, and "
"<methodname>on_size_allocate()</methodname> virtual methods control the "
"layout of the child widgets. For instance, if your container has 2 child "
"widgets, with one below the other, your "
"<methodname>get_request_mode_vfunc()</methodname> might request height-for-"
"width layout. Then your <methodname>measure_vfunc()</methodname> might "
"report the maximum of the widths of the child widgets when asked to report "
"width, and it might report the sum of their heights when asked to report "
"height. If you want padding between the child widgets then you would add "
"that to the width and height too. Your widget's container will use this "
"result to ensure that your widget gets enough space, and not less. By "
"examining each widget's parent, and its parent, this logic will eventually "
"decide the size of the top-level window."
msgstr ""
"<methodname>get_request_mode_vfunc()</methodname>、"
"<methodname>measure_vfunc()</methodname>、<methodname>on_size_allocate()</"
"methodname>虚方法控制子部件的布局。例如，如果你的容器有两个子部件，一个在另一"
"个的下方，则你的<methodname>get_request_mode_vfunc()</methodname>可能会请求布"
"局高度适应宽度。然后你的<methodname>measure_vfunc()</methodname>可能会要求报"
"告宽度的时候报告子部件的最大宽度，在要求报告高度的时候要求子部件的高度之和。"
"如果你想要在子部件之间进行填充，则你应将填充部分算入宽高中。你的容器部件将用"
"这个结果确保部件获得足够的空间。通过对每个部件的父部件进行检查最终确认顶级窗"
"口的大小。"

#: C/index-in.docbook:6925
msgid ""
"You are not guaranteed to get the <literal>Gtk::SizeRequestMode</literal> "
"that you request. Therefore <methodname>measure_vfunc()</methodname> must "
"return sensible values for all reasonable values of its input parameters. "
"For a description of <methodname>measure_vfunc()</methodname>'s parameters "
"see also the description of <methodname>Gtk::Widget::measure()</methodname>, "
"which may be better documented than <methodname>measure_vfunc()</methodname>."
msgstr ""
"你无法确保得到你请求的<literal>Gtk::SizeRequestMode</literal>。因此，"
"<methodname>measure_vfunc()</methodname>必须为其所有合理的输入参数值返回合适"
"的值。有关<methodname>measure_vfunc()</methodname>参数的描述，查看"
"<methodname>Gtk::Widget::measure()</methodname>的描述可能比查看"
"<methodname>measure_vfunc()</methodname>的文档更好。"

#: C/index-in.docbook:6932
msgid ""
"<methodname>on_size_allocate()</methodname> receives the actual height and "
"width that the parent container has decided to give to your widget. This "
"might be more than the minimum, or even more than the natural size, for "
"instance if the top-level window has been expanded. You might choose to "
"ignore the extra space and leave a blank area, or you might choose to expand "
"your child widgets to fill the space, or you might choose to expand the "
"padding between your widgets. It's your container, so you decide."
msgstr ""
"<methodname>on_size_allocate()</methodname>接收父容器决定给你的部件的实际高度"
"和宽度。例如，如果顶层窗口被扩展，则该值将大于最小值，甚至大于自然大小。你可"
"以选择忽略多余的空间留出一个空白区域，或者选择扩展子部件以填充该空间，或者是"
"选择扩展部件之间的填充。"

#: C/index-in.docbook:6943
msgid ""
"This example implements a container with two child widgets, one above the "
"other. Of course, in this case it would be far simpler just to use a "
"vertical <classname>Gtk::Box</classname> or <classname>Gtk::Grid</classname>."
msgstr ""
"本示例实现了一个具有两个子部件的容器，一个在另一个上面。当然在这种情况下直接"
"使用垂直<classname>Gtk::Box</classname>或<classname>Gtk::Grid</classname>会更"
"简单。"

#: C/index-in.docbook:6948
msgid "Custom Container"
msgstr "自定义容器"

#: C/index-in.docbook:6954
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/custom/custom_container/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/custom/custom_container/\">源代码</ulink>"

#: C/index-in.docbook:6961
msgid ""
"By deriving directly from <classname>Gtk::Widget</classname> you can do all "
"the drawing for your widget directly, instead of just arranging child "
"widgets. For instance, a <classname>Gtk::Label</classname> draws the text of "
"the label, but does not do this by using other widgets."
msgstr ""
"通过从<classname>Gtk::Widget</classname>派生部件你可以为部件绘制所有的图形，"
"而不仅仅是排列子部件。例如：<classname>Gtk::Label</classname>不需要使用其他部"
"件即可绘制标签文本。"

#: C/index-in.docbook:6972
msgid ""
"<methodname>get_request_mode_vfunc()</methodname>: (optional) Return what "
"<literal>Gtk::SizeRequestMode</literal> is preferred by the widget."
msgstr ""
"<methodname>get_request_mode_vfunc()</methodname>：覆写此虚函数是可选的，返回"
"此部件的<literal>Gtk::SizeRequestMode</literal>偏好。"

#: C/index-in.docbook:6973
msgid ""
"<methodname>measure_vfunc()</methodname>: Calculate the minimum and natural "
"width or height of the widget."
msgstr ""
"<methodname>measure_vfunc()</methodname>：计算此部件的最小自然高度或宽度。"

#: C/index-in.docbook:6974
msgid ""
"<methodname>on_size_allocate()</methodname>: Position the widget, given the "
"height and width that it has actually been given."
msgstr ""
"<methodname>on_size_allocate()</methodname>：提供将实际给予部件的宽度和高度以"
"定位部件。"

#: C/index-in.docbook:6975
msgid ""
"<methodname>on_realize()</methodname>: Associate a <classname>Gdk::Surface</"
"classname> with the widget."
msgstr ""
"<methodname>on_realize()</methodname>：将一个<classname>Gdk::Surface</"
"classname>与部件相关联。"

#: C/index-in.docbook:6976
msgid ""
"<methodname>on_unrealize()</methodname>: (optional) Break the association "
"with the <classname>Gdk::Surface</classname>."
msgstr ""
"<methodname>on_unrealize()</methodname>：覆写此虚函数是可选的，断开"
"<classname>Gdk::Surface</classname>与部件的关联。"

#: C/index-in.docbook:6977
msgid "<methodname>on_map()</methodname>: (optional)"
msgstr "<methodname>on_map()</methodname>：覆写此虚函数是可选的。"

#: C/index-in.docbook:6978
msgid "<methodname>on_unmap()</methodname>: (optional)"
msgstr "<methodname>on_unmap()</methodname>：覆写此虚函数是可选的。"

#: C/index-in.docbook:6979
msgid ""
"<methodname>snapshot_vfunc()</methodname>: Create a render node, e.g. a "
"<classname>Cairo::Context</classname> node, and draw on it."
msgstr ""
"<methodname>snapshot_vfunc()</methodname>：创建一个渲染节点（例如：一个"
"<classname>Cairo::Context</classname>节点），并在其上进行绘制。"

#: C/index-in.docbook:6967
msgid ""
"When deriving from <classname>Gtk::Widget</classname>, you should override "
"the following virtual methods. The methods marked (optional) need not be "
"overridden in all custom widgets. The base class's methods may be "
"appropriate. <_:itemizedlist-1/>"
msgstr ""
"当你从<classname>Gtk::Widget</classname>派生部件时，你应该覆写以下虚函数。其"
"中标记为可选的的虚函数不必在所有自定义部件中都进行覆写。它们的基类方法通常情"
"况下已经很合适。<_:itemizedlist-1/>"

#: C/index-in.docbook:6983
msgid ""
"The first 3 methods in the previous table are also overridden in custom "
"containers. They are briefly described in the <link linkend=\"sec-custom-"
"containers\">Custom Containers</link> section."
msgstr ""
"上述前三个函数在自定义容器中也被覆写。它们在<link linkend=\"sec-custom-"
"containers\">自定义容器</link>小节做了简要说明。"

#: C/index-in.docbook:6989
msgid "Class Init and Instance Init Functions"
msgstr "类初始化和实例初始化函数"

#: C/index-in.docbook:6991
msgid ""
"Some <application>GTK</application> functions, if called at all, must be "
"called from the class init function. Some other <application>GTK</"
"application> functions, if called, must be called from the instance init "
"function. If your custom widget must call any of those functions, you can "
"derive a class from <classname>Glib::ExtraClassInit</classname> and derive "
"your custom class from that class. The following example shows how that's "
"done."
msgstr ""
"一些<application>GTK</application>函数必须在类的init函数中才能调用。另一些"
"<application>GTK</application>函数必须在实例的init函数中才能调用。如果你的自"
"定义部件必须调用这些函数中的任意一个，那么你可以从<classname>Glib::"
"ExtraClassInit</classname>派生一个类，并从该类派生你的自定义类。以下示例演示"
"了如何完成这些操作。"

#: C/index-in.docbook:7000
msgid "Custom Style Information"
msgstr "自定义样式信息"

#: C/index-in.docbook:7002
msgid ""
"Your widget class, whether it's derived directly from <classname>Gtk::"
"Widget</classname> or from another widget class, can read some style "
"information from a CSS (Cascading Style Sheets) file. The users of your "
"widget, or the users of an application program with your widget, can then "
"modify the style of your widget without modifying the source code. Useful "
"classes are <classname>Gtk::StyleContext</classname> and <classname>Gtk::"
"CssProvider</classname>. With the methods of <classname>Gtk::StyleContext</"
"classname> you can read the values of your widget's style information. CSS "
"files are described in the documentation of <application>GTK</application>. "
"The following example shows a simple use of <methodname>Gtk::StyleContext::"
"get_padding()</methodname>."
msgstr ""
"无论你的部件类是从<classname>Gtk::Widget</classname>还是从其他部件类派生的，"
"它都可以从CSS文件中读取样式信息。然后对于使用你的部件的用户或是使用你的部件的"
"应用程序的用户而言，他们可以不需要修改源代码就能修改部件的样式。用于实现此功"
"能的类是<classname>Gtk::StyleContext</classname>和<classname>Gtk::"
"CssProvider</classname>。你可以使用<classname>Gtk::StyleContext</classname>类"
"的方法读取部件样式信息。<application>GTK</application>文档描述了其对于CSS文件"
"的支持情况。以下是示例演示了<methodname>Gtk::StyleContext::get_padding()</"
"methodname>的简单用法。"

#: C/index-in.docbook:7016
msgid "This example implements a widget which draws Penrose triangles."
msgstr "本示例实现了绘制彭罗斯三角形的部件"

#: C/index-in.docbook:7019
msgid "Custom Widget"
msgstr "自定义部件"

#: C/index-in.docbook:7025
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/custom/custom_widget/\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/custom/custom_widget/\">源代码</ulink>"

#: C/index-in.docbook:7033
msgid "Multi-threaded programs"
msgstr "多线程程序"

#: C/index-in.docbook:7036
msgid "The constraints"
msgstr "约束条件"

#: C/index-in.docbook:7047
msgid ""
"These interactions arise from the fact that, amongst other things, a class "
"inheriting from <classname>sigc::trackable</classname> will, via that "
"inheritance, have a <classname>std::list</classname> object keeping track of "
"slots created by calls to <function>sigc::mem_fun()</function> representing "
"any of its non-static methods (more particularly it keeps a list of "
"callbacks which will null the connected slots on its destruction). Each "
"<classname>sigc::slot</classname> object also keeps, via <classname>sigc::"
"slot_rep</classname>, its own <classname>sigc::trackable</classname> object "
"to track any <classname>sigc::connection</classname> objects which it needs "
"to inform about its demise, and also has a function to deregister itself "
"from any <classname>sigc::trackable</classname> on disconnection or "
"destruction. <classname>sigc::signal</classname> objects also keep lists of "
"slots, which will be updated by a call to their <methodname>connect()</"
"methodname> method or calls to any <classname>sigc::connection</classname> "
"object relating to such a connection."
msgstr ""
"这些交互产生了以下事实：从<classname>sigc::trackable</classname>继承的类将从"
"该继承获得一个<classname>std::list</classname>对象，该对象用于对调用"
"<function>sigc::mem_fun()</function>所创建的槽（它表示任意非静态成员函数）进"
"行跟踪（更特别的是它还保留了一个回调列表，在其被销毁时将已连接的槽置空）。每"
"个<classname>sigc::slot</classname>通过<classname>sigc::slot_rep</classname>"
"保留其自己的<classname>sigc::trackable</classname>对象，用以跟踪任何它需要通"
"知其已消亡的<classname>sigc::connection</classname>对象，并且具有在任何"
"<classname>sigc::trackable</classname>断开连接或销毁时注销自身的能力。"
"<classname>sigc::signal</classname>对象还保留了槽列表，这个列表将通过调用它的"
"<methodname>connect()</methodname>方法或任何与该连接有关的<classname>sigc::"
"connection</classname>对象进行更新。"

#: C/index-in.docbook:7038
msgid ""
"Care is required when writing programs based on <application>gtkmm</"
"application> using multiple threads of execution, arising from the fact that "
"<application>libsigc++</application>, and in particular <classname>sigc::"
"trackable</classname>, are not thread-safe. That's because none of the "
"complex interactions that occur behind the scenes when using "
"<application>libsigc++</application> are protected by a mutex or other means "
"of synchronization. <_:footnote-1/>"
msgstr ""
"由于<application>libsigc++</application>（尤其是<classname>sigc::trackable</"
"classname>）不是线程安全的，所以在编写基于<application>gtkmm</application>的"
"多线程程序时需要格外小心。这是因为使用<application>libsigc++</application>时"
"在幕后发生的复杂交互不受互斥量或其他同步方式的保护。"

#: C/index-in.docbook:7071
msgid "The rules"
msgstr "规则"

#: C/index-in.docbook:7073
msgid ""
"This requires a number of rules to be observed when writing multi-threaded "
"programs using <application>gtkmm</application>. These are set out below, "
"but one point to note is that extra care is required when deriving classes "
"from <classname>sigc::trackable</classname>, because the effects are "
"unintuitive (see particularly points 4 and 5 below)."
msgstr ""
"在使用<application>gtkmm</application>编写多线程程序时需要遵守许多规则。这些"
"规则下下面列出，但要注意的一点是从<classname>sigc::trackable</classname>派生"
"类时需要格外小心，因为效果很不直观（特别是下述4、5条）。"

#: C/index-in.docbook:7084
msgid ""
"Use <classname>Glib::Dispatcher</classname> to invoke <application>gtkmm</"
"application> functions from worker threads (this is dealt with in more "
"detail in the next section)."
msgstr ""
"使用<classname>Glib::Dispatcher</classname>在工作线程中调用"
"<application>gtkmm</application>函数（这点将在下一节详细介绍）"

#: C/index-in.docbook:7092
msgid ""
"A <classname>sigc::signal</classname> object should be regarded as owned by "
"the thread which created it. Only that thread should connect a "
"<classname>sigc::slot</classname> object to the signal object, and only that "
"thread should <methodname>emit()</methodname> or call <methodname>operator()"
"()</methodname> on the signal, or null any connected <classname>sigc::slot</"
"classname> object. It follows (amongst other things) that any signal object "
"provided by a <application>gtkmm</application> widget should only be "
"operated on in the main GUI thread and any object deriving from "
"<classname>sigc::trackable</classname> having its non-static methods "
"referenced by slots connected to the signal object should only be destroyed "
"in that thread."
msgstr ""
"<classname>sigc::signal</classname>对象被创建其的线程所拥有。只有该线程应该将"
"<classname>sigc::slot</classname>对象连接到信号对象，并且只有该线程应该在"
"<methodname>emit()</methodname>信号或在信号上调用<methodname>operator()()</"
"methodname>或是将已连接的<classname>sigc::slot</classname>对象置空。因此任何"
"由<application>gtkmm</application>部件提供的信号对象都只应该在主GUI线程进行操"
"作，以及任何从<classname>sigc::trackable</classname>派生的对象（其非静态方法"
"由连接到信号对象的槽引用）都应该在该线程中销毁。"

#: C/index-in.docbook:7108
msgid ""
"Any <classname>sigc::connection</classname> object should be regarded as "
"owned by the thread in which the method returning the <classname>sigc::"
"connection</classname> object was called. Only that thread should call "
"<classname>sigc::connection</classname> methods on the object."
msgstr ""
"任何<classname>sigc::connection</classname>对象都应视线程的拥有者在此线程调用"
"了返回<classname>sigc::connection</classname>对象的方法。只有该线程才应在此对"
"象上调用<classname>sigc::connection</classname>方法。"

#: C/index-in.docbook:7118
msgid ""
"A <classname>sigc::slot</classname> object created by a call to "
"<function>sigc::mem_fun()</function> which references a method of a class "
"deriving from <classname>sigc::trackable</classname> should never be copied "
"to another thread, nor destroyed by a different thread than the one which "
"created it."
msgstr ""
"通过调用<function>sigc::mem_fun()</function>函数创建的<classname>sigc::slot</"
"classname>对象具有由<classname>sigc::trackable</classname>所派生类的成员函数"
"的引用，请勿将其复制到另一个线程中，也不要让除创建线程以外的线程销毁它。"

#: C/index-in.docbook:7128
msgid ""
"If a particular class object derives from <classname>sigc::trackable</"
"classname>, only one thread should create <classname>sigc::slot</classname> "
"objects representing any of the class's non-static methods by calling "
"<function>sigc::mem_fun()</function>. The first thread to create such a slot "
"should be regarded as owning the relevant object for the purpose of creating "
"further slots referencing <emphasis>any</emphasis> of its non-static methods "
"using that function, or nulling those slots by disconnecting them or "
"destroying the trackable object."
msgstr ""
"如果从<classname>sigc::trackable</classname>派生一个特定的类对象，只应有一个"
"线程通过调用<function>sigc::mem_fun()</function>创建代表该类任意非静态成员函"
"数的<classname>sigc::slot</classname>对象。第一个创建这样的槽的线程被视为拥有"
"相关对象的线程。这个线程可以对该类的<emphasis>任意</emphasis>非静态成员函数使"
"用该函数以创建槽，或者在<classname>sigc::trackable</classname>对象断开连接和"
"被销毁时将那些槽无效化。"

#: C/index-in.docbook:7142
msgid ""
"Although <application>glib</application> is itself thread-safe, any "
"<application>glibmm</application> wrappers which use <application>libsigc++</"
"application> will not be. So for example, only the thread in which a main "
"loop runs should call <methodname>Glib::SignalIdle::connect()</methodname>, "
"<methodname>Glib::SignalIO::connect()</methodname>, <methodname>Glib::"
"SignalTimeout::connect()</methodname>, <methodname>Glib::SignalTimeout::"
"connect_seconds</methodname> for that main loop, or manipulate any "
"<classname>sigc::connection</classname> object returned by them."
msgstr ""
"尽管<application>glib</application>自身是线程安全的，但是任何使用了"
"<application>libsigc++</application>的<application>glibmm</application>封装都"
"不会是线程安全的。因此只有在运行主循环的线程的主循环中才能调用"
"<methodname>Glib::SignalIdle::connect()</methodname>、<methodname>Glib::"
"SignalIO::connect()</methodname>、<methodname>Glib::SignalTimeout::"
"connect()</methodname>、<methodname>Glib::SignalTimeout::connect_seconds</"
"methodname>或是处理由它们返回的<classname>sigc::connection</classname>对象。"

#: C/index-in.docbook:7154
msgid ""
"The connect*_once() variants, <methodname>Glib::SignalIdle::connect_once()</"
"methodname>, <methodname>Glib::SignalTimeout::connect_once()</methodname>, "
"<methodname>Glib::SignalTimeout::connect_seconds_once()</methodname>, are "
"thread-safe for any case where the slot is not created by a call to "
"<function>sigc::mem_fun()</function> which represents a method of a class "
"deriving from <classname>sigc::trackable</classname>."
msgstr ""
"对于<methodname>Glib::SignalIdle::connect_once()</methodname>、"
"<methodname>Glib::SignalTimeout::connect_once()</methodname>、"
"<methodname>Glib::SignalTimeout::connect_seconds_once()</methodname>等"
"connect*_once()变体函数而言，只要它们使用的槽不是通过对<classname>sigc::"
"trackable</classname>派生类的成员函数调用<function>sigc::mem_fun()</function>"
"创建的，那么它们在任何情况下都是线程安全的。"

#: C/index-in.docbook:7172
msgid "Using Glib::Dispatcher"
msgstr "使用<classname>Glib::Dispatcher</classname>"

#: C/index-in.docbook:7174
msgid ""
"The slots connected to <classname>sigc::signal</classname> objects execute "
"in the thread which calls <methodname>emit()</methodname> or "
"<methodname>operator()()</methodname> on the signal. <classname>Glib::"
"Dispatcher</classname> does not behave this way: instead its connected slots "
"execute in the thread in which the <classname>Glib::Dispatcher</classname> "
"object was constructed (which must have a glib main loop). If a "
"<classname>Glib::Dispatcher</classname> object is constructed in the main "
"GUI thread (which will therefore be the receiver thread), any worker thread "
"can emit on it and have the connected slots safely execute "
"<application>gtkmm</application> functions."
msgstr ""
"连接到<classname>sigc::signal</classname>对象的槽将会在调用信号"
"<methodname>emit()</methodname>、<methodname>operator()()</methodname>方法的"
"线程被调用。而<classname>Glib::Dispatcher</classname>的行为与此相反：与其连接"
"的槽将在构造<classname>Glib::Dispatcher</classname>对象的线程执行（该线程必须"
"正在运行Glib主循环）。如果在GUI主线程上构造了<classname>Glib::Dispatcher</"
"classname>，任何工作线程都可以在其上调用<methodname>emit()</methodname>并让槽"
"安全的执行连接的<application>gtkmm</application>函数。"

#: C/index-in.docbook:7188
msgid ""
"Some thread safety rules on the use of <classname>Glib::Dispatcher</"
"classname> still apply. As mentioned, a <classname>Glib::Dispatcher</"
"classname> object must be constructed in the receiver thread (the thread in "
"whose main loop it will execute its connected slots). By default this is the "
"main program thread, although there is a <classname>Glib::Dispatcher</"
"classname> constructor which can take the <classname>Glib::MainContext</"
"classname> object of any thread which has a main loop. Only the receiver "
"thread should call <methodname>connect()</methodname> on the "
"<classname>Glib::Dispatcher</classname> object, or manipulate any related "
"<classname>sigc::connection</classname> object, unless additional "
"synchronization is employed. However, any worker thread can safely emit on "
"the <classname>Glib::Dispatcher</classname> object without any locking once "
"the receiver thread has connected the slots, provided that it is constructed "
"before the worker thread is started (if it is constructed after the thread "
"has started, additional synchronization will normally be required to ensure "
"visibility)."
msgstr ""
"一些线程安全规则对于<classname>Glib::Dispatcher</classname>依旧适用。如前所"
"述，必须在接收器线程（将在该线程的主循环中执行连接的槽）构造<classname>Glib::"
"Dispatcher</classname>对象。默认情况下接收器线程应该是程序的主进程，尽管"
"<classname>Glib::Dispatcher</classname>有一个可以接受<classname>Glib::"
"MainContext</classname>对象为参数并且可以在任何运行Glib主循环的线程中调用的构"
"造函数。只有接受者线程才应该在<classname>Glib::Dispatcher</classname>对象上调"
"用<methodname>connect()</methodname>或操纵相关的<classname>sigc::connection</"
"classname>对象，除非你为此提供了额外的同步措施。一旦接收器线程连接了槽，任何"
"工作现场都可以不加锁直接在<classname>Glib::Dispatcher</classname>对象上调用"
"<methodname>emit()</methodname>，但前提是该对象是在工作线程启动前构造的，如果"
"不是则需要进行额外的同步以确保可见性。"

#: C/index-in.docbook:7208
msgid ""
"Aside from the fact that connected slots always execute in the receiver "
"thread, <classname>Glib::Dispatcher</classname> objects are similar to "
"<classname>sigc::signal&lt;void()&gt;</classname> objects. They therefore "
"cannot pass unbound arguments nor return a value. The best way to pass "
"unbound arguments is with a thread-safe (asynchronous) queue. At the time of "
"writing <application>glibmm</application> does not have one, although most "
"people writing multi-threaded code will have one available to them (they are "
"relatively easy to write although there are subtleties in combining thread "
"safety with strong exception safety)."
msgstr ""
"除了连接的槽在接收者线程执行以外，<classname>Glib::Dispatcher</classname>对象"
"的行为与<classname>sigc::signal&lt;void()&gt;</classname>对象十分相似。因此它"
"们不能传递未绑定的参数，也不能返回值。要传递未绑定参数最好的方法是使用线程安"
"全的（同步）队列。尽管大多数编写多线程代码的人都会有一个可用的多线程代码，但"
"是编写<application>glibmm</application>时没有（尽管线程安全与强异常安全结合有"
"些微妙，但编写它们相对容易）。"

#: C/index-in.docbook:7221
msgid ""
"A <classname>Glib::Dispatcher</classname> object can be emitted on by the "
"receiver thread as well as by a worker thread, although this should be done "
"within reasonable bounds. On unix-like systems <classname>Glib::Dispatcher</"
"classname> objects share a single common pipe, which could in theory at "
"least fill up on a very heavily loaded system running a program with a very "
"large number of <classname>Dispatcher</classname> objects in use. Were the "
"pipe to fill up before the receiver thread's main loop has had an "
"opportunity to read from it to empty it, and the receiver thread attempt to "
"emit and so write to it when it is in that condition, the receiver thread "
"would block on the write, so deadlocking. Where the receiver thread is to "
"emit, a normal <classname>sigc::signal&lt;void()&gt;</classname> object "
"could of course be used instead."
msgstr ""
"接收者线程和工作线程都可以调用<classname>Glib::Dispatcher</classname>的"
"<methodname>emit()</methodname>方法，虽然此操作需要在合理的范围内进行。在类"
"Unix系统上<classname>Glib::Dispatcher</classname>共享同一个公共管道，从理论上"
"讲在一个负载很大的系统上运行使用很大数量<classname>Dispatcher</classname>对象"
"的程序至少可以填满系统。如果在接收者线程的主循环有机会读取并清空管道之前，管"
"道已填满且接收器线程在此时尝试对<classname>Dispatcher</classname>调用"
"<methodname>emit()</methodname>并因此对管道进行写入，这样会导致死锁。当然在接"
"收者线程想要发出信号可以使用普通的<classname>sigc::signal&lt;void()&gt;</"
"classname>对象。"

#: C/index-in.docbook:7241
msgid ""
"This is an example program with two threads, one GUI thread, like in all "
"<application>gtkmm</application> programs, and one worker thread. The worker "
"thread is created when you press the <literal>Start work</literal> button. "
"It is deleted when the work is finished, when you press the <literal>Stop "
"work</literal> button, or when you press the <literal>Quit</literal> button."
msgstr ""
"这是一个具有两个线程的示例程序，一个与所有<application>gtkmm</application>程"
"序一样的GUI线程，和一个工作线程。当你按下<literal>Start work</literal>按钮时"
"将创建工作线程，当工作完成或你按下<literal>Stop work</literal>按钮或是你按下"
"<literal>Quit</literal>按钮时该线程将被删除。"

#: C/index-in.docbook:7249
msgid ""
"A <classname>Glib::Dispatcher</classname> is used for sending notifications "
"from the worker thread to the GUI thread. The <classname>ExampleWorker</"
"classname> class contains data which is accessed by both threads. This data "
"is protected by a <classname>std::mutex</classname>. Only the GUI thread "
"updates the GUI."
msgstr ""
"<classname>Glib::Dispatcher</classname>被用于工作线程向GUI线程发送通知。"
"<classname>ExampleWorker</classname>包含两个线程都可以访问的数据。该数据被一"
"个<classname>std::mutex</classname>保护。只有GUI线程对GUI进行更新。"

#: C/index-in.docbook:7257
msgid ""
"Compiling and linking a multi-threaded program can require special compiler "
"and linker options. If you use the <application>g++</application> compiler, "
"add the <literal>-pthread</literal> option. Other compilers may require "
"other options. If you build with <application>meson</application>, it "
"handles the multi-threading complications for you, if you add "
"<function>dependency('threads')</function>."
msgstr ""
"编译和链接多线程程序可能需要特殊的编译和链接参数。如果你使用<application>g+"
"+</application>编译器你需要添加<literal>-pthread</literal>选项。其他编译器可"
"能会要求使用其他选项。如果你使用<application>meson</application>构建程序，如"
"果你在构建脚本中添加了<function>dependency('threads')</function>，它会帮你处"
"理多线程的复杂性。"

#: C/index-in.docbook:7266
msgid "Multi-Threaded Program"
msgstr "多线程程序"

#: C/index-in.docbook:7272
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/multithread\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/multithread\">源代码</ulink>"

#: C/index-in.docbook:7279
msgid "Recommended Techniques"
msgstr "推荐技术"

#: C/index-in.docbook:7281
msgid ""
"This section is simply a gathering of wisdom, general style guidelines and "
"hints for creating <application>gtkmm</application> applications."
msgstr ""
"本小节将向你展示一些创建<application>gtkmm</application>应用程序的智慧、风格"
"指南和提示。"

#: C/index-in.docbook:7285
msgid ""
"Use GNU <application>autoconf</application> and <application>automake</"
"application>! They are your friends :) <application>Automake</application> "
"examines C files, determines how they depend on each other, and generates a "
"<filename>Makefile</filename> so the files can be compiled in the correct "
"order. <application>Autoconf</application> permits automatic configuration "
"of software installation, handling a large number of system quirks to "
"increase portability."
msgstr ""
"使用GNU <application>autoconf</application>和<application>automake</"
"application>。<application>Automake</application>检查C文件，确定它们之间的依"
"赖关系，并生成<filename>Makefile</filename>，从而以正确的顺序编译文件。"
"<application>Autoconf</application>允许自动配置软件的安装，处理大量来自系统本"
"身的差异以增强可移植性。"

#: C/index-in.docbook:7295
msgid ""
"Subclass Widgets to better organize your code. You should probably subclass "
"your main <classname>Window</classname> at least. Then you can make your "
"child Widgets and signal handlers members of that class."
msgstr ""
"子类部件可以更好的组织你的代码。至少你的主窗口类应该继承<classname>Window</"
"classname>。这样你可以使主窗口的子部件和信号处理函数成为该类的成员。"

#: C/index-in.docbook:7300
msgid ""
"Create your own signals instead of passing pointers around. Objects can "
"communicate with each other via signals and signal handlers. This is much "
"simpler than objects holding pointers to each other and calling each other's "
"methods. <application>gtkmm</application>'s classes uses special versions of "
"<classname>sigc::signal</classname>, but you should use normal "
"<classname>sigc::signal</classname>s, as described in the "
"<application>libsigc++</application> documentation."
msgstr ""
"创建你自己的信号而不是传递指针。对象可以通过信号和信号处理函数相互通信。这比"
"持有指向彼此的指针并以此调用彼此的成员函数要简单明了的多。"
"<application>gtkmm</application>类使用特殊版本的<classname>sigc::signal</"
"classname>，但你应该使用<application>libsigc++</application>所述的正常"
"<classname>sigc::signal</classname>。"

#: C/index-in.docbook:7309
msgid "Application Lifetime"
msgstr "应用程序生命周期"

#: C/index-in.docbook:7310
msgid ""
"Most applications will have only one <classname>Window</classname>, or only "
"one main window. These applications can use the <methodname>Gtk::"
"Application::run(Gtk::Window&amp; window)</methodname> or <methodname>Gtk::"
"Application::run(Gtk::Window&amp; window, int argc, char** argv)</"
"methodname> overloads. They show the window and return when the window has "
"been hidden. This might happen when the user closes the window, or when your "
"code decides to <methodname>hide()</methodname> the window. You can prevent "
"the user from closing the window (for instance, if there are unsaved "
"changes) by overriding <methodname>Gtk::Window::on_delete_event()</"
"methodname>."
msgstr ""
"大多数应用程序只有一个<classname>Window</classname>或一个主窗口。这些应用程序"
"可以使用<methodname>Gtk::Application::run(Gtk::Window&amp; window)</"
"methodname>或<methodname>Gtk::Application::run(Gtk::Window&amp; window, int "
"argc, char** argv)</methodname>重载。它们显示窗口并当用户关闭窗口或你的代码决"
"定调用<methodname>hide()</methodname>时返回。你可以通过覆写<methodname>Gtk::"
"Window::on_delete_event()</methodname>成员函数来阻止用户关闭窗口（例如，当有"
"未保存变更你可能想弹出对话框询问用户是否确定要关闭窗口，再根据用户选择确定是"
"否要关闭窗口）。"

#: C/index-in.docbook:7319
msgid "Most of our examples use this technique."
msgstr "我们的大多数示例都是用这种技术。"

#: C/index-in.docbook:7323
msgid "Using a <application>gtkmm</application> widget"
msgstr "使用<application>gtkmm</application>部件"

#: C/index-in.docbook:7325
msgid ""
"Our examples all tend to have the same structure. They follow these steps "
"for using a <classname>Widget</classname>:"
msgstr ""
"我们的示例都倾向于使用相同的结构。它们按以下步骤使用<classname>Widget</"
"classname>："

#: C/index-in.docbook:7334
msgid ""
"Declare a variable of the type of <classname>Widget</classname> you wish to "
"use, generally as member variable of a derived container class. You could "
"also declare a pointer to the widget type, and then create it with "
"<literal>new</literal> in your code. Even when using the widget via a "
"pointer, it's still probably best to make that pointer a member variable of "
"a container class so that you can access it later."
msgstr ""
"声明一个你想要使用的<classname>Widget</classname>类型变量，通常是作为容器派生"
"类的成员变量。你还可以声明一个指向部件类型的指针，然后在你的代码中使用"
"<literal>new</literal>创建它。即使通过指针使用部件，也应该使该指针成为容器类"
"的成员变量，以便你后续访问它。"

#: C/index-in.docbook:7345
msgid ""
"Set the attributes of the widget. If the widget has no default constructor, "
"then you will need to initialize the widget in the initalizer list of your "
"container class's constructor."
msgstr ""
"设置部件的属性。如果部件没有默认构造函数，则你需要在容器类的构造函数的初始化"
"列表中初始化部件。"

#: C/index-in.docbook:7351
msgid "Connect any signals you wish to use to the appropriate handlers."
msgstr "为所以你需要使用的信号连接合适的信号处理函数。"

#: C/index-in.docbook:7357
msgid ""
"Pack the widget into a container using the appropriate call, e.g. "
"<methodname>Gtk::Box::append()</methodname>."
msgstr ""
"调用适当的函数将部件装入容器中，例如：<methodname>Gtk::Box::append()</"
"methodname>。"

#: C/index-in.docbook:7367
msgid ""
"If you don't want all widgets to be shown, call <methodname>Gtk::Widget::"
"hide()</methodname> on the widgets that you don't want to show. If a "
"container widget is hidden, all of its child widgets are also hidden, even "
"if <methodname>hide()</methodname> is not called on the child widgets."
msgstr ""
"如果你不希望显示部件，请对不想要显示的部件调用<methodname>Gtk::Widget::"
"hide()</methodname>可以将其隐藏，当一个容器部件被隐藏，它的所有子部件将一并被"
"隐藏，即便你没有在那些子部件上调用<methodname>hide()</methodname>。"

#: C/index-in.docbook:7378
msgid "Building applications"
msgstr "构建应用程序"

#: C/index-in.docbook:7380
msgid ""
"This chapter is similar to the \"Building applications\" chapter in the "
"<ulink url=\"https://developer.gnome.org/gtk4/unstable/\">GTK4 Reference "
"Manual</ulink>. The same application is built, but <application>gtkmm</"
"application> is used instead of <application>GTK</application>."
msgstr ""
"本章节与<ulink url=\"https://developer.gnome.org/gtk4/unstable/\">GTK4参考文"
"档</ulink>的\"Building applications\"章节十分类似。"

#: C/index-in.docbook:7389
msgid "The binary file"
msgstr "二进制文件"

#: C/index-in.docbook:7390
msgid "This gets installed in <filename>/usr/bin</filename>."
msgstr "这将被安装在<filename>/usr/bin</filename>。"

#: C/index-in.docbook:7393
msgid "A desktop file"
msgstr "桌面文件"

#: C/index-in.docbook:7394
msgid ""
"The desktop file provides important information about the application to the "
"desktop shell, such as its name, icon, D-Bus name, commandline to launch it, "
"etc. It is installed in <filename>/usr/share/applications</filename>."
msgstr ""
"桌面文件为桌面shell提供了于应用程序有关的重要信息，例如应用程序的名称、图标D-"
"Bus名、启动时的命令行等。此文件将安装在<filename>/usr/share/applications</"
"filename>。"

#: C/index-in.docbook:7399
msgid "An icon"
msgstr "图标"

#: C/index-in.docbook:7400
msgid ""
"The icon gets installed in <filename>/usr/share/icons/hicolor/48x48/apps</"
"filename>, where it will be found regardless of the current theme."
msgstr ""
"图标将被安装在<filename>/usr/share/icons/hicolor/48x48/apps</filename>，无论"
"当前主题是什么你都可以在其中找到图标。"

#: C/index-in.docbook:7404
msgid "A settings schema"
msgstr "设置模式"

#: C/index-in.docbook:7405
msgid ""
"If the application uses <classname>Gio::Settings</classname>, it will "
"install its schema in <filename>/usr/share/glib-2.0/schemas</filename>, so "
"that tools like dconf-editor can find it."
msgstr ""
"如果应用程序使用了<classname>Gio::Settings</classname>，它需要将它的模式安装"
"到<filename>/usr/share/glib-2.0/schemas</filename>，以便dconf-editor之类的工"
"具可以找到它。"

#: C/index-in.docbook:7410
msgid "Other resources"
msgstr "其他资源"

#: C/index-in.docbook:7411
msgid ""
"Other files, such as <classname>Gtk::Builder</classname> ui files, are best "
"loaded from resources stored in the application binary itself. This "
"eliminates the need for most of the files that would traditionally be "
"installed in an application-specific location in <filename>/usr/share</"
"filename>."
msgstr ""
"像<classname>Gtk::Builder</classname>UI文件这样的其他文件，最好从储存应用程序"
"自身的二进制中加载。这样就不需要按照传统将大多数文件安装在<filename>/usr/"
"share</filename>中特定应用程序的位置。"

#: C/index-in.docbook:7385
msgid "An application consists of a number of files: <_:variablelist-1/>"
msgstr "一个应用程序由许多文件组成：<_:variablelist-1/>"

#: C/index-in.docbook:7419
msgid ""
"<application>gtkmm</application> includes application support that is built "
"on top of <classname>Gio::Application</classname>. In this chapter we'll "
"build a simple application by starting from scratch, adding more and more "
"pieces over time. Along the way, we'll learn about <classname>Gtk::"
"Application</classname>, <classname>Gtk::Builder</classname>, resources, "
"menus, settings, <classname>Gtk::HeaderBar</classname>, <classname>Gtk::"
"Stack</classname>, <classname>Gtk::SearchBar</classname>, <classname>Gtk::"
"ListBox</classname>, and more."
msgstr ""
"<application>gtkmm</application>包括构建在<classname>Gio::Application</"
"classname>上的应用程序支持。在本章中我们将从头开始构建一个简单的应用程序。然"
"后逐渐向其中添加更多内容。在此过程中我们将学习<classname>Gtk::Application</"
"classname>、<classname>Gtk::Builder</classname>、资源、菜单、设置、"
"<classname>Gtk::HeaderBar</classname>、<classname>Gtk::Stack</classname>、"
"<classname>Gtk::SearchBar</classname>、<classname>Gtk::ListBox</classname>等"
"内容。"

#: C/index-in.docbook:7428
msgid ""
"The full, buildable sources for these examples can be found in the "
"<filename>examples/book/buildapp</filename> directory of the "
"<application>gtkmm-documentation</application> source distribution, or "
"online in the <ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-"
"documentation/tree/master/examples/book/buildapp\"><application>gtkmm-"
"documentation</application> git repository</ulink>. You can build each "
"example separately by using <command>meson</command> and <command>ninja</"
"command> with the <filename>meson.build</filename> file or by using "
"<command>make</command> with the <filename>Makefile.example</filename> file. "
"For more information, see the <filename>README</filename> included in the "
"<filename>buildapp</filename> directory."
msgstr ""
"这些示例的完整可构建源代码可以从<application>gtkmm-documentation</"
"application>源目录的<filename>examples/book/buildapp</filename>文件夹中找到，"
"或者在<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/"
"master/examples/book/buildapp\"><application>gtkmm-documentation</"
"application>git仓库</ulink>可以找到。你可以通过<filename>meson.build</"
"filename>文件使用<command>meson</command>和<command>ninja</command>，或是通过"
"<filename>Makefile.example</filename>文件使用<command>make</command>以编译每"
"一个示例。更多有关信息，请参见<filename>buildapp</filename>目录中包含的"
"<filename>README</filename>文件。"

#: C/index-in.docbook:7441 C/index-in.docbook:7485
msgid "A trivial application"
msgstr "简单的应用程序"

#: C/index-in.docbook:7443
msgid ""
"When using <classname>Gtk::Application</classname>, the <function>main()</"
"function> function can be very simple. We just call <methodname>Gtk::"
"Application::run()</methodname> on an instance of our application class."
msgstr ""
"使用<classname>Gtk::Application</classname>时，<function>main()</function>函"
"数可以非常简单。我们只是在应用程序类实例上调用<methodname>Gtk::Application::"
"run()</methodname>。"

#: C/index-in.docbook:7449
msgid ""
"All the application logic is in the application class, which is a subclass "
"of <classname>Gtk::Application</classname>. Our example does not yet have "
"any interesting functionality. All it does is open a window when it is "
"activated without arguments, and open the files it is given, if it is "
"started with arguments. (Or rather, our application class tries to open the "
"files, but our subclassed application window does not yet do what it's told "
"to do.)"
msgstr ""
"应用程序的所有逻辑都在应用程序类中，该类是<classname>Gtk::Application</"
"classname>的子类。现在在我们的示例中还没有任何很有趣的功能。它要做的事就是在"
"没有参数的情况下打开一个窗口，或在有参数的启动状态下打开给定的文件（准确的说"
"我们的应用程序类尝试打开文件，但是应用程序的窗口子类并没有执行应执行的操"
"作）。"

#: C/index-in.docbook:7458
msgid ""
"To handle these two cases, we override <methodname>signal_activate()</"
"methodname>'s default handler, which gets called when the application is "
"launched without commandline arguments, and <methodname>signal_open()</"
"methodname>'s default handler, which gets called when the application is "
"launched with commandline arguments."
msgstr ""
"为了处理这两种情况，我们覆写了<methodname>signal_activate()</methodname>和"
"<methodname>signal_open()</methodname>的默认处理函数，在没有命令行参数时前者"
"的处理函数被调用，有命令行参数时后者的处理函数被调用。"

#: C/index-in.docbook:7465
msgid ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/"
"classGio_1_1Application.html\">Gio::Application Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/"
"classGio_1_1Application.html\">Gio::Application参考</ulink>"

#: C/index-in.docbook:7466
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1Application.html\">Gtk::Application Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1Application.html\">Gtk::Application参考</ulink>"

#: C/index-in.docbook:7468
msgid ""
"Another important class that is part of the application support in "
"<application>gtkmm</application> is <classname>Gtk::ApplicationWindow</"
"classname>. It is typically subclassed as well. Our subclass does not do "
"anything yet, so we will just get an empty window."
msgstr ""
"作为<application>gtkmm</application>应用程序支持的另一个重要的类是"
"<classname>Gtk::ApplicationWindow</classname>。通常我们也会将其子类化。此时我"
"们的子类还没有做任何事，所以我们只会得到一个空白的窗口。"

#: C/index-in.docbook:7474
msgid ""
"As part of the initial setup of our application, we also create an icon and "
"a desktop file. Note that @bindir@ in the desktop file needs to be replaced "
"with the actual path to the binary before this desktop file can be used."
msgstr ""
"作为应用程序初始设置的一部分，我们还为其创建了一个图标和桌面文件。请注意在使"
"用这个桌面文件之前你还需要将文件中的@bindir@替换为应用程序二进制的实际路径。"

#: C/index-in.docbook:7480
msgid "Here is what we've achieved so far:"
msgstr "到目前为止我们做到了："

#: C/index-in.docbook:7491
msgid ""
"This does not look very impressive yet, but our application is already "
"presenting itself on the session bus, it has single-instance semantics, and "
"it accepts files as commandline arguments."
msgstr ""
"这看起来还无法让人印象深刻，但是我们的应用程序已经在会话总线上展示了自己。现"
"在它具有单实例语义，并且接受命令行参数作为文件路径。"

#: C/index-in.docbook:7496
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step1\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step1\">源代码</ulink>"

#: C/index-in.docbook:7501 C/index-in.docbook:7544
msgid "Populating the window"
msgstr "填充窗口"

#: C/index-in.docbook:7503
msgid ""
"In this step, we use a <classname>Gtk::Builder</classname> instance to "
"associate a <classname>Gtk::Builder</classname> ui file with our application "
"window class."
msgstr ""
"再次步骤中，我们使用<classname>Gtk::Builder</classname>实例将<classname>Gtk::"
"Builder</classname> UI文件和我们的应用程序窗口类相关联。"

#: C/index-in.docbook:7508
msgid ""
"Our simple ui file gives the window a title, and puts a <classname>Gtk::"
"Stack</classname> widget as the main content."
msgstr ""
"我们的简单UI文件为窗口设定了一个标题，并将一个<classname>Gtk::Stack</"
"classname>文件放入了窗口中。"

#: C/index-in.docbook:7513
msgid ""
"To make use of this file in our application, we revisit our <classname>Gtk::"
"ApplicationWindow</classname> subclass, and call <methodname>Gtk::Builder::"
"create_from_resource()</methodname> and <methodname>Gtk::Builder::"
"get_widget_derived()</methodname> from the <methodname>ExampleAppWindow::"
"create()</methodname> method to get an instance of our subclassed "
"<classname>Gtk::ApplicationWindow</classname>. See the <link linkend=\"sec-"
"builder-using-derived-widgets\">Using derived widgets</link> section for "
"more information about <methodname>get_widget_derived()</methodname>."
msgstr ""
"为了在我们的应用程序中使用这个文件，我们重访<classname>Gtk::"
"ApplicationWindow</classname>子类，并在<methodname>ExampleAppWindow::"
"create()</methodname>成员函数中调用<methodname>Gtk::Builder::"
"create_from_resource()</methodname>和<methodname>Gtk::Builder::"
"get_widget_derived()</methodname>以获取我们的<classname>Gtk::"
"ApplicationWindow</classname>子类的实例。更多有关的"
"<methodname>get_widget_derived()</methodname>的信息，请参见<link linkend="
"\"sec-builder-using-derived-widgets\">使用派生部件</link>小节。"

#: C/index-in.docbook:7532
#, no-wrap
msgid "$ glib-compile-resources --target=resources.c --generate-source exampleapp.gresource.xml"
msgstr "$ glib-compile-resources --target=resources.c --generate-source exampleapp.gresource.xml"

#: C/index-in.docbook:7524
msgid ""
"You may have noticed that we use the <methodname>_from_resource()</"
"methodname> variant of the method that reads the ui file. Now we need to use "
"<application>GLib</application>'s resource functionality to include the ui "
"file in the binary. This is commonly done by listing all resources in a ."
"gresource.xml file. This file has to be converted into a C source file that "
"will be compiled and linked into the application together with the other "
"source files. To do so, we use the <application>glib-compile-resources</"
"application> utility: <_:screen-1/> The <link linkend=\"sec-gio-resource"
"\">Gio::Resource and glib-compile-resources</link> section contains more "
"information about resource files. If you build with Meson, use the "
"<function>compile_resources()</function> function in Meson's <ulink url="
"\"https://mesonbuild.com/Gnome-module.html\">GNOME module</ulink>."
msgstr ""
"你可能已经注意到了，我们使用<methodname>_from_resource()</methodname>变体方法"
"读取UI文件。现在，我们要使用<application>GLib</application>资源功能将这个UI文"
"件放入二进制中。通常我们通过在.gresource.xml文件中列出所有资源来完成此操作。"
"该文件必须被转换为C源文件，并将其与其他源文件一并编译链接到应用程序中去。为"
"此，我们使用了<application>glib-compile-resources</application>实用程序：<_:"
"screen-1/> <link linkend=\"sec-gio-resource\">Gio::Resource和glib-compile-"
"resources</link>小节包含了与资源文件有关的信息。如果你使用Meson进行编译，请使"
"用Meson <ulink url=\"https://mesonbuild.com/Gnome-module.html\">GNOME模块</"
"ulink>中的<function>compile_resources()</function>函数。"

#: C/index-in.docbook:7539
msgid "Our application now looks like this:"
msgstr "我们的应用程序现在看起来像这样："

#: C/index-in.docbook:7550
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step2\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step2\">源代码</ulink>"

#: C/index-in.docbook:7555 C/index-in.docbook:7591
msgid "Opening files"
msgstr "打开文件"

#: C/index-in.docbook:7557
msgid ""
"In this step, we make our application show the contents of all the files "
"that it is given on the commandline."
msgstr "在这一步中，我们使我们的应用程序显示由命令行参数给定的文件的所有内容。"

#: C/index-in.docbook:7562
msgid ""
"To this end, we add a data member to our application window and keep a "
"pointer to the <classname>Gtk::Stack</classname> there. We get the pointer "
"with a call to <methodname>Gtk::Builder::get_widget()</methodname> in the "
"application window's constructor."
msgstr ""
"为此，我们向我们的应用程序窗口中添加一个数据成员，此保持一个指向"
"<classname>Gtk::Stack</classname>的指针。我们通过在应用程序窗口的构造函数中调"
"用<methodname>Gtk::Builder::get_widget()</methodname>获得指向该子部件的指针。"

#: C/index-in.docbook:7568
msgid ""
"Now we revisit the <methodname>ExampleAppWindow::open_file_view()</"
"methodname> method that is called for each commandline argument, and "
"construct a <classname>Gtk::TextView</classname> that we then add as a page "
"to the stack."
msgstr ""
"现在我们重访对每个命令行参数都会调用的<methodname>ExampleAppWindow::"
"open_file_view()</methodname>成员函数，并构造一个<classname>Gtk::TextView</"
"classname>然后将其作为页面添加到<classname>Gtk::Stack</classname>中。"

#: C/index-in.docbook:7574
msgid ""
"Lastly, we add a <classname>Gtk::StackSwitcher</classname> to the titlebar "
"area in the ui file, and we tell it to display information about our stack."
msgstr ""
"最后，我们将<classname>Gtk::StackSwitcher</classname>添加到UI文件的标题栏区"
"域，并告诉它如何显示<classname>Gtk::Stack</classname>的相关信息。"

#: C/index-in.docbook:7579
msgid ""
"The stack switcher gets all its information it needs to display tabs from "
"the stack that it belongs to. Here, we are passing the label to show for "
"each file as the last argument to the <methodname>Gtk::Stack::add()</"
"methodname> method."
msgstr ""
"堆切换器(StackSwitcher)从其所属的堆(Stack)中获取其所需的关于显示选项卡的相关"
"信息。在这，作为<methodname>Gtk::Stack::add()</methodname>方法的最后一个参"
"数，我们为每个显示的文件传递一个标签。"

#: C/index-in.docbook:7586
msgid "Our application is beginning to take shape:"
msgstr "我们的应用程序开始成形："

#: C/index-in.docbook:7597
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step3\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step3\">源代码</ulink>"

#: C/index-in.docbook:7602 C/index-in.docbook:7637
msgid "A menu"
msgstr "菜单"

#: C/index-in.docbook:7604
msgid ""
"The menu is shown at the right side of the headerbar. It is meant to collect "
"infrequently used actions that affect the whole application."
msgstr "菜单显示在标题栏的右侧。它旨在放置所有应用程序不常用的动作。"

#: C/index-in.docbook:7609
msgid ""
"Just like the application window, we specify our menu in a ui file, and add "
"it as a resource to our binary."
msgstr ""
"就像应用程序窗口一样，我们在UI文件中指定一个菜单，并将其作为资源添加到二进制"
"中。"

#: C/index-in.docbook:7614
msgid ""
"To make the menu appear, we have to load the ui file and associate the "
"resulting menu model with the menu button that we've added to the headerbar. "
"Since menus work by activating <classname>Gio::Action</classname>s, we also "
"have to add a suitable set of actions to our application."
msgstr ""
"为了使菜单出现，我们必须加载UI文件，并将生成的菜单模型与添加到标题栏右侧的菜"
"单按钮相关联。由于菜单通过激活<classname>Gio::Action</classname>工作，我们还"
"需要向应用程序中添加一组合适的动作。"

#: C/index-in.docbook:7621
msgid ""
"Adding the actions is best done in the <methodname>on_startup()</methodname> "
"default signal handler, which is guaranteed to be called once for each "
"primary application instance."
msgstr ""
"最好在<methodname>on_startup()</methodname>的默认信号处理函数中完成添加动作，"
"并确保每个应用程序实例都只调用一次。"

#: C/index-in.docbook:7626
msgid ""
"Our preferences menu item does not do anything yet, but the Quit menu item "
"is fully functional. It can also be activated by the usual Ctrl-Q shortcut. "
"The shortcut is added with <methodname>Gtk::Application::"
"set_accel_for_action()</methodname>."
msgstr ""
"现在我们的首选项菜单还什么都不做，但是退出菜单项是有效的。也可以用常用的Ctrl-"
"Q快捷键激活它。快捷键通过<methodname>Gtk::Application::"
"set_accel_for_action()</methodname>添加。"

#: C/index-in.docbook:7632
msgid "The menu looks like this:"
msgstr "菜单如下所示"

#: C/index-in.docbook:7643
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step4\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step4\">源代码</ulink>"

#: C/index-in.docbook:7648
msgid "A preference dialog"
msgstr "首选项对话框"

#: C/index-in.docbook:7650
msgid ""
"A typical application will have some preferences that should be remembered "
"from one run to the next. Even for our simple example application, we may "
"want to change the font that is used for the content."
msgstr ""
"经典的应用程序会有一些首选项，它们应该被记住而不需要在下次运行时在进行设置。"
"即使对于我们这个简单的应用程序示例，我们可能也想改变用于文本内容的字体。"

#: C/index-in.docbook:7656
msgid ""
"We are going to use <classname>Gio::Settings</classname> to store our "
"preferences. <classname>Gio::Settings</classname> requires a schema that "
"describes our settings, in our case the <filename>org.gtkmm.exampleapp."
"gschema.xml</filename> file."
msgstr ""
"我们将使用<classname>Gio::Settings</classname>来储存我们的首选项。"
"<classname>Gio::Settings</classname>需要一个用于描述我们的设置的模式，在本例"
"中为<filename>org.gtkmm.exampleapp.gschema.xml</filename>文件。"

#: C/index-in.docbook:7662
msgid ""
"Before we can make use of this schema in our application, we need to compile "
"it into the binary form that <classname>Gio::Settings</classname> expects. "
"GIO provides macros to do this in autotools-based projects. See the "
"description of <ulink url=\"https://developer.gnome.org/gio/stable/GSettings."
"html\">GSettings</ulink>. Meson provides the <function>compile_schemas()</"
"function> function in the <ulink url=\"https://mesonbuild.com/Gnome-module."
"html\">GNOME module</ulink>."
msgstr ""
"在我们应用程序使用模式之前，我们需要将其编译为<classname>Gio::Settings</"
"classname>能期望的二进制格式。GUI为此提供了基于autotools项目的宏来执行此操"
"作。具体信息请参阅<ulink url=\"https://developer.gnome.org/gio/stable/"
"GSettings.html\">GSettings</ulink>。而Meson在<ulink url=\"https://mesonbuild."
"com/Gnome-module.html\">GNOME模块</ulink>中提供了"
"<function>compile_schemas()</function>执行此操作。"

#: C/index-in.docbook:7676
#, no-wrap
msgid ""
"\n"
"m_settings = Gio::Settings::create(\"org.gtkmm.exampleapp\");\n"
"m_settings-&gt;bind(\"transition\", m_stack-&gt;property_transition_type());\n"
msgstr ""
"\n"
"m_settings = Gio::Settings::create(\"org.gtkmm.exampleapp\");\n"
"m_settings-&gt;bind(\"transition\", m_stack-&gt;property_transition_type());\n"

#: C/index-in.docbook:7671
msgid ""
"Next, we need to connect our settings to the widgets that they are supposed "
"to control. One convenient way to do this is to use <methodname>Gio::"
"Settings::bind()</methodname> to bind settings keys to object properties, as "
"we do for the transition setting in <classname>ExampleAppWindow</"
"classname>'s constructor. <_:programlisting-1/>"
msgstr ""
"接下来，我们需要将设置连接到应该被控制的部件上。一种很方便的方法是使用"
"<methodname>Gio::Settings::bind()</methodname>将对象的属性和设置键相互绑定，"
"就像我们在<classname>ExampleAppWindow</classname>的构造函数中做的过渡设置一"
"样。<_:programlisting-1/>"

#: C/index-in.docbook:7686
#, no-wrap
msgid ""
"\n"
"auto tag = buffer-&gt;create_tag();\n"
"m_settings-&gt;bind(\"font\", tag-&gt;property_font());\n"
"buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());\n"
msgstr ""
"\n"
"auto tag = buffer-&gt;create_tag();\n"
"m_settings-&gt;bind(\"font\", tag-&gt;property_font());\n"
"buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());\n"

#: C/index-in.docbook:7682
msgid ""
"The code to connect the font setting is a little more involved, since it "
"corresponds to an object property in a <classname>Gtk::TextTag</classname> "
"that we must first create. The code is in <methodname>ExampleAppWindow::"
"open_file_view()</methodname>. <_:programlisting-1/>"
msgstr ""
"字体设置的连接要麻烦的多，因为我们需要先创建对应的对象属性的<classname>Gtk::"
"TextTag</classname>。以下代码在<methodname>ExampleAppWindow::"
"open_file_view()</methodname>函数中。<_:programlisting-1/>"

#: C/index-in.docbook:7693
msgid ""
"At this point, the application will already react if you change one of the "
"settings, e.g. using the <command>gsettings</command> commandline tool. Of "
"course, we expect the application to provide a preference dialog for these. "
"So lets do that now. Our preference dialog will be a subclass of "
"<classname>Gtk::Dialog</classname>, and we'll use the same techniques that "
"we've already seen in <classname>ExampleAppWindow</classname>: a "
"<classname>Gtk::Builder</classname> ui file and settings bindings."
msgstr ""
"此时，如果你更改其中一项设置（例如：使用<command>gsettings</command>命令行工"
"具。），则应用程序会做出反应。当然，我们会希望应用程序为这些首选项提供一个对"
"话框。所以我们现在就如此做。我们的首选项对话框将是<classname>Gtk::Dialog</"
"classname>的子类，并且使用我们之前已经在<classname>ExampleAppWindow</"
"classname>中看到的技术：<classname>Gtk::Builder</classname> UI文件和设置绑"
"定。"

#: C/index-in.docbook:7706
#, no-wrap
msgid ""
"\n"
"auto prefs_dialog = ExampleAppPrefs::create(*get_active_window());\n"
"prefs_dialog-&gt;present();\n"
msgstr ""
"\n"
"auto prefs_dialog = ExampleAppPrefs::create(*get_active_window());\n"
"prefs_dialog-&gt;present();\n"

#: C/index-in.docbook:7702
msgid ""
"When we've created the <filename>prefs.ui</filename> file and the "
"<classname>ExampleAppPrefs</classname> class, we revisit the "
"<methodname>ExampleApplication::on_action_preferences()</methodname> method "
"in our application class, and make it open a new preference dialog. <_:"
"programlisting-1/>"
msgstr ""
"我们创建<filename>prefs.ui</filename>文件和<classname>ExampleAppPrefs</"
"classname>子类之后，我们重访<methodname>ExampleApplication::"
"on_action_preferences()</methodname>成员函数，并使其打开一个新的首选项对话"
"框。<_:programlisting-1/>"

#: C/index-in.docbook:7712
msgid ""
"After all this work, our application can now show a preference dialog like "
"this:"
msgstr "完成所有工作后，我们的应用程序现在可以显示如下所示的首选项对话框："

#: C/index-in.docbook:7717
msgid "An preference dialog"
msgstr "首选项对话框"

#: C/index-in.docbook:7723
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step5\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step5\">源代码</ulink>"

#: C/index-in.docbook:7728 C/index-in.docbook:7771
msgid "Adding a search bar"
msgstr "添加搜索栏"

#: C/index-in.docbook:7730
msgid ""
"We continue to flesh out the functionality of our application. For now, we "
"add search. <application>gtkmm</application> supports this with "
"<classname>Gtk::SearchEntry</classname> and <classname>Gtk::SearchBar</"
"classname>. The search bar is a widget that can slide in from the top to "
"present a search entry."
msgstr ""
"我们将继续充实我们的应用程序的功能。现在，我们向其中添加搜索功能。"
"<application>gtkmm</application>通过<classname>Gtk::SearchEntry</classname>和"
"<classname>Gtk::SearchBar</classname>对此提供了支持。搜索栏是一个部件，可以从"
"从顶部滑入以显示搜索条目。"

#: C/index-in.docbook:7736
msgid ""
"We add a toggle button to the header bar, which can be used to slide out the "
"search bar below the header bar. The new widgets are added in the "
"<filename>window.ui</filename> file."
msgstr ""
"我们向标题栏添加了一个开关按钮，可以用于滑出位于标题栏下方的搜索栏。新的部件"
"将添加到<filename>window.ui</filename>文件中。"

#: C/index-in.docbook:7745
#, no-wrap
msgid ""
"\n"
"void ExampleAppWindow::on_search_text_changed()\n"
"{\n"
"  const auto text = m_searchentry-&gt;get_text();\n"
"  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());\n"
"  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());\n"
"\n"
"  // Very simple-minded search implementation.\n"
"  auto buffer = view-&gt;get_buffer();\n"
"  Gtk::TextIter match_start;\n"
"  Gtk::TextIter match_end;\n"
"  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,\n"
"      match_start, match_end))\n"
"  {\n"
"    buffer-&gt;select_range(match_start, match_end);\n"
"    view-&gt;scroll_to(match_start);\n"
"  }\n"
"}\n"
msgstr ""
"\n"
"void ExampleAppWindow::on_search_text_changed()\n"
"{\n"
"  const auto text = m_searchentry-&gt;get_text();\n"
"  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());\n"
"  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());\n"
"\n"
"  // Very simple-minded search implementation.\n"
"  auto buffer = view-&gt;get_buffer();\n"
"  Gtk::TextIter match_start;\n"
"  Gtk::TextIter match_end;\n"
"  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,\n"
"      match_start, match_end))\n"
"  {\n"
"    buffer-&gt;select_range(match_start, match_end);\n"
"    view-&gt;scroll_to(match_start);\n"
"  }\n"
"}\n"

#: C/index-in.docbook:7741
msgid ""
"Implementing the search needs quite a few code changes that we are not going "
"to completely go over here. The central piece of the search implementation "
"is a signal handler that listens for text changes in the search entry, shown "
"here without error handling. <_:programlisting-1/>"
msgstr ""
"实现搜索需要进行大量的代码更改，在此我们不对其进行详细的介绍。实现搜索的核心"
"部分是一个信号处理函数，它监听搜索条目的变更，此处显示的示例没有进行错误处"
"理。<_:programlisting-1/>"

#: C/index-in.docbook:7766
msgid "With the search bar, our application now looks like this:"
msgstr "有了搜索栏后，我们的应用程序看起来像这样："

#: C/index-in.docbook:7777
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step6\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step6\">源代码</ulink>"

#: C/index-in.docbook:7782 C/index-in.docbook:7817
msgid "Adding a side bar"
msgstr "添加侧边栏"

#: C/index-in.docbook:7784
msgid ""
"As another piece of functionality, we are adding a sidebar, which "
"demonstrates <classname>Gtk::Revealer</classname> and <classname>Gtk::"
"ListBox</classname>. The new widgets are added in the <filename>window.ui</"
"filename> file."
msgstr ""
"作为另一项功能，我们向应用程序中添加了侧边栏，用于演示<classname>Gtk::"
"Revealer</classname>和<classname>Gtk::ListBox</classname>。新的部件将被添加到"
"<filename>window.ui</filename>文件中。"

#: C/index-in.docbook:7790
msgid ""
"The code to populate the sidebar with buttons for the words found in each "
"file is a little too involved to go into here. But we'll look at the code to "
"add a checkbutton for the new feature to the menu. A menu item is added to "
"the ui file <filename>gears_menu.ui</filename>."
msgstr ""
"在每个文件中用找到的单词生成按钮填充侧边栏的代码很复杂，这里我们不进行介绍。"
"我们将对为菜单中添加新功能的多选按钮的代码进行介绍。菜单项将被添加到"
"<filename>gears_menu.ui</filename> UI文件中。"

#: C/index-in.docbook:7801
#, no-wrap
msgid ""
"\n"
"// Connect the menu to the MenuButton m_gears, and bind the show-words setting\n"
"// to the win.show-words action and the \"Words\" menu item.\n"
"// (The connection between action and menu item is specified in gears_menu.ui.)\n"
"auto menu_builder = Gtk::Builder::create_from_resource(\"/org/gtkmm/exampleapp/gears_menu.ui\");\n"
"auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;(\"menu\");\n"
"m_gears-&gt;set_menu_model(menu);\n"
"add_action(m_settings-&gt;create_action(\"show-words\"));\n"
msgstr ""
"\n"
"// Connect the menu to the MenuButton m_gears, and bind the show-words setting\n"
"// to the win.show-words action and the \"Words\" menu item.\n"
"// (The connection between action and menu item is specified in gears_menu.ui.)\n"
"auto menu_builder = Gtk::Builder::create_from_resource(\"/org/gtkmm/exampleapp/gears_menu.ui\");\n"
"auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;(\"menu\");\n"
"m_gears-&gt;set_menu_model(menu);\n"
"add_action(m_settings-&gt;create_action(\"show-words\"));\n"

#: C/index-in.docbook:7797
msgid ""
"To connect the menu item to the new <literal>show-words</literal> setting, "
"we use a <classname>Gio::Action</classname> corresponding to the given "
"<classname>Gio::Settings</classname> key. In <classname>ExampleAppWindow</"
"classname>'s constructor: <_:programlisting-1/>"
msgstr ""
"我们使用<classname>Gio::Action</classname>与给定的<classname>Gio::Settings</"
"classname>键相关联，以使菜单项与新的<literal>show-words</literal>设置向连接。"
"在<classname>ExampleAppWindow</classname>构造函数中：<_:programlisting-1/>"

#: C/index-in.docbook:7812
msgid "What our application looks like now:"
msgstr "现在我们的应用程序看起来像这样："

#: C/index-in.docbook:7823
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step7\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step7\">源代码</ulink>"

#: C/index-in.docbook:7829 C/index-in.docbook:7871
msgid "Properties"
msgstr "属性"

#: C/index-in.docbook:7831
msgid ""
"Widgets and other objects have many useful properties. Here we show some "
"ways to use them in new and flexible ways, by wrapping them in actions with "
"<classname>Gio::PropertyAction</classname> or by binding them with "
"<classname>Glib::Binding</classname>."
msgstr ""
"部件和其他对象有很多有用的属性。在这里，我们通过一些新颖的使用方法展示了使用"
"它们的方法。例如，将它们包装在<classname>Gio::PropertyAction</classname>动作"
"中或将它们与<classname>Glib::Binding</classname>绑定。"

#: C/index-in.docbook:7837
msgid ""
"To set this up, we add two labels to the header bar in our <filename>window."
"ui</filename> file, named <literal>lines_label</literal> and <literal>lines</"
"literal>, and get pointers to them in the application window's constructor, "
"as we've seen a couple of times by now. We add a new \"Lines\" menu item to "
"the gears menu, which triggers the <literal>show-lines</literal> action."
msgstr ""
"我们在<filename>window.ui</filename>文件中的标题栏中添加了两个标签，分别命名"
"为<literal>lines_label</literal>和<literal>lines</literal>，并在应用程序窗口"
"的构造函数中获取指向它们的指针。接着我们向齿轮菜单中添加了一个新的\"Lines\"菜"
"单项，该菜单项会触发<literal>show-lines</literal>动作。"

#: C/index-in.docbook:7854
#, no-wrap
msgid ""
"add_action(Gio::PropertyAction::create(\"show-lines\", m_lines-&gt;property_visible()));\n"
"m_binding_lines_visible = Glib::Binding::bind_property(m_lines-&gt;property_visible(),\n"
"  m_lines_label-&gt;property_visible());\n"
"\n"
msgstr ""
"add_action(Gio::PropertyAction::create(\"show-lines\", m_lines-&gt;property_visible()));\n"
"m_binding_lines_visible = Glib::Binding::bind_property(m_lines-&gt;property_visible(),\n"
"  m_lines_label-&gt;property_visible());\n"
"\n"

#: C/index-in.docbook:7845
msgid ""
"To make this menu item do something, we create a property action for the "
"<literal>visible</literal> property of the <literal>lines</literal> label, "
"and add it to the actions of the window. The effect of this is that the "
"visibility of the label gets toggled every time the action is activated. "
"Since we want both labels to appear and disappear together, we bind the "
"<literal>visible</literal> property of the <literal>lines_label</literal> "
"widget to the same property of the <literal>lines</literal> widget. In "
"<classname>ExampleAppWindow</classname>'s constructor: <_:programlisting-1/>"
msgstr ""
"为了使此菜单项能执行某些操作，我们为<literal>lines</literal>标签的"
"<literal>visible</literal>属性创建了一个属性动作，并将其添加到窗口动作中。这"
"样做的效果是，每当动作被激活，标签的可见性就会改变。由于我们希望两个标签的可"
"见性一致，因此我们将<literal>lines_label</literal>部件的<literal>visible</"
"literal>属性绑定到<literal>lines</literal>部件的相同属性上。在"
"<classname>ExampleAppWindow</classname>的构造函数中：<_:programlisting-1/>"

#: C/index-in.docbook:7861
msgid ""
"We also need a function that counts the lines of the currently active tab, "
"and updates the <literal>lines</literal> label. See the full source if you "
"are interested in the details."
msgstr ""
"我们还需要一个函数对当前标签页的行进行计数，并更新<literal>lines</literal>标"
"签。如果你对此感兴趣请阅读完整源代码。"

#: C/index-in.docbook:7866
msgid "This brings our example application to this appearance:"
msgstr "现在我们的示例应用程序看起来如下："

#: C/index-in.docbook:7877
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step8\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step8\">源代码</ulink>"

#: C/index-in.docbook:7882 C/index-in.docbook:7908
msgid "Header bar"
msgstr "标题栏"

#: C/index-in.docbook:7884
msgid ""
"Our application already uses a <classname>Gtk::HeaderBar</classname> instead "
"of a 'normal' window titlebar. The header bar is a direct child of the "
"window, and its type is <literal>titlebar</literal>. This is set in the "
"<filename>window.ui</filename> file."
msgstr ""
"我们的应用程序使用了<classname>Gtk::HeaderBar</classname>而不是普通的窗口标题"
"栏。标题栏是窗口的直接子项，其类型为<literal>titlebar</literal>。这些由"
"<filename>window.ui</filename>文件进行设置。"

#: C/index-in.docbook:7897
#, no-wrap
msgid ""
"Gtk::IconTheme::get_for_display(get_display())-&gt;add_resource_path(\"/org/gtkmm/exampleapp\");\n"
"set_icon_name(\"exampleapp\");\n"
"\n"
msgstr ""
"Gtk::IconTheme::get_for_display(get_display())-&gt;add_resource_path(\"/org/gtkmm/exampleapp\");\n"
"set_icon_name(\"exampleapp\");\n"
"\n"

#: C/index-in.docbook:7891
msgid ""
"Here we'll just make two small changes to the header bar. The "
"<literal>decoration-layout</literal> property is set in the <filename>window."
"ui</filename> file, to show only the close button, and hide the minimize and "
"maximize buttons. We also include an icon in the resource file, and set up "
"this icon as the window icon. In <classname>ExampleAppWindow</classname>'s "
"constructor: <_:programlisting-1/>"
msgstr ""
"在这里我们对标题栏进行了两个小的更改。<literal>decoration-layout</literal>属"
"性在<filename>window.ui</filename>文件中设置，使标题栏只显示关闭按钮，并隐藏"
"最小化和最大化按钮。我们还在资源文件中包含了一个图标，并将其设置为窗口图标。"
"在<classname>ExampleAppWindow</classname>的构造函数中：<_:programlisting-1/>"

#: C/index-in.docbook:7903
msgid "Here is how the application now looks:"
msgstr "现在应用程序看起来如下所示："

#: C/index-in.docbook:7914
msgid ""
"The <filename>window.ui</filename> file sets a header bar title, but this "
"title is not shown. That's because the stack switcher is a child of type "
"<literal>title</literal>. The stack switcher becomes a custom title that "
"hides the title label."
msgstr ""
"<filename>window.ui</filename>文件设置了标题栏标题，但是此标题未显示。这是因"
"为堆切换器是<literal>title</literal>的子类型。此时堆切换器成为了自定义标题并"
"将正常的标题标签隐藏。"

#: C/index-in.docbook:7920
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step9\">Source Code</ulink>"
msgstr ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/buildapp/step9\">源代码</ulink>"

#: C/index-in.docbook:7927
msgid "Contributing"
msgstr "贡献"

#: C/index-in.docbook:7929
msgid ""
"This document, like so much other great software out there, was created for "
"free by volunteers. If you are at all knowledgeable about any aspect of "
"<application>gtkmm</application> that does not already have documentation, "
"please consider contributing to this document."
msgstr ""
"本文档和其他出色的软件一样，是由志愿者免费创建的。如果你对任何一个"
"<application>gtkmm</application>没有文档的部分有所了解，请考虑帮助编写/翻译本"
"文档。"

#: C/index-in.docbook:7935
msgid ""
"Ideally, we would like you to <ulink url=\"https://gitlab.gnome.org/GNOME/"
"gtkmm-documentation/-/merge_requests\"> provide a merge request</ulink> to "
"the <filename>docs/tutorial/C/index-in.docbook</filename> file. This file is "
"in the <literal>gtkmm-documentation</literal> module in GNOME git."
msgstr ""
"理想情况下，我们希望你前往此<ulink url=\"https://gitlab.gnome.org/GNOME/"
"gtkmm-documentation/-/merge_requests\">仓库</ulink>为<filename>docs/tutorial/"
"C/index-in.docbook</filename>提供MR。该文件位于GNOME的gitlab <literal>gtkmm-"
"documentation</literal>模块中。"

#: C/index-in.docbook:7941
msgid ""
"If you do decide to contribute, please post your contribution to the "
"<application>gtkmm</application> mailing list at <ulink url=\"mailto:gtkmm-"
"list@gnome.org\">&lt;gtkmm-list@gnome.org&gt;</ulink> or as an issue or "
"merge request to <ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-"
"documentation\">GitLab</ulink>. Also, be aware that the entirety of this "
"document is free, and any addition you provide must also be free. That is, "
"people must be able to use any portion of your examples in their programs, "
"and copies of this document (including your contribution) may be distributed "
"freely."
msgstr ""
"如果你决定做出贡献，请将你的贡献发送到<application>gtkmm</application>邮件列"
"表，网址为<ulink url=\"mailto:gtkmm-list@gnome.org\">&lt;gtkmm-list@gnome."
"org&gt;</ulink>，或者前往<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-"
"documentation\">GitLab</ulink>新建issue/MR。另外请注意，本文档的全部内容都是"
"免费的，你添加所有内容也需要是免费的。也就是说人们必须能够在程序中使用示例的"
"任何部分，以及自由分发本文档的副本。"

#: C/index-in.docbook:7954
msgid "The RefPtr smartpointer"
msgstr "RefPtr智能指针"

#: C/index-in.docbook:7955
msgid ""
"<classname>Glib::RefPtr</classname> is a smartpointer. Specifically, it is a "
"reference-counting smartpointer. You might be familiar with <classname>std::"
"unique_ptr&lt;&gt;</classname> and <classname>std::shared_ptr&lt;&gt;</"
"classname>, which are also smartpointers. In <application>gtkmm</"
"application>-4.0 <classname>Glib::RefPtr&lt;&gt;</classname> is an alias for "
"<classname>std::shared_ptr&lt;&gt;</classname>, which is reference-counting. "
"<classname>Glib::RefPtr&lt;&gt;</classname> was introduced long before there "
"was a reference-counting smartpointer in the C++ Standard Library."
msgstr ""
"<classname>Glib::RefPtr</classname>是一个智能指针。准确的说，它是一个引用计数"
"智能指针。你可能对<classname>std::unique_ptr&lt;&gt;</classname>和"
"<classname>std::shared_ptr&lt;&gt;</classname>十分熟悉，它们也是智能指针。在"
"<application>gtkmm</application>-4.0中<classname>Glib::RefPtr&lt;&gt;</"
"classname>是<classname>std::shared_ptr&lt;&gt;</classname>的别名。"
"<classname>Glib::RefPtr&lt;&gt;</classname>在C++标准库还没有添加引用计数智能"
"指针的时候就已经存在于<application>glibmm</application>了（译注：事实上Glib::"
"RefPtr的行为与std::shared_ptr的行为并不完全一致，且因glibmm等库的文档是由C文"
"档直接生成而来，在一些C库中可以接受NULL作为参数的函数在对应的C++绑定库中的文"
"档中都是可以接受nullptr作为参数，但实际上并不一定能接受nullptr作为参数，有时"
"候需要传递Glib::RefPtr&lt;FOO&gt;()、Gdk::Event()、空的字符串等。参见："
"<ulink url=\"https://gitlab.gnome.org/GNOME/glibmm/-/issues/24\">问题24</"
"ulink>）。"

#: C/index-in.docbook:7966
msgid ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1RefPtr."
"html\">Reference</ulink>"
msgstr ""
"<ulink url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1RefPtr."
"html\">参考</ulink>"

#: C/index-in.docbook:7968
msgid ""
"A smartpointer acts much like a normal pointer. Here are a few examples."
msgstr "智能指针的行为很像普通指针。这里有几个例子。"

#: C/index-in.docbook:7971
msgid "Copying"
msgstr "复制"

#: C/index-in.docbook:7972
msgid ""
"You can copy <classname>RefPtr</classname>s, just like normal pointers. But "
"unlike normal pointers, you don't need to worry about deleting the "
"underlying instance."
msgstr ""
"你可以像复制普通指针一样复制<classname>RefPtr</classname>，你不需要担心删除底"
"层实例。"

#: C/index-in.docbook:7978
#, no-wrap
msgid ""
"\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"auto refPixbuf2 = refPixbuf;\n"
msgstr ""
"\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"auto refPixbuf2 = refPixbuf;\n"

#: C/index-in.docbook:7983
msgid ""
"Of course this means that you can store <classname>RefPtr</classname>s in "
"standard containers, such as <classname>std::vector</classname> or "
"<classname>std::list</classname>."
msgstr ""
"这意味着你可以将<classname>RefPtr</classname>储存于标准容器中，例如："
"<classname>std::vector</classname>或<classname>std::list</classname>。"

#: C/index-in.docbook:7988
#, no-wrap
msgid ""
"\n"
"std::list&lt;Glib::RefPtr&lt;Gdk::Pixbuf&gt;&gt; listPixbufs;\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"listPixbufs.push_back(refPixbuf);\n"
msgstr ""
"\n"
"std::list&lt;Glib::RefPtr&lt;Gdk::Pixbuf&gt;&gt; listPixbufs;\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"listPixbufs.push_back(refPixbuf);\n"

#: C/index-in.docbook:7996
msgid "Dereferencing"
msgstr "解引用"

#: C/index-in.docbook:7997
msgid ""
"You can dereference a smartpointer with the -&gt; operator, to call the "
"methods of the underlying instance, just like a normal pointer."
msgstr ""
"你可以使用-&gt;操作符解引用智能指针，就像使用普通指针访问底层实例的方法一样。"

#: C/index-in.docbook:8001
#, no-wrap
msgid ""
"\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"auto width = refPixbuf-&gt;get_width();\n"
msgstr ""
"\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"auto width = refPixbuf-&gt;get_width();\n"

#: C/index-in.docbook:8006
msgid ""
"You can also use the * operator and the <methodname>get()</methodname> "
"method to access the underlying instance, but it's usually a bad idea to do "
"so. Unless you are careful, you can end up with a pointer or a reference "
"which is not included in the reference count."
msgstr ""
"你还可以使用*操作符和<methodname>get()</methodname>方法访问底层实例，不过通常"
"这不是一个好主意。除非你非常的谨慎没有犯错，否则你将得到一个不存在于引用计数"
"中的指向底层实例的指针或底层实例的引用。"

#: C/index-in.docbook:8012
#, no-wrap
msgid ""
"\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"auto&amp; underlying = *refPixbuf; // Possible, but not recommended\n"
msgstr ""
"\n"
"auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"auto&amp; underlying = *refPixbuf; // Possible, but not recommended\n"

#: C/index-in.docbook:8019
msgid "Casting"
msgstr "类型转换"

#: C/index-in.docbook:8020
msgid ""
"You can cast <classname>RefPtr</classname>s to base types, just like normal "
"pointers."
msgstr ""
"你可以像对正常指针进行类型转换一样，将<classname>RefPtr</classname>转换到基础"
"类型。"

#: C/index-in.docbook:8025
#, no-wrap
msgid ""
"\n"
"auto refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"
msgstr ""
"\n"
"auto refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"

#: C/index-in.docbook:8030
msgid ""
"This means that any method which takes a <type>const Glib::RefPtr&lt;"
"BaseType&gt;&amp;</type> argument can also take a <type>const Glib::"
"RefPtr&lt;DerivedType&gt;&amp;</type>. The cast is implicit, just as it "
"would be for a normal pointer."
msgstr ""
"这意味着任何接受<type>const Glib::RefPtr&lt;BaseType&gt;&amp;</type>参数的函"
"数也能接受<type>const Glib::RefPtr&lt;DerivedType&gt;&amp;</type>对象。此转换"
"和普通指针一样是隐式的。"

#: C/index-in.docbook:8034
msgid ""
"You can also cast to a derived type, but the syntax is a little different "
"than with a normal pointer."
msgstr "你还可以将其转换为派生类型，但是语法和普通指针的语法略有不同。"

#: C/index-in.docbook:8038
#, no-wrap
msgid ""
"\n"
"auto refStore = std::dynamic_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);\n"
"auto refStore2 = std::static_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);\n"
msgstr ""
"\n"
"auto refStore = std::dynamic_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);\n"
"auto refStore2 = std::static_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);\n"

#: C/index-in.docbook:8045
msgid "Checking for nullptr"
msgstr "nullptr检查"

#: C/index-in.docbook:8046
msgid ""
"Just like normal pointers, you can check whether a <classname>RefPtr</"
"classname> points to anything."
msgstr ""
"就像普通指针一样，你可以检查<classname>RefPtr</classname>是否指向了任何东西。"

#: C/index-in.docbook:8051
#, no-wrap
msgid ""
"\n"
"auto refModel = m_TreeView.get_model();\n"
"if (refModel)\n"
"{\n"
"  auto cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"
msgstr ""
"\n"
"auto refModel = m_TreeView.get_model();\n"
"if (refModel)\n"
"{\n"
"  auto cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"

#: C/index-in.docbook:8060
msgid ""
"But unlike normal pointers, <classname>RefPtr</classname>s are automatically "
"initialized to <literal>nullptr</literal> so you don't need to remember to "
"do that yourself."
msgstr ""
"和普通指针不一样的是，<classname>RefPtr</classname>将会自动初始化为"
"<literal>nullptr</literal>，不需要你自己进行置空。"

#: C/index-in.docbook:8066
msgid "Constness"
msgstr "常数"

#: C/index-in.docbook:8067
msgid ""
"The use of the <literal>const</literal> keyword in C++ is not always clear. "
"You might not realise that <type>const Something*</type> declares a pointer "
"to a <type>const Something</type>. The pointer can be changed, but not the "
"<type>Something</type> that it points to."
msgstr ""
"在C++中<literal>const</literal>关键字的使用并不总是很清晰。你可能没有意识到"
"<type>const Something*</type>声明了一个指向<type>const Something</type>的指"
"针。这个指针的指向是可以被改变的，其指向的<type>Something</type>不能被改变。"

#: C/index-in.docbook:8073
msgid ""
"Therefore, the <classname>RefPtr</classname> equivalent of <type>Something*</"
"type> for a method parameter is <type>const Glib::RefPtr&lt;Something&gt;"
"&amp;</type>, and the equivalent of <type>const Something*</type> is "
"<type>const Glib::RefPtr&lt;const Something&gt;&amp;</type>."
msgstr ""
"因此，在方法参数中与<type>Something*</type>等效的<classname>RefPtr</"
"classname>是<type>const Glib::RefPtr&lt;Something&gt;&amp;</type>，而与"
"<type>const Something*</type>等效的是<type>const Glib::RefPtr&lt;const "
"Something&gt;&amp;</type>。"

#: C/index-in.docbook:8080
msgid ""
"The <literal>const ... &amp;</literal> around both is just for efficiency, "
"like using <classname>const std::string&amp;</classname> instead of "
"<classname>std::string</classname> for a method parameter to avoid "
"unnecessary copying."
msgstr ""
"用<literal>const ... &amp;</literal>包围是处于效率考虑，就像在方法参数中使用"
"<classname>const std::string&amp;</classname>而不是用<classname>std::string</"
"classname>一样，这是为了避免不必要的复制。"

#: C/index-in.docbook:8095
msgid "Connecting signal handlers"
msgstr "连接到信号处理函数"

#: C/index-in.docbook:8096
msgid ""
"<application>gtkmm</application> widget classes have signal accessor "
"methods, such as <methodname>Gtk::Button::signal_clicked()</methodname>, "
"which allow you to connect your signal handler. Thanks to the flexibility of "
"<application>libsigc++</application>, the callback library used by "
"<application>gtkmm</application>, the signal handler can be almost any kind "
"of function, but you will probably want to use a class method. Among "
"<application>GTK</application> C coders, these signal handlers are often "
"named callbacks."
msgstr ""
"<application>gtkmm</application>的部件类拥有信号访问器方法，例如:"
"<methodname>Gtk::Button::signal_clicked()</methodname>。这些方法允许你将你的"
"信号处理函数与信号相连接。<application>gtkmm</application>所使用的的"
"<application>libsigc++</application>回调库提供了非常强的灵活性，它几乎允许你"
"使用任何函数作为信号的处理程序，不过通常你会希望使用类的成员函数。在"
"<application>GTK</application>的C代码中，这些信号处理程序被称为回调。"

#: C/index-in.docbook:8106
msgid "Here's an example of a signal handler being connected to a signal:"
msgstr "这是将信号处理函数与信号相连接的示例："

#: C/index-in.docbook:8111
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"int main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"int main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"

#: C/index-in.docbook:8127
msgid ""
"There's rather a lot to think about in this (non-functional) code. First "
"let's identify the parties involved:"
msgstr "在此代码（非功能性）中有很多事情要考虑，首先让我们确定代码的行为："

#: C/index-in.docbook:8135
msgid "The signal handler is <methodname>on_button_clicked()</methodname>."
msgstr "信号处理函数是<methodname>on_button_clicked()</methodname>。"

#: C/index-in.docbook:8141
msgid ""
"We're hooking it up to the <classname>Gtk::Button</classname> object called "
"<varname>button</varname>."
msgstr ""
"我们将其连接到一个名为<varname>button</varname>的<classname>Gtk::Button</"
"classname>对象。"

#: C/index-in.docbook:8148
msgid ""
"When the Button emits its <literal>clicked</literal> signal, "
"<methodname>on_button_clicked()</methodname> will be called."
msgstr ""
"当<varname>button</varname>发出<literal>clicked</literal>信号时，"
"<methodname>on_button_clicked()</methodname>将被调用。"

#: C/index-in.docbook:8156
msgid "Now let's look at the connection again:"
msgstr "现在，我们再次看一下连接："

#: C/index-in.docbook:8161
#, no-wrap
msgid ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"
msgstr ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"

#: C/index-in.docbook:8168
msgid ""
"Note that we don't pass a pointer to <methodname>on_button_clicked()</"
"methodname> directly to the signal's <methodname>connect()</methodname> "
"method. Instead, we call <function>sigc::ptr_fun()</function>, and pass the "
"result to <methodname>connect()</methodname>."
msgstr ""
"请注意，我们不会直接将一个指向<methodname>on_button_clicked()</methodname>的"
"指针传递给信号的<methodname>connect()</methodname>方法。我们将调用"
"<function>sigc::ptr_fun()</function>并将其返回值传递给<methodname>connect()</"
"methodname>。"

#: C/index-in.docbook:8175
msgid ""
"<function>sigc::ptr_fun()</function> generates a <classname>sigc::slot</"
"classname>. A slot is an object which looks and feels like a function, but "
"is actually an object. These are also known as function objects, or "
"functors. <function>sigc::ptr_fun()</function> generates a slot for a "
"standalone function or static method. <function>sigc::mem_fun()</function> "
"generates a slot for a member method of a particular instance."
msgstr ""
"<function>sigc::ptr_fun()</function>生成一个<classname>sigc::slot</"
"classname>。槽对象看起来很像一个函数，但实际上是一个对象。这类对象也被称为函"
"数对象或是函子。<function>sigc::ptr_fun()</function>为独立函数或静态成员函数"
"生成槽。<function>sigc::mem_fun()</function>为特定实例的成员函数生成槽。"

#: C/index-in.docbook:8184
msgid "Here's a slightly larger example of slots in action:"
msgstr "这是一个在动作中使用槽的较大示例："

#: C/index-in.docbook:8189
#, no-wrap
msgid ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"int main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"
msgstr ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"int main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"

#: C/index-in.docbook:8208
msgid ""
"The first call to <methodname>connect()</methodname> is just like the one we "
"saw last time; nothing new here."
msgstr ""
"第一个<methodname>connect()</methodname>调用与我们之前看到的没有什么区别。"

#: C/index-in.docbook:8211
msgid ""
"The next is more interesting. <function>sigc::mem_fun()</function> is called "
"with two arguments. The first argument is <parameter>some_object</"
"parameter>, which is the object that our new slot will be pointing at. The "
"second argument is a pointer to one of its methods. This particular version "
"of <function>sigc::mem_fun()</function> creates a slot which will, when "
"\"called\", call the pointed-to method of the specified object, in this case "
"<methodname>some_object.on_button_clicked()</methodname>."
msgstr ""
"接下来的一个调用更有趣些。使用两个参数调用<function>sigc::mem_fun()</"
"function>。第一个参数是<parameter>some_object</parameter>，这是我们新的槽将指"
"向的对象。第二个参数是指向其成员函数之一的指针。这个特定版本的"
"<function>sigc::mem_fun()</function>将会创建一个槽，这个槽在被调用的时候将会"
"调用指定对象上函数指针所指向的成员函数，在这个情况下调用的是"
"<methodname>some_object.on_button_clicked()</methodname>。"

#: C/index-in.docbook:8221
msgid ""
"Another thing to note about this example is that we made the call to "
"<methodname>connect()</methodname> twice for the same signal object. This is "
"perfectly fine - when the button is clicked, both signal handlers will be "
"called."
msgstr ""
"另一个与此示例有关的注意事项是，我们对同一个信号对象调用了两次"
"<methodname>connect()</methodname>。所以当该按钮被点击时，这两个信号处理函数"
"都将被调用。"

#: C/index-in.docbook:8228
msgid ""
"We just told you that the button's <literal>clicked</literal> signal is "
"expecting to call a method with no arguments. All signals have requirements "
"like this - you can't hook a function with two arguments to a signal "
"expecting none (unless you use an adapter, such as <function>sigc::bind()</"
"function>, of course). Therefore, it's important to know what type of signal "
"handler you'll be expected to connect to a given signal."
msgstr ""
"你应该已经注意到了，按钮的<literal>clicked</literal>信号期望调用一个不接受任"
"何参数的函数。事实上所有的信号都有这样的要求。所以你不能将一个接受两个参数的"
"函数与期望所调用函数不接受参数的信号相关联，当然你可以通过使用"
"<function>sigc::bind()</function>之类的适配器在一定程度上绕过这个限制。"

#: C/index-in.docbook:8240
msgid "Writing signal handlers"
msgstr "编写信号处理函数"

#: C/index-in.docbook:8242
msgid ""
"To find out what type of signal handler you can connect to a signal, you can "
"look it up in the reference documentation or the header file. Here's an "
"example of a signal declaration you might see in the <application>gtkmm</"
"application> headers:"
msgstr ""
"要找到你可以连接到信号的信号处理函数类型，你可以查看它的参考文档或者是头文"
"件。这是一个你可能在<application>gtkmm</application>头文件中看到的信号声明示"
"例："

#: C/index-in.docbook:8249
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy&lt;bool(Gtk::DirectionType)&gt; signal_focus()\n"
msgstr ""
"\n"
"Glib::SignalProxy&lt;bool(Gtk::DirectionType)&gt; signal_focus()\n"

#: C/index-in.docbook:8254
msgid ""
"Other than the signal's name (<literal>focus</literal>), the template "
"arguments are important to note here. The first argument, <type>bool</type>, "
"is the type that the signal handler should return; and the type within "
"parentheses, <type>Gtk::DirectionType</type>, is the type of this signal's "
"first, and only, argument. By looking at the reference documentation, you "
"can see the names of the arguments too."
msgstr ""
"除了信号名为<literal>focus</literal>之外，这里的膜拜参数很重要。第一个参数"
"<type>bool</type>，表示信号处理函数的返回值应该是个<type>bool</type>类型。而"
"括号中的<type>Gtk::DirectionType</type>表示信号所期望调用的函数的第一个也是唯"
"一一个参数的类型。通过查看参考文档你还可以看到参数的名称。"

#: C/index-in.docbook:8263
msgid ""
"The same principles apply for signals which have more arguments. Here's one "
"with three (taken from <filename>&lt;gtkmm/textbuffer.h&gt;</filename>):"
msgstr ""
"对于接受期望调用的函数有更多参数的信号也是一样的阅读规则。以下声明取自"
"<filename>&lt;gtkmm/textbuffer.h&gt;</filename>："

#: C/index-in.docbook:8269
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy&lt;void(TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int)&gt; signal_insert();\n"
msgstr ""
"\n"
"Glib::SignalProxy&lt;void(TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int)&gt; signal_insert();\n"

#: C/index-in.docbook:8274
msgid ""
"It follows the same form. The first type is <type>void</type>, so that "
"should be our signal handler's return type. The following three types are "
"the argument types, in order. Our signal handler's prototype could look like "
"this:"
msgstr ""
"以一样的阅读规则阅读后可知，该信号所期望调用的函数的返回值类型为<type>void</"
"type>，括号内三种类型为函数的三个参数类型。所以我们的信号处理函数原型可能如下"
"所示："

#: C/index-in.docbook:8282
#, no-wrap
msgid ""
"\n"
"void on_insert(TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)\n"
msgstr ""
"\n"
"void on_insert(TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)\n"

#: C/index-in.docbook:8289
msgid "Disconnecting signal handlers"
msgstr "断开信号处理函数"

#: C/index-in.docbook:8291
msgid ""
"Let's take another look at a Signal's <literal>connect</literal> method:"
msgstr "让我们再来看看信号的<literal>connect</literal>成员函数："

#: C/index-in.docbook:8296
#, no-wrap
msgid ""
"\n"
"sigc::connection signal&lt;void(int)&gt;::connect(const sigc::slot&lt;void(int)&gt;&amp;);\n"
msgstr ""
"\n"
"sigc::connection signal&lt;void(int)&gt;::connect(const sigc::slot&lt;void(int)&gt;&amp;);\n"

#: C/index-in.docbook:8301
msgid ""
"The returned <classname>sigc::connection</classname> can be used to control "
"the connection. By keeping a connection object you can disconnect its "
"associated signal handler using the <methodname>sigc::connection::"
"disconnect()</methodname> method."
msgstr ""
"该函数返回的<classname>sigc::connection</classname>对象可以控制连接。通过保存"
"连接对象就可以断开与其相关联的信号处理函数的连接。若你想如此做，只需对对象调"
"用<methodname>sigc::connection::disconnect()</methodname>成员函数即可。"

#: C/index-in.docbook:8309
msgid "Overriding default signal handlers"
msgstr "覆写默认信号处理函数"

#: C/index-in.docbook:8311
msgid ""
"So far we've told you to perform actions in response to button-presses and "
"the like by handling signals. That's certainly a good way to do things, but "
"it's not the only way."
msgstr ""
"到现在为止，你已经学会了通过将自定义的信号处理函数连接到信号来响应按钮按下等"
"动作。这是一种好方法，但不是唯一的方法。"

#: C/index-in.docbook:8318
msgid ""
"Instead of laboriously connecting signal handlers to signals, you can simply "
"make a new class which inherits from a widget - say, a Button - and then "
"override the default signal handler, such as Button::on_clicked(). This can "
"be a lot simpler than hooking up signal handlers for everything."
msgstr ""
"你还可以创建一个从部件继承而来的新类，然后覆盖默认的信号处理函数（例如，"
"Button::on_clicked()），这样你就可以省去将信号处理函数连接到信号的步骤。"

#: C/index-in.docbook:8325
msgid ""
"Subclassing isn't always the best way to accomplish things. It is only "
"useful when you want the widget to handle its own signal by itself. If you "
"want some other class to handle the signal then you'll need to connect a "
"separate handler. This is even more true if you want several objects to "
"handle the same signal, or if you want one signal handler to respond to the "
"same signal from different objects."
msgstr ""
"子类化并不是银弹。它只在你只希望由部件自身来处理自己的信号时才好用。如果你需"
"要用其他的类来处理信号，你还是需要为此将函数连接到目标信号上。这在你需要用多"
"个对象处理同一个信号或者需要一个信号处理函数处理不同的对象的信号的时候会很不"
"方便。"

#: C/index-in.docbook:8330
msgid ""
"<application>gtkmm</application> classes are designed with overriding in "
"mind; they contain virtual member methods specifically intended to be "
"overridden."
msgstr ""
"<application>gtkmm</application>类在设计的时候已经考虑到了覆写；它们包含了专"
"门用于被覆写的虚成员函数。"

#: C/index-in.docbook:8335
msgid "Let's look at an example of overriding:"
msgstr "让我们看一个覆写的例子："

#: C/index-in.docbook:8340
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"  void on_clicked() override;\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"  std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"  // call the base class's version of the method:\n"
"  Gtk::Button::on_clicked();\n"
"}\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"  void on_clicked() override;\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"  std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"  // call the base class's version of the method:\n"
"  Gtk::Button::on_clicked();\n"
"}\n"

#: C/index-in.docbook:8359
msgid ""
"Here we define a new class called <classname>OverriddenButton</classname>, "
"which inherits from <classname>Gtk::Button</classname>. The only thing we "
"change is the <methodname>on_clicked()</methodname> method, which is called "
"whenever <classname>Gtk::Button</classname> emits the <literal>clicked</"
"literal> signal. This method prints \"Hello World\" to <literal>stdout</"
"literal>, and then calls the original, overridden method, to let "
"<classname>Gtk::Button</classname> do what it would have done had we not "
"overridden."
msgstr ""
"在这我们定义了一个名为<classname>OverriddenButton</classname>的新类，该类继承"
"自<classname>Gtk::Button</classname>。我们对其唯一的更改是"
"<methodname>on_clicked()</methodname>成员函数，只要<classname>Gtk::Button</"
"classname>发出<literal>clicked</literal>信号该成员函数就会被调用。这个成员函"
"数将字符串\"Hello World\"打印到<literal>stdout</literal>，然后调用"
"<classname>Gtk::Button</classname>已被覆写本该被调用的成员函数。"

#: C/index-in.docbook:8370
msgid ""
"You don't always need to call the parent's method; there are times when you "
"might not want to. Note that we called the parent method <emphasis>after</"
"emphasis> writing \"Hello World\", but we could have called it before. In "
"this simple example, it hardly matters much, but there are times when it "
"will. With connected signal handlers, it's not quite so easy to change "
"details like this, and you can do something here which you can't do at all "
"with connected signal handlers: you can call the parent method in the "
"<emphasis>middle</emphasis> of your custom code."
msgstr ""
"调用父方法不是必须的，你可以在不想做的时候不调用它。请注意在此我们在做完了想"
"做的事情<emphasis>之后</emphasis>调用了父方法，而你当然可以在此函数的中间或是"
"任何你想调用父方法的位置调用它。这对于通过连接到信号调用的信号处理函数是无法"
"做到的。"

#: C/index-in.docbook:8384
msgid "Binding extra arguments"
msgstr "绑定额外参数"

#: C/index-in.docbook:8391
#, no-wrap
msgid ""
"\n"
"m_button1.signal_clicked().connect(sigc::bind(sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\"));\n"
msgstr ""
"\n"
"m_button1.signal_clicked().connect(sigc::bind(sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\"));\n"

#: C/index-in.docbook:8398
#, no-wrap
msgid ""
"\n"
"void on_button_clicked(const Glib::ustring&amp; data);\n"
msgstr ""
"\n"
"void on_button_clicked(const Glib::ustring&amp; data);\n"

#: C/index-in.docbook:8385
msgid ""
"If you use one signal handler to catch the same signal from several widgets, "
"you might like that signal handler to receive some extra information. For "
"instance, you might want to know which button was clicked. You can do this "
"with <function>sigc::bind()</function>. Here's some code from the <link "
"linkend=\"sec-helloworld2\">helloworld2</link> example. <_:programlisting-1/"
"> This says that we want the signal to send an extra <classname>Glib::"
"ustring</classname> argument to the signal handler, and that the value of "
"that argument should be \"button 1\". Of course we will need to add that "
"extra argument to the declaration of our signal handler: <_:programlisting-2/"
"> Of course, a normal \"clicked\" signal handler would have no arguments."
msgstr ""
"如果你想使用一个信号处理函数从多个部件捕获同一个信号，你可能希望信号处理函数"
"能收到一些额外的信息。例如，你可能想知道那个按钮被点击了。你可以使用"
"<function>sigc::bind()</function>。这是<link linkend=\"sec-"
"helloworld2\">helloworld2</link>示例的部分代码：<_:programlisting-1/> 这表示"
"我们希望信号向信号处理函数发送一个额外的<classname>Glib::ustring</classname>"
"参数，并且该参数的值为\"button 1\"。当然，我们将会需要向信号处理函数的声明中"
"添加额外的参数:<_:programlisting-2/>。当然，正常的\"clicked\"信号处理函数是没"
"有参数的。"

#: C/index-in.docbook:8403
msgid ""
"<function>sigc::bind()</function> is not commonly used, but you might find "
"it helpful sometimes. If you are familiar with <application>GTK</"
"application> programming then you have probably noticed that this is similar "
"to the extra <literal>gpointer data</literal> arguments which all GTK "
"callbacks have. This is generally overused in <application>GTK</application> "
"to pass information that should be stored as member data in a derived "
"widget, but widget derivation is very difficult in C. We have far less need "
"of this hack in <application>gtkmm</application>."
msgstr ""
"<function>sigc::bind()</function>并不常用，不过偶尔会对你有所帮助（译注：很多"
"时候直接使用lambda比调用sigc::bind要好）。如果你对使用<application>GTK</"
"application>编程很熟悉，就会注意到，这和<application>GTK</application>中所有"
"的回调函数都具有一个额外的<literal>gpointer data</literal>参数十分的类似。因"
"为在C语言中要派生一个部件十分的困难，通过让<application>GTK</application>中所"
"有回调函数都具有一个这样的额外参数用于传递本该储存于派生部件成员中的数据可以"
"有效降低代码复杂度。而在<application>gtkmm</application>中派生部件类十分的简"
"单，所以这种强侵入式的写法不再需要了。"

#: C/index-in.docbook:8415
msgid "X Event signals"
msgstr "X事件信号"

#: C/index-in.docbook:8416
msgid ""
"The <classname>Widget</classname> class has some special signals which "
"correspond to the underlying X-Windows events. These are suffixed by "
"<literal>_event</literal>; for instance, <methodname>Widget::"
"signal_button_press_event()</methodname>."
msgstr ""
"<classname>Widget</classname>有一些对应底层X-Windows事件的特殊信号。它们具有"
"<literal>_event</literal>后缀。例如：<methodname>Widget::"
"signal_button_press_event()</methodname>。"

#: C/index-in.docbook:8422
msgid ""
"You might occasionally find it useful to handle X events when there's "
"something you can't accomplish with normal signals. <classname>Gtk::Button</"
"classname>, for example, does not send mouse-pointer coordinates with its "
"<literal>clicked</literal> signal, but you could handle "
"<literal>button_press_event</literal> if you needed this information. X "
"events are also often used to handle key-presses."
msgstr ""
"当有些事情你无法使用常规信号完成时，你可能会发现X事件信号非常有用。例如："
"<classname>Gtk::Button</classname>的<literal>clicked</literal>信号不会发送鼠"
"标指针的坐标，而<literal>button_press_event</literal>信号会。X事件也用于处理"
"按键。"

#: C/index-in.docbook:8431
msgid ""
"These signals behave slightly differently. The value returned from the "
"signal handler indicates whether it has fully \"handled\" the event. If the "
"value is <literal>false</literal> then <application>gtkmm</application> will "
"pass the event on to the next signal handler. If the value is <literal>true</"
"literal> then no other signal handlers will need to be called."
msgstr ""
"这些信号的行为有所不同。它们的信号处理函数将通过返回值指示有没有完全处理事"
"件。如果返回值为<literal>false</literal>，则<application>gtkmm</application>"
"将会把事件再次发送到下一个信号处理函数。如果返回值为<literal>true</literal>则"
"不再传播信号不再调用其他的信号处理函数。"

#: C/index-in.docbook:8436
msgid ""
"Handling an X event doesn't affect the Widget's other signals. If you handle "
"<literal>button_press_event</literal> for <classname>Gtk::Button</"
"classname>, you'll still be able to get the <literal>clicked</literal> "
"signal. They are emitted at (nearly) the same time."
msgstr ""
"处理X事件不会影响部件的其他信号。如果你处理<classname>Gtk::Button</classname>"
"的<literal>button_press_event</literal>信号，你依旧可以得到<literal>clicked</"
"literal>信号。这两个信号将几乎于同一时间被发出。"

#: C/index-in.docbook:8445
#, no-wrap
msgid ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"
msgstr ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"

#: C/index-in.docbook:8451
msgid ""
"When the mouse is over the button and a mouse button is pressed, "
"<methodname>on_button_press()</methodname> will be called."
msgstr ""
"当鼠标悬停在鼠标上方并按下鼠标按钮时，<methodname>on_button_press()</"
"methodname>将被调用。"

#: C/index-in.docbook:8456
msgid ""
"<type>GdkEventButton</type> is a structure containing the event's "
"parameters, such as the coordinates of the mouse pointer at the time the "
"button was pressed. There are several different types of <type>GdkEvent</"
"type> structures for the various events."
msgstr ""
"<type>GdkEventButton</type>是一个包含事件参数的结构体，其中包含按下按钮时鼠标"
"指针的坐标等一系列信息。对于不同的事件，有不同的<type>GdkEvent</type>结构体类"
"型与之对应。"

#: C/index-in.docbook:8464
msgid "Signal Handler sequence"
msgstr "信号处理函数序列"

#: C/index-in.docbook:8472
#, no-wrap
msgid ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"
msgstr ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"

#: C/index-in.docbook:8465
msgid ""
"By default, your signal handlers are called after any previously-connected "
"signal handlers. However, this can be a problem with the X Event signals. "
"For instance, the existing signal handlers, or the default signal handler, "
"might return <literal>true</literal> to stop other signal handlers from "
"being called. To specify that your signal handler should be called before "
"the other signal handlers, so that it will always be called, you can specify "
"<literal>false</literal> for the optional <literal>after</literal> "
"parameter. For instance, <_:programlisting-1/>"
msgstr ""
"默认情况下，你的信号处理函数将于所有之前连接到信号的信号处理函数之后被调用。"
"但是这对于X事件信号可能会出问题。例如，现有的信号处理函数或默认信号处理函数如"
"果返回了<literal>true</literal>将会停止事件传播，这时候你的信号处理函数就不会"
"被调用。你可以指定可选参数<literal>after</literal>为<literal>false</"
"literal>，这样你的信号处理函数就总是会被调用。例如：<_:programlisting-1/>"

#: C/index-in.docbook:8476
msgid ""
"The event is delivered first to the widget the event occurred in. If all "
"signal handlers in that widget return <literal>false</literal> (indicating "
"that the event has not been handled), then the signal will be propagated to "
"the parent widget and emitted there. This continues all the way up to the "
"top-level widget if no one handles the event."
msgstr ""
"这个事件将首先被发送到发生事件的部件中。如果该部件的所有信号处理函数都返回"
"<literal>false</literal>。则该信号将被传播到部件的父部件中。如果后续没有人处"
"理事件，信号会一直传播到顶级窗口部件。"

#: C/index-in.docbook:8487
msgid "Exceptions in signal handlers"
msgstr "信号处理函数中的异常"

#: C/index-in.docbook:8488
msgid ""
"When a program is aborted because of an unhandled C++ exception, it's "
"sometimes possible to use a debugger to find the location where the "
"exception was thrown. This is more difficult than usual if the exception was "
"thrown from a signal handler."
msgstr ""
"当程序因未处理C++异常而终止时，有时候可以使用调试器查找抛出异常的位置。但是如"
"果异常是在信号处理函数中抛出的，这将会比平常困难的多。"

#: C/index-in.docbook:8493
msgid ""
"This section describes primarily what you can expect on a Linux system, when "
"you use <ulink url=\"http://www.gnu.org/software/gdb/\">the gdb debugger</"
"ulink>."
msgstr ""
"本小节组要介绍使用<ulink url=\"http://www.gnu.org/software/gdb/\">gdb调试器</"
"ulink>在Linux系统上调试异常。"

#: C/index-in.docbook:8500
#, no-wrap
msgid ""
"\n"
"// without_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  throwSomething();\n"
"  auto app = Gtk::Application::create(\"org.gtkmm.without_signal\");\n"
"  return app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"// without_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  throwSomething();\n"
"  auto app = Gtk::Application::create(\"org.gtkmm.without_signal\");\n"
"  return app-&gt;run();\n"
"}\n"

#: C/index-in.docbook:8497
msgid ""
"First, let's look at a simple example where an exception is thrown from a "
"normal function (no signal handler). <_:programlisting-1/>"
msgstr ""
"首先让我们看一个简单的示例，其中的一个普通函数（非信号处理函数）抛出异常：<_:"
"programlisting-1/>"

#: C/index-in.docbook:8521
#, no-wrap
msgid ""
"\n"
"&gt; gdb without_signal\n"
"(gdb) run\n"
"terminate called after throwing an instance of 'char const*'\n"
"\n"
"Program received signal SIGABRT, Aborted.\n"
"(gdb) backtrace\n"
"#7  0x08048864 in throwSomething () at without_signal.cc:6\n"
"#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12\n"
msgstr ""
"\n"
"&gt; gdb without_signal\n"
"(gdb) run\n"
"terminate called after throwing an instance of 'char const*'\n"
"\n"
"Program received signal SIGABRT, Aborted.\n"
"(gdb) backtrace\n"
"#7  0x08048864 in throwSomething () at without_signal.cc:6\n"
"#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12\n"

#: C/index-in.docbook:8518
msgid ""
"Here is an excerpt from a <application>gdb</application> session. Only the "
"most interesting parts of the output are shown. <_:programlisting-1/> You "
"can see that the exception was thrown from <filename>without_signal.cc</"
"filename>, line 6 (<code>throw \"Something\";</code>)."
msgstr ""
"这是<application>gdb</application>会话的摘要。只显示输出中最有趣的部分：<_:"
"programlisting-1/> 你可以看到在<filename>without_signal.cc</filename>的第六行"
"抛出了异常(<code>throw \"Something\";</code>)。"

#: C/index-in.docbook:8537
#, no-wrap
msgid ""
"\n"
"// with_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);\n"
"  auto app = Gtk::Application::create(\"org.gtkmm.with_signal\");\n"
"  app-&gt;hold();\n"
"  return app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"// with_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);\n"
"  auto app = Gtk::Application::create(\"org.gtkmm.with_signal\");\n"
"  app-&gt;hold();\n"
"  return app-&gt;run();\n"
"}\n"

#: C/index-in.docbook:8534
msgid ""
"Now let's see what happens when an exception is thrown from a signal "
"handler. Here's the source code. <_:programlisting-1/>"
msgstr ""
"现在，让我们看看从信号处理函数中抛出异常会发生什么。这是源代码：<_:"
"programlisting-1/>"

#: C/index-in.docbook:8558
#, no-wrap
msgid ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) run\n"
"(with_signal:2703): glibmm-ERROR **:\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
"(gdb) backtrace\n"
"#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77\n"
"#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150\n"
"#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212\n"
"#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178\n"
"#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16\n"
msgstr ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) run\n"
"(with_signal:2703): glibmm-ERROR **:\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
"(gdb) backtrace\n"
"#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77\n"
"#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150\n"
"#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212\n"
"#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178\n"
"#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16\n"

#: C/index-in.docbook:8556
msgid ""
"And here's an excerpt from a <application>gdb</application> session. <_:"
"programlisting-1/> The exception is caught in <application>glibmm</"
"application>, and the program ends with a call to <function>g_error()</"
"function>. Other exceptions may result in different behaviour, but in any "
"case the exception from a signal handler is caught in <application>glibmm</"
"application> or <application>gtkmm</application>, and <application>gdb</"
"application> can't see where it was thrown."
msgstr ""
"这是<application>gdb</application>会话的摘录：<_:programlisting-1/> "
"<application>glibmm</application>将捕获了异常，并调用<function>g_error()</"
"function>结束了程序。其他的异常行为可能不一样，不过所有从信号处理函数中抛出的"
"异常都会被<application>glibmm</application>或<application>gtkmm</application>"
"所捕获，并且<application>gdb</application>将无法看到异常被抛出的具体位置。"

#: C/index-in.docbook:8581
#, no-wrap
msgid ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) catch throw\n"
"Catchpoint 1 (throw)\n"
"(gdb) run\n"
"Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()\n"
"(gdb) backtrace\n"
"#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6\n"
"#1  0x08048bd4 in throwSomething () at with_signal.cc:6\n"
"(gdb) continue\n"
"Continuing.\n"
"(with_signal:2375): glibmm-ERROR **\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
msgstr ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) catch throw\n"
"Catchpoint 1 (throw)\n"
"(gdb) run\n"
"Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()\n"
"(gdb) backtrace\n"
"#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6\n"
"#1  0x08048bd4 in throwSomething () at with_signal.cc:6\n"
"(gdb) continue\n"
"Continuing.\n"
"(with_signal:2375): glibmm-ERROR **\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"

#: C/index-in.docbook:8578
msgid ""
"To see where the exception is thrown, you can use the <application>gdb</"
"application> command <userinput>catch throw</userinput>. <_:programlisting-1/"
">"
msgstr ""
"要查看哪里抛出了异常，你可以使用<application>gdb</application>的"
"<userinput>catch throw</userinput>命令。<_:programlisting-1/>"

#: C/index-in.docbook:8602
#, no-wrap
msgid ""
"\n"
"(gdb) catch throw\n"
"(gdb) commands\n"
"(gdb)   backtrace\n"
"(gdb)   continue\n"
"(gdb)   end\n"
"(gdb) set pagination off\n"
"(gdb) run\n"
msgstr ""
"\n"
"(gdb) catch throw\n"
"(gdb) commands\n"
"(gdb)   backtrace\n"
"(gdb)   continue\n"
"(gdb)   end\n"
"(gdb) set pagination off\n"
"(gdb) run\n"

#: C/index-in.docbook:8598
msgid ""
"If there are many caught exceptions before the interesting uncaught one, "
"this method can be tedious. It can be automated with the following "
"<application>gdb</application> commands. <_:programlisting-1/> These "
"commands will print a backtrace from each <code>throw</code> and continue. "
"The backtrace from the last (or possibly the last but one) <code>throw</"
"code> before the program stops, is the interesting one."
msgstr ""
"如果在感兴趣的未捕获异常之前有多个捕获异常，这个方法将会非常的枯燥。可以使用"
"以下<application>gdb</application>命令自动化进行这个工作。<_:"
"programlisting-1/> 这些命令将在每次抛出时打印回溯信息并继续。通常最后一个或第"
"一个<code>throw</code>是你所需要的。"

#: C/index-in.docbook:8621
msgid "Creating your own signals"
msgstr ""

#: C/index-in.docbook:8622
msgid ""
"Now that you've seen signals and signal handlers in <application>gtkmm</"
"application>, you might like to use the same technique to allow interaction "
"between your own classes. That's actually very simple by using the "
"<application>libsigc++</application> library directly."
msgstr ""

#: C/index-in.docbook:8628
msgid ""
"This isn't purely a <application>gtkmm</application> or GUI issue. "
"<application>gtkmm</application> uses <application>libsigc++</application> "
"to implement its proxy wrappers for the <application>GTK</application> "
"signal system, but for new, non-GTK signals, you can create pure C++ "
"signals, using the <classname>sigc::signal&lt;&gt;</classname> template."
msgstr ""

#: C/index-in.docbook:8639
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void(bool, int)&gt; signal_something;\n"
msgstr ""

#: C/index-in.docbook:8635
msgid ""
"For instance, to create a signal that sends 2 parameters, a <type>bool</"
"type> and an <type>int</type>, just declare a <classname>sigc::signal</"
"classname>, like so: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:8647
#, no-wrap
msgid ""
"\n"
"class Server\n"
"{\n"
"public:\n"
"  //signal accessor:\n"
"  using type_signal_something = sigc::signal&lt;void(bool, int)&gt;;\n"
"  type_signal_something signal_something();\n"
"\n"
"protected:\n"
"  type_signal_something m_signal_something;\n"
"};\n"
"\n"
"Server::type_signal_something Server::signal_something()\n"
"{\n"
"  return m_signal_something;\n"
"}\n"
msgstr ""

#: C/index-in.docbook:8643
msgid ""
"You could just declare that signal as a public member variable, but some "
"people find that distasteful and prefer to make it available via an accessor "
"method, like so: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:8669
#, no-wrap
msgid ""
"\n"
"server.signal_something().connect(\n"
"  sigc::mem_fun(client, &amp;Client::on_server_something) );\n"
msgstr ""

#: C/index-in.docbook:8666
msgid ""
"You can then connect to the signal using the same syntax used when "
"connecting to <application>gtkmm</application> signals. For instance, <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:8677
msgid "This is a full working example that defines and uses custom signals."
msgstr ""

#: C/index-in.docbook:8681
msgid ""
"<ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/master/"
"examples/book/signals/custom/\">Source Code</ulink>"
msgstr ""

#: C/index-in.docbook:8689
msgid "Comparison with other signalling systems"
msgstr ""

#: C/index-in.docbook:8690
msgid ""
"(An aside: <application>GTK</application> calls this scheme \"signalling\"; "
"the sharp-eyed reader with GUI toolkit experience will note that this same "
"design is often seen under the name of \"broadcaster-listener\" (e.g., in "
"Metrowerks' PowerPlant framework for the Macintosh). It works in much the "
"same way: one sets up <literal>broadcasters</literal>, and then connects "
"<literal>listeners</literal> to them; the broadcaster keeps a list of the "
"objects listening to it, and when someone gives the broadcaster a message, "
"it calls all of its objects in its list with the message. In "
"<application>gtkmm</application>, signal objects play the role of "
"broadcasters, and slots play the role of listeners - sort of. More on this "
"later.)"
msgstr ""

#: C/index-in.docbook:8704
msgid ""
"<application>gtkmm</application> signal handlers are strongly-typed, whereas "
"<application>GTK</application> C code allows you to connect a callback with "
"the wrong number and type of arguments, leading to a segfault at runtime. "
"And, unlike <application>Qt</application>, <application>gtkmm</application> "
"achieves this without modifying the C++ language."
msgstr ""

#: C/index-in.docbook:8710
msgid ""
"Re. Overriding signal handlers: You can do this in the straight-C world of "
"GTK too; that's what GTK's object system is for. But in GTK, you have to go "
"through some complicated procedures to get object-oriented features like "
"inheritance and overloading. In C++, it's simple, since those features are "
"supported in the language itself; you can let the compiler do the dirty work."
msgstr ""

#: C/index-in.docbook:8718
msgid ""
"This is one of the places where the beauty of C++ really comes out. One "
"wouldn't think of subclassing a GTK widget simply to override its action "
"method; it's just too much trouble. In GTK, you almost always use signals to "
"get things done, unless you're writing a new widget. But because overriding "
"methods is so easy in C++, it's entirely practical - and sensible - to "
"subclass a button for that purpose."
msgstr ""

#: C/index-in.docbook:8729
msgid "<application>gtkmm</application> and Win32"
msgstr ""

#: C/index-in.docbook:8730
msgid ""
"One of the major advantages of <application>gtkmm</application> is that it "
"is crossplatform. <application>gtkmm</application> programs written on other "
"platforms such as GNU/Linux can generally be transferred to Windows (and "
"vice versa) with few modifications to the source."
msgstr ""

#: C/index-in.docbook:8735
msgid ""
"<application>gtkmm</application> currently works with the <ulink url="
"\"http://mingw.org/\">MinGW/GCC compiler</ulink> with a compiler version "
"that supports C++17, such as gcc 7 or 8. It also works with Microsoft Visual "
"C++ 2017 15.7.x or later (including the freely available express/community "
"editions) on the Windows platform. There is an <ulink url=\"ftp://ftp.gnome."
"org/pub/GNOME/binaries/win32/gtkmm\">installer</ulink> available for "
"<application>gtkmm</application> on Microsoft Windows, but as of this "
"writing (October 2020) it has not been updated for a long time. Please be "
"aware that although normally it is fine to mix builds done with Visual "
"Studio 2017 and 2019, please do not do so when building <application>gtkmm</"
"application> with its -mm dependencies."
msgstr ""

#: C/index-in.docbook:8748
msgid ""
"Refer to the <ulink url=\"https://gitlab.gnome.org/GNOME/gtkmm/tree/master/"
"README.win32\">README.win32</ulink>, as well as the <ulink url=\"https://"
"gitlab.gnome.org/GNOME/gtkmm/tree/master/MSVC_NMake/README\">README</ulink> "
"files in the <application>gtkmm</application>, pangomm and glibmm for "
"instructions on how to build <application>gtkmm</application> on Windows."
msgstr ""

#: C/index-in.docbook:8755
msgid "Working with gtkmm's Source Code"
msgstr ""

#: C/index-in.docbook:8756
msgid ""
"If you are interested in helping out with the development of "
"<application>gtkmm</application>, or fixing a bug in <application>gtkmm</"
"application>, you'll probably need to build the development version of "
"<application>gtkmm</application>. However, you should not install a "
"development version over your stable version. Instead, you should install it "
"alongside your existing <application>gtkmm</application> installation, in a "
"separate path."
msgstr ""

#: C/index-in.docbook:8763
msgid ""
"The easiest way to do this is using <ulink url=\"https://wiki.gnome.org/"
"Projects/Jhbuild\">jhbuild</ulink>. <application>jhbuild</application> is a "
"program that makes building GNOME software much easier by calculating "
"dependencies and building things in the correct order. This section will "
"give a brief explanation of how to set up <application>jhbuild</application> "
"to build and install <application>gtkmm</application> from the source "
"repository (git). For up-to-date information on <application>jhbuild</"
"application>, please refer to the <ulink url=\"http://developer.gnome.org/"
"jhbuild/unstable/\">jhbuild manual</ulink>."
msgstr ""

#: C/index-in.docbook:8775
msgid ""
"Note that to build <application>gtkmm</application> from git, you'll often "
"need to build many of its dependencies from git as well. "
"<application>jhbuild</application> makes this easier than it would normally "
"be, but it will take quite a while to build and install them all. You will "
"probably encounter build problems, though these will usually be corrected "
"quickly if you report them."
msgstr ""

#: C/index-in.docbook:8783
msgid ""
"<application>gnome-build-meta</application> is an alternative to "
"<application>jhbuild</application>. It is described at the <ulink url="
"\"https://wiki.gnome.org/Newcomers/BuildSystemComponent\">Building system "
"components</ulink> wiki page, but here we concentrate on "
"<application>jhbuild</application>."
msgstr ""

#: C/index-in.docbook:8790
msgid "Setting up jhbuild"
msgstr ""

#: C/index-in.docbook:8799
#, no-wrap
msgid "$ cp examples/sample.jhbuildrc ~/.config/jhbuildrc"
msgstr ""

#: C/index-in.docbook:8791
msgid ""
"To set up <application>jhbuild</application>, follow the basic installation "
"instructions from the <ulink url=\"http://developer.gnome.org/jhbuild/"
"unstable/\">jhbuild manual</ulink>. After you have installed "
"<application>jhbuild</application>, you should copy the sample "
"<application>jhbuild</application> configuration file into your home "
"directory by executing the following command from the <application>jhbuild</"
"application> directory: <_:screen-1/>"
msgstr ""

#: C/index-in.docbook:8805
#, no-wrap
msgid "moduleset = 'gnome-suites-core-deps-latest'"
msgstr ""

#: C/index-in.docbook:8801
msgid ""
"The <application>gtkmm</application> module is defined in the "
"<filename>gnome-suites-core-deps-latest.modules</filename> moduleset. So "
"edit your <filename>jhbuildrc</filename> file and set your moduleset setting "
"like so: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:8812
#, no-wrap
msgid "modules = [ 'gtkmm' ]"
msgstr ""

#: C/index-in.docbook:8807
msgid ""
"After setting the correct moduleset, you need to tell <application>jhbuild</"
"application> which module or modules to build. To build <application>gtkmm</"
"application> and all of its dependencies, set <varname>modules</varname> "
"like so: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:8814
msgid ""
"You can build several modules by setting the <varname>modules</varname> "
"variable to a meta-package, e.g. <literal>meta-gnome-core</literal>, or "
"listing more than one module name. The <varname>modules</varname> variable "
"specifies which modules will be built when you don't explicitly specify "
"anything on the command line. You can always build a different moduleset "
"later by specifying it on the commandline (e.g. <command>jhbuild build "
"gtkmm</command>)."
msgstr ""

#: C/index-in.docbook:8824
msgid "Setting a prefix"
msgstr ""

#: C/index-in.docbook:8825
msgid ""
"By default, <application>jhbuild</application>'s configuration is configured "
"to install all software built with <application>jhbuild</application> under "
"the <filename>~/jhbuild/install</filename> prefix. You can choose a "
"different prefix, but it is recommended that you keep this prefix different "
"from other software that you've installed (don't set it to <filename>/usr</"
"filename>!) If you've followed the jhbuild instructions then this prefix "
"belongs to your user, so you don't need to run jhbuild as <literal>root</"
"literal>."
msgstr ""

#: C/index-in.docbook:8837
msgid ""
"When you downloaded <application>jhbuild</application> from the git "
"repository, you got a number of <filename>.modules</filename> files, "
"specifying dependencies between modules. By default <application>jhbuild</"
"application> does not use the downloaded versions of these files, but reads "
"the latest versions in the git repository. This is usually what you want. If "
"you don't want it, use the <varname>use_local_modulesets</varname> variable "
"in <filename>.jhbuildrc</filename>."
msgstr ""

#: C/index-in.docbook:8848
msgid ""
"Installing and Using the git version of <application>gtkmm</application>"
msgstr ""

#: C/index-in.docbook:8856
#, no-wrap
msgid ""
"$ jhbuild bootstrap\n"
"$ jhbuild sanitycheck"
msgstr ""

#: C/index-in.docbook:8849
msgid ""
"Once you've configured <application>jhbuild</application> as described "
"above, building <application>gtkmm</application> should be relatively "
"straightforward. The first time you run <application>jhbuild</application>, "
"you should run the following sequence of commands to ensure that "
"<application>jhbuild</application> has the required tools and verify that it "
"is set up correctly: <_:screen-1/>"
msgstr ""

#: C/index-in.docbook:8860
msgid ""
"Installing <application>gtkmm</application> with <application>jhbuild</"
"application>"
msgstr ""

#: C/index-in.docbook:8861
msgid ""
"If everything worked correctly, you should be able to build "
"<application>gtkmm</application> and all of its dependencies from git by "
"executing <command>jhbuild build</command> (or, if you didn't specify "
"<application>gtkmm</application> in the <varname>modules</varname> variable, "
"with the command <command>jhbuild build gtkmm</command>)."
msgstr ""

#: C/index-in.docbook:8868
msgid ""
"This command will build and install a series of modules and will probably "
"take quite a long time the first time through. After the first time, "
"however, it should go quite a bit faster since it only needs to rebuild "
"files that changed since the last build. Alternatively, after you've built "
"and installed <application>gtkmm</application> the first time, you can "
"rebuild <application>gtkmm</application> by itself (without rebuilding all "
"of its dependencies) with the command <command>jhbuild buildone gtkmm</"
"command>."
msgstr ""

#: C/index-in.docbook:8879
msgid "Using the git version of <application>gtkmm</application>"
msgstr ""

#: C/index-in.docbook:8880
msgid ""
"After you've installed the git version of <application>gtkmm</application>, "
"you're ready to start using and experimenting with it. In order to use the "
"new version of <application>gtkmm</application> you've just installed, you "
"need to set some environment variables so that your <filename>configure</"
"filename> or <filename>meson.build</filename> script knows where to find the "
"new libraries. Fortunately, <application>jhbuild</application> offers an "
"easy solution to this problem. Executing the command <command>jhbuild shell</"
"command> will start a new shell with all of the correct environment "
"variables set. Now if you re-configure and build your project just as you "
"usually do, it should link against the newly installed libraries. To return "
"to your previous environment, simply exit the <application>jhbuild</"
"application> shell."
msgstr ""

#: C/index-in.docbook:8894
msgid ""
"Once you've built your software, you'll need to run your program within the "
"jhbuild environment as well. To do this, you can again use the "
"<command>jhbuild shell</command> command to start a new shell with the "
"<application>jhbuild</application> environment set up. Alternatively, you "
"can execute a one-off command in the <application>jhbuild</application> "
"environment using the following command: <command>jhbuild run command-name</"
"command>. In this case, the command will be run with the correct environment "
"variables set, but will return to your previous environment after the "
"program exits."
msgstr ""

#: C/index-in.docbook:8911
msgid "Wrapping C Libraries with gmmproc"
msgstr ""

#: C/index-in.docbook:8912
msgid ""
"<application>gtkmm</application> uses the <command>gmmproc</command> tool to "
"generate most of its source code, using .defs files that define the APIs of "
"<classname>GObject</classname>-based libraries. So it's quite easy to create "
"additional gtkmm-style wrappers of other glib/GObject-based libraries."
msgstr ""

#: C/index-in.docbook:8917
msgid ""
"This involves a variety of tools, some of them crufty, but at least they "
"work, and has been used successfully by several projects."
msgstr ""

#: C/index-in.docbook:8922
msgid "The build structure"
msgstr ""

#: C/index-in.docbook:8923
msgid ""
"Generation of the source code for a gtkmm-style wrapper API requires use of "
"tools such as <command>gmmproc</command> and <filename>generate_wrap_init."
"pl</filename>, which are included in <application>glibmm</application>. In "
"theory you could write your own build files to use these appropriately, but "
"a much better option is to make use of the build infrastructure provided by "
"the <application>mm-common</application> module. To get started, it helps a "
"lot to pick an existing binding module as an example to look at."
msgstr ""

#: C/index-in.docbook:8931
msgid ""
"For instance, let's pretend that we are wrapping a C library called "
"libsomething. It provides a <classname>GObject</classname>-based API with "
"types named, for instance, <classname>SomeWidget</classname> and "
"<classname>SomeStuff</classname>."
msgstr ""

#: C/index-in.docbook:8937
msgid "Copying the skeleton project"
msgstr ""

#: C/index-in.docbook:8944
#, no-wrap
msgid ""
"\n"
"  $ git clone https://gitlab.gnome.org/GNOME/mm-common.git\n"
"  $ cp -a mm-common/skeletonmm libsomethingmm\n"
msgstr ""

#: C/index-in.docbook:8939
msgid ""
"Typically our wrapper library would be called libsomethingmm. We can start "
"by copying the <ulink url=\"https://gitlab.gnome.org/GNOME/mm-common/tree/"
"master/skeletonmm\"> skeleton source tree</ulink> from the <application>mm-"
"common</application> module. Starting with <application>mm-common</"
"application> 1.0.0 this skeleton application is built with the <ulink url="
"\"https://mesonbuild.com/\">Meson build system</ulink>. <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:8954
msgid "<filename>libsomethingmm</filename>: The top-level directory."
msgstr ""

#: C/index-in.docbook:8956
msgid ""
"<filename>libsomething</filename>: Contains the main include file and the "
"pkg-config .pc file."
msgstr ""

#: C/index-in.docbook:8958
msgid "<filename>src</filename>: Contains .hg and .ccg source files."
msgstr ""

#: C/index-in.docbook:8959
msgid ""
"<filename>libsomethingmm</filename>: Contains hand-written .h and .cc files."
msgstr ""

#: C/index-in.docbook:8949
msgid ""
"This provides a directory structure for the source .hg and .ccg files and "
"the hand-written .h and .cc files, with <filename>meson.build</filename> "
"files that can specify the various files in use, in terms of Meson "
"variables. The directory structure usually looks like this, after we have "
"renamed the directories appropriately: <_:itemizedlist-1/>"
msgstr ""

#: C/index-in.docbook:8970
#, no-wrap
msgid ""
"\n"
"$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\\n"
"    d=\"${f%/*}\"; b=\"${f##*/}\"; mv \"$f\" \"$d/${b//skeleton/libsomething}\"; \\\n"
"  done\n"
msgstr ""

#: C/index-in.docbook:8968
msgid ""
"As well as renaming the directories, we should rename some of the source "
"files. For instance: <_:programlisting-1/> A number of the skeleton files "
"must still be filled in with project-specific content later."
msgstr ""

#: C/index-in.docbook:8977
msgid ""
"Note that files ending in <filename>.in</filename> will be used to generate "
"files with the same name but without the <filename>.in</filename> suffix, by "
"replacing some variables with actual values during the configure stage."
msgstr ""

#: C/index-in.docbook:8980
msgid ""
"Generated files are saved in the build tree, which is separated from the "
"source tree when <command>meson</command> and <command>ninja</command> are "
"used."
msgstr ""

#: C/index-in.docbook:8985
msgid "Modifying build files"
msgstr ""

#: C/index-in.docbook:8987
msgid ""
"Now we edit the files to adapt them to our needs. You might prefer to use a "
"multiple-file search-replace utility for this, such as <command>regexxer</"
"command>. Note that nearly all of the files provided with the skeleton "
"source tree contain placeholder text. Thus, the substitutions should be "
"performed globally, and not be limited to the Meson files."
msgstr ""

#: C/index-in.docbook:8991
msgid ""
"All mentions of <varname>skeleton</varname> should be replaced by the "
"correct name of the C library you are wrapping, such as \"something\" or "
"\"libsomething\". In the same manner, all instances of <varname>SKELETON</"
"varname> should be replaced by \"SOMETHING\" or \"LIBSOMETHING\", and all "
"occurrences of <varname>Skeleton</varname> changed to \"Something\"."
msgstr ""

#: C/index-in.docbook:8995
msgid ""
"Likewise, replace all instances of <varname>Joe Hacker</varname> by the name "
"of the intended copyright holder, which is probably you. Do the same for the "
"<varname>joe@example.com</varname> email address."
msgstr ""

#: C/index-in.docbook:9000
msgid "meson.build in the top-level directory"
msgstr ""

#: C/index-in.docbook:9003
msgid ""
"It is common for binding modules to track the version number of the library "
"they are wrapping. So, for instance, if the C library is at version 1.23.4, "
"then the initial version of the binding module would be 1.23.0. However, "
"avoid starting with an even minor version number as that usually indicates a "
"stable release."
msgstr ""

#: C/index-in.docbook:9008
msgid ""
"In the <function>project()</function> function, change the license and the C+"
"+ version, if necessary."
msgstr ""

#: C/index-in.docbook:9010
msgid ""
"You probably need to add more required modules than <application>glibmm</"
"application> and <application>skeleton</application> "
"(<application>libsomething</application>)."
msgstr ""

#: C/index-in.docbook:9018
msgid "Other meson.build files"
msgstr ""

#: C/index-in.docbook:9021
msgid ""
"<filename>skeleton/meson.build</filename>: Perhaps not much to change here "
"more than the global name substitutions."
msgstr ""

#: C/index-in.docbook:9024
msgid "<filename>skeleton/skeletonmm/meson.build</filename>"
msgstr ""

#: C/index-in.docbook:9027
msgid "<varname>defs_basefiles</varname>"
msgstr ""

#: C/index-in.docbook:9028
msgid "If we have more .defs and docs.xml files, we add them here."
msgstr ""

#: C/index-in.docbook:9032
msgid "<varname>hg_ccg_basenames</varname>"
msgstr ""

#: C/index-in.docbook:9033
msgid ""
"We must mention all of our <filename>.hg</filename> and <filename>.ccg</"
"filename> files here."
msgstr ""

#: C/index-in.docbook:9037
msgid "<varname>extra_cc_files, extra_h_files</varname>"
msgstr ""

#: C/index-in.docbook:9038
msgid ""
"Any additional hand-written <filename>.h</filename> and <filename>.cc</"
"filename> source files go here."
msgstr ""

#: C/index-in.docbook:9019
msgid ""
"Next we must adapt the other <filename>meson.build</filename> files: <_:"
"itemizedlist-1/>"
msgstr ""

#: C/index-in.docbook:9048
msgid "Creating .hg and .ccg files"
msgstr ""

#: C/index-in.docbook:9049
msgid ""
"We should now create our first <filename>.hg</filename> and <filename>.ccg</"
"filename> files, to wrap one of the objects in the C library. One pair of "
"example source files already exists: <filename>skeleton.ccg</filename> and "
"<filename>skeleton.hg</filename>. Create copies of these files as necessary."
msgstr ""

#: C/index-in.docbook:9053
msgid ""
"In the <link linkend=\"sec-wrapping-hg-files\">.hg and .ccg files</link> "
"section you can learn about the syntax used in these files."
msgstr ""

#: C/index-in.docbook:9060
msgid "Generating the .defs files."
msgstr ""

#: C/index-in.docbook:9064
msgid "objects (GObjects, widgets, interfaces, boxed-types and plain structs)"
msgstr ""

#: C/index-in.docbook:9065
msgid "functions"
msgstr ""

#: C/index-in.docbook:9066
msgid "enums"
msgstr ""

#: C/index-in.docbook:9067
msgid "signals"
msgstr ""

#: C/index-in.docbook:9068
msgid "properties"
msgstr ""

#: C/index-in.docbook:9069
msgid "vfuncs"
msgstr ""

#: C/index-in.docbook:9061
msgid ""
"The <filename>.defs</filename> files are text files, in a lisp format, that "
"describe the API of a C library, including its <_:itemizedlist-1/>"
msgstr ""

#: C/index-in.docbook:9078
msgid "<filename>gtk.defs</filename>"
msgstr ""

#: C/index-in.docbook:9079
msgid "Includes the other files."
msgstr ""

#: C/index-in.docbook:9082
msgid "<filename>gtk_methods.defs</filename>"
msgstr ""

#: C/index-in.docbook:9083
msgid "Objects and functions."
msgstr ""

#: C/index-in.docbook:9086
msgid "<filename>gtk_enums.defs</filename>"
msgstr ""

#: C/index-in.docbook:9087
msgid "Enumerations."
msgstr ""

#: C/index-in.docbook:9090
msgid "<filename>gtk_signals.defs</filename>"
msgstr ""

#: C/index-in.docbook:9091
msgid "Signals and properties."
msgstr ""

#: C/index-in.docbook:9094
msgid "<filename>gtk_vfuncs.defs</filename>"
msgstr ""

#: C/index-in.docbook:9095
msgid "vfuncs (function pointer member fields in structs), written by hand."
msgstr ""

#: C/index-in.docbook:9072
msgid ""
"At the moment, we have separate tools for generating different parts of "
"these <filename>.defs</filename>, so we split them up into separate files. "
"For instance, in the <filename>gtk/src</filename> directory of the "
"<application>gtkmm</application> sources, you will find these files: <_:"
"variablelist-1/>"
msgstr ""

#: C/index-in.docbook:9099
msgid ""
"The <filename>skeletonmm/tools/generate_defs_and_docs.sh</filename> script "
"generates all <filename>.defs</filename> files and the <filename>*_docs.xml</"
"filename> file, described in the <link linkend=\"sec-wrapping-documentation"
"\">Documentation</link> section."
msgstr ""

#: C/index-in.docbook:9105
msgid "Generating the methods .defs"
msgstr ""

#: C/index-in.docbook:9109
#, no-wrap
msgid ""
"\n"
"$ ./h2def.py /usr/include/gtk-4.0/gtk/*.h &gt; gtk_methods.defs\n"
msgstr ""

#: C/index-in.docbook:9106
msgid ""
"This <filename>.defs</filename> file describes objects and their functions. "
"It is generated by the <command>h2def.py</command> script which you can find "
"in glibmm's <filename>tools/defs_gen</filename> directory. For instance, <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9116
msgid "Generating the enums .defs"
msgstr ""

#: C/index-in.docbook:9120
#, no-wrap
msgid ""
"\n"
"$ ./enum.pl /usr/include/gtk-4.0/gtk/*.h &gt; gtk_enums.defs\n"
msgstr ""

#: C/index-in.docbook:9117
msgid ""
"This <filename>.defs</filename> file describes enum types and their possible "
"values. It is generated by the <filename>enum.pl</filename> script which you "
"can find in glibmm's <filename>tools</filename> directory. For instance, <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9127
msgid "Generating the signals and properties .defs"
msgstr ""

#: C/index-in.docbook:9132
#, no-wrap
msgid ""
"\n"
"$ cd tools/extra_defs_gen\n"
"$ ./generate_extra_defs &gt; gtk_signals.defs\n"
msgstr ""

#: C/index-in.docbook:9128
msgid ""
"This <filename>.defs</filename> file describes signals and properties. It is "
"generated by the special <filename>generate_extra_defs</filename> utility "
"that is in every wrapping project, such as <filename>gtkmm/tools/"
"extra_defs_gen/</filename>. For instance <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9137
msgid ""
"You must edit the source code of your own <filename>generate_extra_defs</"
"filename> tool in order to generate the <filename>.defs</filename> for the "
"GObject C types that you wish to wrap. In the skeleton source tree, the "
"source file is named <filename>tools/extra_defs_gen/generate_defs_skeleton."
"cc</filename>. If not done so already, the file should be renamed, with the "
"basename of your new binding substituted for the <varname>skeleton</varname> "
"placeholder. The <filename>tools/extra_defs_gen/meson.build</filename> file "
"should also mention the new source filename."
msgstr ""

#: C/index-in.docbook:9146
#, no-wrap
msgid ""
"\n"
"#include &lt;glibmm_generate_extra_defs/generate_extra_defs.h&gt;\n"
"#include &lt;libsomething.h&gt;\n"
"#include &lt;iostream&gt;\n"
"\n"
"int main(int, char**)\n"
"{\n"
"  something_init();\n"
"\n"
"  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)\n"
"            &lt;&lt; get_defs(SOME_TYPE_STUFF);\n"
"  return 0;\n"
"}\n"
msgstr ""

#: C/index-in.docbook:9144
msgid ""
"Then edit the <filename>.cc</filename> file to specify the correct types. "
"For instance, your <function>main()</function> function might look like "
"this: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9164
msgid "Writing the vfuncs .defs"
msgstr ""

#: C/index-in.docbook:9165
msgid ""
"This <filename>.defs</filename> file describes virtual functions (vfuncs). "
"It must be written by hand. There is the skeleton file <filename>skeleton/"
"src/skeleton_vfunc.defs</filename> to start from. You can also look at "
"<application>gtkmm</application>'s <filename>gtk/src/gtk_vfuncs.defs</"
"filename> file."
msgstr ""

#: C/index-in.docbook:9176
msgid "The .hg and .ccg files"
msgstr ""

#: C/index-in.docbook:9177
msgid ""
"The .hg and .ccg source files are very much like .h and .cc C++ source "
"files, but they contain extra macros, such as <function>_CLASS_GOBJECT()</"
"function> and <function>_WRAP_METHOD()</function>, from which "
"<command>gmmproc</command> generates appropriate C++ source code, usually at "
"the same position in the header. Any additional C++ source code will be "
"copied verbatim into the corresponding .h or .cc file."
msgstr ""

#: C/index-in.docbook:9190
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/bin.h&gt;\n"
"#include &lt;gtkmm/actionable.h&gt;\n"
"_DEFS(gtkmm,gtk)\n"
"_PINCLUDE(gtkmm/private/bin_p.h)\n"
"\n"
"namespace Gtk\n"
"{\n"
"\n"
"class Button\n"
"  : public Bin,\n"
"    public Actionable\n"
"{\n"
"  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
"  _IMPLEMENTS_INTERFACE(Actionable)\n"
"public:\n"
"\n"
"  _CTOR_DEFAULT\n"
"  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
"\n"
"  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
"};\n"
"\n"
"} // namespace Gtk\n"
msgstr ""

#: C/index-in.docbook:9185
msgid ""
"A .hg file will typically include some headers and then declare a class, "
"using some macros to add API or behaviour to this class. For instance, "
"<application>gtkmm</application>'s <filename>button.hg</filename> looks "
"roughly like this: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9227
msgid "<function>_DEFS()</function>"
msgstr ""

#: C/index-in.docbook:9228
msgid ""
"Specifies the destination directory for generated sources, and the name of "
"the main .defs file that <command>gmmproc</command> should parse."
msgstr ""

#: C/index-in.docbook:9231
msgid "<function>_PINCLUDE()</function>"
msgstr ""

#: C/index-in.docbook:9232
msgid ""
"Tells <command>gmmproc</command> to include a header in the generated "
"<filename>private/button_p.h</filename> file."
msgstr ""

#: C/index-in.docbook:9235
msgid "<function>_CLASS_GTKOBJECT()</function>"
msgstr ""

#: C/index-in.docbook:9236
msgid ""
"Tells <command>gmmproc</command> to add some typedefs, constructors, and "
"standard methods to this class, as appropriate when wrapping a widget."
msgstr ""

#: C/index-in.docbook:9239
msgid "<function>_IMPLEMENTS_INTERFACE()</function>"
msgstr ""

#: C/index-in.docbook:9240
msgid ""
"Tells <command>gmmproc</command> to add initialization code for the "
"interface."
msgstr ""

#: C/index-in.docbook:9243
msgid "<function>_CTOR_DEFAULT</function>"
msgstr ""

#: C/index-in.docbook:9244
msgid "Adds a default constructor."
msgstr ""

#: C/index-in.docbook:9247
msgid ""
"<function>_WRAP_METHOD()</function>, <function>_WRAP_SIGNAL()</function>, "
"and <function>_WRAP_PROPERTY()</function>"
msgstr ""

#: C/index-in.docbook:9250
msgid "Add methods to wrap parts of the C API."
msgstr ""

#: C/index-in.docbook:9224
msgid "The macros in this example do the following: <_:variablelist-1/>"
msgstr ""

#: C/index-in.docbook:9257
#, no-wrap
msgid ""
"\n"
"$ cd gtk/src\n"
"$ /usr/lib/glibmm-2.68/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm\n"
msgstr ""

#: C/index-in.docbook:9254
msgid ""
"The .h and .cc files will be generated from the .hg and .ccg files by "
"processing them with <command>gmmproc</command> like so, though this happens "
"automatically when using the above build structure: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9262
msgid ""
"Notice that we provided <command>gmmproc</command> with the path to the .m4 "
"convert files, the path to the .defs file, the name of a .hg file, the "
"source directory, and the destination directory."
msgstr ""

#: C/index-in.docbook:9265
msgid ""
"You should avoid including the C header from your C++ header, to avoid "
"polluting the global namespace, and to avoid exporting unnecessary public "
"API. But you will need to include the necessary C headers from your .ccg "
"file."
msgstr ""

#: C/index-in.docbook:9270
msgid "The macros are explained in more detail in the following sections."
msgstr ""

#: C/index-in.docbook:9273
msgid "m4 Conversions"
msgstr ""

#: C/index-in.docbook:9281
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')\n"
msgstr ""

#: C/index-in.docbook:9274
msgid ""
"The macros that you use in the .hg and .ccg files often need to know how to "
"convert a C++ type to a C type, or vice-versa. <command>gmmproc</command> "
"takes this information from an .m4 file in your <literal>tools/m4/</literal> "
"or <literal>codegen/m4/</literal> directory. This allows it to call a C "
"function in the implementation of your C++ method, passing the appropriate "
"parameters to that C functon. For instance, this tells <command>gmmproc</"
"command> how to convert a <classname>GtkTreeView</classname> pointer to a "
"<classname>Gtk::TreeView</classname> pointer: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9286
msgid ""
"<literal>$3</literal> will be replaced by the parameter name when this "
"conversion is used by <command>gmmproc</command>."
msgstr ""

#: C/index-in.docbook:9293
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)\n"
"_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)\n"
"_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))\n"
msgstr ""

#: C/index-in.docbook:9290
msgid ""
"Some extra macros make this easier and consistent. Look in "
"<application>gtkmm</application>'s .m4 files for examples. For instance: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9302
msgid "m4 Initializations"
msgstr "安装m4"

#: C/index-in.docbook:9303
msgid ""
"Often when wrapping methods, it is desirable to store the return of the C "
"function in what is called an output parameter. In this case, the C++ method "
"returns <type>void</type> but an output parameter in which to store the "
"value of the C function is included in the argument list of the C++ method. "
"<command>gmmproc</command> allows such functionality, but appropriate "
"initialization macros must be included to tell <command>gmmproc</command> "
"how to initialize the C++ parameter from the return of the C function."
msgstr ""

#: C/index-in.docbook:9318
#, no-wrap
msgid ""
"\n"
"_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')\n"
msgstr ""

#: C/index-in.docbook:9312
msgid ""
"For example, if there was a C function that returned a <type>GtkWidget*</"
"type> and for some reason, instead of having the C++ method also return the "
"widget, it was desirable to have the C++ method place the widget in a "
"specified output parameter, an initialization macro such as the following "
"would be necessary: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9323
msgid ""
"<literal>$3</literal> will be replaced by the output parameter name of the C+"
"+ method and <literal>$4</literal> will be replaced by the return of the C "
"function when this initialization is used by <command>gmmproc</command>. For "
"convenience, <literal>$1</literal> will also be replaced by the C++ type "
"without the ampersand (&amp;) and <literal>$2</literal> will be replaced by "
"the C type."
msgstr ""

#: C/index-in.docbook:9334
msgid "Class macros"
msgstr ""

#: C/index-in.docbook:9335
msgid ""
"The class macro declares the class itself and its relationship with the "
"underlying C type. It generates some internal constructors, the member "
"<varname>gobject_</varname>, typedefs, the <function>gobj()</function> "
"accessors, type registration, and the <function>Glib::wrap()</function> "
"method, among other things."
msgstr ""

#: C/index-in.docbook:9340
msgid ""
"Other macros, such as <function>_WRAP_METHOD()</function> and "
"<function>_WRAP_SIGNAL()</function> may only be used after a call to a "
"<function>_CLASS_*</function> macro."
msgstr ""

#: C/index-in.docbook:9345
msgid "_CLASS_GOBJECT"
msgstr ""

#: C/index-in.docbook:9346
msgid ""
"This macro declares a wrapper for a type that is derived from "
"<classname>GObject</classname>, but whose wrapper is not derived from "
"<classname>Gtk::Object</classname>."
msgstr ""

#: C/index-in.docbook:9349
msgid ""
"<function>_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base "
"class, C base class )</function>"
msgstr ""

#: C/index-in.docbook:9351
#, no-wrap
msgid ""
"\n"
"_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)\n"
msgstr ""

#: C/index-in.docbook:9350
msgid ""
"For instance, from <filename>accelgroup.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9358
msgid "_CLASS_GTKOBJECT"
msgstr ""

#: C/index-in.docbook:9359
msgid ""
"This macro declares a wrapper for a type whose wrapper is derived from "
"<classname>Gtk::Object</classname>, such as a widget or dialog."
msgstr ""

#: C/index-in.docbook:9361
msgid ""
"<function>_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base "
"class, C base class )</function>"
msgstr ""

#: C/index-in.docbook:9363
#, no-wrap
msgid ""
"\n"
"_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)\n"
msgstr ""

#: C/index-in.docbook:9362 C/index-in.docbook:9847 C/index-in.docbook:9952
msgid ""
"For instance, from <filename>button.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9367
msgid ""
"You will typically use this macro when the class already derives from "
"<classname>Gtk::Object</classname>. For instance, you will use it when "
"wrapping a GTK Widget, because <classname>Gtk::Widget</classname> derives "
"from <classname>Gtk::Object</classname>."
msgstr ""

#: C/index-in.docbook:9371
msgid ""
"You might also derive non-widget classes from <classname>Gtk::Object</"
"classname> so they can be used without <classname>Glib::RefPtr</classname>. "
"For instance, they could then be instantiated with <function>Gtk::"
"make_managed()</function> or on the stack as a member variable. This is "
"convenient, but you should use this only when you are sure that true "
"reference-counting is not needed. We consider it useful for widgets."
msgstr ""

#: C/index-in.docbook:9381
msgid "_CLASS_BOXEDTYPE"
msgstr ""

#: C/index-in.docbook:9382
msgid ""
"This macro declares a wrapper for a non-<classname>GObject</classname> "
"struct, registered with <function>g_boxed_type_register_static()</function>."
msgstr ""

#: C/index-in.docbook:9385
msgid ""
"<function>_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, "
"free function )</function>"
msgstr ""

#: C/index-in.docbook:9387
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)\n"
msgstr ""

#: C/index-in.docbook:9386
msgid ""
"For instance, from <classname>Gdk::RGBA</classname>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9394
msgid "_CLASS_BOXEDTYPE_STATIC"
msgstr ""

#: C/index-in.docbook:9395
msgid ""
"This macro declares a wrapper for a simple assignable struct such as "
"<classname>GdkRectangle</classname>. It is similar to "
"<function>_CLASS_BOXEDTYPE</function>, but the C struct is not allocated "
"dynamically."
msgstr ""

#: C/index-in.docbook:9399
msgid "<function>_CLASS_BOXEDTYPE_STATIC( C++ class, C class )</function>"
msgstr ""

#: C/index-in.docbook:9401
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)\n"
msgstr ""

#: C/index-in.docbook:9400
msgid ""
"For instance, for <classname>Gdk::Rectangle</classname>: <_:programlisting-1/"
">"
msgstr ""

#: C/index-in.docbook:9408
msgid "_CLASS_OPAQUE_COPYABLE"
msgstr ""

#: C/index-in.docbook:9409
msgid ""
"This macro declares a wrapper for an opaque struct that has copy and free "
"functions. The new, copy and free functions will be used to instantiate the "
"default constructor, copy constructor and destructor."
msgstr ""

#: C/index-in.docbook:9412
msgid ""
"<function>_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy "
"function, free function )</function>"
msgstr ""

#: C/index-in.docbook:9414
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)\n"
msgstr ""

#: C/index-in.docbook:9413
msgid ""
"For instance, from <classname>Glib::Checksum</classname>: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9421
msgid "_CLASS_OPAQUE_REFCOUNTED"
msgstr ""

#: C/index-in.docbook:9422
msgid ""
"This macro declares a wrapper for a reference-counted opaque struct. The C++ "
"wrapper cannot be directly instantiated and can only be used with "
"<classname>Glib::RefPtr</classname>."
msgstr ""

#: C/index-in.docbook:9425
msgid ""
"<function>_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref "
"function, unref function )</function>"
msgstr ""

#: C/index-in.docbook:9427
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)\n"
msgstr ""

#: C/index-in.docbook:9426
msgid ""
"For instance, for <classname>Pango::Coverage</classname>: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9434
msgid "_CLASS_GENERIC"
msgstr ""

#: C/index-in.docbook:9435
msgid ""
"This macro can be used to wrap structs which don't fit into any specialized "
"category."
msgstr ""

#: C/index-in.docbook:9437
msgid "<function>_CLASS_GENERIC( C++ class, C class )</function>"
msgstr ""

#: C/index-in.docbook:9439
#, no-wrap
msgid ""
"\n"
"_CLASS_GENERIC(AttrIter, PangoAttrIterator)\n"
msgstr ""

#: C/index-in.docbook:9438
msgid ""
"For instance, for <classname>Pango::AttrIter</classname>: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9446
msgid "_CLASS_INTERFACE"
msgstr ""

#: C/index-in.docbook:9447
msgid ""
"This macro declares a wrapper for a type that is derived from "
"<classname>GTypeInterface</classname>."
msgstr ""

#: C/index-in.docbook:9450
msgid ""
"<function>_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface "
"struct, Base C++ class (optional), Base C class (optional) )</function>"
msgstr ""

#: C/index-in.docbook:9453
#, no-wrap
msgid ""
"\n"
"_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)\n"
msgstr ""

#: C/index-in.docbook:9451
msgid ""
"For instance, from <filename>celleditable.hg</filename>: <_:programlisting-1/"
">"
msgstr ""

#: C/index-in.docbook:9460
#, no-wrap
msgid ""
"\n"
"_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)\n"
msgstr ""

#: C/index-in.docbook:9457
msgid ""
"Two extra parameters are optional, for the case that the interface derives "
"from another interface, which should be the case when the GInterface has "
"another GInterface as a prerequisite. For instance, from "
"<filename>loadableicon.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9469
msgid "Constructor macros"
msgstr ""

#: C/index-in.docbook:9470
msgid ""
"The <function>_CTOR_DEFAULT()</function> and <function>_WRAP_CTOR()</"
"function> macros add constructors, wrapping the specified <function>*_new()</"
"function> C functions. These macros assume that the C object has properties "
"with the same names as the function parameters, as is usually the case, so "
"that it can supply the parameters directly to a <function>g_object_new()</"
"function> call. These constructors never actually call the "
"<function>*_new()</function> C functions, because <application>gtkmm</"
"application> must actually instantiate derived GTypes, and the "
"<function>*_new()</function> C functions are meant only as convenience "
"functions for C programmers."
msgstr ""

#: C/index-in.docbook:9485
#, no-wrap
msgid ""
"\n"
"class TextMark : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)\n"
"\n"
"protected:\n"
"  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)\n"
"\n"
"public:\n"
"  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)\n"
msgstr ""

#: C/index-in.docbook:9480
msgid ""
"When using <function>_CLASS_GOBJECT()</function>, the constructors should be "
"protected (rather than public) and each constructor should have a "
"corresponding <function>_WRAP_CREATE()</function> in the public section. "
"This prevents the class from being instantiated without using a "
"<classname>RefPtr</classname>. For instance: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9499
msgid "_CTOR_DEFAULT"
msgstr ""

#: C/index-in.docbook:9500
msgid "This macro creates a default constructor with no arguments."
msgstr ""

#: C/index-in.docbook:9505
msgid "_WRAP_CTOR"
msgstr ""

#: C/index-in.docbook:9506
msgid ""
"This macro creates a constructor with arguments, equivalent to a "
"<function>*_new()</function> C function. It won't actually call the "
"<function>*_new()</function> function, but will simply create an equivalent "
"constructor with the same argument types. It takes a C++ constructor "
"signature, and a C function name."
msgstr ""

#: C/index-in.docbook:9516 C/index-in.docbook:10020
msgid "errthrow"
msgstr ""

#: C/index-in.docbook:9518
msgid ""
"This tells <command>gmmproc</command> that the C <function>*_new()</"
"function> has a final <type>GError**</type> parameter which should be "
"ignored."
msgstr ""

#: C/index-in.docbook:9513
msgid "It also takes an optional extra argument: <_:variablelist-1/>"
msgstr ""

#: C/index-in.docbook:9527
msgid "Hand-coding constructors"
msgstr ""

#: C/index-in.docbook:9536
#, no-wrap
msgid ""
"\n"
"Button::Button(const Glib::ustring&amp; label, bool mnemonic)\n"
":\n"
"  _CONSTRUCT(\"label\", label.c_str(), \"use_underline\", gboolean(mnemonic))\n"
"{}\n"
msgstr ""

#: C/index-in.docbook:9528
msgid ""
"When a constructor must be partly hand written because, for instance, the "
"<function>*_new()</function> C function's parameters do not correspond "
"directly to object properties, or because the <function>*_new()</function> C "
"function does more than call <function>g_object_new()</function>, the "
"<function>_CONSTRUCT()</function> macro may be used in the .ccg file to save "
"some work. The <function>_CONSTRUCT</function> macro takes a series of "
"property names and values. For instance, from <filename>button.ccg</"
"filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9548
msgid "Macros that suppress generation of some code"
msgstr ""

#: C/index-in.docbook:9549
msgid ""
"Some macros suppress the generation of some code when they are used after a "
"<function>_CLASS_*</function> macro. Some suppress the definition in the "
"generated .cc file, others suppress both the declaration in the .h file and "
"the definition in the .cc file."
msgstr ""

#: C/index-in.docbook:9556
msgid "_CUSTOM_DEFAULT_CTOR"
msgstr ""

#: C/index-in.docbook:9557
msgid ""
"Suppresses declaration and definition of default constructor in "
"<function>_CLASS_BOXEDTYPE</function>, <function>_CLASS_BOXEDTYPE_STATIC</"
"function> and <function>_CLASS_OPAQUE_COPYABLE</function>."
msgstr ""

#: C/index-in.docbook:9564
msgid "_CUSTOM_CTOR_CAST"
msgstr ""

#: C/index-in.docbook:9565
msgid ""
"Suppresses declaration and definition of the constructor that takes a "
"pointer to the wrapped C object in <function>_CLASS_BOXEDTYPE</function> and "
"<function>_CLASS_BOXEDTYPE_STATIC</function>."
msgstr ""

#: C/index-in.docbook:9569
msgid ""
"Suppresses definition of the constructor that takes a pointer to the wrapped "
"C object in <function>_CLASS_INTERFACE</function> and "
"<function>_CLASS_OPAQUE_COPYABLE</function>."
msgstr ""

#: C/index-in.docbook:9573
msgid ""
"Suppresses definition of the constructor that takes a pointer to the wrapped "
"C object and the constructor that takes construct_params in "
"<function>_CLASS_GOBJECT</function> and <function>_CLASS_GTKOBJECT</"
"function>."
msgstr ""

#: C/index-in.docbook:9580
msgid "_CUSTOM_DTOR"
msgstr ""

#: C/index-in.docbook:9581
msgid ""
"Suppresses definition of destructor in <function>_CLASS_GOBJECT</function> "
"and <function>_CLASS_GTKOBJECT</function>."
msgstr ""

#: C/index-in.docbook:9587
msgid "_CUSTOM_MOVE_OPERATIONS"
msgstr ""

#: C/index-in.docbook:9588
msgid ""
"Suppresses declaration and definition of move constructor and move "
"assignment operator in <function>_CLASS_GOBJECT</function> and "
"<function>_CLASS_GTKOBJECT</function>."
msgstr ""

#: C/index-in.docbook:9593
#, no-wrap
msgid ""
"\n"
"class Derived : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(Derived, GDerived, G_DERIVED, Glib::Object, GObject)\n"
"\n"
"  _CUSTOM_MOVE_OPERATIONS\n"
"\n"
"public:\n"
"  Derived(Derived&amp;&amp; src) noexcept;\n"
"  Derived&amp; operator=(Derived&amp;&amp; src) noexcept;\n"
"  // ...\n"
"};\n"
msgstr ""

#: C/index-in.docbook:9592
msgid "For example: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9610
msgid "_CUSTOM_WRAP_NEW"
msgstr ""

#: C/index-in.docbook:9611
msgid ""
"Suppresses definition of <function>Glib::wrap_new()</function> function in "
"<function>_CLASS_GOBJECT</function>."
msgstr ""

#: C/index-in.docbook:9617
msgid "_CUSTOM_WRAP_FUNCTION"
msgstr ""

#: C/index-in.docbook:9618
msgid ""
"Suppresses definition of <function>Glib::wrap()</function> function in "
"<function>_CLASS_GOBJECT</function> and <function>_CLASS_GTKOBJECT</"
"function>."
msgstr ""

#: C/index-in.docbook:9624
msgid "_NO_WRAP_FUNCTION"
msgstr ""

#: C/index-in.docbook:9625
msgid ""
"Suppresses declaration and definition of <function>Glib::wrap()</function> "
"function in <function>_CLASS_GOBJECT</function>, <function>_CLASS_BOXEDTYPE</"
"function>, <function>_CLASS_BOXEDTYPE_STATIC</function>, "
"<function>_CLASS_OPAQUE_COPYABLE</function>, <function>_CLASS_INTERFACE</"
"function> and <function>_CLASS_GTKOBJECT</function>."
msgstr ""

#: C/index-in.docbook:9635
msgid "Method macros"
msgstr ""

#: C/index-in.docbook:9638
msgid "_WRAP_METHOD"
msgstr ""

#: C/index-in.docbook:9639
msgid "This macro generates the C++ method to wrap a C function."
msgstr ""

#: C/index-in.docbook:9640
msgid ""
"<function>_WRAP_METHOD( C++ method signature, C function name)</function>"
msgstr ""

#: C/index-in.docbook:9642
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)\n"
msgstr ""

#: C/index-in.docbook:9641
msgid "For instance, from <filename>entry.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9646
msgid ""
"The C function (e.g. <function>gtk_entry_set_text</function>) is described "
"more fully in the .defs file, and the <filename>convert*.m4</filename> files "
"contain the necessary conversion from the C++ parameter type to the C "
"parameter type. This macro also generates doxygen documentation comments "
"based on the <filename>*_docs.xml</filename> and <filename>*_docs_override."
"xml</filename> files."
msgstr ""

#: C/index-in.docbook:9655 C/index-in.docbook:9885 C/index-in.docbook:9995
msgid "refreturn"
msgstr ""

#: C/index-in.docbook:9657
msgid ""
"Do an extra <function>reference()</function> on the return value, in case "
"the C function does not provide a reference."
msgstr ""

#: C/index-in.docbook:9662 C/index-in.docbook:9785
msgid "errthrow [\"&lt;exceptions&gt;\"]"
msgstr ""

#: C/index-in.docbook:9664
msgid ""
"Use the last GError** parameter of the C function to throw an exception. The "
"optional \"&lt;exceptions&gt;\" is a comma-separated list of exceptions that "
"can be thrown. It determines which @throws Doxygen commands are added to the "
"documentation. Default value is <classname>Glib::Error</classname>. If you "
"want a comma in the description of an exception, precede it by a backslash. "
"Example: <code>errthrow \"Glib::OptionError Hello\\, world, Glib::"
"ConvertError\"</code>"
msgstr ""

#: C/index-in.docbook:9675 C/index-in.docbook:9893 C/index-in.docbook:9960
#: C/index-in.docbook:10206
msgid "deprecated [\"&lt;text&gt;\"]"
msgstr ""

#: C/index-in.docbook:9677 C/index-in.docbook:9895 C/index-in.docbook:9962
#: C/index-in.docbook:10208
msgid ""
"Puts the generated code in #ifdef blocks. Text about the deprecation can be "
"specified as an optional parameter."
msgstr ""

#: C/index-in.docbook:9683
msgid "constversion"
msgstr ""

#: C/index-in.docbook:9685
msgid ""
"Just call the non-const version of the same function, instead of generating "
"almost duplicate code."
msgstr ""

#: C/index-in.docbook:9690 C/index-in.docbook:9798 C/index-in.docbook:9900
#: C/index-in.docbook:9967 C/index-in.docbook:10213
msgid "newin \"&lt;version&gt;\""
msgstr ""

#: C/index-in.docbook:9692 C/index-in.docbook:9800 C/index-in.docbook:9902
#: C/index-in.docbook:9969 C/index-in.docbook:10215
msgid ""
"Adds a @newin Doxygen command to the documentation, or replaces the @newin "
"command generated from the C documentation."
msgstr ""

#: C/index-in.docbook:9697 C/index-in.docbook:9907 C/index-in.docbook:10042
#: C/index-in.docbook:10129
msgid "ifdef &lt;identifier&gt;"
msgstr ""

#: C/index-in.docbook:9699 C/index-in.docbook:9909 C/index-in.docbook:10044
#: C/index-in.docbook:10131
msgid "Puts the generated code in #ifdef blocks."
msgstr ""

#: C/index-in.docbook:9703 C/index-in.docbook:10048
msgid "slot_name &lt;parameter_name&gt;"
msgstr ""

#: C/index-in.docbook:9705 C/index-in.docbook:10050
msgid ""
"Specifies the name of the slot parameter of the method, if it has one. This "
"enables <command>gmmproc</command> to generate code to copy the slot and "
"pass the copy on to the C function in its final <literal>gpointer user_data</"
"literal> parameter. The <literal>slot_callback</literal> option must also be "
"used to specify the name of the glue callback function to also pass on to "
"the C function."
msgstr ""

#: C/index-in.docbook:9715 C/index-in.docbook:10060
msgid "slot_callback &lt;function_name&gt;"
msgstr ""

#: C/index-in.docbook:9717 C/index-in.docbook:10062
msgid ""
"Used in conjunction with the <literal>slot_name</literal> option to specify "
"the name of the glue callback function that handles extracting the slot and "
"then calling it. The address of this callback is also passed on to the C "
"function that the method wraps."
msgstr ""

#: C/index-in.docbook:9725 C/index-in.docbook:10070
msgid "no_slot_copy"
msgstr ""

#: C/index-in.docbook:9727 C/index-in.docbook:10072
msgid ""
"Tells <command>gmmproc</command> not to pass a copy of the slot to the C "
"function, if the method has one. Instead the slot itself is passed. The slot "
"parameter name and the glue callback function must have been specified with "
"the <literal>slot_name</literal> and <literal>slot_callback</literal> "
"options respectively."
msgstr ""

#: C/index-in.docbook:9652 C/index-in.docbook:9782 C/index-in.docbook:9855
#: C/index-in.docbook:9957 C/index-in.docbook:9992 C/index-in.docbook:10147
msgid "There are some optional extra arguments: <_:variablelist-1/>"
msgstr ""

#: C/index-in.docbook:9740
msgid ""
"Objects used via <classname>RefPtr</classname>: Pass the <classname>RefPtr</"
"classname> as a const reference. For instance, <code>const Glib::RefPtr&lt;"
"Gtk::FileFilter&gt;&amp; filter</code>."
msgstr ""

#: C/index-in.docbook:9744
msgid ""
"Const Objects used via <classname>RefPtr</classname>: If the object should "
"not be changed by the function, then make sure that the object is const, "
"even if the <classname>RefPtr</classname> is already const. For instance, "
"<code>const Glib::RefPtr&lt;const Gtk::FileFilter&gt;&amp; filter</code>."
msgstr ""

#: C/index-in.docbook:9749
msgid ""
"Wrapping <classname>GList*</classname> and <classname>GSList*</classname> "
"parameters: First, you need to discover what objects are contained in the "
"list's data field for each item, usually by reading the documentation for "
"the C function. The list can then be wrapped by a <classname>std::vector</"
"classname> type. For instance, <code>std::vector&lt;Glib::RefPtr&lt;Gdk::"
"Pixbuf&gt;&gt;</code>. You may need to define a Traits type to specify how "
"the C and C++ types should be converted."
msgstr ""

#: C/index-in.docbook:9765
#, no-wrap
msgid "#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')"
msgstr ""

#: C/index-in.docbook:9757
msgid ""
"Wrapping <classname>GList*</classname> and <classname>GSList*</classname> "
"return types: You must discover whether the caller should free the list and "
"whether it should release the items in the list, again by reading the "
"documentation of the C function. With this information you can choose the "
"ownership (none, shallow or deep) for the m4 conversion rule, which you "
"should probably put directly into the .hg file because the ownership depends "
"on the function rather than the type. For instance: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9736
msgid ""
"Selecting which C++ types should be used is also important when wrapping C "
"API. Though it's usually obvious what C++ types should be used in the C++ "
"method, here are some hints: <_:itemizedlist-1/>"
msgstr ""

#: C/index-in.docbook:9771
msgid "_WRAP_METHOD_DOCS_ONLY"
msgstr ""

#: C/index-in.docbook:9772
msgid ""
"This macro is like <function>_WRAP_METHOD()</function>, but it generates "
"only the documentation for a C++ method that wraps a C function. Use this "
"when you must hand-code the method, but you want to use the documentation "
"that would be generated if the method was generated."
msgstr ""

#: C/index-in.docbook:9776
msgid "<function>_WRAP_METHOD_DOCS_ONLY(C function name)</function>"
msgstr ""

#: C/index-in.docbook:9778
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD_DOCS_ONLY(gtk_container_add)\n"
msgstr ""

#: C/index-in.docbook:9777
msgid ""
"For instance, from <filename>container.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9787
msgid ""
"Excludes documentation of the last GError** parameter of the C function. The "
"optional \"&lt;exceptions&gt;\" is a comma-separated list of exceptions that "
"can be thrown. It determines which @throws Doxygen commands are added to the "
"documentation. Default value is <classname>Glib::Error</classname>. If you "
"want a comma in the description of an exception, precede it by a backslash. "
"Example: <code>errthrow \"Glib::OptionError Hello\\, world, Glib::"
"ConvertError\"</code>"
msgstr ""

#: C/index-in.docbook:9805
msgid "voidreturn"
msgstr ""

#: C/index-in.docbook:9807
msgid ""
"Don't include a @return Doxygen command in the documentation. Useful if the "
"wrapped C function returns a value, but the corresponding C++ method returns "
"<type>void</type>."
msgstr ""

#: C/index-in.docbook:9817
msgid "_IGNORE, _IGNORE_SIGNAL, _IGNORE_PROPERTY"
msgstr ""

#: C/index-in.docbook:9818
msgid ""
"<command>gmmproc</command> will warn you on stdout about functions, signals, "
"properties and child properties that you have forgotten to wrap, helping to "
"ensure that you are wrapping the complete API. But if you don't want to wrap "
"some functions, signals, properties or child properties, or if you chose to "
"hand-code some methods then you can use the _IGNORE(), _IGNORE_SIGNAL() or "
"_IGNORE_PROPERTY() macro to make <command>gmmproc</command> stop complaining."
msgstr ""

#: C/index-in.docbook:9826
#, no-wrap
msgid ""
"<function>_IGNORE(C function name 1, C function name 2, etc)\n"
"_IGNORE_SIGNAL(C signal name 1, C signal name 2, etc)\n"
"_IGNORE_PROPERTY(C property name 1, C property name 2, etc)</function>"
msgstr ""

#: C/index-in.docbook:9831
#, no-wrap
msgid ""
"\n"
"_IGNORE(gtk_flow_box_set_filter_func, gtk_flow_box_set_sort_func)\n"
"_IGNORE_SIGNAL(activate-cursor-child, toggle-cursor-child, move-cursor)\n"
msgstr ""

#: C/index-in.docbook:9830
msgid ""
"For instance, from <filename>flowbox.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9839
msgid "_WRAP_SIGNAL"
msgstr ""

#: C/index-in.docbook:9840
msgid ""
"This macro generates the C++ libsigc++-style signal to wrap a C GObject "
"signal. It actually generates a public accessor method, such as "
"<function>signal_clicked()</function>, which returns a proxy object. "
"<command>gmmproc</command> uses the .defs file to discover the C parameter "
"types and the .m4 convert files to discover appropriate type conversions."
msgstr ""

#: C/index-in.docbook:9846
msgid ""
"<function>_WRAP_SIGNAL( C++ signal handler signature, C signal name)</"
"function>"
msgstr ""

#: C/index-in.docbook:9848
#, no-wrap
msgid ""
"\n"
"_WRAP_SIGNAL(void clicked(),\"clicked\")\n"
msgstr ""

#: C/index-in.docbook:9852
msgid ""
"Signals usually have function pointers in the GTK struct, with a "
"corresponding enum value and a <function>g_signal_new()</function> in the .c "
"file."
msgstr ""

#: C/index-in.docbook:9858
msgid "no_default_handler"
msgstr ""

#: C/index-in.docbook:9860
msgid ""
"Do not generate an <function>on_something()</function> virtual method to "
"allow easy overriding of the default signal handler. Use this when adding a "
"signal with a default signal handler would break the ABI by increasing the "
"size of the class's virtual function table, and when adding a signal without "
"a public C default handler."
msgstr ""

#: C/index-in.docbook:9869
msgid "custom_default_handler"
msgstr ""

#: C/index-in.docbook:9871
msgid ""
"Generate a declaration of the <function>on_something()</function> virtual "
"method in the <filename>.h</filename> file, but do not generate a definition "
"in the <filename>.cc</filename> file. Use this when you must generate the "
"definition by hand."
msgstr ""

#: C/index-in.docbook:9878
msgid "custom_c_callback"
msgstr ""

#: C/index-in.docbook:9880
msgid ""
"Do not generate a C callback function for the signal. Use this when you must "
"generate the callback function by hand."
msgstr ""

#: C/index-in.docbook:9887
msgid ""
"Do an extra <function>reference()</function> on the return value of the "
"<function>on_something()</function> virtual method, in case the C function "
"does not provide a reference."
msgstr ""

#: C/index-in.docbook:9913 C/index-in.docbook:10096
msgid "exception_handler &lt;method_name&gt;"
msgstr ""

#: C/index-in.docbook:9915 C/index-in.docbook:10098
msgid ""
"Allows to use custom exception handler instead of default one. Exception "
"might be rethrown by user-defined handler, and it will be caught by default "
"handler."
msgstr ""

#: C/index-in.docbook:9921
msgid "detail_name &lt;parameter_name&gt;"
msgstr ""

#: C/index-in.docbook:9923
msgid ""
"Adds a <type>const Glib::ustring&amp;</type> parameter to the "
"<methodname>signal_something()</methodname> method. Use it, if the signal "
"accepts a detailed signal name, i.e. if the underlying C code registers the "
"signal with the <literal>G_SIGNAL_DETAILED</literal> flag."
msgstr ""

#: C/index-in.docbook:9930
msgid "two_signal_methods"
msgstr ""

#: C/index-in.docbook:9932
msgid ""
"Used in conjunction with the <literal>detail_name</literal> option to "
"generate two <methodname>signal_something()</methodname> methods, one "
"without a parameter and one with a parameter without a default value. With "
"only the <literal>detail_name</literal> option one method is generated, with "
"a parameter with default value. Use the <literal>two_signal_methods</"
"literal> option, if it's necessary in order to preserve ABI."
msgstr ""

#: C/index-in.docbook:9946
msgid "_WRAP_PROPERTY"
msgstr ""

#: C/index-in.docbook:9947
msgid ""
"This macro generates the C++ method to wrap a C GObject property. You must "
"specify the property name and the wanted C++ type for the property. "
"<command>gmmproc</command> uses the .defs file to discover the C type and "
"the .m4 convert files to discover appropriate type conversions."
msgstr ""

#: C/index-in.docbook:9951
msgid "<function>_WRAP_PROPERTY(C property name, C++ type)</function>"
msgstr ""

#: C/index-in.docbook:9953
#, no-wrap
msgid ""
"\n"
"_WRAP_PROPERTY(\"label\", Glib::ustring)\n"
msgstr ""

#: C/index-in.docbook:9978
msgid "_WRAP_VFUNC"
msgstr ""

#: C/index-in.docbook:9979
msgid "This macro generates the C++ method to wrap a virtual C function."
msgstr ""

#: C/index-in.docbook:9980
msgid ""
"<function>_WRAP_VFUNC( C++ method signature, C function name)</function>"
msgstr ""

#: C/index-in.docbook:9982
#, no-wrap
msgid ""
"\n"
"_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)\n"
msgstr ""

#: C/index-in.docbook:9981
msgid ""
"For instance, from <filename>widget.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:9986
msgid ""
"The C function (e.g. <function>get_request_mode</function>) is described "
"more fully in the <filename>*_vfuncs.defs</filename> file, and the "
"<filename>convert*.m4</filename> files contain the necessary conversion from "
"the C++ parameter type to the C parameter type. Conversions can also be "
"written in the .hg file. Virtual functions often require special conversions "
"that are best kept local to the .hg file where they are used."
msgstr ""

#: C/index-in.docbook:9997
msgid ""
"Do an extra <function>reference()</function> on the return value of the "
"<function>something_vfunc()</function> function, in case the virtual C "
"function does not provide a reference."
msgstr ""

#: C/index-in.docbook:10003
msgid "refreturn_ctype"
msgstr ""

#: C/index-in.docbook:10005
msgid ""
"Do an extra <function>reference()</function> on the return value of an "
"overridden <function>something_vfunc()</function> function in the C callback "
"function, in case the calling C function expects it to provide a reference."
msgstr ""

#: C/index-in.docbook:10012
msgid "keep_return"
msgstr ""

#: C/index-in.docbook:10014
msgid ""
"Keep a copy of the return value in the C callback function, in case the "
"calling C function does not expect to get its own reference."
msgstr ""

#: C/index-in.docbook:10022
msgid ""
"Use the last GError** parameter of the C virtual function (if there is one) "
"to throw an exception."
msgstr ""

#: C/index-in.docbook:10027
msgid "custom_vfunc"
msgstr ""

#: C/index-in.docbook:10029
msgid ""
"Do not generate a definition of the vfunc in the <filename>.cc</filename> "
"file. Use this when you must generate the vfunc by hand."
msgstr ""

#: C/index-in.docbook:10035
msgid "custom_vfunc_callback"
msgstr ""

#: C/index-in.docbook:10037
msgid ""
"Do not generate a C callback function for the vfunc. Use this when you must "
"generate the callback function by hand."
msgstr ""

#: C/index-in.docbook:10080
msgid "return_value &lt;value&gt;"
msgstr ""

#: C/index-in.docbook:10082
msgid "Defines a non-default return value."
msgstr ""

#: C/index-in.docbook:10086
msgid "err_return_value &lt;value&gt;"
msgstr ""

#: C/index-in.docbook:10088
msgid ""
"Defines a non-default return value, used only if the C++ "
"<function>something_vfunc()</function> function throws an exception which is "
"propagated to the C callback function. If return_value is specified, but "
"err_return_value is not, then return_value is used also when an exception is "
"propagated."
msgstr ""

#: C/index-in.docbook:10105
msgid ""
"A rule to which there may be exceptions: If the virtual C function returns a "
"pointer to an object derived from <classname>GObject</classname>, i.e. a "
"reference-counted object, then the virtual C++ function shall return a "
"<classname>Glib::RefPtr&lt;&gt;</classname> object. One of the extra "
"arguments <parameter>refreturn</parameter> or <parameter>refreturn_ctype</"
"parameter> is required."
msgstr ""

#: C/index-in.docbook:10116
msgid "Other macros"
msgstr ""

#: C/index-in.docbook:10118
msgid "_IMPLEMENTS_INTERFACE"
msgstr ""

#: C/index-in.docbook:10119
msgid "This macro generates initialization code for the interface."
msgstr ""

#: C/index-in.docbook:10120
msgid "<function>_IMPLEMENTS_INTERFACE(C++ interface name)</function>"
msgstr ""

#: C/index-in.docbook:10122
#, no-wrap
msgid ""
"\n"
"_IMPLEMENTS_INTERFACE(Orientable)\n"
msgstr ""

#: C/index-in.docbook:10121
msgid "For instance, from <filename>grid.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10126
msgid "There is one optional extra argument: <_:variablelist-1/>"
msgstr ""

#: C/index-in.docbook:10139
msgid "_WRAP_ENUM"
msgstr ""

#: C/index-in.docbook:10140
msgid ""
"This macro generates a C++ enum to wrap a C enum. You must specify the "
"desired C++ name and the name of the underlying C enum."
msgstr ""

#: C/index-in.docbook:10143
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(WindowType, GtkWindowType)\n"
msgstr ""

#: C/index-in.docbook:10142
msgid "For instance, from <filename>enums.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10150
msgid "NO_GTYPE"
msgstr ""

#: C/index-in.docbook:10152
msgid ""
"Use this option, if the enum is not a <classname>GType</classname>. This is "
"the case when there is no <function>*_get_type()</function> function for the "
"C enum, but be careful that you don't just need to include an extra header "
"for that function. You should also file a bug against the C API, because all "
"enums should be registered as GTypes."
msgstr ""

#: C/index-in.docbook:10157
msgid ""
"If you specify <literal>NO_GTYPE</literal>, don't use that enum as the type "
"in _WRAP_PROPERTY. It would cause a runtime error, when the generated "
"<methodname>property_*()</methodname> method is called."
msgstr ""

#: C/index-in.docbook:10161
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)\n"
"      "
msgstr ""

#: C/index-in.docbook:10160
msgid ""
"For example, from <filename>icontheme.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10168
msgid "gtype_func &lt;function_name&gt;"
msgstr ""

#: C/index-in.docbook:10170
msgid ""
"Specifies the name of the <function>*_get_type()</function> function for the "
"C enum. Use this parameter if <command>gmmproc</command> can't deduce the "
"correct function name from the name of the C enum type."
msgstr ""

#: C/index-in.docbook:10174
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(ProxyFlags, GDBusProxyFlags, gtype_func g_dbus_proxy_flags_get_type)\n"
"      "
msgstr ""

#: C/index-in.docbook:10173
msgid ""
"For example, from <filename>dbusproxy.hg</filename> in glibmm: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10181
msgid "CONV_TO_INT"
msgstr ""

#: C/index-in.docbook:10183
msgid ""
"\"Convertible to int.\" Generates a plain enum (not an enum class) within a "
"class. Such an enum is scoped like an enum class, but unlike an enum class, "
"it can be implicitly converted to <type>int</type>."
msgstr ""

#: C/index-in.docbook:10187
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(ResponseType, GtkResponseType, CONV_TO_INT)\n"
"      "
msgstr ""

#: C/index-in.docbook:10186
msgid "For example, from <filename>dialog.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10194
msgid "s#&lt;from&gt;#&lt;to&gt;#"
msgstr ""

#: C/index-in.docbook:10196
msgid ""
"Substitutes (part of) the name of one or more enum constants. You can add "
"any number of substitutions."
msgstr ""

#: C/index-in.docbook:10199
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(SeekType, GSeekType, NO_GTYPE, s#^SEEK_#SEEK_TYPE_#)\n"
"      "
msgstr ""

#: C/index-in.docbook:10198
msgid ""
"For example, from <filename>iochannel.hg</filename> in glibmm: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10224
msgid "_WRAP_ENUM_DOCS_ONLY"
msgstr ""

#: C/index-in.docbook:10225
msgid ""
"This macro just generates a Doxygen documentationn block for the enum. This "
"is useful for enums that can't be wrapped with <function>_WRAP_ENUM()</"
"function> because they are complexly defined (maybe using C macros) but "
"including the generated enum documentation is still desired. It is used with "
"the same syntax as <function>_WRAP_ENUM()</function> and also processes the "
"same options (though NO_GTYPE, gtype_func &lt;function_name&gt; and "
"CONV_TO_INT are ignored because they make no difference when just generating "
"the enum's documentation)."
msgstr ""

#: C/index-in.docbook:10237
msgid "_WRAP_GERROR"
msgstr ""

#: C/index-in.docbook:10238
msgid ""
"This macro generates a C++ exception class, derived from <classname>Glib::"
"Error</classname>, with a <type>Code</type> enum and a <methodname>code()</"
"methodname> method. You must specify the desired C++ name, the name of the "
"corresponding C enum, and the prefix for the C enum values."
msgstr ""

#: C/index-in.docbook:10241
msgid ""
"This exception can then be thrown by methods which are generated from "
"_WRAP_METHOD() with the errthrow option."
msgstr ""

#: C/index-in.docbook:10244
#, no-wrap
msgid ""
"\n"
"_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)\n"
msgstr ""

#: C/index-in.docbook:10243
msgid ""
"For instance, from <filename>pixbuf.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10248
msgid ""
"_WRAP_GERROR() accepts the same optional arguments as _WRAP_ENUM() (though "
"CONV_TO_INT is ignored because all exception class enums are plain enums "
"within a class)."
msgstr ""

#: C/index-in.docbook:10254
msgid "_MEMBER_GET / _MEMBER_SET"
msgstr ""

#: C/index-in.docbook:10255
msgid ""
"Use these macros if you're wrapping a simple struct or boxed type that "
"provides direct access to its data members, to create getters and setters "
"for the data members."
msgstr ""

#: C/index-in.docbook:10259
msgid "<function>_MEMBER_GET(C++ name, C name, C++ type, C type)</function>"
msgstr ""

#: C/index-in.docbook:10260
msgid "<function>_MEMBER_SET(C++ name, C name, C++ type, C type)</function>"
msgstr ""

#: C/index-in.docbook:10263
#, no-wrap
msgid "_MEMBER_GET(x, x, int, int)"
msgstr ""

#: C/index-in.docbook:10261
msgid ""
"For example, in <filename>rectangle.hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10267
msgid "_MEMBER_GET_PTR / _MEMBER_SET_PTR"
msgstr ""

#: C/index-in.docbook:10268
msgid ""
"Use these macros to automatically provide getters and setters for a data "
"member that is a pointer type. For the getter function, it will create two "
"methods, one const and one non-const."
msgstr ""

#: C/index-in.docbook:10273
msgid ""
"<function>_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)</function>"
msgstr ""

#: C/index-in.docbook:10274
msgid ""
"<function>_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)</function>"
msgstr ""

#: C/index-in.docbook:10276
#, no-wrap
msgid ""
"\n"
"// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)\n"
"// It's just a comment. It's difficult to find a real-world example.\n"
msgstr ""

#: C/index-in.docbook:10275
msgid ""
"For example, for <classname>Pango::Analysis</classname> in <filename>item."
"hg</filename>: <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10283
msgid "_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT"
msgstr ""

#: C/index-in.docbook:10284
msgid ""
"Use these macros to provide getters and setters for a data member that is a "
"<classname>GObject</classname> type that must be referenced before being "
"returned."
msgstr ""

#: C/index-in.docbook:10289
msgid ""
"<function>_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)</function>"
msgstr ""

#: C/index-in.docbook:10290
msgid ""
"<function>_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)</function>"
msgstr ""

#: C/index-in.docbook:10292
#, no-wrap
msgid ""
"\n"
"_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)\n"
msgstr ""

#: C/index-in.docbook:10291
msgid ""
"For example, in Pangomm, <filename>layoutline.hg</filename>: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10301
msgid "gmmproc Parameter Processing"
msgstr ""

#: C/index-in.docbook:10302
msgid ""
"<command>gmmproc</command> allows processing the parameters in a method "
"signature for the macros that process method signatures (like "
"<function>_WRAP_METHOD()</function>, <function>_WRAP_CTOR()</function> and "
"<function>_WRAP_CREATE()</function>) in a variety of ways:"
msgstr ""

#: C/index-in.docbook:10309
msgid "Parameter Reordering"
msgstr ""

#: C/index-in.docbook:10316
#, no-wrap
msgid ""
"\n"
"void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,\n"
"  GdkEventMask events);\n"
msgstr ""

#: C/index-in.docbook:10323
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},\n"
"  const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),\n"
"  gtk_widget_set_device_events)\n"
msgstr ""

#: C/index-in.docbook:10333
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void set_device_events(Gdk::EventMask events{.},\n"
"  const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),\n"
"  gtk_widget_set_device_events)\n"
msgstr ""

#: C/index-in.docbook:10310
msgid ""
"For all the macros that process method signatures, it is possible to specify "
"a different order for the C++ parameters than the existing order in the C "
"function, virtual function or signal. For example, say that the following C "
"function were being wrapped as a C++ method for the <classname>Gtk::Widget</"
"classname> class: <_:programlisting-1/> However, changing the order of the C+"
"+ method's two parameters is necessary. Something like the following would "
"wrap the function as a C++ method with a different order for the two "
"parameters: <_:programlisting-2/> The <literal>{c_param_name}</literal> "
"following the method parameter names tells <command>gmmproc</command> to map "
"the C++ parameter to the specified C parameter within the <literal>{}</"
"literal>. Since the C++ parameter names correspond to the C ones, the above "
"could be re-written as: <_:programlisting-3/>"
msgstr ""

#: C/index-in.docbook:10340
msgid ""
"Please note that when reordering parameters for a <function>_WRAP_SIGNAL()</"
"function> method signature, the C parameter names would always be "
"<literal>p0</literal>, <literal>p1</literal>, etc. because the "
"<filename>generate_extra_defs</filename> utility uses those parameter names "
"no matter what the C API's parameter names may be. It's how the utility is "
"written presently."
msgstr ""

#: C/index-in.docbook:10352
msgid "Optional Parameter Processing"
msgstr ""

#: C/index-in.docbook:10361
#, no-wrap
msgid ""
"\n"
"GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar* label);\n"
msgstr ""

#: C/index-in.docbook:10370
#, no-wrap
msgid ""
"\n"
"_WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp; label{?}),\n"
"  gtk_tool_button_new)\n"
msgstr ""

#: C/index-in.docbook:10353
msgid ""
"For all macros processing method signatures except <function>_WRAP_SIGNAL()</"
"function> and <function>_WRAP_VFUNC()</function> it is also possible to make "
"the parameters optional so that extra C++ methods are generated without the "
"specified optional parameter. For example, say that the following "
"<function>*_new()</function> function were being wrapped as a constructor in "
"the <classname>Gtk::ToolButton</classname> class: <_:programlisting-1/> "
"Also, say that the C API allowed NULL for the function's <parameter>label</"
"parameter> parameter so that that parameter is optional. It would be "
"possible to have <command>gmmproc</command> generate the original "
"constructor (with all the parameters) along with an additional constructor "
"without that optional parameter by appending a <literal>{?}</literal> to the "
"parameter name like so: <_:programlisting-2/> In this case, two constructors "
"would be generated: One with the optional parameter and one without it."
msgstr ""

#: C/index-in.docbook:10380
msgid "Output Parameter Processing"
msgstr ""

#: C/index-in.docbook:10390
#, no-wrap
msgid ""
"\n"
"GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);\n"
msgstr ""

#: C/index-in.docbook:10396
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT}) const,\n"
"  gtk_widget_get_request_mode)\n"
msgstr ""

#: C/index-in.docbook:10405
#, no-wrap
msgid ""
"\n"
"_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = (SizeRequestMode)($4)')\n"
msgstr ""

#: C/index-in.docbook:10409
#, no-wrap
msgid ""
"\n"
"_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = ($1)($4)')\n"
msgstr ""

#: C/index-in.docbook:10381
msgid ""
"With <function>_WRAP_METHOD()</function> it is also possible for the return "
"of the wrapped C function (if it has one) to be placed in an output "
"parameter of the C++ method instead of having the C++ method also return a "
"value like the C function does. To do that, simply include the output "
"parameter in the C++ method parameter list appending a <literal>{OUT}</"
"literal> to the output parameter name. For example, if "
"<function>gtk_widget_get_request_mode()</function> is declared as the "
"following: <_:programlisting-1/> And having the C++ method set an output "
"parameter is desired instead of returning a <type>SizeRequestMode</type>, "
"something like the following could be used: <_:programlisting-2/> The "
"<literal>{OUT}</literal> appended to the name of the <parameter>mode</"
"parameter> output parameter tells <command>gmmproc</command> to place the "
"return of the C function in that output parameter. In this case, however, a "
"necessary initialization macro like the following would also have to be "
"specified: <_:programlisting-3/> Which could also be written as: <_:"
"programlisting-4/>"
msgstr ""

#: C/index-in.docbook:10419
#, no-wrap
msgid ""
"\n"
"gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,\n"
"  GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);\n"
msgstr ""

#: C/index-in.docbook:10426
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(bool get_cell_rect(const TreeModel::Path&amp; path,\n"
"  const CellRenderer&amp; cell, Gdk::Rectangle&amp; rect{&gt;&gt;}) const,\n"
"  gtk_icon_view_get_cell_rect)\n"
msgstr ""

#: C/index-in.docbook:10441
#, no-wrap
msgid ""
"\n"
"_INITIALIZATION(`Gdk::Rectangle&amp;',`GdkRectangle',`$3 = Glib::wrap(&amp;($4))')\n"
msgstr ""

#: C/index-in.docbook:10413
msgid ""
"<function>_WRAP_METHOD()</function> also supports setting C++ output "
"parameters from C output parameters if the C function being wrapped has any. "
"Suppose, for example, that we want to wrap the following C function that "
"returns a value in its C output parameter <parameter>rect</parameter>: <_:"
"programlisting-1/> To have <command>gmmproc</command> place the value "
"returned in the C++ <parameter>rect</parameter> output parameter, something "
"like the following <function>_WRAP_METHOD()</function> macro could be used: "
"<_:programlisting-2/> The <literal>{&gt;&gt;}</literal> following the "
"<parameter>rect</parameter> parameter name indicates that the C++ output "
"parameter should be set from the value returned in the C parameter from the "
"C function. <command>gmmproc</command> will generate a declaration of a "
"temporary variable in which to store the value of the C output parameter and "
"a statement that sets the C++ output parameter from the temporary variable. "
"In this case it may be necessary to have an <function>_INITIALIZATION()</"
"function> describing how to set a <classname>Gdk::Rectangle&amp;</classname> "
"from a <classname>GdkRectangle*</classname> such as the following: <_:"
"programlisting-3/>"
msgstr ""

#: C/index-in.docbook:10448
msgid "String Parameter Processing"
msgstr ""

#: C/index-in.docbook:10449
msgid ""
"A string-valued input parameter in a C++ method is usually a <type>const "
"Glib::ustring&amp;</type> or a <type>const std::string&amp;</type>. In C "
"code it's a <type>const gchar*</type>. When an empty string is converted to "
"<type>const gchar*</type>, it can be converted either to <literal>nullptr</"
"literal> or to a pointer to an empty string (with <methodname>c_str()</"
"methodname>). Some parameters in some C functions accept a <literal>nullptr</"
"literal>, and interpret it in a special way. Other parameters must not be "
"<literal>nullptr</literal>."
msgstr ""

#: C/index-in.docbook:10462
msgid ""
"for mandatory parameters (with or without default values): empty string to "
"empty string,"
msgstr ""

#: C/index-in.docbook:10464
msgid ""
"for optional parameters (with appended <literal>{?}</literal>): empty string "
"to <literal>nullptr</literal>."
msgstr ""

#: C/index-in.docbook:10458
msgid ""
"The default conversion in <function>_WRAP_METHOD()</function> and similar "
"macros is <_:itemizedlist-1/> If the default conversion is not the best "
"conversion, append <literal>{NULL}</literal> to a mandatory parameter or "
"<literal>{?!NULL}</literal> to an optional parameter (<literal>!NULL</"
"literal> = not <literal>NULL</literal>). If you append both a C parameter "
"name and <literal>NULL</literal>, separate them with a space: "
"<literal>{c_param_name NULL}</literal>."
msgstr ""

#: C/index-in.docbook:10478
msgid "Basic Types"
msgstr ""

#: C/index-in.docbook:10479
msgid ""
"Some of the basic types that are used in C APIs have better alternatives in C"
"++. For example, there's no need for a <type>gboolean</type> type since C++ "
"has <type>bool</type>. The following list shows some commonly-used types in "
"C APIs and what you might convert them to in a C++ wrapper library."
msgstr ""

#: C/index-in.docbook:10484
msgid "Basic Type equivalents"
msgstr ""

#: C/index-in.docbook:10486
msgid "C type"
msgstr ""

#: C/index-in.docbook:10487
msgid "C++ type"
msgstr ""

#: C/index-in.docbook:10488
msgid "<type>gboolean</type>"
msgstr ""

#: C/index-in.docbook:10488
msgid "<type>bool</type>"
msgstr ""

#: C/index-in.docbook:10489
msgid "<type>gint</type>"
msgstr ""

#: C/index-in.docbook:10489
msgid "<type>int</type>"
msgstr ""

#: C/index-in.docbook:10490
msgid "<type>guint</type>"
msgstr ""

#: C/index-in.docbook:10491
msgid "<type>gdouble</type>"
msgstr ""

#: C/index-in.docbook:10491
msgid "<type>double</type>"
msgstr ""

#: C/index-in.docbook:10492
msgid "<type>gunichar</type>"
msgstr ""

#: C/index-in.docbook:10493
msgid "<type>gchar*</type>"
msgstr ""

#: C/index-in.docbook:10493
msgid ""
"<classname>Glib::ustring</classname> (or <classname>std::string</classname> "
"for filenames)"
msgstr ""

#: C/index-in.docbook:10500
msgid "Hand-coded source files"
msgstr ""

#: C/index-in.docbook:10501
msgid ""
"You might want to include additional source files that will not be generated "
"by <command>gmmproc</command> from <filename>.hg</filename> and <filename>."
"ccg</filename> files. You can simply place these in your "
"<filename>libsomething/libsomethingmm</filename> directory and mention them "
"in the <filename>meson.build</filename> in the <varname>extra_h_files</"
"varname> and <varname>extra_cc_files</varname> variables."
msgstr ""

#: C/index-in.docbook:10511
msgid "Initialization"
msgstr ""

#: C/index-in.docbook:10520
#, no-wrap
msgid ""
"\n"
"void init()\n"
"{\n"
"  Gtk::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.\n"
"  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.\n"
"}\n"
msgstr ""

#: C/index-in.docbook:10512
msgid ""
"Your library must be initialized before it can be used, to register the new "
"types that it makes available. Also, the C library that you are wrapping "
"might have its own initialization function that you should call. You can do "
"this in an <function>init()</function> function that you can place in hand-"
"coded <filename>init.h</filename> and <filename>init.cc</filename> files. "
"This function should initialize your dependencies (such as the C function, "
"and <application>gtkmm</application>) and call your generated "
"<function>wrap_init()</function> function. For instance: <_:programlisting-1/"
">"
msgstr ""

#: C/index-in.docbook:10528
msgid ""
"The implementation of the <function>wrap_init()</function> method in "
"<filename>wrap_init.cc</filename> is generated by "
"<filename>generate_wrap_init.pl</filename>, but the declaration in "
"<filename>wrap_init.h</filename> is hand-coded, so you will need to adjust "
"<filename>wrap_init.h</filename> so that the <function>wrap_init()</"
"function> function appears in the correct C++ namespace."
msgstr ""

#: C/index-in.docbook:10537
msgid "Problems in the C API."
msgstr ""

#: C/index-in.docbook:10538
msgid ""
"You are likely to encounter some problems in the library that you are "
"wrapping, particularly if it is a new project. Here are some common "
"problems, with solutions."
msgstr ""

#: C/index-in.docbook:10540
msgid "Unable to predeclare structs"
msgstr ""

#: C/index-in.docbook:10542
#, no-wrap
msgid ""
"\n"
"typedef struct _ExampleWidget ExampleWidget;\n"
"\n"
"struct _ExampleWidget\n"
"{\n"
"  ...\n"
"};\n"
msgstr ""

#: C/index-in.docbook:10541
msgid ""
"By convention, structs are declared in glib/GTK-style headers like so: <_:"
"programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10551
msgid ""
"The extra typedef allows the struct to be used in a header without including "
"its full definition, simply by predeclaring it, by repeating that typedef. "
"This means that you don't have to include the C library's header in your C++ "
"header, thus keeping it out of your public API. <command>gmmproc</command> "
"assumes that this technique was used, so you will see compiler errors if "
"that is not the case."
msgstr ""

#: C/index-in.docbook:10558
#, no-wrap
msgid ""
"\n"
"example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'\n"
"../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here\n"
"make[4]: *** [example-widget.lo] Error 1\n"
msgstr ""

#: C/index-in.docbook:10564
#, no-wrap
msgid ""
"\n"
"example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol\n"
"../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'\n"
msgstr ""

#: C/index-in.docbook:10556
msgid ""
"This compiler error might look like this: <_:programlisting-1/> or this: <_:"
"programlisting-2/>"
msgstr ""

#: C/index-in.docbook:10569
msgid ""
"This is easy to correct in the C library, so do send a patch to the relevant "
"maintainer."
msgstr ""

#: C/index-in.docbook:10573
msgid "Lack of properties"
msgstr ""

#: C/index-in.docbook:10580
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        return g_object_new (EXAMPLE_TYPE_WIDGET, \"something\", something, \"thing\", thing, NULL);\n"
"}\n"
msgstr ""

#: C/index-in.docbook:10574
msgid ""
"By convention, glib/GTK-style objects have <function>*_new()</function> "
"functions, such as <function>example_widget_new()</function> that do nothing "
"more than call <function>g_object_new()</function> and return the result. "
"The input parameters are supplied to <function>g_object_new()</function> "
"along with the names of the properties for which they are values. For "
"instance, <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10587
msgid ""
"This allows language bindings to implement their own equivalents (such as C+"
"+ constructors), without using the <function>*_new()</function> function. "
"This is often necessary so that they can actually instantiate a derived "
"GType, to add their own hooks for signal handlers and vfuncs."
msgstr ""

#: C/index-in.docbook:10591
msgid ""
"At the least, the <function>_new()</function> function should not use any "
"private API (functions that are only in a .c file). Even when there are no "
"functions, we can sometimes reimplement 2 or 3 lines of code in a "
"<function>_new()</function> function as long as those lines of code use API "
"that is available to us."
msgstr ""

#: C/index-in.docbook:10599
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        ExampleWidget* widget;\n"
"        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);\n"
"        example_widget_construct(widget, \"something\", something, \"thing\", thing);\n"
"}\n"
"\n"
"void example_widget_construct(ExampleWidget* widget, int something, const char* thing)\n"
"{\n"
"        //Do stuff that uses private API:\n"
"        widget-&gt;priv-&gt;thing = thing;\n"
"        do_something(something);\n"
"}\n"
msgstr ""

#: C/index-in.docbook:10596
msgid ""
"Another workaround is to add a <function>*_construct()</function> function "
"that the C++ constructor can call after instantiating its own type. For "
"instance, <_:programlisting-1/>"
msgstr ""

#: C/index-in.docbook:10615
msgid ""
"Adding properties, and ensuring that they interact properly with each other, "
"is relatively difficult to correct in the C library, but it is possible, so "
"do file a bug and try to send a patch to the relevant maintainer."
msgstr ""

#: C/index-in.docbook:10623
msgid "Documentation"
msgstr ""

#: C/index-in.docbook:10624
msgid ""
"In general, gtkmm-style projects use Doxygen, which reads specially "
"formatted C++ comments and generates HTML documentation. You may write these "
"doxygen comments directly in the header files."
msgstr ""

#: C/index-in.docbook:10627
msgid "Reusing C documentation"
msgstr ""

#: C/index-in.docbook:10628
msgid ""
"You might wish to reuse documentation that exists for the C library that you "
"are wrapping. GTK-style C libraries typically use gtk-doc and therefore have "
"source code comments formatted for gtk-doc and some extra documentation in ."
"sgml and .xml files. The docextract_to_xml.py script, from glibmm's "
"<filename>tools/defs_gen</filename> directory, can read these files and "
"generate an .xml file that <command>gmmproc</command> can use to generate "
"doxygen comments. <command>gmmproc</command> will even try to transform the "
"documentation to make it more appropriate for a C++ API."
msgstr ""

#: C/index-in.docbook:10638
#, no-wrap
msgid "./docextract_to_xml.py -s ~/checkout/gnome/gtk/gtk/ &gt; gtk_docs.xml\n"
msgstr ""

#: C/index-in.docbook:10641
msgid ""
"Because this automatic transformation is not always appropriate, you might "
"want to provide hand-written text for a particular method. You can do this "
"by copying the XML node for the function from your <filename>something_docs."
"xml</filename> file to the <filename>something_docs_override.xml</filename> "
"file and changing the contents. Alternatively you can write your own "
"documentation in the <filename>.hg</filename> file."
msgstr ""

#: C/index-in.docbook:10651
msgid "Documentation build structure"
msgstr ""

#: C/index-in.docbook:10652
msgid ""
"If you copied the skeleton source tree in <application>mm-common</"
"application> and substituted the placeholder text, then you will already "
"have suitable <filename>meson.build</filename> and <filename>Doxyfile.in</"
"filename> files in the <filename>doc/reference/</filename> directory. You "
"probably need to modify the <varname>tag_file_modules</varname> variable in "
"<filename>meson.build</filename>, though. With the <application>mm-common</"
"application> build setup, the list of Doxygen input files is not defined in "
"the Doxygen configuration file, but passed along from <command>meson/ninja</"
"command> to the standard input of <command>doxygen</command>."
msgstr ""

#~ msgid "Murray"
#~ msgstr "Murray"

#~ msgid "Cumming"
#~ msgstr "Cumming"

#~ msgid "Bernhard"
#~ msgstr "Bernhard"

#~ msgid "Rieder"
#~ msgstr "Rieder"

#~ msgid "Chapter on \"Timeouts\"."
#~ msgstr "章节《超时》"

#~ msgid "Jonathon"
#~ msgstr "Jonathon"

#~ msgid "Jongsma"
#~ msgstr "Jongsma"

#~ msgid "Chapter on \"Drawing with Cairo\"."
#~ msgstr "章节《使用 Cairo 绘图》"

#~ msgid "Chapter on \"Working with gtkmm's Source Code\"."
#~ msgstr "章节《使用 gtkmm 源代码》"

#~ msgid "Chapter on \"Recent Files\"."
#~ msgstr "章节《最近的文件》"

#~ msgid "Jason"
#~ msgstr "Jason"

#~ msgid "M'Sadoques"
#~ msgstr "M'Sadoques"

#~ msgid "Chapter on \"Drawing Area\"."
#~ msgstr "章节《绘图区域》"

#~ msgid "Ole"
#~ msgstr "Ole"

#~ msgid "Laursen"
#~ msgstr "Laursen"

#~ msgid "Parts of chapter on \"Internationalization\"."
#~ msgstr "部分章节《国际化》"

#~ msgid "Gene"
#~ msgstr "Gene"

#~ msgid "Ruebsamen"
#~ msgstr "Ruebsamen"

#~ msgid "Chapter on \"Win32 Installation\"."
#~ msgstr "章节《Win32 安装》"

#~ msgid "Cedric"
#~ msgstr "Cedric"

#~ msgid "Gustin"
#~ msgstr "Gustin"

#~ msgid "Marko"
#~ msgstr "Marko"

#~ msgid "Anastasov"
#~ msgstr "Anastasov"

#~ msgid "Chapter on \"Printing\"."
#~ msgstr "章节《打印》"

#~ msgid "Alan"
#~ msgstr "Alan"

#~ msgid "Ott"
#~ msgstr "Ott"

#~ msgid "Appendix on \"Visual Studio 2005\"."
#~ msgstr "章节《Visual Studio 2005》"

#~ msgid "Daniel"
#~ msgstr "Daniel"

#~ msgid "Elstner"
#~ msgstr "Elstner"

#~ msgid "Murray Cumming"
#~ msgstr "Murray Cumming"

#~ msgid "libsigc++ 2.0"
#~ msgstr "libsigc++ 2.0"

#~ msgid "GTK+ 2.4"
#~ msgstr "GTK+ 2.4"

#~ msgid "cairomm"
#~ msgstr "cairomm"

#~ msgid "pkg-config"
#~ msgstr "pkg-config"

#~ msgid "glib"
#~ msgstr "glib"

#~ msgid "ATK"
#~ msgstr "ATK"

#~ msgid "Pango"
#~ msgstr "Pango"

#~ msgid "cairo"
#~ msgstr "cairo"

#~ msgid ""
#~ "\n"
#~ "# ./configure\n"
#~ "# make\n"
#~ "# make install\n"
#~ msgstr ""
#~ "\n"
#~ "# ./configure\n"
#~ "# make\n"
#~ "# make install\n"

#~ msgid "Source Code"
#~ msgstr "源代码"

#~ msgid "Gtk::Main kit(argc, argv);"
#~ msgstr "Gtk::Main kit(argc, argv);"

#~ msgid ""
#~ "The next line: <placeholder-1/> creates a <classname>Gtk::Main</"
#~ "classname> object. This is needed in all <application>gtkmm</application> "
#~ "applications. The constructor for this object initializes "
#~ "<application>gtkmm</application>, and checks the arguments passed to your "
#~ "application on the command line, looking for standard options such as "
#~ "<literal>-display</literal>. It takes these from the argument list, "
#~ "leaving anything it does not recognize for your application to parse or "
#~ "ignore. This ensures that all <application>gtkmm</application> "
#~ "applications accept the same set of standard arguments."
#~ msgstr ""
#~ "下面一行：<placeholder-1/> 创建了一个 <classname>Gtk::Main</classname> 对"
#~ "象。这是所有的 <application>gtkmm</application> 程序中所必须的。这个对象的"
#~ "构造函数初始化了 <application>gtkmm</application>，并且检查传递给你的程序"
#~ "的命令行参数，从中寻找像 <literal>-display</literal> 这样的标准选项。然后"
#~ "它会将这些可以识别的参数从参数列表中删除，留下那些它不能识别的选项，交由你"
#~ "的程序处理或者忽略。这样就保证了 <application>gtkmm</application> 应用程序"
#~ "能和其它程序一样接受所有的标准参数。"

#~ msgid "Gtk::Window window;"
#~ msgstr "Gtk::Window window;"

#~ msgid ""
#~ "The last line shows the window and enters the <application>gtkmm</"
#~ "application> main processing loop, which will finish when the window is "
#~ "closed."
#~ msgstr ""
#~ "最后一行显示窗口，并且进入 <application>gtkmm</application> 的主处理循环，"
#~ "它将一直运行到窗口被关闭。"

#~ msgid "Gtk::Main::run(window);"
#~ msgstr "Gtk::Main::run(window);"

#~ msgid ""
#~ "Openismus has more <ulink url=\"http://www.openismus.com/documents/linux/"
#~ "automake/automake.shtml\">basic help with automake and autoconf</ulink>."
#~ msgstr ""
#~ "Openismus 有更多 <ulink url=\"http://www.openismus.com/documents/linux/"
#~ "automake/automake.shtml\">帮助使用 automake 和 autoconf 的基础知识</"
#~ "ulink>。"

#~ msgid "Reference"
#~ msgstr "参考"

#~ msgid "Intermediate types"
#~ msgstr "中间类型"

#~ msgid ""
#~ "<classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>: Use "
#~ "<classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
#~ "list&lt;Gtk::Widget*&gt;</classname>, etc."
#~ msgstr ""
#~ "<classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>：使用 "
#~ "<classname>std::vector&lt;Gtk::Widget*&gt;</classname>、<classname>std::"
#~ "list&lt;Gtk::Widget*&gt;</classname> 等。"

#~ msgid ""
#~ "<classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>: Use "
#~ "<classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
#~ "list&lt;Gtk::Widget*&gt;</classname>, etc."
#~ msgstr ""
#~ "<classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>：使用 "
#~ "<classname>std::vector&lt;Gtk::Widget*&gt;</classname>、<classname>std::"
#~ "list&lt;Gtk::Widget*&gt;</classname> 等。"

#~ msgid ""
#~ "Some parts of the <application>gtkmm</application> API use intermediate "
#~ "data containers, such as <classname>Glib::StringArrayHandle</classname> "
#~ "instead of a specific Standard C++ container such as <classname>std::"
#~ "vector</classname> or <classname>std::list</classname>. You should not "
#~ "declare these types yourself -- you should use whatever Standard C++ "
#~ "container you prefer instead. <application>gtkmm</application> will do "
#~ "the conversion for you. Here are some of these intermediate types: "
#~ "<placeholder-1/>"
#~ msgstr ""
#~ "部分 <application>gtkmm</application> API 使用了中间数据容器，如 "
#~ "<classname>Glib::StringArrayHandle</classname> 而不是特定的标准 C++ 容器 "
#~ "<classname>std::vector</classname> 或 <classname>std::list</classname>。但"
#~ "是你不应该自己声明这些类型，你应当使用你所倾向的标准 C++ 容器。"
#~ "<application>gtkmm</application> 将会帮你进行类型转换。这里有一些这类中间"
#~ "类型：<placeholder-1/>"

#~ msgid ""
#~ "To obtain a <application>gtkmm</application> instance from a C GObject "
#~ "instance, use the Glib::wrap() function. For instance"
#~ msgstr ""
#~ "要从 C GObject 实例得到一个 <application>gtkmm</application> 实例，则使用 "
#~ "Glib::wrap() 函数。例如"

#~ msgid ""
#~ "Next, we use the Window's <methodname>add()</methodname> method to put "
#~ "<literal>m_button</literal> in the Window. (<methodname>add()</"
#~ "methodname> comes from <classname>Gtk::Container</classname>, which is "
#~ "described in the chapter on container widgets.) The <methodname>add()</"
#~ "methodname> method places the Widget in the Window, but it doesn't "
#~ "display the widget. <application>gtkmm</application> widgets are always "
#~ "invisible when you create them - to display them, you must call their "
#~ "<methodname>show()</methodname> method, which is what we do in the next "
#~ "line."
#~ msgstr ""
#~ "下一步，我们使用 Window 类的 <methodname>add()</methodname> 方法把 "
#~ "<literal>m_button</literal> 加到 Window 类中。(<methodname>add()</"
#~ "methodname> 方法由 <classname>Gtk::Container</classname> 类继承而来，我们"
#~ "将在容器组件这一章中具体介绍。) <methodname>add()</methodname> 方法仅仅将"
#~ "组件添加到窗口中，它并不负责显示这些组件。<application>gtkmm</"
#~ "application> 组件在创建以后都是不可见的。要显示它们，你必须调用 "
#~ "<methodname>show()</methodname> 方法，通常我们会在接下来的一行就调用它。"

#~ msgid "Checkboxes"
#~ msgstr "复选框 (CheckButton)"

#~ msgid "Constructors"
#~ msgstr "构造函数"

#~ msgid "Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);"
#~ msgstr "Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);"

#~ msgid ""
#~ "Wherever possible you should use Stock items, to ensure consistency with "
#~ "other applications, and to improve the appearance of your applications by "
#~ "using icons. For instance, <placeholder-1/> This will use standard text, "
#~ "in all languages, with standard keyboard accelerators, with a standard "
#~ "icon."
#~ msgstr ""
#~ "任何时候你都应尽可能的使用 Stock Item，这样可以使你的应用程序和其它的保持"
#~ "一致，并且可以通过使用图标来改善程序的外观。例如， <placeholder-1/> 这样在"
#~ "所有的语言中都会使用标准的文字，标准的快捷键，以及标准的图标。"

#~ msgid "pressed"
#~ msgstr "pressed (按下)"

#~ msgid "Emitted when the button is pressed."
#~ msgstr "当按钮按下时发出。"

#~ msgid "released"
#~ msgstr "released (释放)"

#~ msgid "Emitted when the button is released."
#~ msgstr "当按钮释放后发出。"

#~ msgid "clicked"
#~ msgstr "clicked (点击)"

#~ msgid "Emitted when the button is pressed and released."
#~ msgstr "当按钮按下并抬起时发出。"

#~ msgid "enter"
#~ msgstr "enter (进入)"

#~ msgid "Emitted when the mouse pointer moves over the button's window."
#~ msgstr "当鼠标指针移到按钮上时发出。"

#~ msgid "leave"
#~ msgstr "leave (离开)"

#~ msgid "Emitted when the mouse pointer leaves the button's window."
#~ msgstr "当鼠标指针离开按钮时发出。"

#~ msgid ""
#~ "There are two ways to set up a group of radio buttons. The first way is "
#~ "to create the buttons, and set up their groups afterwards. Only the first "
#~ "two constructors are used. In the following example, we make a new window "
#~ "class called <classname>RadioButtons</classname>, and then put three "
#~ "radio buttons in it:"
#~ msgstr ""
#~ "有两种方式创建一个单选按钮的组。第一种方式是先创建按钮，然后再设置它们的"
#~ "组。这种方式只用到了前两个构造函数。在下面的示例中，我们创建了一个新的窗口"
#~ "类 <classname>RadioButtons</classname>，然后在其中放置3个单选按钮："

#~ msgid ""
#~ "class RadioButtons : public Gtk::Window\n"
#~ "{\n"
#~ "public:\n"
#~ "    RadioButtons();\n"
#~ "\n"
#~ "protected:\n"
#~ "    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
#~ "};\n"
#~ "\n"
#~ "RadioButtons::RadioButtons()\n"
#~ "  : m_rb1(\"button1\"),\n"
#~ "    m_rb2(\"button2\"),\n"
#~ "    m_rb3(\"button3\")\n"
#~ "{\n"
#~ "    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
#~ "    m_rb2.set_group(group);\n"
#~ "    m_rb3.set_group(group);\n"
#~ "}"
#~ msgstr ""
#~ "class RadioButtons : public Gtk::Window\n"
#~ "{\n"
#~ "public:\n"
#~ "    RadioButtons();\n"
#~ "\n"
#~ "protected:\n"
#~ "    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
#~ "};\n"
#~ "\n"
#~ "RadioButtons::RadioButtons()\n"
#~ "  : m_rb1(\"button1\"),\n"
#~ "    m_rb2(\"button2\"),\n"
#~ "    m_rb3(\"button3\")\n"
#~ "{\n"
#~ "    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
#~ "    m_rb2.set_group(group);\n"
#~ "    m_rb3.set_group(group);\n"
#~ "}"

#~ msgid "m_rb2.set_group(m_rb1.get_group()); //doesn't work"
#~ msgstr "m_rb2.set_group(m_rb1.get_group()); //无法工作"

#~ msgid ""
#~ "Note that you can't just do <placeholder-1/> because the group is "
#~ "modified by <methodname>set_group()</methodname> and therefore non-const."
#~ msgstr ""
#~ "注意，你不能只是 <placeholder-1/> 因为该组会由 <methodname>set_group()</"
#~ "methodname> 修改，所以它不能是一个常量。"

#~ msgid ""
#~ "The second way to set up radio buttons is to make a group first, and then "
#~ "add radio buttons to it. Here's an example:"
#~ msgstr ""
#~ "第二种创建单选按钮的方式是，先创建一个组，然后再向该组加入按钮。请看下面的"
#~ "示例："

#~ msgid ""
#~ "class RadioButtons : public Gtk::Window\n"
#~ "{\n"
#~ "public:\n"
#~ "    RadioButtons();\n"
#~ "};\n"
#~ "\n"
#~ "RadioButtons::RadioButtons()\n"
#~ "{\n"
#~ "    Gtk::RadioButton::Group group;\n"
#~ "    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
#~ "      new Gtk::RadioButton(group,\"button1\"));\n"
#~ "    Gtk::RadioButton *m_rb2 = manage(\n"
#~ "      new Gtk::RadioButton(group,\"button2\"));\n"
#~ "      Gtk::RadioButton *m_rb3 = manage(\n"
#~ "        new Gtk::RadioButton(group,\"button3\"));\n"
#~ "}"
#~ msgstr ""
#~ "class RadioButtons : public Gtk::Window\n"
#~ "{\n"
#~ "public:\n"
#~ "    RadioButtons();\n"
#~ "};\n"
#~ "\n"
#~ "RadioButtons::RadioButtons()\n"
#~ "{\n"
#~ "    Gtk::RadioButton::Group group;\n"
#~ "    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
#~ "      new Gtk::RadioButton(group,\"button1\"));\n"
#~ "    Gtk::RadioButton *m_rb2 = manage(\n"
#~ "      new Gtk::RadioButton(group,\"button2\"));\n"
#~ "      Gtk::RadioButton *m_rb3 = manage(\n"
#~ "        new Gtk::RadioButton(group,\"button3\"));\n"
#~ "}"

#~ msgid ""
#~ "We made a new group by simply declaring a variable, <literal>group</"
#~ "literal>, of type <classname>Gtk::RadioButton::Group</classname>. Then we "
#~ "made three radio buttons, using a constructor to make each of them part "
#~ "of <literal>group</literal>."
#~ msgstr ""
#~ "我们通过声明一个类型为 <classname>Gtk::RadioButton::Group</classname> 的名"
#~ "为 <literal>group</literal> 的变量。然后我们创建三个单选按钮，用构造函数把"
#~ "它们放置到组 <literal>group</literal> 中。"

#~ msgid "Update Policies"
#~ msgstr "更新策略"

#~ msgid ""
#~ "<literal>Gtk::UPDATE_CONTINUOUS</literal> - This is the default. The "
#~ "<literal>value_changed</literal> signal is emitted continuously, i.e. "
#~ "whenever the slider is moved by even the tiniest amount."
#~ msgstr ""
#~ "<literal>Gtk::UPDATE_CONTINUOUS</literal> - 这是默认的更新规则。会连续不断"
#~ "的发出 <literal>value_changed</literal> 信号，即使滑块只是被移动了一点点，"
#~ "也会发出该信号。"

#~ msgid ""
#~ "<literal>Gtk::UPDATE_DISCONTINUOUS</literal> - The "
#~ "<literal>value_changed</literal> signal is only emitted once the slider "
#~ "has stopped moving and the user has released the mouse button."
#~ msgstr ""
#~ "<literal>Gtk::UPDATE_DISCONTINUOUS</literal> - 只有在滑块停止了移动并且用"
#~ "户释放了鼠标的时候才会发出 <literal>value_changed</literal> 信号。"

#~ msgid ""
#~ "<literal>Gtk::UPDATE_DELAYED</literal> - The <literal>value_changed</"
#~ "literal> signal is emitted when the user releases the mouse button, or if "
#~ "the slider stops moving for a short period of time."
#~ msgstr ""
#~ "<literal>Gtk::UPDATE_DELAYED</literal> - 只有当用户释放鼠标，或者滑块停止"
#~ "移动一小段时间后，才发出 <literal>value_changed</literal> 信号。"

#~ msgid ""
#~ "The <emphasis>update policy</emphasis> of a <classname>Range</classname> "
#~ "widget defines at what points during user interaction it will change the "
#~ "<literal>value</literal> field of its <classname>Gtk::Adjustment</"
#~ "classname> and emit the <literal>value_changed</literal> signal. The "
#~ "update policies, set with the <methodname>set_update_policy()</"
#~ "methodname> method, are: <placeholder-1/>"
#~ msgstr ""
#~ "<classname>Range</classname> 组件的 <emphasis>更新策略</emphasis> 定义了在"
#~ "用户操作期间的什么时候更新 <classname>Gtk::Adjustment</classname> 的值 "
#~ "<literal>value</literal>，并且何时发出 <literal>value_changed</literal> 信"
#~ "号。可以使用 <methodname>set_update_policy()</methodname> 方法来设置更新策"
#~ "略。这些策略包括：<placeholder-1/>"

#~ msgid ""
#~ "Note that the <classname>XPMLabelBox</classname> class can be used to "
#~ "place XPMs and labels into any widget that can be a container."
#~ msgstr ""
#~ "请注意，<classname>XPMLabelBox</classname> 类可以用于将 XPM 和标签放置到任"
#~ "何容器组件。"
