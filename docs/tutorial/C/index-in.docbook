<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE book [
  <!ENTITY url_refdocs_base_glib_html "https://gnome.pages.gitlab.gnome.org/glibmm/">
  <!ENTITY url_refdocs_base_glib "&url_refdocs_base_glib_html;classGlib_1_1">
  <!ENTITY url_refdocs_base_gio "&url_refdocs_base_glib_html;classGio_1_1">
  <!ENTITY url_refdocs_base_gtk_html "https://gnome.pages.gitlab.gnome.org/gtkmm/">
  <!ENTITY url_refdocs_base_gdk "&url_refdocs_base_gtk_html;classGdk_1_1">
  <!ENTITY url_refdocs_base_gtk "&url_refdocs_base_gtk_html;classGtk_1_1">
  <!ENTITY url_figures_base "figures/">
  <!ENTITY url_examples_branch "master">
  <!ENTITY url_examples_base "https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/&url_examples_branch;/examples/book/">
  <!ENTITY url_gtkmm_base "https://gitlab.gnome.org/GNOME/gtkmm/tree/&url_examples_branch;/">
  <!ENTITY gtkmm "<application xmlns='http://docbook.org/ns/docbook'>gtkmm</application>">
  <!ENTITY cpp "<phrase xmlns='http://docbook.org/ns/docbook' role='nowrap'>C++</phrase>">
  <!ENTITY uuml "&#252;" >
  <!ENTITY szlig "&#223;" >
  <!ENTITY copy "&#169;" >
  <!ENTITY nbsp "&#160;" >   <!-- non-breaking space -->
  <!ENTITY nbhy "&#8209;" >  <!-- non-breaking hyphen -->
]>

<!--
NOTE TO TUTORIAL DOCUMENTATION AUTHORS:
When referring to the gtkmm project in this document, please use the form
&gtkmm; so that the name is consistent throughout the document. This will wrap
gtkmm with <application></application> tags which can then be styled by CSS if
desired (e.g. boldface, monospace, etc) to make it stand out as the project
name
-->

<!--
Avoid <programlisting> elements within <para> elements.
In some situations (not quite clear exactly which situations) the translation
tools (itstool and friends) can't create translated index.docbook files if
a <programlisting> element occurs in a <para> element.
<programlisting> can be a direct child of e.g. <chapter>, <listitem>,
<sect1>, <sect2>, <sect3>, <sect4>, <sect5>, <section>.
See https://gitlab.gnome.org/GNOME/gtkmm-documentation/-/merge_requests/11
-->

<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      version="5.0" xml:id="index" xml:lang="en">

  <info>
    <title>Programming with &gtkmm; 4</title>
    <authorgroup>
      <author>
        <personname><firstname>Murray</firstname><surname>Cumming</surname></personname>
      </author>
      <author>
        <personname><firstname>Bernhard</firstname><surname>Rieder</surname></personname>
        <contrib>Chapter on "Timeouts".</contrib>
      </author>
      <author>
        <personname><firstname>Jonathon</firstname><surname>Jongsma</surname></personname>
        <contrib>Chapter on "Drawing with Cairo".</contrib>
        <contrib>Chapter on "Working with gtkmm's Source Code".</contrib>
        <contrib>Chapter on "Recent Files".</contrib>
      </author>
      <author>
        <personname><firstname>Ole</firstname><surname>Laursen</surname></personname>
        <contrib>Parts of chapter on "Internationalization".</contrib>
      </author>
      <author>
        <personname><firstname>Marko</firstname><surname>Anastasov</surname></personname>
        <contrib>Chapter on "Printing".</contrib>
        <contrib>Parts of chapter on "Internationalization".</contrib>
      </author>
      <author>
        <personname><firstname>Daniel</firstname><surname>Elstner</surname></personname>
        <contrib>Section "Build Structure" of chapter on "Wrapping C Libraries with gmmproc".</contrib>
      </author>
      <author>
        <personname><firstname>Chris</firstname><surname>Vine</surname></personname>
        <contrib>Chapter on "Multi-threaded programs".</contrib>
      </author>
      <author>
        <personname><firstname>David</firstname><surname>King</surname></personname>
        <contrib>Section on Gtk::Grid.</contrib>
      </author>
      <author>
        <personname><firstname>Pedro</firstname><surname>Ferreira</surname></personname>
        <contrib>Chapter on "Keyboard Events".</contrib>
      </author>
      <author>
        <personname><firstname>Kjell</firstname><surname>Ahlstedt</surname></personname>
        <contrib>Update from gtkmm 3 to gtkmm 4.</contrib>
        <contrib>Chapter on "Building applications".</contrib>
        <contrib>Chapter on "The DropDown Widget".</contrib>
        <contrib>Chapter on "ListView, GridView, ColumnView".</contrib>
      </author>
      <author>
        <personname><firstname>Daniel</firstname><surname>Boles</surname></personname>
        <contrib>Notes on need to remove widgets in non-managed wrappers from parents to dispose, other tweaks.</contrib>
      </author>
    </authorgroup>

    <abstract>
      <!-- This text is copied from the introduction. -->
      <para>This book explains key concepts of the &gtkmm; &cpp; API for creating user interfaces. It also introduces the main user interface elements ("widgets").
      </para>
    </abstract>
    <copyright>
      <year>2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010</year>
      <holder>Murray Cumming</holder>
    </copyright>

    <legalnotice>
      <para>
        Permission is granted to copy, distribute and/or modify this document
        under the terms of the GNU Free Documentation License, Version 1.2
        or any later version published by the Free Software Foundation;
        with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
        A copy of the license is included in the section entitled
        <link linkend="chapter-gfdl">"GNU Free Documentation License"</link>.
      </para>
    </legalnotice>
  </info>

<chapter xml:id="chapter-introduction">
<title>Introduction</title>

<section xml:id="sec-this-book">
<title>This book</title>

<para>This book explains key concepts of the &gtkmm; &cpp; API for creating user interfaces. It also introduces the main user interface elements ("widgets"). Although it mentions classes, constructors, and methods, it does not go into great detail. Therefore, for full API information you should follow the links into the reference documentation.</para>

<para>This book assumes a good understanding of &cpp;, and how to create &cpp; programs.</para>

<para>
We would very much like to hear of any problems you have learning &gtkmm;
with this document, and would appreciate input regarding improvements. Please see the <link linkend="chapter-contributing">Contributing</link> section for further information.
</para>

</section>

<section xml:id="sec-gtkmm">
<title>gtkmm</title>

<para>
&gtkmm; is a &cpp; wrapper for
<link xlink:href="http://www.gtk.org/">GTK</link>,
a library used to create graphical user
interfaces. It is licensed using the LGPL license, so you can develop
open software, free software, or even commercial non-free software
using &gtkmm; without purchasing licenses.
</para>
<para>&gtkmm; was originally named gtk-- because GTK was originally named GTK+
and had a + in the name. However, as -- is not easily indexed by search engines,
the package generally went by the name &gtkmm;, and that's what we stuck with.</para>

<section xml:id="why-use-gtkmm">
<title>Why use &gtkmm; instead of GTK?</title>

<para>&gtkmm; allows you to write code using normal &cpp; techniques such as encapsulation, derivation, and polymorphism. As a &cpp; programmer you probably already realize that this leads to clearer and better organized code.</para>
<para>&gtkmm; is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration.</para>
<para>Inheritance can be used to derive new widgets. The derivation of new widgets in GTK C code is so complicated and error prone that almost no C coders do it. As a &cpp; developer you know that derivation is an essential Object Orientated technique.</para>
<para>Member instances can be used, simplifying memory management. All GTK C widgets are dealt with by use of pointers. As a &cpp; coder you know that pointers should be avoided where possible.</para>
<para>&gtkmm; involves less code compared to GTK, which uses prefixed function names and lots of cast macros.</para>
</section>

<section xml:id="gtkmm-vs-qt">
<title>&gtkmm; compared to Qt</title>

<para>Trolltech's Qt is the closest competition to &gtkmm;, so it deserves discussion.</para>

<para>&gtkmm; developers tend to prefer &gtkmm; to Qt because &gtkmm; does things in a more &cpp; way. Qt originates from a time when &cpp; and the standard library were not standardized or well supported by compilers. It therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech modified the &cpp; language to provide signals, so that Qt classes cannot be used easily with non-Qt classes. &gtkmm; was able to use standard &cpp; to provide signals without changing the &cpp; language.
See the <link xlink:href="https://gtkmm.gnome.org/en/faq.html">FAQ</link> for more detailed differences.</para>
</section>

<section xml:id="gtkmm-is-a-wrapper">
<title>&gtkmm; is a wrapper</title>

<para>
&gtkmm; is not a native &cpp; toolkit, but a &cpp; wrapper of a C toolkit. This separation of interface and implementation has advantages. The &gtkmm; developers spend most of their time talking about how &gtkmm; can present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK code base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK benefits from a broader user base than language-specific toolkits - there are more implementers, more developers, more testers, and more users.</para>
</section>
</section>

<section xml:id="sec-cpp-resources">
<title>C++ Resources</title>
<para>Useful links:</para>
<itemizedlist>
  <listitem><para><link xlink:href="https://en.wikipedia.org/wiki/C%2B%2B">Wikipedia C++</link>: An introduction to &cpp;, and many links.</para></listitem>
  <listitem><para><link xlink:href="https://en.cppreference.com/w/">C++ reference</link>: A convenient version of the C and &cpp; standards.</para></listitem>
  <listitem><para><link xlink:href="https://cplusplus.com/">The C++ Resources Network</link></para></listitem>
  <listitem><para><link xlink:href="https://www.stroustrup.com/">Bjarne Stroustrup's homepage</link></para></listitem>
</itemizedlist>
</section>

</chapter>

<chapter xml:id="chapter-installation">
<title>Installation</title>

<section xml:id="sec-installation-dependencies">
<title>Dependencies</title>

<para>
  Before attempting to install &gtkmm;<application>-4.0</application>,
  you might first need to install these other packages.
</para>
<itemizedlist>
  <listitem><para><application>sigc++-3.0</application></para></listitem>
  <listitem><para><application>gtk4</application></para></listitem>
  <listitem><para><application>glibmm-2.68</application></para></listitem>
  <listitem><para><application>cairomm-1.16</application></para></listitem>
  <listitem><para><application>pangomm-2.48</application></para></listitem>
</itemizedlist>
<para>
These dependencies have their own dependencies, including the following
applications and libraries:
</para>
<itemizedlist>
  <listitem><para><application>pkg-config</application></para></listitem>
  <listitem><para><application>glib-2.0</application></para></listitem>
  <listitem><para><application>pango</application></para></listitem>
  <listitem><para><application>cairo</application></para></listitem>
  <listitem><para><application>gdk-pixbuf-2.0</application></para></listitem>
  <listitem><para><application>graphene-1.0</application></para></listitem>
</itemizedlist>
</section>

<section xml:id="sec-install-unix-and-linux">
<title>Unix and Linux</title>

<section xml:id="sec-linux-install-from-packages">
<title>Prebuilt Packages</title>

<para>
    Recent versions of &gtkmm; are packaged by nearly every major Linux
    distribution these days. So, if you use Linux, you can probably get
    started with &gtkmm; by installing the package from the official repository
    for your distribution. Distributions that include &gtkmm; in their
    repositories include Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and
    many others.
</para>
<para>
    The names of the &gtkmm; packages vary from distribution to distribution
    (e.g. <application>libgtkmm-4.0-dev</application> on Debian and Ubuntu or
    <application>gtkmm4.0-devel</application> on Red Hat and Fedora), so check
    with your distribution's package management program for the correct package
    name and install it like you would any other package.
</para>
<note>
<para>
The package names will not change when new API/ABI-compatible versions of &gtkmm;
are released. Otherwise they would not be API/ABI-compatible. So don't be
surprised, for instance, to find &gtkmm; 4.8 supplied by Debian's
<application>libgtkmm-4.0-dev</application> package.
</para>
</note>
</section>

<section xml:id="sec-install-from-source">
<title>Installing From Source</title>

<para>
If your distribution does not provide a pre-built &gtkmm; package, or if you
want to install a different version than the one provided by your distribution,
you can also install &gtkmm; from source. The source code for &gtkmm; can
be downloaded from <link xlink:href="https://download.gnome.org/sources/gtkmm/"/>.
</para>
<para>
  After you've installed all of the dependencies, download the &gtkmm; source
  code, unpack it, and change to the newly created directory. &gtkmm; can be
  built with Meson. See the <filename>README</filename> file in the &gtkmm; version
  you've downloaded.
</para>
<note>
<para>
  Remember that on a Unix or Linux operating system, you will probably need to
  be <literal>root</literal> to install software. The <command>su</command> or <command>sudo</command>
  command will allow you to enter the <literal>root</literal> password and have
  <literal>root</literal> status temporarily.
</para>
</note>
<para>
    The <filename>configure</filename> script or <command>meson</command> will check
    to make sure all of the required dependencies are already installed. If you are
    missing any dependencies, it will exit and display an error.
</para>
<para>
    By default, &gtkmm; if built with Meson or Autotools, will be installed under the
    <filename>/usr/local</filename> directory. On some systems you may need to
    install to a different location. For instance, on Red Hat Linux systems
    you might use the <literal>--prefix</literal> option with configure, like
    one of:
<screen>
# meson setup --prefix=/usr &lt;builddir&gt; &lt;srcdir&gt;
# meson configure --prefix=/usr
# ./configure --prefix=/usr
</screen>
</para>
<warning>
    <para>
        You should be very careful when installing to standard system prefixes
        such as <filename>/usr</filename>. Linux distributions install software
        packages to <filename>/usr</filename>, so installing a source package
        to this prefix could corrupt or conflict with software installed using
        your distribution's package-management system. Ideally, you should use
        a separate prefix for all software you install from source.
    </para>
</warning>
<para>
  If you want to help develop &gtkmm; or experiment with new features, you can
  also install &gtkmm; from git. Most users will never need to do this, but if
  you're interested in helping with &gtkmm; development, see the <link linkend="chapter-working-with-source">Working with gtkmm's Source Code</link> appendix.
</para>
</section>

</section>

<section xml:id="sec-packages-windows">
<title>Microsoft Windows</title>

<para>GTK and &gtkmm; were designed to work well with Microsoft Windows, and the
developers encourage its use on the win32 platform. However, Windows has no standard
installation system for development libraries. Please see the
<link xlink:href="https://wiki.gnome.org/Projects/gtkmm/MSWindows">Windows Installation</link>
page (somewhat outdated) or the <link linkend="sec-windows-installation">&gtkmm; and Win32</link>
appendix for Windows-specific installation instructions and notes.</para>
</section>

</chapter>

<chapter xml:id="chapter-basics">
<title>Basics</title>

<para>
This chapter will introduce some of the most important aspects of &gtkmm; coding. These will be demonstrated with simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information.
</para>
<para>
Your existing knowledge of &cpp; will help you with &gtkmm; as it would with any library. Unless we state otherwise, you can expect &gtkmm; classes to behave like any other &cpp; class, and you can expect to use your existing &cpp; techniques with &gtkmm; classes.
</para>

<section xml:id="sec-basics-simple-example">
<title>Simple Example</title>

<para>
To begin our introduction to &gtkmm;, we'll start with the simplest
program possible. This program will create an empty 200 x 200 pixel window.
</para>

<para><link xlink:href="&url_examples_base;base">Source Code</link></para>

<para>We will now explain each part of the example</para>
<programlisting><code>#include &lt;gtkmm.h&gt;</code></programlisting>
<para>
All &gtkmm; programs must include certain &gtkmm; headers; <filename>gtkmm.h</filename>
includes the entire &gtkmm; kit. This is usually not a good idea, because
it includes a megabyte or so of headers, but for simple programs, it
suffices.
</para>

<para>The next part of the program:</para>
<programlisting><code>class MyWindow : public Gtk::Window
{
public:
  MyWindow();
};

MyWindow::MyWindow()
{
  set_title("Basic application");
  set_default_size(200, 200);
}</code></programlisting>
<para>
defines the <classname>MyWindow</classname> class. Its default constructor sets the
window's title and default (initial) size.
</para>

<para>The <function>main()</function> function's first statement:</para>
<programlisting><code>auto app = Gtk::Application::create("org.gtkmm.examples.base");</code></programlisting>
<para>
creates a <classname>Gtk::Application</classname> object, stored in a <classname>Glib::RefPtr</classname> smartpointer.
This is needed in all &gtkmm; applications. The <methodname>create()</methodname> method for this object initializes &gtkmm;.
</para>

<para>
The last line creates and shows a window and enters the &gtkmm; main processing loop, which will finish when the window is closed.
Your <function>main()</function> function will then return with an appropriate success or error code.
The <parameter>argc</parameter> and <parameter>argv</parameter> arguments, passed to your application on the command line,
can be checked when <methodname>make_window_and_run()</methodname> is called, but this simple application does not use those arguments.
</para>
<programlisting><code>return app-&gt;make_window_and_run&lt;MyWindow&gt;(argc, argv);</code></programlisting>

<para>
After putting the source code in <filename>base.cc</filename> you can compile
the above program with <application>gcc</application> using:
</para>
<programlisting><code>g++ base.cc -o base `pkg-config --cflags --libs gtkmm-4.0` -std=c++17</code></programlisting>
<para>
Note that you must surround the <application>pkg-config</application> invocation with backquotes.
Backquotes cause the shell to execute the command inside them, and to use
the command's output as part of the command line.
Note also that <filename>base.cc</filename> must come before the <application>pkg-config</application>
invocation on the command line. <literal><phrase role="nowrap">-std=c++17</phrase></literal> is necessary only if
your compiler is not <phrase role="nowrap">C++17</phrase> compliant by default.
</para>
</section>

<section xml:id="sec-headers-and-linking">
<title>Headers and Linking</title>

<para>
Although we have shown the compilation command for the simple example, you really
should use the <link xlink:href="https://mesonbuild.com/">Meson build system</link>.
The examples used in this book are included in the <application>gtkmm-documentation</application>
package, with appropriate build files, so we won't show the build commands in future.
The <filename>README</filename> file in <application>gtkmm-documentation</application>
describes how to build the examples.
</para>
<para>
To simplify compilation, we use <literal>pkg-config</literal>, which
is present in all (properly installed) &gtkmm; installations. This
program 'knows' what compiler switches are needed to compile programs
that use &gtkmm;. The <literal>--cflags</literal> option causes
<literal>pkg-config</literal> to output a list of include directories for the
compiler to look in; the <literal>--libs</literal> option requests the
list of libraries for the compiler to link with and the directories to
find them in. Try running it from your shell-prompt to see the results on your system.
</para>
<para>
However, this is even simpler when using the <function>dependency()</function> function
in a <filename>meson.build</filename> file with Meson. For instance:
</para>
<programlisting><code>gtkmm_dep = dependency('gtkmm-4.0', version: '>= 4.6.0')</code></programlisting>
<para>
This checks for the presence of gtkmm and defines <literal>gtkmm_dep</literal> for use
in your <filename>meson.build</filename> files. For instance:
</para>
<programlisting><code>exe_file = executable('my_program', 'my_source1.cc', 'my_source2.cc',
  dependencies: gtkmm_dep,
  win_subsystem: 'windows',
)</code></programlisting>
<para>gtkmm-4.0 is the name of the current stable API. There are older APIs called gtkmm-2.4
and gtkmm-3.0 which install in parallel when they are available. There are several
versions of gtkmm-2.4, such as gtkmm 2.10 and there are several versions of the gtkmm-3.0 API.
Note that the API name does not change for every version because that would be an incompatible
API and ABI break. There might be a future gtkmm-5.0 API which would install in parallel
with gtkmm-4.0 without affecting existing applications.
</para>
<para>If you start by experimenting with a small application that you plan to use just for yourself,
it's easier to start with a <filename>meson.build</filename> similar to the <filename>meson.build</filename> files
in the <link linkend="chapter-building-applications">Building applications</link> chapter.
</para>

<para>If you use the older Autotools build system, see also the GNU site. It has more
information about <link xlink:href="https://www.gnu.org/software/autoconf/">autoconf</link>
and <link xlink:href="https://www.gnu.org/software/automake/">automake</link>.
There are also some books describing Autotools: "GNU Autoconf, Automake, and Libtool"
by Gary Vaughan et al. and "Autotools, A Practitioner's Guide to GNU Autoconf,
Automake, and Libtool" by John Calcote.
</para>

</section>

<section xml:id="sec-widgets-overview">
<title>Widgets</title>

<para>&gtkmm; applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, widgets are called "controls". For each widget in your application's windows, there is a &cpp; object in your application's code. So you just need to call a method of the widget's class to affect the visible widget.</para>
<para>Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container widgets, such as <classname>Gtk::Grid</classname>, are not visible - they exist only to arrange other widgets. Here is some example code that adds 2 <classname>Gtk::Button</classname> widgets to a <classname>Gtk::Box</classname> container widget:
</para>
<programlisting><code>m_box.append(m_Button1);
m_box.append(m_Button2);</code></programlisting>
<para>and here is how to add the <classname>Gtk::Box</classname>, containing those buttons, to a <classname>Gtk::Frame</classname>, which has a visible frame and title:
</para>
<programlisting><code>m_frame.set_child(m_box);</code></programlisting>
<para>
Most of the chapters in this book deal with specific widgets. See the <link linkend="chapter-container-widgets">Container Widgets</link> section for more details about adding widgets to container widgets.
</para>

<para>Although you can specify the layout and appearance of windows and widgets with &cpp; code,
you will probably find it more convenient to design your user interfaces with
<filename class="extension">.ui</filename> XML files and load them at runtime with
<classname>Gtk::Builder</classname>. See the <link linkend="chapter-builder">Gtk::Builder</link> chapter.
</para>

<para>Although &gtkmm; widget instances have lifetimes and scopes just like
those of other &cpp; classes, &gtkmm; has an optional time-saving feature that you
will see in some of the examples. The <function>Gtk::make_managed()</function>
allows you to create a new widget and state that it will become owned by the
container into which you place it. This allows you to create the widget, add it
to the container and not be concerned about deleting it, since that will occur
when the parent container (which may itself be managed) is deleted. You can
learn more about &gtkmm; memory management techniques in the
<link linkend="chapter-memory">Memory Management chapter</link>.
</para>

</section>

<section xml:id="sec-signals-overview">
<title>Signals</title>

<para>
&gtkmm;, like most GUI toolkits, is <emphasis>event-driven</emphasis>. When an event occurs, such as the press of a mouse
button, the appropriate signal will be <emphasis>emitted</emphasis> by the Widget
that was pressed. Each Widget has a different set of signals that it can emit. To make a
button click result in an action, we set up a
<emphasis>signal handler</emphasis> to catch the button's "clicked" signal.
</para>
<para>&gtkmm; uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's "clicked" signal with a signal handler called "on_button_clicked":
</para>
<programlisting><code>m_button1.signal_clicked().connect( sigc::mem_fun(*this,
  &amp;HelloWorld::on_button_clicked) );</code></programlisting>

<para>For more detailed information about signals, see the <link linkend="chapter-signals">appendix</link>.</para>
<para>For information about implementing your own signals rather than
just connecting to the existing &gtkmm; signals, see the <link linkend="chapter-custom-signals">appendix</link>.</para>

</section>

<section xml:id="sec-basics-ustring">
<title>Glib::ustring</title>

<para>You might be surprised to learn that &gtkmm; doesn't use <classname>std::string</classname> in its interfaces. Instead it uses <classname>Glib::ustring</classname>, which is so similar and unobtrusive that you could actually pretend that each <classname>Glib::ustring</classname> is a <classname>std::string</classname> and ignore the rest of this section. But read on if you want to use languages other than English in your application.</para>
<para>std::string uses 8 bits per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese.
Although the encodings for these languages have been specified by the <link xlink:href="http://www.unicode.org/">Unicode Consortium</link>,
the C and &cpp; languages do not yet provide any standardized Unicode support for UTF-8 encoding.
GTK and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring.
It provides almost exactly the same interface as std::string, along with automatic conversions to and from std::string.</para>
<para>One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. <classname>std::string</classname> will still work for 7-bit ASCII strings. But when you try to localize your application for languages like Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using <classname>Glib::ustring</classname> instead.</para>
<para>Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting "Gr&uuml;&szlig; Gott" would be "Gr\xC3\xBC\xC3\x9F Gott").</para>
<para>You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not possible to assume that the next byte is another character. <classname>Glib::ustring</classname> worries about the details of this for you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes.</para>

<para>Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not result in Unicode executables and libraries which are incompatible with ASCII ones.</para>

<para><link xlink:href="&url_refdocs_base_glib;ustring.html">Reference</link></para>

<para>See the <link linkend="chapter-internationalization">Internationalization</link> section for information about providing the UTF-8 string literals.</para>

</section>

<section xml:id="sec-basics-gobj-and-wrap">
<title>Mixing C and C++ APIs</title>

<para>You can use C APIs which do not yet have convenient &cpp; interfaces.
It is generally not a problem to use C APIs from &cpp;, and &gtkmm; helps by
providing access to the underlying C object, and providing an easy way to create
a &cpp; wrapper object from a C object, provided that the C API is also based on
the <classname>GObject</classname> system.</para>

<para>
To use a &gtkmm; instance with a C function that requires a C
<classname>GObject</classname> instance, use the &cpp; instance’s
<function>gobj()</function> function to obtain a pointer to the underlying C
instance. For example:</para>
<programlisting><code>Gtk::Button button("example");
gtk_button_do_something_that_gtkmm_cannot(button.gobj());
</code></programlisting>

<para>
To obtain a &gtkmm; instance from a C <classname>GObject</classname> instance,
use one of the many overloaded <function>Glib::wrap()</function> functions.
The C instance’s reference count is not incremented, unless you set the optional
<parameter>take_copy</parameter> argument to <literal>true</literal>. For
example:</para>
<programlisting><code>GtkButton* cbutton = get_a_button();
Gtk::Button* button = Glib::wrap(cbutton);
button-&gt;set_label("Now I speak C++ too!");
</code></programlisting>
<para>The &cpp; wrapper shall be explicitly deleted if
<itemizedlist>
<listitem><para>it's a widget or other class that inherits from <classname>Gtk::Object</classname>, and</para></listitem>
<listitem><para>the C instance has a floating reference when the wrapper is created, and</para></listitem>
<listitem><para><function>Gtk::manage()</function> has not been called on it (which includes if it was created with <function>Gtk::make_managed()</function>), or</para></listitem>
<listitem><para><function>Gtk::manage()</function> was called on it, but it was never added to a parent.</para></listitem>
</itemizedlist>
<function>Glib::wrap()</function> binds the C and &cpp; instances to each other.
Don't delete the &cpp; instance before you want the C instance to die.
</para>
<para>In all other cases the &cpp; instance is automatically deleted when the last reference
to the C instance is dropped. This includes all <function>Glib::wrap()</function>
overloads that return a <classname>Glib::RefPtr</classname>.</para>

</section>

<section xml:id="sec-helloworld">
<title>Hello World in &gtkmm;</title>

<para>
We've now learned enough to look at a real example. In accordance with an ancient
tradition of computer science, we now introduce Hello World, a la &gtkmm;:
</para>

<para><link xlink:href="&url_examples_base;helloworld">Source Code</link></para>

<para>
Try to compile and run it before going on. You should see something like this:
</para>

<figure xml:id="figure-helloworld">
  <title>Hello World</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;helloworld.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para>
Pretty thrilling, eh?  Let's examine the code. First, the
<classname>HelloWorld</classname> class:
</para>

<programlisting><code>class HelloWorld : public Gtk::Window
{
public:
  HelloWorld();
  ~HelloWorld() override;

protected:
  //Signal handlers:
  void on_button_clicked();

  //Member widgets:
  Gtk::Button m_button;
};</code></programlisting>

<para>
This class implements the "Hello World" window. It's derived from
<classname>Gtk::Window</classname>, and has a single <classname>Gtk::Button</classname> as a member.
We've chosen to use the
constructor to do all of the initialization work for the window,
including setting up the signals. Here it is, with the comments
omitted:
</para>

<programlisting><code>HelloWorld::HelloWorld()
: m_button("Hello World")
{
  m_button.set_margin(10);
  m_button.signal_clicked().connect(sigc::mem_fun(*this,
    &amp;HelloWorld::on_button_clicked));
  set_child(m_button);
}</code></programlisting>

<para>
Notice that we've used an initializer statement to give the <literal>m_button</literal>
object the label "Hello World".
</para>

<para>
Next we call the Button's <methodname>set_margin()</methodname> method. This sets
the amount of space around the button.
</para>

<para>
We then hook up a signal handler to <literal>m_button</literal>'s <literal>clicked</literal> signal.
This prints our friendly greeting to <literal>stdout</literal>.
</para>

<para>
Next, we use the Window's <methodname>set_child()</methodname> method to put
<literal>m_button</literal> in the Window. The <methodname>set_child()</methodname>
method places the Widget in the Window.
</para>

<para>
Now let's look at our program's <function>main()</function> function. Here it is,
without comments:
</para>

<programlisting><code>int main(int argc, char* argv[])
{
  auto app = Gtk::Application::create("org.gtkmm.example");
  return app-&gt;make_window_and_run&lt;HelloWorld&gt;(argc, argv);
}</code></programlisting>

<para>
First we instantiate an object stored in a <classname>Glib::RefPtr</classname> smartpointer called <literal>app</literal>. This is of type
<classname>Gtk::Application</classname>. Every &gtkmm; program must have one of these.
</para>

<para>
Next we call <methodname>make_window_and_run()</methodname> which creates an object
of our <classname>HelloWorld</classname> class, shows that Window and starts the &gtkmm;
<emphasis>event loop</emphasis>. During the event loop &gtkmm; idles, waiting for actions
from the user, and responding appropriately.
When the user closes the Window, <methodname>make_window_and_run()</methodname> will return,
causing our <function>main()</function> function to return. The application will then finish.
</para>

<para>
Like the simple example we showed earlier, this Hello World program does not use
the command-line parameters.
</para>

</section>
</chapter>

<chapter xml:id="changes-gtkmm3">
<title>Changes in &gtkmm; 3</title>

<para>&gtkmm;-3.0 is an old version of the &gtkmm; API that installs in parallel with the still older &gtkmm;-2.4 API and the new &gtkmm;-4.0 API. The last version of the &gtkmm;-2.4 API was &gtkmm; 2.24. &gtkmm; 3 has no major fundamental differences to &gtkmm; 2 but does make several small changes that were not possible while maintaining binary compatibility. If you never used the &gtkmm;-2.4 API then you can safely ignore this chapter.</para>

<para>&gtkmm; 3's library is called <literal>libgtkmm-3.0</literal> rather than <literal>libgtkmm-2.4</literal> and installs its headers in a similarly-versioned directory, so your pkg-config check should ask for <literal>gtkmm-3.0</literal>  rather than <literal>gtkmm-2.4</literal>.</para>

<para>&gtkmm; 3 added some new classes:</para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><simpara><classname>Gtk::AppChooser</classname>, <classname>Gtk::AppChooserButton</classname>, <classname>Gtk::AppChooserDialog</classname> allow the user to select an installed application to open a particular type of content.</simpara></listitem>
<listitem><simpara><classname>Gtk::Grid</classname> is a new container widget that will eventually replace <classname>Gtk::Box</classname> and <classname>Gtk::Table</classname>. It arranges its children according to properties of those children rather than its own layout details.</simpara></listitem>
<listitem><simpara><classname>Gtk::Switch</classname> displays On/Off states more explicitly than <classname>Gtk::CheckButton</classname>. It may be useful, for instance, when allowing users to activate hardware.</simpara></listitem>
</orderedlist>

<para>&gtkmm; 3 also made several small changes to the API, which you will probably encounter when porting code that used &gtkmm;-2.4. Here is a short list:</para>

<para>
<orderedlist inheritnum="ignore" continuation="restarts">

<listitem><simpara><classname>Gtk::CellLayout</classname>, used by <classname>Gtk::IconView</classname>, <classname>Gtk::TreeView::Column</classname> and <classname>Gtk::ComboBox</classname>, now has a <classname>Gtk::CellArea</classname> which can be used to specify more details of how the <classname>CellRenderer</classname>s are arranged and aligned.</simpara></listitem>

<listitem><simpara>Gtk::ComboBox now derives from CellLayout, allowing easier layout and alignment of its <classname>Gtk::CellRenderer</classname>s.</simpara></listitem>

<listitem><simpara><classname>Gtk::Adjustment</classname> and <classname>IconSet</classname> and <classname>Gdk::Cursor</classname> are now used via <classname>Glib::RefPtr</classname>.</simpara></listitem>

<listitem><simpara><classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>, <classname>Gtk::IconView</classname>, <classname>Gtk::Paned</classname>, <classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</classname>, <classname>Gtk::Scrollbar</classname> and <classname>Gtk::Separator</classname> now derive from <classname>Gtk::Orientable</classname>, allowing their
orientation (vertical or horizontal) to be specified without requiring the use of a derived class such as <classname>Gtk::HBox</classname>.</simpara></listitem>

<listitem><simpara><classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, <classname>Gtk::TreeView</classname> and other widgets derive from Scrollable instead of having their own methods such as <methodname>get_vadjustment()</methodname> and instead of having their own set_scroll_adjustments signal.</simpara></listitem>

<listitem><simpara><classname>Gtk::Style</classname> and <classname>Gtk::Rc</classname> were removed, replaced by <classname>Gtk::StyleContext</classname>, and <classname>Gtk::StyleProvider</classname>s, such as <classname>Gtk::CssProvider</classname>.</simpara></listitem>

<listitem><simpara>Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes that cairomm is used for drawing, via the provided <classname>Cairo::Context</classname> and does not require you to call <methodname>Cairo::Context::clip()</methodname>.</simpara></listitem>

<listitem><simpara><classname>Gdk::RGBA</classname> replaces <classname>Color</classname>, adding an alpha component for opacity. <classname>Colormap</classname> was removed, along with its awkward use to allocate colors.</simpara></listitem>

<listitem><simpara><classname>Gdk::Pixmap</classname> and <classname>Gdk::Bitmap</classname> were removed in favor of <classname>Gdk::Pixbuf</classname>.</simpara></listitem>

<listitem><simpara><classname>Gdk::Drawable</classname> was removed, with its methods moving into <classname>Gdk::Window</classname>.</simpara></listitem>

<listitem><simpara>We now use std::vector in several methods instead of the intermediate *Handle types to make the API clearer.</simpara></listitem>

</orderedlist>
</para>

<para>All deprecated API was removed in &gtkmm; 3.0, though there have been new deprecations in later &gtkmm; 3.x versions.</para>

<para>As a first step to porting your source code to &gtkmm;-3.0 you should probably ensure that your application builds with the deprecated &gtkmm;-2.4 API disabled, by defining macro such as GTKMM_DISABLE_DEPRECATED. There are some autotools macros that can help with this by defining them optionally at build time. See the <link xlink:href="https://wiki.gnome.org/Projects/gtkmm/PortingToGtkmm3">gtkmm 3 porting wiki page</link> for more details.</para>

</chapter>

<chapter xml:id="changes-gtkmm4">
<title>Changes in &gtkmm;-4.0 and <application>glibmm-2.68</application></title>

<para>&gtkmm;-4.0 is a new version of the &gtkmm; API that installs in parallel with the
older &gtkmm;-2.4 and &gtkmm;-3.0 APIs. The last version of the &gtkmm;-3.0 API
is &gtkmm; 3.24. &gtkmm; 4 has no major fundamental differences to &gtkmm; 3 but
does make several changes (both small and large ones) that were not possible while
maintaining binary compatibility. If you never used the &gtkmm;-3.0 API then you
can safely ignore this chapter.
</para>

<para>&gtkmm; 4's library is called <literal>libgtkmm-4.0</literal> rather than
<literal>libgtkmm-3.0</literal> and installs its headers in a similarly-versioned
directory, so your <application>pkg-config</application> check should ask for
<literal>gtkmm-4.0</literal> rather than <literal>gtkmm-3.0</literal>.
</para>

<para>&gtkmm;-4.0 is used in combination with <application>glibmm-2.68</application>,
which sets the global locale for your program. The older <application>glibmm-2.4</application>
does not do that, and &gtkmm;-3.0 does it only to some extent. What this means is
briefly that if your &gtkmm;-3.0 program contains a call to
<function>std::locale::global(std::locale(""))</function>, you can probably remove it.
If you don't want <application>glibmm</application> or &gtkmm;
to set the global locale for you, you should add a call to
<function>Glib::set_init_to_users_preferred_locale(false)</function> before any call to
<function>Glib::init()</function> or <methodname>Gtk::Application::create()</methodname>.
See the <application>glibmm</application> <link xlink:href="&url_refdocs_base_glib_html;namespaceGlib.html">
reference</link>.</para>

<para>There are lots and lots of differences between &gtkmm;-3.0 and &gtkmm;-4.0.
The following lists are not complete.</para>

<para>There are some important behavioural changes, to which you must adapt when migrating:</para>
<para>
<itemizedlist>
<listitem><simpara>
Whereas in &gtkmm;-3.0, destruction of a non-managed &cpp; widget wrapper caused the wrapped GtkWidget
to be destroyed, changes in GTK4 mean that in &gtkmm;-4.0 this canʼt always be the case. GTK4 has no
uniform way to remove a widget from a parent, as GTK3 did with <methodname>Gtk::Container::remove()</methodname>,
so &gtkmm;-4.0 canʼt do the removal for you as &gtkmm;-3.0 did. Hence, if a non-managed &cpp; widget
instance is destructed while the widget is a child of another, &gtkmm;-4.0 wonʼt remove it from the
parent, the parent retains a ref that stops the child being disposed, and the GtkWidget stays alive.
The end result is that to destroy a non-managed widget with its &cpp; wrapper you must first remove it
from its parent (however that parent allows) so the &cpp; wrapperʼs dtor can drop the final reference.
</simpara></listitem>
</itemizedlist>
</para>

<para>Some new classes were added in &gtkmm; 4 and <application>glibmm</application> 2.68:</para>
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><simpara><classname>Glib::ExtraClassInit</classname> and <classname>Gtk::Snapshot</classname>:
  These classes are needed only for writing custom widgets. See the
  <link linkend="sec-custom-widgets">Custom Widgets</link> section.</simpara></listitem>
<listitem><simpara><classname>Gtk::EventControllerKey</classname>,
  <classname>Gtk::EventControllerMotion</classname>, <classname>Gtk::EventControllerScroll</classname>
  and <classname>Gtk::GestureStylus</classname></simpara></listitem>
<listitem><simpara><classname>Gdk::Paintable</classname>, <classname>Gdk::Texture</classname>,
  <classname>Gtk::Picture</classname> and <classname>Gtk::WidgetPaintable</classname>
  </simpara></listitem>
<listitem><simpara><classname>Gdk::Window</classname> has been renamed to <classname>Gdk::Surface</classname>.
  (<classname>Gtk::Window</classname> keeps its name.)</simpara></listitem>
<listitem><simpara><classname>Gdk::DrawContext</classname> and <classname>Gdk::CairoContext</classname>
  are new. <classname>Gdk::DrawingContext</classname> has been removed.</simpara></listitem>
<listitem><simpara><classname>Gtk::Clipboard</classname> has been replaced by the new
  <classname>Gdk::Clipboard</classname>.</simpara></listitem>
<listitem><simpara><classname>Gdk::DragContext</classname> has been split into
  <classname>Gdk::Drag</classname> and <classname>Gdk::Drop</classname>.</simpara></listitem>
</orderedlist>

<para>There have also been several changes to the API, which you will probably encounter
when porting code that used &gtkmm;-3.0 and <application>glibmm</application>-2.4. Here is a short list:</para>
<para>
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><simpara>A C++17 compiler is required.</simpara></listitem>
<listitem><simpara><classname>Gtk::Button</classname>, <classname>Gtk::ToolButton</classname>,
  <classname>Gtk::MenuItem</classname> and <classname>Gtk::Switch</classname>
  implement the <classname>Gtk::Actionable</classname> interface instead of the removed
  <classname>Gtk::Activatable</classname> interface.</simpara></listitem>
<listitem><simpara><classname>Gtk::FontButton</classname> implements the <classname>Gtk::FontChooser</classname> interface.</simpara></listitem>
<listitem><simpara><classname>Gtk::Widget</classname>: The <methodname>get_preferred_*_vfunc()</methodname>s
  have been replaced by <methodname>measure_vfunc()</methodname>. This change only affects
  custom widgets.</simpara></listitem>
<listitem><simpara><classname>sigc::slot</classname>s use the <classname>sigc::slot&lt;R(Args...)&gt;</classname> syntax.
  Example: <classname>sigc::slot&lt;void(int, int)&gt;</classname> instead of <classname>sigc::slot&lt;void, int, int&gt;</classname>.</simpara></listitem>
<listitem><simpara><classname>Gtk::DrawingArea</classname> uses a draw function instead of the draw signal.</simpara></listitem>
<listitem><simpara><classname>Glib::ArrayHandle</classname>, <classname>Glib::StringArrayHandle</classname>,
  <classname>Glib::ListHandle</classname> and <classname>Glib::SListHandle</classname> have been removed.
  They were used in <application>glibmm</application>-2.4, but not used in &gtkmm;-3.0.
  If you've ever used these classes, replace them with a standard &cpp; container, such as <classname>std::vector</classname>.</simpara></listitem>
<listitem><simpara><classname>Gtk::Container</classname> has been removed.</simpara></listitem>
<listitem><simpara><methodname>Gtk::Widget::show_all()</methodname> has been removed. The default value
  of <methodname>Gtk::Widget::property_visible()</methodname> has been changed from
  <literal>false</literal> to <literal>true</literal>.</simpara></listitem>
<listitem><simpara>All event signals have been removed from <classname>Gtk::Widget</classname>.
  In most cases you can use one of the subclasses of <classname>Gtk::EventController</classname>
  as a replacement. For instance, use <classname>Gtk::GestureMultiPress</classname>
  instead of <methodname>signal_button_press_event()</methodname> and
  <methodname>signal_button_release_event()</methodname>, and <classname>Gtk::EventControllerKey</classname>
  instead of <methodname>signal_key_press_event()</methodname> and
  <methodname>signal_key_release_event()</methodname>.</simpara></listitem>
<listitem><simpara><classname>Glib::RefPtr</classname> is an alias for <classname>std::shared_ptr</classname>.
  If you make your own <classname>Glib::ObjectBase</classname>-derived classes with
  <methodname>create()</methodname> methods that return a <classname>Glib::RefPtr</classname>,
  you must use <methodname>Glib::make_refptr_for_instance()</methodname> in your
  <methodname>create()</methodname> methods.</simpara></listitem>
<listitem><simpara><methodname>Gtk::Box::pack_start()</methodname> and <methodname>Gtk::Box::pack_end()</methodname>
  have been removed. Use the new <classname>Gtk::Box</classname> methods
  <methodname>append()</methodname>, <methodname>prepend()</methodname>,
  <methodname>insert_child_after()</methodname> and <methodname>insert_child_at_start()</methodname>.
  </simpara></listitem>
<listitem><simpara><classname>Gtk::ButtonBox</classname> has been removed.</simpara></listitem>
<listitem><simpara><classname>Gtk::RadioButton</classname> and <classname>Gtk::RadioButtonGroup</classname>
  have been removed. Use <classname>Gtk::CheckButton</classname> or <classname>Gtk::ToggleButton</classname>
  with <methodname>set_group()</methodname>.</simpara></listitem>
</orderedlist>
</para>
<para>All deprecated API was removed in &gtkmm; 4.0 and <application>glibmm</application> 2.68,
  though there will be new deprecations in future versions.</para>

<para>As a first step to porting your source code to &gtkmm;-4.0 you should probably ensure
that your application builds with the deprecated &gtkmm;-3.0 and <application>glibmm-2.4</application>
API disabled, by defining the macros GTKMM_DISABLE_DEPRECATED, GDKMM_DISABLE_DEPRECATED,
GLIBMM_DISABLE_DEPRECATED and GIOMM_DISABLE_DEPRECATED. There are some autotools macros
that can help with this by defining them optionally at build time. See the
<link xlink:href="https://wiki.gnome.org/Projects/gtkmm/PortingToGtkmm3">Porting from
gtkmm-2.4 to gtkmm-3.0</link> wiki page for more details.</para>
<para>See also <link xlink:href="https://docs.gtk.org/gtk4/migrating-3to4.html">
Migrating from GTK 3.x to GTK 4</link>.</para>

<section xml:id="sec-deprecations-4-10">
<title>Deprecations in &gtkmm; 4.10</title>
<para>Many classes are deprecated since &gtkmm; 4.10. They can still be used in
&gtkmm;4 applications, provided GTKMM_DISABLE_DEPRECATED and GDKMM_DISABLE_DEPRECATED
are not defined. There are also many new classes in &gtkmm; 4.10, which replace
some of the deprecated classes. Some example programs in this tutorial use classes
deprecated since &gtkmm; 4.10. Some other programs use classes available since &gtkmm; 4.10.
</para>
<para>Deprecated classes:
  AppChooser, AppChooserButton, AppChooserDialog,
  AppChooserWidget, CellArea, CellAreaBox, CellAreaContext,
  CellLayout, CellRenderer, CellRendererAccel, CellRendererCombo,
  CellRendererPixbuf, CellRendererProgress, CellRendererSpin,
  CellRendererSpinner, CellRendererText, CellRendererToggle, CellView,
  ComboBox, ComboBoxText, EntryCompletion, IconView, ListStore,
  ListViewText, StyleContext, TreeDragDest, TreeDragSource,
  TreeIter and other classes in treeiter.h,
  TreeModel, TreeModelFilter, TreeModelSort, TreePath, TreeRowReference,
  TreeSelection, TreeSortable, TreeStore, TreeView, TreeViewColumn,
  namespace CellRenderer_Generation, namespace TreeView_Private,
  ColorButton, ColorChooser, ColorChooserDialog,
  FileChooser, FileChooserDialog, FileChooserNative, FileChooserWidget,
  FontButton, FontChooser, FontChooserDialog, FontChooserWidget,
  MessageDialog, TreeModelColumn, TreeModelColumnRecord, InfoBar,
  Assistant, AssistantPage, LockButton, Statusbar, VolumeButton.
</para>
<para>New classes and enums:
  AlertDialog, ColorDialog, ColorDialogButton, ColumnViewSorter, FileDialog,
  FontDialog, FontDialogButton, FileLauncher, UriLauncher, ATContext,
  enums DialogError, FontLevel, Collation.
</para>
<para>In most cases there are replacements for the deprecated classes.
See the reference documentation.
</para>
</section>

</chapter>

<chapter xml:id="chapter-button-widget">
<title>Buttons</title>

<para>
&gtkmm; provides four basic types of buttons:
</para>

<variablelist>

<varlistentry>
<term>Push buttons</term>
<listitem>
<para>
<link xlink:href="&url_refdocs_base_gtk;Button.html"><classname>Gtk::Button</classname></link>. Standard buttons, usually
marked with a label or picture. Pushing one triggers an action. See the <link linkend="sec-pushbuttons">Button</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Toggle buttons</term>
<listitem>
<para>
<link xlink:href="&url_refdocs_base_gtk;ToggleButton.html"><classname>Gtk::ToggleButton</classname></link>.
Unlike a normal Button, which springs back up, a ToggleButton stays down until you
press it again. It might be useful as an on/off switch. See the <link linkend="sec-toggle-buttons">ToggleButton</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Check buttons</term>
<listitem>
<para>
<link xlink:href="&url_refdocs_base_gtk;CheckButton.html"><classname>Gtk::CheckButton</classname></link>.
These act like ToggleButtons, but show their state in small squares,
with their label at the side. They should be used in most situations
which require an on/off setting.
See the <link linkend="sec-checkbuttons">CheckButton</link> section.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term>Radio buttons</term>
<listitem>
<para>
Named after the station selectors on old car
radios, these buttons are used in groups for options which are
mutually exclusive. Pressing one causes all the
others in its group to turn off. They are similar to ToggleButtons or
CheckButtons (a small widget with a label at the side), but usually
look different. There is no separate radio button class. Check buttons
and toggle buttons can act as radio buttons.
See the <link linkend="sec-radio-buttons">Radio Button</link> section.
</para>
</listitem>
</varlistentry>
</variablelist>

<para>
Note that, due to GTK's theming system, the appearance of these
widgets will vary. In the case of check buttons and radio buttons, they
may vary considerably.
</para>

<section xml:id="sec-pushbuttons">
<title>Button</title>

<para>
There are two ways to create a Button. You can specify a label
string in the <classname>Gtk::Button</classname> constructor,
or set it later with <methodname>set_label()</methodname>.
</para>

<para>To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify <literal>true</literal> for the optional <literal>mnemonic</literal> parameter. For instance:
</para>
<programlisting><code>Gtk::Button* pButton = new Gtk::Button("_Something", true);</code></programlisting>

<para>
<classname>Gtk::Button</classname> is also
a container so you could put any other widget, such as a
<classname>Gtk::Image</classname> into it.
</para>

<para>
The <classname>Gtk::Button</classname> widget has the <literal>clicked</literal> signal
which is emitted when the button is pressed and released.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Button.html">Reference</link></para>

<section xml:id="pushbutton-example">
<title>Example</title>

<para>
This example creates a button with a picture and a label.
</para>

<figure xml:id="figure-buttons">
  <title>buttons example</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buttons.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buttons/button">Source Code</link></para>

</section>

</section>

<section xml:id="sec-toggle-buttons">
<title>ToggleButton</title>

<para><classname>ToggleButton</classname>s are like normal <classname>Button</classname>s, but when clicked they remain activated, or pressed,  until clicked again.</para>

<para>
To retrieve the state of the <classname>ToggleButton</classname>, you can use the
<methodname>get_active()</methodname> method. This returns <literal>true</literal> if the button
is "down". You can also set the toggle button's state, with <methodname>set_active()</methodname>. Note that, if you do this, and the state actually changes, it causes the
"clicked" signal to be emitted. This is usually what you want.
</para>

<para>
You can use the <methodname>toggled()</methodname> method to toggle the button, rather than
forcing it to be up or down: This switches the button's state, and causes the <literal>toggled</literal> signal to be emitted.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ToggleButton.html">Reference</link></para>

</section>

<section xml:id="sec-checkbuttons">
<title>CheckButton</title>

<para>
<classname>Gtk::CheckButton</classname> inherits directly from
<classname>Gtk::Widget</classname>. It is similar to <classname>Gtk::ToggleButton</classname>.
The only real difference between the two is <classname>Gtk::CheckButton</classname>'s
appearance. You can check and set a check button using the same
member methods as for <classname>Gtk::ToggleButton</classname>.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;CheckButton.html">Reference</link></para>

<section xml:id="checkbutton-example">
<title>Example</title>

<figure xml:id="figure-checkbutton">
  <title>CheckButton</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;checkbutton.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buttons/checkbutton">Source Code</link></para>
</section>

</section>

<section xml:id="sec-radio-buttons">
<title>Radio Button</title>

<para>
There is no separate class for radio buttons. Check buttons and toggle buttons
act as radio buttons when they form a group. Only one button in a group can be
selected at any one time.
</para>

<section xml:id="radiobutton-groups">
<title>Groups</title>
<para>
You create the buttons, and set up their group afterwards. In the following example,
we put 3 radio buttons in a group:
</para>

<programlisting><code>auto rb1 = Gtk::make_managed&lt;Gtk::CheckButton&gt;("button1");
auto rb2 = Gtk::make_managed&lt;Gtk::CheckButton&gt;("button2");
auto rb3 = Gtk::make_managed&lt;Gtk::CheckButton&gt;("button3");
rb2-&gt;set_group(*rb1);
rb3-&gt;set_group(*rb1);
</code></programlisting>

<para>
We told &gtkmm; to put all three <classname>CheckButton</classname>s in the
same group by using <methodname>set_group()</methodname> to tell the other
<classname>CheckButton</classname>s to share group with the first
<classname>CheckButton</classname>.
</para>

</section>

<section xml:id="radiobutton-methods">
<title>Methods</title>
<para>
<classname>CheckButton</classname>s and <classname>ToggleButton</classname>s are "off"
when created; this means that when you first make a group of them, they will all be off.
Don't forget to turn one of them on using <methodname>set_active()</methodname>.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;RadioButton.html">Reference</link></para>

</section>

<section xml:id="radiobutton-example">
<title>Example</title>
<para>
The following example demonstrates the use of grouped
<classname>CheckButton</classname>s:
</para>

<figure xml:id="figure-radiobutton">
  <title>RadioButton</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;radiobuttons.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buttons/radiobutton">Source Code</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-range-widgets">
<title>Range Widgets</title>

<para>
<classname>Gtk::Scale</classname> inherits from <classname>Gtk::Range</classname>.
<classname>Gtk::Scrollbar</classname> does not inherit from <classname>Gtk::Range</classname>,
but it shares much functionality with <classname>Gtk::Scale</classname>.
They both contain a "trough" and a "slider" (sometimes called a
"thumbwheel" in other GUI environments). Dragging the slider with the pointer
moves it within the trough, while clicking in the trough advances the slider
towards the location of the click, either completely, or by a designated
amount, depending on which mouse button is used. This should be familiar
scrollbar behavior.
</para>

<para>
As will be explained in the <link linkend="chapter-adjustment">Adjustments</link>
section, all range widgets are associated with an
<classname>Adjustment</classname> object. To change the lower, upper, and
current values used by the widget you need to use the methods of its
<classname>Adjustment</classname>, which you can get with the
<methodname>get_adjustment()</methodname> method. The range
widgets' default constructors create an <classname>Adjustment</classname>
automatically, or you can specify an existing
<classname>Adjustment</classname>, maybe to share it with another widget. See
the <link linkend="chapter-adjustment">Adjustments</link> section for further
details.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Range.html">Reference</link></para>

<section xml:id="sec-scrollbar-widgets">
<title>Scrollbar Widgets</title>

<para>
These are standard scrollbars. They should be used only to scroll another
widget, such as a <classname>Gtk::Entry</classname> or a
<classname>Gtk::Viewport</classname>, though it's usually easier to use the
<classname>Gtk::ScrolledWindow</classname> widget in most cases.
</para>

<para>
The orientation of a <classname>Gtk::Scrollbar</classname> can be either
horizontal or vertical.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Scrollbar.html">Reference</link></para>

</section>

<section xml:id="sec-scale-widgets">
<title>Scale Widgets</title>

<para>
<classname>Gtk::Scale</classname> widgets (or "sliders") allow the user to
visually select and manipulate a value within a specific range. You
might use one, for instance, to adjust the
magnification level on a zoomed preview of a picture, or to control
the brightness of a colour, or to specify the number of minutes of
inactivity before a screensaver takes over the screen.
</para>

<para>
As with <classname>Scrollbar</classname>s, the orientation can be either
horizontal or vertical. The default constructor creates an
<classname>Adjustment</classname> with all of its values set to
<literal>0.0</literal>. This isn't useful so you will need to set some
<classname>Adjustment</classname> details to get meaningful behavior.
</para>

<section xml:id="scale-useful-methods">
<title>Useful methods</title>

<para>
<classname>Scale</classname> widgets can display their current value as a number
next to the trough. By default they show the value, but you can change this
with the <methodname>set_draw_value()</methodname> method.
</para>

<para>
The value displayed by a scale widget is rounded to one decimal point
by default, as is the <literal>value</literal> field in its
<classname>Gtk::Adjustment</classname>. You can change this with the
<methodname>set_digits()</methodname> method.
</para>

<para>
Also, the value can be drawn in different positions relative to the trough,
specified by the <methodname>set_value_pos()</methodname> method.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Scale.html">Reference</link></para>

</section>
</section>

<section xml:id="sec-range-example">
<title>Example</title>

<para>
This example displays a window with three range widgets all connected
to the same adjustment, along with a couple of controls for adjusting
some of the parameters mentioned above and in the section on
adjustments, so you can see how they affect the way these widgets work
for the user.
</para>

<figure xml:id="figure-range-widgets">
  <title>Range Widgets</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;range_widgets.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;range_widgets">Source Code</link></para>

</section>

</chapter>

<chapter xml:id="chapter-misc-widgets">
<title>Miscellaneous Widgets</title>

<section xml:id="sec-labels">
<title>Label</title>

<para>
Labels are the  main method of placing non-editable text in windows, for
instance to place a title next to an <classname>Entry</classname> widget. You
can specify the text in the constructor, or later with the
<methodname>set_text()</methodname> or <methodname>set_markup()</methodname> methods.
</para>

<para>
The width of the label will be adjusted automatically. You can produce multi-line labels by putting line breaks ("\n") in the label string.
</para>

<para>
The label text can be justified using the <methodname>set_justify()</methodname>
method. The widget is also capable of word-wrapping, which can be activated
with <methodname>set_wrap()</methodname>.
</para>

<para>
Gtk::Label supports some simple formatting, for instance allowing you to make some
text bold, colored, or larger. You can do this by providing a string to
<methodname>set_markup()</methodname>, using the <link xlink:href="https://docs.gtk.org/Pango/pango_markup.html">Pango Markup syntax</link>. For instance,
<code>
&lt;b&gt;bold text&lt;/b&gt; and &lt;s&gt;strikethrough text&lt;/s&gt;
</code>
.</para>

<para><link xlink:href="&url_refdocs_base_gtk;Label.html">Reference</link></para>

<section xml:id="label-example">
<title>Example</title>
<para>
Below is a short example to illustrate these functions. This example
makes use of the Frame widget to better demonstrate the label styles.
 (The Frame widget is explained in the <link linkend="sec-frame">Frame</link> section.)
It is possible that the first character in <literal>m_Label_Normal</literal> is shown
underlined only when you press the <keycap>Alt</keycap> key.
</para>

<figure xml:id="figure-label">
  <title>Label</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;label.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;label">Source Code</link></para>

</section>

</section>

<section xml:id="sec-text-entry">
<title>Entry</title>

<section xml:id="sec-text-entry-simple">
<title>Simple Use</title>

<para>
Entry widgets allow the user to enter text. You can change the contents with the <methodname>set_text()</methodname> method,
and read the current contents with the <methodname>get_text()</methodname> method.
</para>

<para>
Occasionally you might want to make an <classname>Entry</classname> widget
read-only. This can be done by passing <literal>false</literal> to the
<methodname>set_editable()</methodname> method.
</para>

<para>
For the input of passwords, passphrases and other information you don't want
echoed on the screen, calling <methodname>set_visibility()</methodname> with
<literal>false</literal> will cause the text to be hidden.
</para>

<para>
You might want to be notified whenever the user types in a text entry widget.
<classname>Gtk::Entry</classname> provides two signals,
<literal>activate</literal> (since &gtkmm; 4.8) and <literal>changed</literal>, for this purpose.
<literal>activate</literal> is emitted when the user presses the <keycap>Enter</keycap> key in
a text-entry widget; <literal>changed</literal> is emitted when the text in
the widget changes. You can use these, for instance, to validate or filter
the text the user types. Moving the keyboard focus to another widget may also
signal that the user has finished entering text. The <literal>leave</literal>
signal in a <classname>Gtk::EventControllerFocus</classname> can notify you when
that happens. The <link linkend="sec-comboboxentry">ComboBox with an Entry</link>
section contains example programs that use these signals.
</para>

<para>
If you pass <literal>true</literal> to the <methodname>set_activates_default()</methodname>
method, pressing <keycap>Enter</keycap> in the <classname>Gtk::Entry</classname> will activate
the default widget for the window containing the <classname>Gtk::Entry</classname>.
This is especially useful in dialog boxes. The default widget is usually one of
the dialog buttons, which e.g. will close the dialog box. To set a widget as the
default widget, use <methodname>Gtk::Window::set_default_widget()</methodname>.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Entry.html">Reference</link></para>

<section xml:id="entry-example">
<title>Simple Entry Example</title>
<para>
This example uses <classname>Gtk::Entry</classname>. It also has two
<classname>CheckButton</classname>s, with which you can toggle the editable and
visible flags.
</para>

<figure xml:id="figure-entry-simple">
  <title>Entry</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;entry.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;entry/simple">Source Code</link></para>

</section>

</section>

<section xml:id="sec-text-entry-completion">
<title>Entry Completion</title>

<note><para><classname>Gtk::EntryCompletion</classname> is deprecated since &gtkmm; 4.10.
There is no replacement in &gtkmm;.
</para></note>

<para>An <classname>Entry</classname> widget can offer a drop-down list of
pre-existing choices based on the first few characters typed by the user. For
instance, a search dialog could suggest text from previous searches.
</para>

<para>To enable this functionality, you must create an
<classname>EntryCompletion</classname> object, and provide it to the
<classname>Entry</classname> widget via the
<methodname>set_completion()</methodname> method.</para>

<para>The <classname>EntryCompletion</classname> may use a
<classname>TreeModel</classname> containing possible entries, specified with
<methodname>set_model()</methodname>. You should then call
<methodname>set_text_column()</methodname> to specify which of your model columns
should be used to match possible text entries.</para>

<para>Alternatively, if a complete list of possible entries
would be too large or too inconvenient to generate, a callback slot may instead
be specified with <methodname>set_match_func()</methodname>.
This is also useful if you wish to match on a part of the string other
than the start.</para>

<para><link xlink:href="&url_refdocs_base_gtk;EntryCompletion.html">Reference</link></para>

<section xml:id="entry-completion-example">
<title>Entry Completion Example</title>
<para>
This example creates a <classname>Gtk::EntryCompletion</classname> and associates
it with a <classname>Gtk::Entry</classname> widget. The completion uses a
<classname>Gtk::TreeModel</classname> of possible entries, and some additional
actions.
</para>

<figure xml:id="figure-entry-completion">
  <title>Entry Completion</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;entry_completion.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;entry/completion">Source Code</link></para>

</section>
</section>

<section xml:id="sec-text-entry-icons">
<title>Entry Icons</title>

<para>An <classname>Entry</classname> widget can show an icon at the start or
end of the text area. The icon can be specified by methods such as
<methodname>set_icon_from_paintable()</methodname> or
<methodname>set_icon_from_icon_name()</methodname>. An application can respond to the
user pressing the icon by handling the
<methodname>signal_icon_press</methodname> signal.</para>

<section xml:id="entry-icon-example">
<title>Entry Icon Example</title>
<para>
This example shows a <classname>Gtk::Entry</classname> widget with a named
search icon, and prints text to the terminal when the icon is pressed.
</para>

<figure xml:id="figure-entry-icon">
  <title>Entry with Icon</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;entry_icon.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;entry/icon">Source Code</link></para>

</section>
</section>

<section xml:id="sec-text-entry-progress">
<title>Entry Progress</title>

<para>An <classname>Entry</classname> widget can show a progress bar inside the
text area, under the entered text. The progress bar will be shown if the
<methodname>set_progress_fraction()</methodname> or
<methodname>set_progress_pulse_step()</methodname> methods are called.</para>

<section xml:id="entry-progress-example">
<title>Entry Progress Example</title>
<para>
This example shows a <classname>Gtk::Entry</classname> widget with a progress
bar.
</para>

<figure xml:id="figure-entry-progress">
  <title>Entry with Progress Bar</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;entry_progress.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;entry/progress">Source Code</link></para>

</section>
</section>

</section>

<section xml:id="sec-spinbutton">
<title>SpinButton</title>

<para>
A <classname>SpinButton</classname> allows the user to select a value from a
range of numeric values. It has an <classname>Entry</classname> widget with increment and decrement buttons
at the side. Clicking the buttons causes the value to 'spin' up and down across
the range of possible values. The <classname>Entry</classname> widget may also
be used to enter a value directly.
</para>

<para>
The value can have an adjustable number of decimal places, and the step size is
configurable. <classname>SpinButton</classname>s have an 'auto-repeat' feature
as well: holding down the increment or decrement button can optionally cause the value to
change more quickly the longer the button is held down.
</para>

<para>
<classname>SpinButton</classname>s use an <link linkend="chapter-adjustment">Adjustment</link> object to hold information about
the range of values. These Adjustment attributes are used by the Spin Button
like so:
<itemizedlist>
<listitem>

<para>
 <literal>value</literal>: value for the Spin Button
</para>
</listitem>
<listitem>

<para>
 <literal>lower</literal>: lower range value
</para>
</listitem>
<listitem>

<para>
 <literal>upper</literal>: upper range value
</para>
</listitem>
<listitem>
<para>
 <literal>step_increment</literal>: value to increment/decrement when pressing
mouse button 1
</para>
</listitem>
<listitem>

<para>
 <literal>page_increment</literal>: value to increment/decrement when pressing
mouse button 2
</para>
</listitem>
<listitem>

<para>
 <literal>page_size</literal>: unused
</para>
</listitem>

</itemizedlist>
</para>

<para>
Additionally, mouse button 3 can be used to jump directly to the
<literal>upper</literal> or <literal>lower</literal> values.
</para>

<para>
The <classname>SpinButton</classname> can create a default
<classname>Adjustment</classname>, which you can access via the
<methodname>get_adjustment()</methodname> method, or you can specify an existing
<classname>Adjustment</classname> in the constructor.
</para>


<section xml:id="spinbutton-methods">
<title>Methods</title>

<para>
The number of decimal places can be altered using the
<methodname>set_digits()</methodname> method.
</para>

<para>
You can set the spinbutton's value using the <methodname>set_value()</methodname>
method, and retrieve it with <methodname>get_value()</methodname>.
</para>

<para>
The <methodname>spin()</methodname> method 'spins' the
<classname>SpinButton</classname>, as if its increment or decrement button had been clicked.
You need to specify a <classname>Gtk::SpinType</classname> to specify the
direction or new position.
</para>

<para>
To prevent the user from typing non-numeric characters into the entry box, pass
<literal>true</literal> to the <methodname>set_numeric()</methodname> method.
</para>

<para>
To make the <classname>SpinButton</classname> 'wrap' between its upper and
lower bounds, use the <methodname>set_wrap()</methodname> method.
</para>

<para>
To force it to snap to the nearest <literal>step_increment</literal>,
use <methodname>set_snap_to_ticks()</methodname>.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;SpinButton.html">Reference</link></para>

</section>

<section xml:id="spinbutton-example">
<title>Example</title>

<para>
Here's an example of a <classname>SpinButton</classname> in action:
</para>

<figure xml:id="figure-spinbutton">
  <title>SpinButton</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;spinbutton.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;spinbutton">Source Code</link></para>

</section>

</section>

<section xml:id="sec-progressbar">
<title>ProgressBar</title>

<para>
Progress bars are used to show the status of an ongoing operation. For
instance, a <classname>ProgressBar</classname> can show how much of a task has
been completed.
</para>

<para>
To change the value shown, use the <methodname>set_fraction()</methodname> method,
passing a <type>double</type> between 0.0 and 1.0 to provide the new fraction.
</para>

<para>
A <classname>ProgressBar</classname> is horizontal and left-to-right by default,
but you can change it to a vertical progress bar by using the
<methodname>set_orientation()</methodname> method.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ProgressBar.html">Reference</link></para>

<section xml:id="progressbar-activity-mode">
<title>Activity Mode</title>

<para>
Besides indicating the amount of progress that has occurred, the
progress bar can also be used to indicate that there is some activity;
this is done by placing the progress bar in <emphasis>activity mode</emphasis>. In
this mode, the progress bar displays a small rectangle which moves
back and forth. Activity mode is useful in situations where the
progress of an operation cannot be calculated as a value range (e.g.,
receiving a file of unknown length).
</para>

<para>
To do this, you need to call the <methodname>pulse()</methodname> method at regular
intervals. You can also choose the step size, with the
<methodname>set_pulse_step()</methodname> method.
</para>

<para>
The progress bar can also display a configurable text
string next to the bar, using the <methodname>set_text()</methodname> method.
</para>
</section>

<section xml:id="progressbar-example">
<title>Example</title>

<figure xml:id="figure-progressbar">
  <title>ProgressBar</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;progressbar.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;progressbar">Source Code</link></para>

</section>
</section>

<section xml:id="sec-infobar">
<title>InfoBar</title>

<para>
An <classname>InfoBar</classname> may show small items of information or ask brief questions. Unlike a <classname>Dialog</classname>, it appears at the top of the current window instead of opening a new window. Its API is very similar to the <link linkend="chapter-dialogs">Gtk::Dialog</link> API.</para>

<para><link xlink:href="&url_refdocs_base_gtk;InfoBar.html">Reference</link></para>

<section xml:id="infobar-example">
<title>Example</title>

<para>The <classname>InfoBar</classname> widget is deprecated since &gtkmm; 4.10.
The example shows an info bar consisting of a <classname>Box</classname> with
a <classname>Label</classname> and a <classname>Button</classname>.</para>

<figure xml:id="figure-infobar">
  <title>InfoBar</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;infobar.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;infobar">Source Code</link></para>

</section>

</section>

<section xml:id="sec-tooltips">
<title>Tooltips</title>

<para>
Tooltips are the little information windows that pop up when you leave your
pointer over a widget for a few seconds. Use
<methodname>set_tooltip_text()</methodname> to set a text string as a tooltip
on any <classname>Widget</classname>.
<classname>Gtk::Tooltip</classname> is used for more advanced tooltip usage,
such as showing an image as well as text.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Widget.html">Widget Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;Tooltip.html">Tooltip Reference</link></para>

<section xml:id="tooltip-example">
<title>Example</title>

<figure xml:id="figure-tooltip">
  <title>Tooltip</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;tooltip.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;tooltips">Source Code</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-container-widgets">
<title>Container Widgets</title>

<para>
Container widgets, like other widgets, derive from <classname>Gtk::Widget</classname>.
Some container widgets, such as <classname>Gtk::Grid</classname> can hold many
child widgets, so these typically have more complex interfaces. Others, such as
<classname>Gtk::Frame</classname> contain only one child widget.
</para>

<section xml:id="sec-single-item-containers">
<title>Single-item Containers</title>

<para>
Most single-item container widgets have <methodname>set_child()</methodname>
and <methodname>unset_child()</methodname> methods for the child widget.
<classname>Gtk::Button</classname> and <classname>Gtk::Window</classname> are
technically single-item containers, but we have discussed them already elsewhere.
</para>

<para>
We also discuss the <classname>Gtk::Paned</classname> widget, which allows you
to divide a window into two separate "panes". This widget actually contains
two child widgets, but the number is fixed so it seems appropriate.
</para>

<section xml:id="sec-frame">
<title>Frame</title>

<para>
Frames can enclose one or a group of widgets within a box, optionally with a
title. For instance, you might place a group of
<classname>ToggleButton</classname>s or <classname>CheckButton</classname>s in a
<classname>Frame</classname>.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Frame.html">Reference</link></para>

<section xml:id="frame-example">
<title>Example</title>

<figure xml:id="figure-frame">
  <title>Frame</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;frame.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;frame">Source Code</link></para>

</section>
</section>

<section xml:id="sec-paned">
<title>Paned</title>

<para>
Panes divide a widget into two halves, separated by a moveable divider.
The two halves (panes) can be oriented either horizontally (side by side) or
vertically (one above the other).
</para>

<para>
Unlike the other widgets in this section, pane widgets contain not one but two
child widgets, one in each pane. Therefore, you should use
<methodname>set_start_child()</methodname> and <methodname>set_end_child()</methodname>
instead of a <methodname>set_child()</methodname> method.
</para>

<para>
You can adjust the position of the divider using the
<methodname>set_position()</methodname> method, and you will probably need to do
so.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Paned.html">Reference</link></para>

<section xml:id="paned-example">
<title>Example</title>

<figure xml:id="figure-paned">
  <title>Paned</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;paned.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;paned">Source Code</link></para>

</section>
</section>

<section xml:id="sec-scrolledwindow">
<title>ScrolledWindow</title>

<para>
<classname>ScrolledWindow</classname> widgets create a scrollable
area. You can insert any type of widget into a
<classname>ScrolledWindow</classname>, and it will be accessible
regardless of its size by using the scrollbars. Note that
<classname>ScrolledWindow</classname> is not a
<classname>Gtk::Window</classname> despite the slightly misleading name.
</para>

<para>
Scrolled windows have <emphasis>scrollbar policies</emphasis> which determine
whether the <classname>Scrollbar</classname>s will be displayed. The policies
can be set with the <methodname>set_policy()</methodname> method. The policy may be
for instance <literal>Gtk::PolicyType::AUTOMATIC</literal> or
<literal>Gtk::PolicyType::ALWAYS</literal>.
<literal>Gtk::PolicyType::AUTOMATIC</literal> will cause the scrolled window
to display the scrollbar only if the contained widget is larger than the
visible area. <literal>Gtk::PolicyType::ALWAYS</literal> will cause the
scrollbar to be displayed always.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ScrolledWindow.html">Reference</link></para>

<section xml:id="scrolledwindow-example">
<title>Example</title>

<para>
Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react.
</para>

<figure xml:id="figure-scrolledwindow">
  <title>ScrolledWindow</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;scrolledwindow.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;scrolledwindow">Source Code</link></para>

</section>
</section>

<section xml:id="sec-aspectframe">
<title>AspectFrame</title>

<para>
The <classname>AspectFrame</classname> widget looks like a
<classname>Frame</classname> widget, but it also enforces the <emphasis>aspect
    ratio</emphasis> (the ratio of the width to the height) of the child
widget, adding extra space if necessary. For instance, this would allow you to
display a photograph without allowing the user to distort it horizontally or
vertically while resizing.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;AspectFrame.html">Reference</link></para>

<section xml:id="aspectframe-example">
<title>Example</title>

<para>
The following program uses a <classname>Gtk::AspectFrame</classname> to present a
drawing area whose aspect ratio will always be 2:1, no matter how the user
resizes the top-level window.
</para>

<figure xml:id="figure-aspectframe">
  <title>AspectFrame</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;aspectframe.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;aspectframe">Source Code</link></para>
</section>

</section>

<section xml:id="sec-other-single-item-containers">
<title>Other Single-item Containers</title>

<para>
There are other single-item containers. See the reference documentation for a
complete list. Here are links to some example programs that show containers,
which are not mentioned elsewhere in this tutorial.
</para>

<para><link xlink:href="&url_examples_base;expander">Source Code, Expander</link></para>
<para><link xlink:href="&url_examples_base;popover">Source Code, Popover</link></para>

</section>

</section>

<section xml:id="sec-multi-item-containers">
<title>Multiple-item Containers </title>

<para>
Multiple-item container widgets have other methods than <methodname>set_child()</methodname>
and <methodname>unset_child()</methodname>. Different containers can have different
methods for adding and removing child widgets. For instance, <classname>Gtk::Box</classname>
has <methodname>append()</methodname> and <methodname>remove()</methodname> as
well as other methods. The <methodname>remove()</methodname> method for multiple-item
containers takes an argument, specifying which widget to remove.
</para>

<section xml:id="container-packing">
<title>Packing</title>

<para>
You've probably noticed that &gtkmm; windows seem "elastic" - they can usually be stretched in many  different ways. This is due to the <emphasis>widget packing</emphasis>
system.
</para>

<para>
Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:
</para>

<itemizedlist>

<listitem>
<para>The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger.</para>
</listitem>

<listitem>
<para>It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager.</para>
</listitem>

<listitem>
<para>
Changing the layout of a window "on the fly", to make some extra widgets appear, for instance, is complex. It  requires tedious recalculation of every widget's position.</para>
</listitem>

</itemizedlist>

<para>
&gtkmm; uses the packing system to solve these problems. Rather than specifying the position and size of each widget in the window,
you can arrange your widgets in rows, columns,
and/or grids. &gtkmm; can size your window automatically, based on the
sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets.
You can perfect your layout by
specifying margins and centering values for each of your widgets. &gtkmm; then uses
all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window. </para>

<para>
&gtkmm; arranges widgets hierarchically, using <emphasis>containers</emphasis>.
A container widget contains other widgets. Most &gtkmm; widgets are
containers. Windows, Notebook tabs, and Buttons are all container widgets.
There are two flavors of containers: single-child containers and multiple-child
containers. Most container widgets in &gtkmm; are single-child containers,
including <classname>Gtk::Window</classname>.
</para>

<para>
Yes, that's correct: a Window can contain at most one widget. How, then, can
we use a window for anything useful?  By placing a multiple-child container in
the window. The most useful container widgets are
<classname>Gtk::Grid</classname> and <classname>Gtk::Box</classname>.
</para>


<itemizedlist>

<listitem>
<para>
<classname>Gtk::Grid</classname> arranges its child widgets in rows and
columns. Use <methodname>attach()</methodname> and
<methodname>attach_next_to()</methodname> to insert child widgets.
</para>
</listitem>

<listitem>
<para>
<classname>Gtk::Box</classname> arranges its child widgets vertically or horizontally.
Use <methodname>append()</methodname> to insert child widgets.
</para>
</listitem>

</itemizedlist>

<para>
 There are several other containers, which we will also discuss.
</para>

<para>
If you've never used a packing toolkit before, it can take some
getting used to. You'll probably find, however, that you don't
need to rely on visual form editors quite as much as you might with
other toolkits.
</para>

</section>

<section xml:id="sec-helloworld2">
<title>An improved Hello World</title>

<para>
Let's take a look at a slightly improved <literal>helloworld</literal>, showing what we've learnt.
</para>

<figure xml:id="figure-helloworld2">
  <title>Hello World 2</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;helloworld2.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;helloworld2">Source Code</link></para>

<para>
After building and running this program, try resizing the window to see the
behavior. Also, try playing with <methodname>set_expand()</methodname>,
<methodname>set_hexpand()</methodname>, <methodname>set_vexpand()</methodname>,
<methodname>set_halign()</methodname> and <methodname>set_valign()</methodname>
while reading the <link linkend="sec-boxes">Boxes</link> section.
</para>

</section>

<section xml:id="sec-boxes">
<title>Boxes</title>

<para>
Most packing uses boxes as in the above example. These
are invisible containers into which we can pack our widgets. When
packing widgets into a horizontal box, the objects are inserted
horizontally from left to right. In a vertical box, widgets are packed from
top to bottom. You may use any combination of boxes inside or beside other
boxes to create the desired effect.
</para>

<section xml:id="boxes-adding-widgets">
<title>Adding widgets</title>
<section xml:id="per-child-packing-options">
<title>Per-child packing options</title>
<para>
The <methodname>append()</methodname> method places widgets inside these
containers. It will start at the top and work its way down in a
<classname>Box</classname> with vertical orientation, or pack left to right in
a <classname>Box</classname> with horizontal orientation. If it's inconvenient
to add widgets in this order, use <methodname>insert_child_after()</methodname>
or <methodname>insert_child_at_start()</methodname>. We will use
<methodname>append()</methodname> in our examples.
</para>

<para>
There are several options governing how widgets are to be packed, and this can
be confusing at first. You can modify the packing by using <methodname>set_expand()</methodname>,
<methodname>set_hexpand()</methodname>, <methodname>set_vexpand()</methodname>,
<methodname>set_halign()</methodname>, <methodname>set_valign()</methodname>
and/or <methodname>set_margin()</methodname> on the child widgets. If you have
difficulties, then it is sometimes a good idea to play with the
<application>Cambalache</application> GUI designer to see what is possible.
You can then use the <classname>Gtk::Builder</classname> API to load your GUI at runtime.
</para>

<para>
There are basically five
different styles, as shown in this picture:
</para>

<figure xml:id="figure-box-packing1">
  <title>Box Packing 1</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;box_packing1.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para>
Each line contains one horizontal <classname>Box</classname> with
several buttons. Each of the buttons on a line is packed into the
<classname>Box</classname> with the same arguments to the
<methodname>set_hexpand()</methodname>, <methodname>set_halign()</methodname>,
<methodname>set_margin_start()</methodname> and <methodname>set_margin_end()</methodname>
methods.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Box.html">Reference</link></para>

</section>

<section xml:id="per-container-packing-options">
<title>Per-container packing options</title>
<para>
Here's the constructor for the <classname>Box</classname> widget,
and methods that set per-container packing options:</para>
<programlisting><code>Gtk::Box(Gtk::Orientation orientation = Gtk::Orientation::HORIZONTAL, int spacing = 0);
void set_orientation(Gtk::Orientation orientation);
void set_spacing(int spacing);
void set_homogeneous(bool homogeneous = true);</code></programlisting>
<para>Passing <literal>true</literal> to <methodname>set_homogeneous()</methodname> will
cause all of the contained widgets to be the same size.
<parameter>spacing</parameter> is a (minimum) number of pixels to leave between
each widget.
</para>

<para>
What's the difference between spacing (set when the box is created)
and margins (set separately for each child widget)? Spacing is added between
objects, and margins are added on one or more sides of a widget. The following
figure should make it clearer. The shown margins are the left and right margins
of each button in the row.
</para>

<figure xml:id="figure-box-packing2">
  <title>Box Packing 2</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;box_packing2.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

</section>
</section>

<section xml:id="boxes-command-line-options">
<title>Gtk::Application and command-line options</title>

<para>The following example program requires a command-line option.
The source code shows two ways of handling command-line options in combination
with <classname>Gtk::Application</classname>.
</para>

<itemizedlist>
<listitem><para>
Handle the options in <function>main()</function> and hide them from
<classname>Gtk::Application</classname> by setting <literal>argc = 1</literal>
in the call to <methodname>Gtk::Application::run()</methodname>.
</para></listitem>

<listitem><para>
Give all command-line options to <methodname>Gtk::Application::run()</methodname>
and add the flag <literal>Gio::Application::Flags::HANDLES_COMMAND_LINE</literal>
to <methodname>Gtk::Application::create()</methodname>.
Connect a signal handler to the <literal>command_line</literal> signal, and
handle the command-line options in the signal handler.</para>

<para>You must set the optional parameter <literal>after = false</literal> in
the call to <literal>signal_command_line().connect()</literal>, because your signal
handler must be called before the default signal handler. You must also call
<methodname>Gio::Application::activate()</methodname> in the signal handler,
unless you want your application to exit without showing its main window.
(<classname>Gio::Application</classname> is a base class of
<classname>Gtk::Application</classname>.)
</para></listitem>
</itemizedlist>
</section>

<section xml:id="box-packing-example">
<title>Example</title>

<para>
Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use.</para>

<para><link xlink:href="&url_examples_base;box">Source Code</link></para>
</section>

</section>

<section xml:id="sec-grid">
<title>Grid</title>

<para>
A <classname>Grid</classname> dynamically lays out child widgets in rows and
columns. The dimensions of the grid do not need to be specified in the constructor.
</para>

<para>
Child widgets can span multiple rows or columns, using
<methodname>attach()</methodname>, or added next to an existing widget inside
the grid with <methodname>attach_next_to()</methodname>. Individual rows and columns of the grid can be set to have uniform height or width with
<methodname>set_row_homogeneous()</methodname> and
<methodname>set_column_homogeneous()</methodname>.
</para>
<para>You can set the <emphasis>margin</emphasis> and <emphasis>expand</emphasis> properties of the
child <classname>Widget</classname>s to control their spacing and their behavior when the Grid is resized.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Grid.html">Reference</link></para>

<section xml:id="grid-example">
<title>Example</title>
<para>
This example creates a window with three buttons in a grid.
The first two buttons are in the upper row, from left to right. A
third button is attached underneath the first button, in a new lower row,
spanning two columns.
</para>

<figure xml:id="figure-grid">
  <title>Grid</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;grid.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;grid">Source Code</link></para>

</section>
</section>

<section xml:id="sec-notebook">
<title>Notebook</title>

<para>
A <classname>Notebook</classname> has a set of stacked
<literal>pages</literal>, each of which contains widgets. Labelled
<literal>tabs</literal> allow the user to select the pages.
<classname>Notebook</classname>s allow several sets of widgets to be placed in a
small space, by only showing one page at a time. For instance, they are often
used in preferences dialogs.
</para>

<para>
Use the <methodname>append_page()</methodname>, <methodname>prepend_page()</methodname>
and <methodname>insert_page()</methodname> methods to add tabbed pages to the
<literal>Notebook</literal>, supplying the child widget and the name for the
tab.
</para>

<para>
To discover the currently visible page, use the
<methodname>get_current_page()</methodname> method. This returns the page number,
and then calling <methodname>get_nth_page()</methodname> with that number will give
you a pointer to the actual child widget.
</para>

<para>
To programmatically change the selected page, use the
<methodname>set_current_page()</methodname> method.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Notebook.html">Reference</link></para>

<section xml:id="notebook-example">
<title>Example</title>

<figure xml:id="figure-notebook">
  <title>Notebook</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;notebook.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;notebook/">Source Code</link></para>

</section>

</section>

<section xml:id="sec-assistant">
<title>Assistant</title>

<note><para><classname>Gtk::Assistant</classname> is deprecated since &gtkmm; 4.10.
There is no replacement in &gtkmm;. libadwaita (a C library) has replacement parts
(like AdwCarousel). In some cases, a <classname>Gtk::Notebook</classname> might
be an acceptable replacement.
</para></note>

<para>
An <classname>Assistant</classname> splits a complex operation into steps. Each step is a page, containing a header, a child widget and an action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with <methodname>set_page_type()</methodname>.
</para>

<para>
Use the <methodname>append_page()</methodname>, <methodname>prepend_page</methodname> and <methodname>insert_page()</methodname> methods to add pages to the <classname>Assistant</classname>, supplying the child widget for each page.
</para>

<para>
To determine the currently-visible page, use the <methodname>get_current_page()</methodname> method, and pass the result to <methodname>get_nth_page()</methodname>, which returns a pointer to the actual widget. To programmatically change the current page, use the <methodname>set_current_page()</methodname> method.
</para>

<para>
To set the title of a page, use the <methodname>set_page_title()</methodname> method.
</para>

<para>
To add widgets to the action area, use the <methodname>add_action_widget()</methodname> method. They will be packed alongside the default buttons. Use the <methodname>remove_action_widget()</methodname> method to remove widgets.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Assistant.html">Reference</link></para>

<section xml:id="assistant-example">
<title>Example</title>

<figure xml:id="figure-assistant">
  <title>Assistant</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;assistant.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;assistant/">Source Code</link></para>

</section>

</section>

<section xml:id="sec-other-multi-item-containers">
<title>Other Multi-item Containers</title>

<para>
There are other multi-item containers. See the reference documentation for a
complete list. Here are links to some example programs that show containers,
which are not mentioned elsewhere in this tutorial.
</para>

<para><link xlink:href="&url_examples_base;actionbar">Source Code, ActionBar</link></para>
<para><link xlink:href="&url_examples_base;listbox_flowbox/flowbox">Source Code, FlowBox</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-listmodel">
<title>ListView, GridView, ColumnView</title>

<para>
Lists are intended to be used whenever developers want to display many objects
in roughly the same way. They are perfectly fine to be used for very short lists
of only 2 or 3 items, but generally scale fine to thousands of items.
</para>

<para>
Lists are meant to be used with changing data, both with the items themselves
changing as well as the list adding and removing items. Of course, they work just
as well with static data.
</para>

<para>
The <link xlink:href="https://docs.gtk.org/gtk4/section-list-widget.html">List Widget Overview</link>
chapter in the GTK documentation contains more information about list widgets.
</para>

<para>
Some examples are shown in this chapter. There are more examples in the
<link xlink:href="&url_examples_base;listmodelviews/">listmodelviews directory</link>
in <application>gtkmm-documentation</application>'s examples.</para>

<section xml:id="sec-listmodel-datamodel">
<title>The Data Model</title>

<para>
The data model is a class that implements the <classname>Gio::ListModel</classname>
interface. Examples of such classes are <classname>Gio::ListStore</classname>
(not to be confused with the deprecated <classname>Gtk::ListStore</classname>),
<classname>Gtk:StringList</classname>, <classname>Gtk:DirectoryList</classname>
and <classname>Pango::FontMap</classname>.
</para>

<para>
The elements in a model are called <emphasis>items</emphasis>.
All items are instances of a subclass of <classname>Glib::Object</classname>.
For instance, you might have a <classname>ColumnView</classname> with one integer
and one text column, like so:
</para>
<programlisting><code><![CDATA[class ModelColumns : public Glib::Object
{
public:
  int m_col_id;
  Glib::ustring m_col_name;

  static Glib::RefPtr<ModelColumns> create(
    int col_id, const Glib::ustring& col_name)
  {
    return Glib::make_refptr_for_instance<ModelColumns>(
      new ModelColumns(col_id, col_name));
  }

protected:
  ModelColumns(int col_id, const Glib::ustring& col_name)
  : m_col_id(col_id), m_col_name(col_name)
  {}
};

Glib::RefPtr<Gio::ListStore<ModelColumns>> m_ListStore;
]]></code></programlisting>

<para>
Every item in a model has a position which is the unsigned integer that describes
where in the model the item is located. The first item in a model is at position 0.
The position of an item can of course change as other items are added to or removed
from the model.
</para>
<para><link xlink:href="&url_refdocs_base_gio;ListStore.html">Gio::ListStore Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;StringList.html">StringList Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;DirectoryList.html">DirectoryList Reference</link></para>
</section>

<section xml:id="sec-listmodel-selectionmodel">
<title>The Selection Model</title>

<para>
The selection model is a class that implements the <classname>Gtk::SelectionModel</classname>
interface. You can choose between <classname>NoSelection</classname>,
<classname>SingleSelection</classname> and <classname>MultiSelection</classname>.
</para>
<para><link xlink:href="&url_refdocs_base_gtk;NoSelection.html">NoSelection Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;SingleSelection.html">SingleSelection Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;MultiSelection.html">MultiSelection Reference</link></para>
</section>

<section xml:id="sec-listmodel-factory">
<title>The Factory</title>

<para>
Data from the data model is added to the view by a factory, which is a subclass of
<classname>ListItemFactory</classname>. There is only one such subclass in &gtkmm;,
<classname>SignalListItemFactory</classname>. Data from the model is added to the
view with signal handlers connected to a <classname>SignalListItemFactory</classname>.
</para>
<para><link xlink:href="&url_refdocs_base_gtk;SignalListItemFactory.html">SignalListItemFactory Reference</link></para>
</section>

<section xml:id="sec-listmodel-view">
<title>The View</title>

<para>
The View is the widget that displays the model data and allows the user to interact
with it. The View can show all of the model's columns, or just some, and it can show
them in various ways.
</para>

<para>
An important requirement for views (especially views of long lists) is that they need
to know which items are not visible so they can be recycled. Views achieve that by
implementing the <classname>Scrollable</classname> interface and expecting
to be placed directly into a <classname>ScrolledWindow</classname>.
</para>

<para>
There are different view widgets to choose from.
</para>

<section xml:id="sec-listmodel-listview">
<title>ListView</title>

<para>
The <classname>ListView</classname> shows a 1-dimensional list with one column.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ListView.html">Reference</link></para>

<section xml:id="listmodel-listview-example">
<title>Example</title>

<figure xml:id="figure-listmodel-listview">
  <title>ListView</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;listmodel_listview.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;listmodelviews/list_listview">Source Code</link></para>

</section>
</section>

<section xml:id="sec-listmodel-gridview">
<title>GridView</title>

<para>
The <classname>GridView</classname> shows a 2-dimensional grid.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;GridView.html">Reference</link></para>

<section xml:id="listmodel-gridview-example">
<title>Example</title>

<figure xml:id="figure-listmodel-gridview">
  <title>GridView</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;listmodel_gridview.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;listmodelviews/gridview">Source Code</link></para>

</section>
</section>

<section xml:id="sec-listmodel-columnview">
<title>ColumnView</title>

<para>
The <classname>ColumnView</classname> shows a 1-dimensional list with one or more columns.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ColumnView.html">Reference</link></para>

<section xml:id="listmodel-columnview-example">
<title>Example</title>

<figure xml:id="figure-listmodel-columnview">
  <title>ColumnView</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;listmodel_columnview.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;listmodelviews/list_columnview">Source Code</link></para>

</section>
</section>
</section>

<section xml:id="sec-listmodel-sorting">
<title>Sorting</title>

<para>
The list can be sorted by wrapping it in a <classname>SortListModel</classname>.
There are two ways to do this.
</para>
<itemizedlist>
  <listitem><para>In a <classname>ColumnView</classname>, get the
  <classname>ColumnViewSorter</classname> from the <classname>ColumnView</classname>
  and set it to the <classname>SortListModel</classname>. Set a <classname>Sorter</classname>
  to each <classname>ColumnViewColumn</classname>. Then the user of your app can
  sort the items by clicking on a column heading.</para></listitem>
  <listitem><para>In any view, set a <classname>Sorter</classname> such as a
  <classname>StringSorter</classname> or a <classname>NumericSorter</classname>
  to the <classname>SortListModel</classname>.</para></listitem>
</itemizedlist>

<para><link xlink:href="&url_refdocs_base_gtk;SortListModel.html">SortListModel Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;StringSorter.html">StringSorter Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;NumericSorter.html">NumericSorter Reference</link></para>

<section xml:id="listmodel-sorting-example">
<title>Example</title>

<figure xml:id="figure-listmodel-sorting">
  <title>SortListModel</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;listmodel_sort.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;listmodelviews/sort">Source Code</link></para>

</section>
</section>

<section xml:id="sec-listmodel-filtering">
<title>Filtering</title>

<para>
The list can be filtered by wrapping it in a <classname>FilterListModel</classname>.
Set a <classname>Filter</classname> such as a <classname>StringFilter</classname>
or a <classname>BoolFilter</classname> to the <classname>FilterListModel</classname>.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;FilterListModel.html">FilterListModel Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;StringFilter.html">StringFilter Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;BoolFilter.html">BoolFilter Reference</link></para>

<section xml:id="listmodel-filtering-example">
<title>Example</title>

<figure xml:id="figure-listmodel-filtering">
  <title>FilterListModel</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;listmodel_filter.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;listmodelviews/filter">Source Code</link></para>

</section>
</section>

<section xml:id="sec-listmodel-trees">
<title>Displaying Trees</title>

<para>
While the deprecated <classname>TreeView</classname> provided built-in support for trees,
the list widgets, and in particular <classname>Gio::ListModel</classname>, do not.
However, &gtkmm; provides functionality to make trees look and behave like lists for
the people who still want to display lists. This is achieved by using the
<classname>TreeListModel</classname> to flatten a tree into a list.
The <classname>TreeExpander</classname> widget can then be used inside a listitem
to allow users to expand and collapse rows.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TreeListModel.html">TreeListModel Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;TreeExpander.html">TreeExpander Reference</link></para>

<section xml:id="listmodel-tree-example">
<title>Example</title>

<figure xml:id="figure-listmodel-tree">
  <title>TreeListModel</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;listmodel_tree.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;listmodelviews/tree_columnview">Source Code</link></para>

</section>
</section>

</chapter>

<chapter xml:id="chapter-treeview">
<title>The TreeView widget</title>

<note><para><classname>Gtk::TreeView</classname> is deprecated since &gtkmm; 4.10.
In new code, use <classname>Gtk::ListView</classname> for lists and
<classname>Gtk::ColumnView</classname> for tabular lists.
</para></note>

<para>
The <classname>Gtk::TreeView</classname> widget can contain lists or trees of
data, in columns.
</para>

<section xml:id="sec-treeview-model">
<title>The Model</title>

<para>
Each <classname>Gtk::TreeView</classname> has an associated
<classname>Gtk::TreeModel</classname>, which contains the data displayed by the
<classname>TreeView</classname>. Each <classname>Gtk::TreeModel</classname> can
be used by more than one <classname>Gtk::TreeView</classname>. For instance,
this allows the same underlying data to be displayed and edited in 2 different
ways at the same time. Or the 2 Views might display different columns from the
same Model data, in the same way that 2 SQL queries (or "views") might
show different fields from the same database table.
</para>
<para>
Although you can theoretically implement your own Model, you will normally use
either the <classname>ListStore</classname> or <classname>TreeStore</classname>
model classes.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TreeModel.html">Reference</link></para>

<section xml:id="treeview-model-liststore">
<title>ListStore, for rows</title>

<para>
The <classname>ListStore</classname> contains simple rows of data, and each row
has no children.
</para>

<figure xml:id="figure-treeview-liststore-model">
  <title>TreeView - ListStore</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_list.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_refdocs_base_gtk;ListStore.html">Reference</link></para>

</section>

<section xml:id="treeview-model-treestore">
<title>TreeStore, for a hierarchy</title>

<para>
The <classname>TreeStore</classname> contains rows of data, and each row may
have child rows.
</para>

<figure xml:id="figure-treeview-treestore-model">
  <title>TreeView - TreeStore</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_tree.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_refdocs_base_gtk;TreeStore.html">Reference</link></para>

</section>

<section xml:id="treeview-model-columns">
<title>Model Columns</title>

<para>
The <classname>TreeModelColumnRecord</classname> class is used to keep track
of the columns and their data types. You add
<classname>TreeModelColumn</classname> instances to the
<classname>ColumnRecord</classname> and then use those
<classname>TreeModelColumn</classname>s when getting and setting the data in
model rows. You will probably find it convenient to derive a new
<classname>TreeModelColumnRecord</classname> which has your
<classname>TreeModelColumn</classname> instances as member data.
</para>

<programlisting><code>class ModelColumns : public Gtk::TreeModelColumnRecord
{
public:

  ModelColumns()
    { add(m_col_text); add(m_col_number); }

  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;
  Gtk::TreeModelColumn&lt;int&gt; m_col_number;
};

ModelColumns m_Columns;</code></programlisting>

<para>
You specify the <classname>ColumnRecord</classname> when creating the Model,
like so:
</para>
<programlisting><code>Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =
    Gtk::ListStore::create(m_Columns);</code></programlisting>
<para>
As a <classname>TreeModelColumnRecord</classname> describes structure, not data,
it can be shared among multiple models, and this is preferable for efficiency.
However, the instance (such as <varname>m_Columns</varname> here) should usually
not be static, because it often needs to be instantiated after
<application>glibmm</application> has been initialized. The best solution is
to make it a lazily instantiated singleton, so that it will be constructed
on-demand, whenever the first model accesses it.
</para>
</section>

<section xml:id="treeview-adding-rows">
<title>Adding Rows</title>

<para>
Add rows to the model with the <methodname>append()</methodname>,
<methodname>prepend()</methodname>, or <methodname>insert()</methodname> methods.
</para>
<programlisting><code>auto iter = m_refListStore-&gt;append();</code></programlisting>
<para>You can dereference the iterator to get the Row:
</para>
<programlisting><code>auto row = *iter;</code></programlisting>
<section xml:id="treeview-adding-child-rows">
<title>Adding child rows</title>
<para>
<classname>Gtk::TreeStore</classname> models can have child items. Add them
with the <methodname>append()</methodname>, <methodname>prepend()</methodname>, or
<methodname>insert()</methodname> methods, like so:
</para>
<programlisting><code>auto iter_child =
    m_refTreeStore-&gt;append(row.children());</code></programlisting>
</section>

</section>

<section xml:id="treeview-setting-values">
<title>Setting values</title>

<para>
You can use the <methodname>operator[]</methodname> overload to set the data for a
particular column in the row, specifying the
<classname>TreeModelColumn</classname> used to create the model.
</para>
<programlisting><code>row[m_Columns.m_col_text] = "sometext";</code></programlisting>
</section>

<section xml:id="treeview-getting-values">
<title>Getting values</title>

<para>
You can use the <methodname>operator[]</methodname> overload to get the data in a
particular column in a row, specifying the
<classname>TreeModelColumn</classname> used to create the model.
</para>
<programlisting><code>auto strText = row[m_Columns.m_col_text];
auto number = row[m_Columns.m_col_number];</code></programlisting>
<para>
The compiler will complain if you use an inappropriate type. For
instance, this would generate a compiler error:
</para>
<programlisting><code>//compiler error - no conversion from ustring to int.
int number = row[m_Columns.m_col_text];</code></programlisting>
</section>

<section xml:id="treeview-hidden-columns">
<title>"Hidden" Columns</title>

<para>
You might want to associate extra data with each row. If so, just add
it as a Model column, but don't add it to the View.
</para>
</section>

</section>

<section xml:id="sec-treeview">
<title>The View</title>

<para>
The View is the actual widget (<classname>Gtk::TreeView</classname>) that
displays the model (<classname>Gtk::TreeModel</classname>) data and allows the
user to interact with it. The View can show all of the model's columns, or just
some, and it can show them in various ways.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TreeView.html">Reference</link></para>

<section xml:id="sec-treeview-using-a-model">
<title>Using a Model</title>

<para>
You can specify a <classname>Gtk::TreeModel</classname> when constructing the
<classname>Gtk::TreeView</classname>, or you can use the
<methodname>set_model()</methodname> method, like so:
</para>
<programlisting><code>m_TreeView.set_model(m_refListStore);</code></programlisting>
</section>

<section xml:id="treeview-adding-view-columns">
<title>Adding View Columns</title>

<para>
You can use the <methodname>append_column()</methodname> method to  tell the View
that it should display certain Model columns, in a certain order, with a
certain column title.
</para>
<programlisting><code>m_TreeView.append_column("Messages", m_Columns.m_col_text);</code></programlisting>
<para>
When using this simple <methodname>append_column()</methodname> overload, the
<classname>TreeView</classname> will display the model data with an appropriate
<classname>CellRenderer</classname>. For instance, strings and numbers are
shown in a simple <classname>Gtk::Entry</classname> widget, and booleans are
shown in a <classname>Gtk::CheckButton</classname>. This is usually what you
need. For other column types you must either connect a callback that converts
your type into a string representation, with
<methodname>TreeViewColumn::set_cell_data_func()</methodname>, or derive a custom
<classname>CellRenderer</classname>. Note that (unsigned) short is not
supported by default - You could use (unsigned) int or (unsigned) long as the
column type instead.
</para>
</section>

<section xml:id="treeview-multiple-model-columns-per-view-column">
<title>More than one Model Column per View Column</title>

<para>
To render more than one model column in a view column, you need to create the
<classname>TreeView::Column</classname> widget manually, and use
<methodname>pack_start()</methodname> to add the model columns to it.
</para>

<para>
Then use <methodname>append_column()</methodname> to add the view Column to the
View. Notice that <methodname>Gtk::TreeView::append_column()</methodname> is overloaded
to accept either a prebuilt <classname>Gtk::TreeView::Column</classname> widget, or
just the <classname>TreeModelColumn</classname> from which it generates an
appropriate <classname>Gtk::TreeView::Column</classname> widget.
</para>
<para>
Here is some example code, which has a pixbuf icon and a text name in the same column:
</para>
<programlisting><code>auto pColumn = Gtk::make_managed&lt;Gtk::TreeView::Column&gt;("Icon Name");

// m_columns.icon and m_columns.iconname are columns in the model.
// pColumn is the column in the TreeView:
pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);
pColumn-&gt;pack_start(m_columns.iconname);

m_TreeView.append_column(*pColumn);</code></programlisting>
</section>

<section xml:id="treeview-cellrenderer-details">
<title>Specifying CellRenderer details</title>

<para>
The default <classname>CellRenderer</classname>s and their default behavior
will normally suffice, but you might occasionally need finer control. For
instance, this example code from
<filename>gtkmm/demos/gtk-demo/example_treeview_treestore.cc</filename>, appends a
<classname>Gtk::CellRenderer</classname> widget and instructs it to render the
data from various model columns through various aspects of its appearance.
</para>
<programlisting><code>auto cols_count = m_TreeView.append_column_editable("Alex", m_columns.alex);
auto pColumn = m_TreeView.get_column(cols_count-1);
if(pColumn)
{
  auto pRenderer = static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());
  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);
  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);</code></programlisting>

<para>
    You can also connect to <classname>CellRenderer</classname> signals to detect user
actions. For instance:
</para>
<programlisting><code>auto pRenderer = Gtk::make_managed&lt;Gtk::CellRendererToggle&gt;();
pRenderer-&gt;signal_toggled().connect(
    sigc::bind( sigc::mem_fun(*this,
        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)
);</code></programlisting>
</section>

<section xml:id="treeview-editable-cells">
<title>Editable Cells</title>

<section xml:id="treeview-editable-cells-automatic">
<title>Automatically-stored editable cells.</title>

<para>
Cells in a <classname>TreeView</classname> can be edited in-place by the user.
To allow this, use the <classname>Gtk::TreeView</classname>
<methodname>insert_column_editable()</methodname> and
<methodname>append_column_editable()</methodname> methods instead of
<methodname>insert_column()</methodname> and <methodname>append_column()</methodname>.
When these cells are edited the new values will be stored immediately in the
Model. Note that these methods are templates which can only be instantiated for
simple column types such as <classname>Glib::ustring</classname>, int, and
long.
</para>
</section>

<section xml:id="treeview-editable-cells-custom">
<title>Implementing custom logic for editable cells.</title>

<para>
However, you might not want the new values to be stored
immediately. For instance, maybe you want to restrict the input to
certain characters or ranges of values.
</para>
<para>
To achieve this, you should use the normal <classname>Gtk::TreeView</classname>
<methodname>insert_column()</methodname> and <methodname>append_column()</methodname>
methods, then use <methodname>get_column_cell_renderer()</methodname> to get the
<classname>Gtk::CellRenderer</classname> used by that column.
</para>
<para>
You should then cast that <classname>Gtk::CellRenderer*</classname> to the
specific <classname>CellRenderer</classname> that you expect, so you can use specific API.
</para>
<para>For instance, for a CellRendererText, you would set the cell's <emphasis>editable</emphasis> property to true, like
so:
</para>
<programlisting><code>cell-&gt;property_editable() = true;</code></programlisting>
<para>
For a CellRendererToggle, you would set the <emphasis>activatable</emphasis>
property instead.
</para>
<para>You can then connect
to the appropriate "edited" signal. For instance, connect to
<methodname>Gtk::CellRendererText::signal_edited()</methodname>, or
<methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. If the column
contains more than one <classname>CellRenderer</classname> then you will need
to use <methodname>Gtk::TreeView::get_column()</methodname> and then call
<methodname>get_cells()</methodname> on that view Column.
</para>
<para>
In your signal handler, you should examine the new value and then
store it in the Model if that is appropriate for your application.
</para>
</section>
</section>
</section>

<section xml:id="sec-iterating-over-model-rows">
<title>Iterating over Model Rows</title>

<para>
<classname>Gtk::TreeModel</classname> provides a &cpp; Standard Library-style container of its
children, via the <methodname>children()</methodname> method. You can use the
familiar <methodname>begin()</methodname> and <methodname>end()</methodname> methods
iterator incrementing, like so:
</para>
<programlisting><code>auto children = refModel-&gt;children();
for (auto iter = children.begin(), end = children.end(); iter != end; ++iter)
{
  auto row = *iter;
  //Do something with the row - see above for set/get.
}</code></programlisting>
<para>
If you always want to iterate across the entire range, much more succinct syntax
is possible using &cpp;'s range-based <literal>for</literal> loop:
</para>
<programlisting><code>for (auto row: refModel-&gt;children())
{
  //Do something with the row - see above for set/get.
}</code></programlisting>

<section xml:id="treeview-row-children">
<title>Row children</title>

<para>
When using a <classname>Gtk::TreeStore</classname>, the rows can have child
rows, which can have their own children in turn. Use
<methodname>Gtk::TreeModel::Row::children()</methodname> to get the container of child <classname>Row</classname>s:
</para>
<programlisting><code>Gtk::TreeModel::Children children = row.children();</code></programlisting>
</section>

</section>

<section xml:id="sec-treeview-selection">
<title>The Selection</title>

<para>
To find out what rows the user has selected, get the
<classname>Gtk::TreeView::Selection</classname> object from the
<classname>TreeView</classname>, like so:
</para>
<programlisting><code>auto refTreeSelection = m_TreeView.get_selection();</code></programlisting>

<section xml:id="treeview-selection-mode">
<title>Single or multiple selection</title>

<para>
By default, only single rows can be selected, but you can allow
multiple selection by setting the mode, like so:
</para>
<programlisting><code>refTreeSelection-&gt;set_mode(Gtk::SelectionMode::MULTIPLE);</code></programlisting>
</section>

<section xml:id="treeview-selected-rows">
<title>The selected rows</title>

<para>
For single-selection, you can just call <methodname>get_selected()</methodname>,
like so:
</para>
<programlisting><code>auto iter = refTreeSelection-&gt;get_selected();
if(iter) //If anything is selected
{
  auto row = *iter;
  //Do something with the row.
}</code></programlisting>

<para>
For multiple-selection, you need to call <methodname>get_selected_rows()</methodname>
or define a callback, and give it to
<methodname>selected_foreach()</methodname>,
<methodname>selected_foreach_path()</methodname>, or
<methodname>selected_foreach_iter()</methodname>, like so:
</para>
<programlisting><code>refTreeSelection-&gt;selected_foreach_iter(
    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );

void TheClass::selected_row_callback(
    const Gtk::TreeModel::const_iterator&amp; iter)
{
  auto row = *iter;
  //Do something with the row.
}</code></programlisting>

</section>

<section xml:id="treeview-selection-changed-signal">
<title>The "changed" signal</title>

<para>
To respond to the user clicking on a row or range of rows, connect to the
signal like so:
</para>
<programlisting><code>refTreeSelection-&gt;signal_changed().connect(
    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)
);</code></programlisting>
</section>

<section xml:id="treeview-selection-preventing">
<title>Preventing row selection</title>

<para>
Maybe the user should not be able to select every item in your list or tree.
For instance, in the gtk-demo, you can select a demo to see the source code,
but it doesn't make any sense to select a demo category.
</para>
<para>
To control which rows can be selected, use the
<methodname>set_select_function()</methodname> method, providing a
<classname>sigc::slot</classname> callback. For instance:
</para>
<programlisting><code>m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,
    &amp;DemoWindow::select_function) );</code></programlisting>
<para>
and then
</para>
<programlisting><code>bool DemoWindow::select_function(
    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,
    const Gtk::TreeModel::Path&amp; path, bool)
{
  const auto iter = model-&gt;get_iter(path);
  return iter-&gt;children().empty(); // only allow leaf nodes to be selected
}</code></programlisting>
</section>

<section xml:id="treeview-selection-changing">
<title>Changing the selection</title>

<para>
To change the selection, specify a
<classname>Gtk::TreeModel::iterator</classname> or
<classname>Gtk::TreeModel::Row</classname>, like so:
</para>
<programlisting><code>auto row = m_refModel-&gt;children()[5]; //The sixth row.
if(row)
  refTreeSelection-&gt;select(row.get_iter());</code></programlisting>
<para>
or
</para>
<programlisting><code>auto iter = m_refModel-&gt;children().begin()
if(iter)
  refTreeSelection-&gt;select(iter);</code></programlisting>
</section>
</section>

<section xml:id="sec-treeview-sort">
<title>Sorting</title>

<para>
The standard tree models (<classname>TreeStore</classname> and <classname>ListStore</classname>) derive from <classname>TreeSortable</classname>, so they offer sorting functionality. For instance, call <methodname>set_sort_column()</methodname>, to sort the model by the specified column. Or supply a callback function to <methodname>set_sort_func()</methodname> to implement a more complicated sorting algorithm.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TreeSortable.html">TreeSortable Reference</link></para>

<section xml:id="treeview-sort-headers">
<title>Sorting by clicking on columns</title>

<para>
So that a user can click on a <classname>TreeView</classname>'s column header to sort the <classname>TreeView</classname>'s contents, call <methodname>Gtk::TreeView::Column::set_sort_column()</methodname>, supplying the model column on which model should be sorted when the header is clicked. For instance:
</para>
<programlisting><code>auto pColumn = treeview.get_column(0);
if(pColumn)
  pColumn-&gt;set_sort_column(m_columns.m_col_id);</code></programlisting>
</section>

<section xml:id="treeview-sort-independent-views">
<title>Independently sorted views of the same model</title>

<para>
The <classname>TreeView</classname> already allows you to show the same <classname>TreeModel</classname>
in two <classname>TreeView</classname> widgets. If you need one of these TreeViews to sort the model
differently than the other then you should use a <classname>TreeModelSort</classname> instead of just,
for instance, <methodname>Gtk::TreeViewColumn::set_sort_column()</methodname>.
<classname>TreeModelSort</classname> is a model that contains another model, presenting a sorted version
of that model. For instance, you might add a sorted version of a model to a <classname>TreeView</classname> like so:
</para>
<programlisting><code>auto sorted_model = Gtk::TreeModelSort::create(model);
sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SortType::ASCENDING);
treeview.set_model(sorted_model);</code></programlisting>

<para>Note, however, that the TreeView will provide iterators to the sorted model. You must convert them to iterators to the underlying child model in order to perform actions on that model. For instance:
</para>
<programlisting><code>void ExampleWindow::on_button_delete()
{
  auto refTreeSelection = m_treeview.get_selection();
  if(refTreeSelection)
  {
    auto sorted_iter = m_refTreeSelection-&gt;get_selected();
    if(sorted_iter)
    {
      auto iter = m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);
      m_refModel-&gt;erase(iter);
    }
  }
}</code></programlisting>

<para><link xlink:href="&url_refdocs_base_gtk;TreeModelSort.html">TreeModelSort Reference</link></para>
</section>

</section>

<section xml:id="sec-treeview-draganddrop">
<title>Drag and Drop</title>

<para>
<classname>Gtk::TreeView</classname> already implements simple drag-and-drop
when used with the <classname>Gtk::ListStore</classname> or
<classname>Gtk::TreeStore</classname> models (since gtk 4.8). If necessary, it also allows you
to implement more complex behavior when items are dragged and dropped, using
the normal <link linkend="chapter-draganddrop">Drag and Drop</link> API.
</para>

<section xml:id="treeview-reorderable-rows">
<title>Reorderable rows</title>

<para>
If you call <methodname>Gtk::TreeView::set_reorderable()</methodname> then your
TreeView's items can be moved within the treeview itself. This is demonstrated
in the <classname>TreeStore</classname> example.
</para>
<para>However, this does not allow you any control of which items can be dragged, and where they can be dropped.
If you need that extra control then you might create a derived <literal>Gtk::TreeModel</literal> from
<literal>Gtk::TreeStore</literal> or <literal>Gtk::ListStore</literal> and override the
<literal>Gtk::TreeDragSource::row_draggable_vfunc()</literal> and
<literal>Gtk::TreeDragDest::row_drop_possible_vfunc()</literal> virtual methods.
You can examine the <literal>Gtk::TreeModel::Path</literal>s provided and allow or disallow dragging
or dropping by returning <literal>true</literal> or <literal>false</literal>.</para>
<para>This is demonstrated in the drag_and_drop example.</para>
</section>

</section>

<section xml:id="sec-treeview-contextmenu">
<title>Popup Context Menu</title>

<para>
Lots of people need to implement right-click context menus for
<classname>TreeView</classname>s so we will explain how to do that here to
save you some time. It's much the same as a normal context menu, as described
in the <link linkend="sec-menus-popup">menus chapter</link>. You use a
<classname>Gtk::GestureClick</classname> to detect the mouse click.
</para>
<para>This is demonstrated in the Popup Context Menu example. In that example
a derived <classname>TreeView</classname> is used, but that's not necessary.
</para>

</section>

<section xml:id="sec-treeview-examples">
<title>Examples</title>

<para>Some <classname>TreeView</classname> examples are shown here. There are
more examples in the <link xlink:href="&url_examples_base;treeview/">treeview directory</link>
in <application>gtkmm-documentation</application>'s examples.</para>

<para>If neither <classname>ListStore</classname> nor <classname>TreeStore</classname>
is suitable for your application, look at the
<link xlink:href="&url_examples_base;treeview/custom_treemodel">custom TreeModel</link>
example. It shows how you can make your own implementation of the <classname>TreeModel</classname>
interface.</para>

<section xml:id="liststore-example">
<title>ListStore</title>
<para>
This example has a <classname>Gtk::TreeView</classname> widget, with a
<classname>Gtk::ListStore</classname> model.
</para>

<figure xml:id="figure-treeview-liststore">
  <title>TreeView - ListStore</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_list.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;treeview/list/">Source Code</link></para>

</section>

<section xml:id="treestore-example">
<title>TreeStore</title>

<para>
This example is very similar to the <classname>ListStore</classname> example,
but uses a <classname>Gtk::TreeStore</classname> model instead, and adds
children to the rows.
</para>

<figure xml:id="figure-treeview-treestore">
  <title>TreeView - TreeStore</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_tree.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;treeview/tree/">Source Code</link></para>

</section>

<section xml:id="sec-editable-cells-example">
<title>Editable Cells</title>

<para>
This example is identical to the <classname>ListStore</classname> example, but
it uses <methodname>TreeView::append_column_editable()</methodname> instead of
<methodname>TreeView::append_column()</methodname>.
</para>

<figure xml:id="figure-treeview-editablecells">
  <title>TreeView - Editable Cells</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_editablecells.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;treeview/editable_cells/">Source Code</link></para>

</section>

<section xml:id="treeview-dnd-example">
<title>Drag and Drop</title>

<para>
This example is much like the <classname>TreeStore</classname> example, but has
2 extra columns to indicate whether the row can be dragged, and whether it can
receive drag-and-dropped rows. It uses a derived
<classname>Gtk::TreeStore</classname> which overrides the virtual functions as
described in the <link linkend="sec-treeview-draganddrop">TreeView Drag and
    Drop</link> section.
</para>

<figure xml:id="figure-treeview-draganddrop">
  <title>TreeView - Drag And Drop</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_draganddrop.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;treeview/drag_and_drop/">Source Code</link></para>

</section>

<section xml:id="treeview-popup-menu-example">
<title>Popup Context Menu</title>

<para>
This example is much like the <classname>ListStore</classname> example, but
derives a custom <classname>TreeView</classname> to encapsulate the tree model
code and popup menu code in our derived class. See the
<link linkend="sec-treeview-contextmenu">TreeView Popup Context Menu</link> section.
</para>

<figure xml:id="figure-treeview-popup">
  <title>TreeView - Popup Context Menu</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;treeview_popup.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;treeview/popup/">Source Code</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-dropdown">
<title>The DropDown Widget</title>

<para>The <classname>DropDown</classname> widget is an alternative to the deprecated
<classname>ComboBox</classname>. It uses list models instead of tree models,
and the content is displayed using widgets instead of cell renderers.
</para>

<para>The <classname>DropDown</classname> widget offers a list of choices in a
dropdown menu. If appropriate, it can show extra information about each item,
such as text, a picture, or a check button. The <classname>DropDown</classname> widget
can optionally have an <classname>Entry</classname> in the dropdown menu, allowing
the user to search in a long list.
</para>

<para>The list is provided via a <classname>Gio::ListModel</classname>, and data
from this model is added to the <classname>DropDown</classname>'s view with
signal handlers connected to a <classname>SignalListItemFactory</classname>.
This provides flexibility, but the <classname>StringList</classname> class provides
a simpler text-based specialization in case that flexibility is not required.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;DropDown.html">Reference</link></para>

<section xml:id="sec-dropdown-model">
<title>The model</title>

<para>The model for a <classname>DropDown</classname> can be defined and filled
exactly as for a <classname>ListView</classname> or a <classname>ColumnView</classname>.
It must be a subclass of <classname>Glib::Object</classname>.
For instance, you might have a <classname>DropDown</classname> with one integer
and one text column, like so:
</para>
<programlisting><code><![CDATA[class ModelColumns : public Glib::Object
{
public:
  int m_col_id;
  Glib::ustring m_col_name;

  static Glib::RefPtr<ModelColumns> create(
    int col_id, const Glib::ustring& col_name)
  {
    return Glib::make_refptr_for_instance<ModelColumns>(
      new ModelColumns(col_id, col_name));
  }

protected:
  ModelColumns(int col_id, const Glib::ustring& col_name)
  : m_col_id(col_id), m_col_name(col_name)
  {}
};

Glib::RefPtr<Gio::ListStore<ModelColumns>> m_ListStore;
]]></code></programlisting>

<para>After appending rows to this model, you should provide the model to the
<classname>DropDown</classname> with the <methodname>set_model()</methodname> method.
Unless you use the <classname>StringList</classname> model, you also need to set
a <classname>ListItemFactory</classname> with <methodname>set_factory()</methodname>.
If you want the items in the dropdown menu to look different from the item
in the <classname>DropDown</classname> widget, you also need to set a separate
<classname>ListItemFactory</classname> with <methodname>set_list_factory()</methodname>.
</para>
</section>

<section xml:id="sec-dropdown-get">
<title>The selected item</title>

<para>To discover what item, if any, the user has selected from the <classname>DropDown</classname>,
call <methodname>DropDown::get_selected()</methodname>. This returns an
<type>unsigned int</type> that you can use to get the selected data from the model.
For instance, you might read an integer ID value from the model, even though you
have chosen only to show the human-readable description in the
<classname>DropDown</classname>. For instance:
</para>
<programlisting><code><![CDATA[unsigned int sel = m_DropDown.get_selected();
if (sel != GTK_INVALID_LIST_POSITION)
{
  // Get the data for the selected row, using our knowledge of the list model:
  auto id = m_ListStore->get_item(sel).m_col_id;
  set_some_id_chosen(id); // Your own function.
}
else
  set_nothing_chosen(); // Your own function.
]]></code></programlisting>
</section>

<section xml:id="sec-dropdown-changes">
<title>Responding to changes</title>

<para>You might need to react to every change of selection in the <classname>DropDown</classname>,
for instance to update other widgets. To do so, you should connect to
<methodname>property_selected().signal_changed()</methodname>. For instance:
</para>
<programlisting><code><![CDATA[m_DropDown.property_selected().signal_changed().connect(
  sigc::mem_fun(*this, &ExampleWindow::on_dropdown_changed));
]]></code></programlisting>
</section>

<section xml:id="sec-dropdown-simple">
<title>Simple String Example</title>

<figure xml:id="figure-dropdown-string">
  <title>Simple DropDown</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dropdown_string.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dropdown/string">Source Code</link></para>
</section>

<section xml:id="sec-dropdown-search">
<title>Examples with a Search Entry</title>

<para>The dropdown menu may contain an <classname>Entry</classname> that allows
to search for items in the list. Call <methodname>set_enable_search()</methodname>
and <methodname>set_expression()</methodname>. For instance:
</para>
<programlisting><code><![CDATA[m_DropDown.set_enable_search(true);
auto expression = Gtk::ClosureExpression<Glib::ustring>::create(
  sigc::mem_fun(*this, &ExampleWindow::get_col_name));
m_DropDown.set_expression(expression);

//-------
Glib::ustring ExampleWindow::get_col_name(const Glib::RefPtr<Glib::ObjectBase>& item)
{
  const auto col = std::dynamic_pointer_cast<ModelColumns>(item);
  return col ? col->m_col_name : "";
}
]]></code></programlisting>

<section xml:id="sec-dropdown-search-string">
<title>String Example</title>

<figure xml:id="figure-dropdown-search-string">
  <title>Search String</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dropdown_search_string.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dropdown/search_string">Source Code</link></para>
</section>

<section xml:id="sec-dropdown-search-font">
<title>Font Example</title>

<para>This example uses a <classname>Pango::FontMap</classname> as its model.
This is possible because <classname>Pango::FontMap</classname> implements
the <classname>Gio::ListModel</classname> interface. Of course you can use a
<classname>FontDialogButton</classname> instead.
</para>

<figure xml:id="figure-dropdown-search-font">
  <title>Search Font</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dropdown_search_font.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dropdown/search_font">Source Code</link></para>
</section>
</section>

<section xml:id="sec-dropdown-complex">
<title>Complex Example</title>

<para>This is a more complex example with two <classname>SignalListItemFactory</classname>
objects and their signal handlers. This example would be simpler without the
checkmark in the dropdown menu.
</para>

<figure xml:id="figure-dropdown-complex">
  <title>Search Font</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dropdown_complex.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dropdown/complex">Source Code</link></para>
</section>
</chapter>

<chapter xml:id="chapter-combobox">
<title>Combo Boxes</title>

<note><para><classname>Gtk::ComboBox</classname> and <classname>Gtk::ComboBoxText</classname>
are deprecated since &gtkmm; 4.10. Use <classname>Gtk::DropDown</classname> in new code.
</para></note>

<para>The <classname>ComboBox</classname> widget offers a list (or tree) of choices in a dropdown menu. If appropriate, it can show extra information about each item, such as text, a picture, a check button, or a progress bar. The <classname>ComboBox</classname> widget usually restricts the user to the available choices, but it can optionally have an <classname>Entry</classname>, allowing the user to enter arbitrary text if none of the available choices are suitable.
</para>

<para>The list is provided via a <classname>TreeModel</classname>, and columns from this model are added to the ComboBox's view with the <methodname>ComboBox::pack_start()</methodname> method. This provides flexibility and compile-time type-safety, but the <classname>ComboBoxText</classname> class provides a simpler text-based specialization in case that flexibility is not required.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ComboBox.html">Reference</link></para>

<section xml:id="sec-combobox-model">
<title>The model</title>

<para>The model for a ComboBox can be defined and filled exactly as for a <classname>TreeView</classname>. For instance, you might derive a ComboBox class with one integer and one text column, like so:
</para>
<programlisting><code>class ModelColumns : public Gtk::TreeModel::ColumnRecord
{
public:
  ModelColumns()
  { add(m_col_id); add(m_col_name); }

  Gtk::TreeModelColumn&lt;int&gt; m_col_id;
  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;
};

ModelColumns m_columns;</code></programlisting>

<para>After appending rows to this model, you should provide the model to the <classname>ComboBox</classname> with the <methodname>set_model()</methodname> method. Then use the <methodname>pack_start()</methodname> or <methodname>pack_end()</methodname> methods to specify what columns will be displayed in the ComboBox. As with the TreeView you may either use the default cell renderer by passing the <classname>TreeModelColumn</classname> to the pack methods, or you may instantiate a specific <classname>CellRenderer</classname> and specify a particular mapping with either <methodname>add_attribute()</methodname> or <methodname>set_cell_data_func()</methodname>. Note that these methods are in the <classname>CellLayout</classname> base class.</para>
</section>

<section xml:id="sec-combobox-get">
<title>The chosen item</title>

<para>To discover what item, if any, the user has chosen from the ComboBox, call <methodname>ComboBox::get_active()</methodname>. This returns a <classname>TreeModel::iterator</classname> that you can dereference to a <classname>Row</classname> in order to read the values in your columns. For instance, you might read an integer ID value from the model, even though you have chosen only to show the human-readable description in the ComboBox. For instance:
</para>
<programlisting><code>Gtk::TreeModel::iterator iter = m_Combo.get_active();
if(iter)
{
  auto row = *iter;

  //Get the data for the selected row, using our knowledge
  //of the tree model:
  auto id = row[m_Columns.m_col_id];
  set_something_id_chosen(id); //Your own function.
}
else
  set_nothing_chosen(); //Your own function.</code></programlisting>
</section>

<section xml:id="sec-combobox-changes">
<title>Responding to changes</title>

<para>
You might need to react to every change of selection in the ComboBox, for instance to update other widgets. To do so, you should handle the <literal>changed</literal> signal. For instance:
</para>
<programlisting><code>m_combo.signal_changed().connect( sigc::mem_fun(*this,
      &amp;ExampleWindow::on_combo_changed) );</code></programlisting>
</section>

<section xml:id="combobox-example-full">
<title>Full Example</title>

<figure xml:id="figure-combobox-complex">
  <title>ComboBox</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;combobox_complex.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;combobox/complex">Source Code</link></para>

</section>

<section xml:id="combobox-example-simple">
<title>Simple Text Example</title>

<figure xml:id="figure-combobox-text">
  <title>ComboBoxText</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;combobox_text.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;combobox/text">Source Code</link></para>

</section>

<section xml:id="sec-comboboxentry">
<title>ComboBox with an Entry</title>

<para>A <classname>ComboBox</classname> may contain an <classname>Entry</classname> widget for entering of arbitrary text, by specifying <literal>true</literal> for the constructor's <literal>has_entry</literal> parameter.</para>

<section xml:id="sec-comboboxentry-text-column">
<title>The text column</title>

<para>So that the <classname>Entry</classname> can interact with the drop-down list of choices, you must specify which of your model columns is the text column, with <methodname>set_entry_text_column()</methodname>. For instance:
</para>
<programlisting><code>m_combo.set_entry_text_column(m_columns.m_col_name);</code></programlisting>
<para>
When you select a choice from the drop-down menu, the value from this column will be placed in the <classname>Entry</classname>.
</para>
</section>

<section xml:id="sec-comboboxentry-model">
<title>The entry</title>

<para>Because the user may enter arbitrary text, an active model row isn't enough to tell us what text the user has entered. Therefore, you should retrieve the <classname>Entry</classname> widget with the <methodname>ComboBox::get_entry()</methodname> method and call <methodname>get_text()</methodname> on that.
</para>
</section>

<section xml:id="sec-comboboxentry-changes">
<title>Responding to changes</title>

<para>
When the user enters arbitrary text, it may not be enough to connect to the
<literal>changed</literal> signal, which is emitted for every typed character.
It is not emitted when the user presses the <keycap>Enter</keycap> key.
Pressing the <keycap>Enter</keycap> key or moving the keyboard focus to another
widget may signal that the user has finished entering text. To be notified of
these events, connect to the <classname>Entry</classname>'s <literal>activate</literal>
signal (available since &gtkmm; 4.8), and add a <classname>Gtk::EventControllerFocus</classname>
and connect to its <literal>leave</literal> signal, like so
</para>
<programlisting><code><![CDATA[auto entry = m_Combo.get_entry();
if (entry)
{
  // Alternatively you can connect to m_Combo.signal_changed().
  entry->signal_changed().connect(sigc::mem_fun(*this,
    &ExampleWindow::on_entry_changed));
  entry->signal_activate().connect(sigc::mem_fun(*this,
    &ExampleWindow::on_entry_activate));
  // The Entry shall receive focus-leave events.
  auto controller = Gtk::EventControllerFocus::create();
  m_ConnectionFocusLeave = controller->signal_leave().connect(
    sigc::mem_fun(*this, &ExampleWindow::on_entry_focus_leave));
  entry->add_controller(controller);
}]]></code></programlisting>
<para>
The <literal>changed</literal> signals of <classname>ComboBox</classname> and
<classname>Entry</classname> are both emitted for every change. It doesn't matter
which one you connect to. But the <classname>EventControllerFocus</classname>
must be added to the <classname>Entry</classname>.
</para>
</section>

<section xml:id="comboboxentry-example-full">
<title>Full Example</title>

<figure xml:id="figure-comboboxentry-complex">
  <title>ComboBox with Entry</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;comboboxentry_complex.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;combobox/entry_complex">Source Code</link></para>

</section>

<section xml:id="comboboxentry-example-simple">
<title>Simple Text Example</title>

<figure xml:id="figure-comboboxentry-text">
  <title>ComboBoxText with Entry</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;comboboxentry_text.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;combobox/entry_text">Source Code</link></para>

</section>
</section>

</chapter>

<chapter xml:id="chapter-textview">
<title>TextView</title>

<para>
The <classname>TextView</classname> widget can be used to display and edit
large amounts of formatted text. Like the <classname>TreeView</classname>, it
has a model/view design. In this case the <classname>TextBuffer</classname> is
the model.
</para>

<section xml:id="sec-textview-buffer">
<title>The Buffer</title>

<para>
<classname>Gtk::TextBuffer</classname> is a model containing the data for the
<classname>Gtk::TextView</classname>, like the
<classname>Gtk::TreeModel</classname> used by <classname>Gtk::TreeView</classname>.
This allows two or more <classname>Gtk::TextView</classname>s to share the same
<classname>TextBuffer</classname>, and allows those TextBuffers to be displayed
slightly differently. Or you could maintain several
<classname>Gtk::TextBuffer</classname>s and choose to display each one at different
times in the same <classname>Gtk::TextView</classname> widget.
</para>
<para>
The <classname>TextView</classname> creates its own default
<classname>TextBuffer</classname>, which you can access via the
<methodname>get_buffer()</methodname> method.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TextBuffer.html">Reference</link></para>

<section xml:id="textview-iterators">
<title>Iterators</title>

<para>
A <classname>Gtk::TextBuffer::iterator</classname> and a <classname>Gtk::TextBuffer::const_iterator</classname>
represent a position between two characters in the text buffer. Whenever the buffer
is modified in a way that affects the number of characters in the buffer, all outstanding
iterators become invalid. Because of this, iterators can't be used to preserve positions
across buffer modifications. To preserve a position, use <classname>Gtk::TextBuffer::Mark</classname>.
</para>
<para><link xlink:href="&url_refdocs_base_gtk;TextIter.html">Reference</link></para>
</section>

<section xml:id="textview-formatting">
<title>Tags and Formatting</title>

<section xml:id="textview-formatting-tags">
<title>Tags</title>

<para>
To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text. For instance, to define the tag and its properties:
</para>
<programlisting><code>auto refTagMatch = Gtk::TextBuffer::Tag::create();
refTagMatch-&gt;property_background() = "orange";</code></programlisting>
<para>
You can specify a name for the <classname>Tag</classname> when using the
<methodname>create()</methodname> method, but it is not necessary.
</para>

<para>
The <classname>Tag</classname> class has many other properties.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TextTag.html">Reference</link></para>

</section>

<section xml:id="textview-formatting-tagtable">
<title>TagTable</title>

<para>
Each <classname>Gtk::TextBuffer</classname> uses a
<classname>Gtk::TextBuffer::TagTable</classname>, which contains the
<classname>Tag</classname>s for that buffer. 2 or more
<classname>TextBuffer</classname>s may share the same
<classname>TagTable</classname>. When you create <classname>Tag</classname>s
you should add them to the <classname>TagTable</classname>. For instance:
</para>
<programlisting><code>auto refTagTable = Gtk::TextBuffer::TagTable::create();
refTagTable-&gt;add(refTagMatch);
//Hopefully a future version of gtkmm will have a set_tag_table() method,
//for use after creation of the buffer.
auto refBuffer = Gtk::TextBuffer::create(refTagTable);</code></programlisting>

<para>
You can also use <methodname>get_tag_table()</methodname> to get, and maybe modify,
the <classname>TextBuffer</classname>'s default <classname>TagTable</classname>
instead of creating one explicitly.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TextTagTable.html">Reference</link></para>

</section>

<section xml:id="textview-formatting-applying-tags">
<title>Applying Tags</title>

<para>
If you have created a <classname>Tag</classname> and added it to the
<classname>TagTable</classname>, you may apply that tag to part of the
<classname>TextBuffer</classname> so that some of the text is displayed with that
formatting. You define the start and end of the range of text by specifying
<classname>Gtk::TextBuffer::iterator</classname>s. For instance:
</para>
<programlisting><code>refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);</code></programlisting>
<para>
Or you could specify the tag when first inserting the text:
</para>
<programlisting><code>refBuffer-&gt;insert_with_tag(iter, "Some text", refTagMatch);</code></programlisting>

<para>
You can apply more than one <classname>Tag</classname> to the same text, by
using <methodname>apply_tag()</methodname> more than once, or by using
<methodname>insert_with_tags()</methodname>. The <classname>Tag</classname>s might
specify different values for the same properties, but you can resolve these
conflicts by using <methodname>Tag::set_priority()</methodname>.
</para>

</section>
</section>

<section xml:id="textview-marks">
<title>Marks</title>

<para>
<classname>TextBuffer</classname> iterators are generally invalidated when the
text changes, but you can use a <classname>Gtk::TextBuffer::Mark</classname> to
remember a position in these situations. For instance,
</para>
<programlisting><code>auto refMark = refBuffer-&gt;create_mark(iter);</code></programlisting>

<para>
You can then use the <methodname>get_iter()</methodname> method later to create an
iterator for the <classname>Mark</classname>'s new position.
</para>

<para>
There are two built-in <classname>Mark</classname>s - <literal>insert</literal>
and <literal>selection_bound</literal>, which you can access with
<classname>TextBuffer</classname>'s <methodname>get_insert()</methodname> and
<methodname>get_selection_bound()</methodname> methods.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TextMark.html">Reference</link></para>

</section>

<section xml:id="textview-view">
<title>The View</title>

<para>
As mentioned above, each <classname>TextView</classname> has a
<classname>TextBuffer</classname>, and one or more
<classname>TextView</classname>s can share the same
<classname>TextBuffer</classname>.
</para>

<para>
Like the <classname>TreeView</classname>, you should probably put your
<classname>TextView</classname> inside a <classname>ScrolledWindow</classname>
to allow the user to see and move around the whole text area with
scrollbars.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;TextView.html">Reference</link></para>

<section xml:id="textview-default-formatting">
<title>Default formatting</title>

<para>
<classname>TextView</classname> has various methods which allow you to change
the presentation of the buffer for this particular view. Some of these may be
overridden by the <classname>Gtk::TextTag</classname>s in the buffer, if they
specify the same things. For instance, <methodname>set_left_margin()</methodname>,
<methodname>set_right_margin()</methodname>, <methodname>set_indent()</methodname>,
etc.
</para>
</section>

<section xml:id="textview-scrolling">
<title>Scrolling</title>

<para>
<classname>Gtk::TextView</classname> has various
<methodname>scroll_to()</methodname> methods. These allow you to ensure that a
particular part of the text buffer is visible. For instance, your application's
Find feature might use <methodname>Gtk::TextView::scroll_to()</methodname> to
show the found text.
</para>
</section>

</section>


</section>

<section xml:id="sec-widgets-and-childanchors">
<title>Widgets and ChildAnchors</title>

<para>
You can embed widgets, such as <classname>Gtk::Button</classname>s, in the
text. Each such child widget needs a <classname>ChildAnchor</classname>.
ChildAnchors are associated with <classname>iterator</classname>s. For
instance, to create a child anchor at a particular position, use
<methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:
</para>
<programlisting><code>auto refAnchor = refBuffer-&gt;create_child_anchor(iter);</code></programlisting>

<para>
Then, to add a widget at that position, use
<methodname>Gtk::TextView::add_child_at_anchor()</methodname>:
</para>
<programlisting><code>m_TextView.add_child_at_anchor(m_Button, refAnchor);</code></programlisting>

<para><link xlink:href="&url_refdocs_base_gtk;TextChildAnchor.html">Reference</link></para>

</section>

<section xml:id="sec-textview-examples">
<title>Examples</title>

<section xml:id="textview-example-simple">
<title>Simple Example</title>

<figure xml:id="figure-textview">
  <title>TextView</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;textview.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;textview/">Source Code</link></para>

</section>
<section xml:id="textview-example-other">
<title>Other Examples</title>

<para>The example in the <link linkend="sec-i18n-example">
Internationalization and Localization</link> chapter uses <classname>TextView</classname>.
</para>

<para>There is a more complicated example among
<link xlink:href="&url_gtkmm_base;demos/gtk-demo/example_textview.cc">&gtkmm;'s demo programs</link>.
</para>
</section>
</section>
</chapter>

<chapter xml:id="chapter-menus-and-toolbars">
<title>Menus and Toolbars</title>

<para>
There are specific APIs for menus and toolbars, but you should usually deal
with them together, creating <classname>Gio::SimpleAction</classname>s that
you can refer to in both menus and toolbars. In this way you can handle
activation of the action instead of responding to the menu and toolbar items
separately. And you can enable or disable both the menu and toolbar item via
the action. <classname>Gtk::Builder</classname> can create menus and toolbars.
</para>
<para>
This involves the use of the <classname>Gio::SimpleActionGroup</classname>,
<classname>Gio::SimpleAction</classname> and <classname>Gtk::Builder</classname>
classes, all of which should be instantiated via their <methodname>create()</methodname>
methods, which return <classname>RefPtr</classname>s.
</para>

<section xml:id="sec-actions">
<title>Actions</title>

<para>
First create the <classname>Gio::SimpleAction</classname>s and add them to a
<classname>Gio::SimpleActionGroup</classname>, with
<methodname>Gio::ActionMap::add_action()</methodname>.
(<classname>Gio::ActionMap</classname> is a base class of
<classname>Gio::SimpleActionGroup</classname>.) Then add the action group to
your window with <methodname>Gtk::Widget::insert_action_group()</methodname>.
</para>
<para>
The arguments to <methodname>add_action()</methodname> specify the action's
name, which is used in the menu items and toolbar buttons. You can also specify
a signal handler when calling <methodname>add_action()</methodname>. This signal
handler will be called when the action is activated via either a menu item or
a toolbar button.
</para>

<para>For instance:
</para>
<programlisting><code>m_refActionGroup = Gio::SimpleActionGroup::create();

m_refActionGroup-&gt;add_action("new", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new));
m_refActionGroup-&gt;add_action("open", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open));
m_refActionGroup-&gt;add_action("quit", sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit));

insert_action_group("example", m_refActionGroup);
</code></programlisting>

<para>
If you use an <classname>Gtk::ApplicationWindow</classname>, you don't have to
create your own action group. <classname>Gio::ActionGroup</classname> and
<classname>Gio::ActionMap</classname> are base classes of
<classname>Gtk::ApplicationWindow</classname>.
</para>

</section>


<section xml:id="sec-menubar-and-toolbar">
<title>Menubar and Toolbar</title>

<para>
Next you should create a <classname>Gtk::Builder</classname>. At this point is
also a good idea to tell the application to respond to keyboard shortcuts,
by using <methodname>Gtk::Application::set_accel_for_action()</methodname>.
</para>

<para>For instance,
</para>
<programlisting><code>m_refBuilder = Gtk::Builder::create();

app-&gt;set_accel_for_action("example.new", "&lt;Primary&gt;n");
app-&gt;set_accel_for_action("example.quit", "&lt;Primary&gt;q");
app-&gt;set_accel_for_action("example.copy", "&lt;Primary&gt;c");
app-&gt;set_accel_for_action("example.paste", "&lt;Primary&gt;v");
</code></programlisting>

<!-- Not true in gtkmm4 (July 2022). Will it become true in the future?
<para>
If your main window is derived from <classname>ApplicationWindow</classname> and
you instantiate your menubar with <methodname>Gtk::Application::set_menubar()</methodname>,
then you don't have to call <methodname>set_accel_for_action()</methodname>.
See <link linkend="menu-example-main">Application Menu and Main Menu example</link>
for an example.
</para>
-->

<para>
Then, you can define the actual visible layout of the menus and toolbars, and
add the UI layout to the <classname>Builder</classname>. This "ui
string" uses an XML format, in which you should mention the names of the
actions that you have already created. For instance:
</para>
<programlisting><code>Glib::ustring ui_info =
  "&lt;interface&gt;"
  "  &lt;menu id='menubar'&gt;"
  "    &lt;submenu&gt;"
  "      &lt;attribute name='label' translatable='yes'&gt;_File&lt;/attribute&gt;"
  "      &lt;section&gt;"
  "        &lt;item&gt;"
  "          &lt;attribute name='label' translatable='yes'&gt;_New&lt;/attribute&gt;"
  "          &lt;attribute name='action'&gt;example.new&lt;/attribute&gt;"
  "        &lt;/item&gt;"
  "      &lt;/section&gt;"
  "      &lt;section&gt;"
  "        &lt;item&gt;"
  "          &lt;attribute name='label' translatable='yes'&gt;_Quit&lt;/attribute&gt;"
  "          &lt;attribute name='action'&gt;example.quit&lt;/attribute&gt;"
  "        &lt;/item&gt;"
  "      &lt;/section&gt;"
  "    &lt;/submenu&gt;"
  "    &lt;submenu&gt;"
  "      &lt;attribute name='label' translatable='yes'&gt;_Edit&lt;/attribute&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;_Copy&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;example.copy&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;_Paste&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;example.paste&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "    &lt;/submenu&gt;"
  "  &lt;/menu&gt;"
  "&lt;/interface&gt;";

m_refBuilder-&gt;add_from_string(ui_info);
m_refBuilder-&gt;add_from_resource("/toolbar/toolbar.ui");
</code></programlisting>

<para>This is where we specify the names of the menu items as they will be seen
by users in the menu. Therefore, this is where you should make strings
translatable, by adding <literal>translatable='yes'</literal>.
</para>
<para>
To instantiate a <classname>Gtk::PopoverMenuBar</classname> and toolbar (a horizontal
<classname>Gtk::Box</classname>) which you can actually show, you should use
the <methodname>Builder::get_object()</methodname> and
<methodname>Builder::get_widget()</methodname> methods, and then add the widgets
to a container. For instance:
</para>
<programlisting><code>auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;("menubar");
auto pMenuBar = Gtk::make_managed&lt;Gtk::PopoverMenuBar&gt;(gmenu);
m_Box.append(*pMenuBar);

auto toolbar = m_refBuilder-&gt;get_widget&lt;Gtk::Box&gt;("toolbar");
m_Box.append(*toolbar);
</code></programlisting>

</section>


<section xml:id="sec-menus-popup">
<title>Popup Menus</title>
<para>
<classname>Menu</classname>s are normally just added to a window, but they can
also be displayed temporarily as the result of a mouse button click. For
instance, a context menu might be displayed when the user clicks their right
mouse button.
</para>

<para>For instance:
</para>
<programlisting><code>Glib::ustring ui_info =
  "&lt;interface&gt;"
  "  &lt;menu id='menu-examplepopup'&gt;"
  "    &lt;section&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;Edit&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;examplepopup.edit&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;Process&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;examplepopup.process&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "      &lt;item&gt;"
  "        &lt;attribute name='label' translatable='yes'&gt;Remove&lt;/attribute&gt;"
  "        &lt;attribute name='action'&gt;examplepopup.remove&lt;/attribute&gt;"
  "      &lt;/item&gt;"
  "    &lt;/section&gt;"
  "  &lt;/menu&gt;"
  "&lt;/interface&gt;";

m_refBuilder-&gt;add_from_string(ui_info);

auto gmenu = m_refBuilder-&gt;get_object&lt;Gio::Menu&gt;("menu-examplepopup");
m_MenuPopup.set_menu_model(gmenu);
</code></programlisting>

<para>
To show the popup menu, use  a <classname>Gtk::GestureClick</classname>
and connect to its <literal>pressed</literal> signal. In the signal handler,
use <classname>Gtk::PopoverMenu</classname>'s
<methodname>popup()</methodname> method. For instance:
</para>
<programlisting><code>void ExampleWindow::on_label_pressed(int /* n_press */, double x, double y)
{
  const Gdk::Rectangle rect(x, y, 1, 1);
  m_MenuPopup.set_pointing_to(rect);
  m_MenuPopup.popup();
}</code></programlisting>

</section>

<section xml:id="sec-gio-resource">
<title>Gio::Resource and glib-compile-resources</title>

<para>
Applications and libraries often contain binary or textual data that is
really part of the application, rather than user data. For instance
<classname>Gtk::Builder</classname> <filename class="extension">.ui</filename> files,
splashscreen images, <classname>Gio::Menu</classname> markup xml, CSS files,
icons, etc. These are often shipped as files in <filename class="directory">$datadir/appname</filename>,
or manually included as literal strings in the code.
</para>
<para>
The <classname>Gio::Resource</classname> API and the <application>glib-compile-resources</application>
program provide a convenient and efficient alternative to this, which has some nice properties. You
maintain the files as normal files, so it's easy to edit them, but during the build the files
are combined into a binary bundle that is linked into the executable. This means that loading
the resource files is efficient (as they are already in memory, shared with other instances) and
simple (no need to check for things like I/O errors or locate the files in the filesystem). It
also makes it easier to create relocatable applications.
</para>
<!-- TODO: Add a link to the description of glib-compile-resources, if it will
be described at https://docs.gtk.org/gio/glib-compile-resources.html or elsewhere.
-->
<para>
Resource bundles are created by the <application>glib-compile-resources</application>
program which takes an xml file that describes the bundle, and a set of files that the xml references.
These are combined into a binary resource bundle.
</para>
<para><link xlink:href="&url_refdocs_base_gio;Resource.html">Gio::Resource Reference</link></para>
<para>An example:</para>
<programlisting><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;gresources&gt;
  &lt;gresource prefix="/toolbar"&gt;
    &lt;file preprocess="xml-stripblanks"&gt;toolbar.ui&lt;/file&gt;
    &lt;file&gt;rain.png&lt;/file&gt;
  &lt;/gresource&gt;
&lt;/gresources&gt;
</code></programlisting>
<para>This will create a resource bundle with the files
<itemizedlist>
  <listitem><para><filename>/toolbar/toolbar.ui</filename></para></listitem>
  <listitem><para><filename>/toolbar/rain.png</filename></para></listitem>
</itemizedlist>
</para>
<para>
You can then use <application>glib-compile-resources</application> to compile the xml to a binary bundle
that you can load with <methodname>Gio::Resource::create_from_file()</methodname>.
However, it's more common to use the <parameter class="command">--generate-source</parameter>
argument to create a C source file to link directly into your application. E.g.
<screen>$ glib-compile-resources --target=resources.c --generate-source toolbar.gresource.xml</screen>
</para>
<para>
Once a <classname>Gio::Resource</classname> has been created and registered all the data
in it can be accessed globally in the process by using API calls like
<methodname>Gio::Resource::open_stream_from_global_resources()</methodname>
to stream the data or <methodname>Gio::Resource::lookup_data_in_global_resources()</methodname>
to get a direct pointer to the data. You can also use URIs like <uri>resource:///toolbar/rain.png</uri>
with <classname>Gio::File</classname> to access the resource data.
</para>
<para>
Often you don't need a <classname>Gio::Resource</classname> instance,
because resource data can be loaded with methods such as
<methodname>Gdk::Pixbuf::create_from_resource()</methodname>,
<methodname>Gtk::Builder::add_from_resource()</methodname> and
<methodname>Gtk::Image::set_from_resource()</methodname>.
</para>

</section>

<section xml:id="sec-menus-examples">
<title>Examples</title>

<section xml:id="menu-example-main">
<title>Application Menu and Main Menu example</title>
<para>
This program contains an application menu, a menubar and a toolbar.
Classes are derived from <classname>Gtk::Application</classname> and
<classname>Gtk::ApplicationWindow</classname>.
</para>

<figure xml:id="figure-menus-mainmenu">
  <title>App and Main Menu</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;main_menu.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;menus/main_menu/">Source Code</link></para>

</section>

<section xml:id="menu-example-main2">
<title>Main Menu example</title>
<para>
This program contains a menubar and a toolbar.
A class is derived from <classname>Gtk::Window</classname>.
</para>

<figure xml:id="figure-menus-mainmenu2">
  <title>Main Menu</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;menus_and_toolbars.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;menus_and_toolbars">Source Code</link></para> <!-- Insert toolbar.gresource.xml -->

</section>

<section xml:id="menu-example-popup">
<title>Popup Menu example</title>

<figure xml:id="figure-menus-popup">
  <title>Popup Menu</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;menu_popup.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;menus/popup/">Source Code</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-adjustment">
<title>Adjustments</title>

<para>
&gtkmm; has various widgets that can be visually adjusted using the mouse or
the keyboard, such as the <classname>Range</classname> widgets (described in
the <link linkend="chapter-range-widgets">Range Widgets</link> section). There are
also a few widgets that display some adjustable part of a larger area, such as
the <classname>Viewport</classname> widget. These widgets have
<classname>Gtk::Adjustment</classname> objects that express this common part of
their API.
</para>

<para>
So that applications can react to changes, for instance when a user moves a
scrollbar, <classname>Gtk::Adjustment</classname> has a
<literal>value_changed</literal> signal. You can then use the
<methodname>get_value()</methodname> method to discover the new value.
</para>

<section xml:id="sec-creating-adjustment">
<title>Creating an Adjustment</title>

<para>
The <classname>Gtk::Adjustment</classname> is created by its
<methodname>create()</methodname> method which is as follows:
</para>

<programlisting><code>Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(
  double value,
  double lower,
  double upper,
  double step_increment = 1,
  double page_increment = 10,
  double page_size = 0);</code></programlisting>

<para>
The <parameter>value</parameter> argument is the initial value of the
adjustment, usually corresponding to the topmost or leftmost position of an
adjustable widget. The <parameter>lower</parameter> and
<parameter>upper</parameter> arguments specify the possible range of values
which the adjustment can hold. The
<parameter>step_increment</parameter> argument specifies the smaller of
the two increments by which the user can change the value, while the
<parameter>page_increment</parameter> is the larger one. The
<parameter>page_size</parameter> argument usually corresponds somehow to
the visible area of a panning widget. The <parameter>upper</parameter> argument
is used to represent the bottommost or rightmost coordinate in a panning
widget's child.
<!-- TODO: Investigate the upper argument properly. There was some unclear stuff about it not always being the upper value. -->
</para>

</section>

<section xml:id="sec-adjustments-easy">
<title>Using Adjustments the Easy Way</title>

<para>
The adjustable widgets can be roughly divided into those which use and
require specific units for these values, and those which treat them as
arbitrary numbers.
</para>
<para>
The group which treats the values as arbitrary numbers includes the
<classname>Range</classname> widgets (<classname>Scrollbar</classname> and
<classname>Scale</classname>), the <classname>ScaleButton</classname> widget,
and the <classname>SpinButton</classname> widget. These widgets  are typically
"adjusted" directly by the user with the mouse or keyboard. They will treat the
<parameter>lower</parameter> and <parameter>upper</parameter> values of an
adjustment as a range within which the user can manipulate the adjustment's
<parameter>value</parameter>. By default, they will only modify the
<parameter>value</parameter> of an adjustment.
</para>

<para>
The other group includes the <classname>Viewport</classname> widget and the
<classname>ScrolledWindow</classname> widget. All of these widgets use pixel
values for their adjustments. These are also typically adjusted indirectly
using scrollbars. While all widgets which use adjustments can either create
their own adjustments or use ones you supply, you'll generally want to let this
particular category of widgets create its own adjustments.
</para>

<para>
If you share an adjustment object between a Scrollbar and a TextView
widget, manipulating the scrollbar will automagically adjust the TextView
widget. You can set it up like this:
</para>
<programlisting><code>// creates its own adjustments
Gtk::TextView textview;
// uses the newly-created adjustment for the scrollbar as well
Gtk::Scrollbar vscrollbar(textview.get_vadjustment(), Gtk::Orientation::VERTICAL);</code></programlisting>

</section>

<section xml:id="sec-adjustment-internals">
<title>Adjustment Internals</title>

<para>
OK, you say, that's nice, but what if I want to create my own handlers to
respond when the user adjusts a <classname>Range</classname> widget or a
<classname>SpinButton</classname>. To access the value of a
<classname>Gtk::Adjustment</classname>, you can use the
<methodname>get_value()</methodname> and <methodname>set_value()</methodname> methods:
</para>

<para>
As mentioned earlier, <classname>Gtk::Adjustment</classname> can emit signals.
This is, of course, how updates happen automatically when you share an
<classname>Adjustment</classname> object between a
<classname>Scrollbar</classname> and another adjustable widget; all adjustable
widgets connect signal handlers to their adjustment's
<literal>value_changed</literal> signal, as can your program.
</para>

<para>
So, for example, if you have a <classname>Scale</classname> widget, and you
want to change the rotation of a picture whenever its value changes, you would
create a signal handler like this:
</para>
<programlisting><code>void cb_rotate_picture(MyPicture* picture)
{
  picture-&gt;set_rotation(adj-&gt;get_value());
...</code></programlisting>
<para>
and connect it to the scale widget's adjustment like this:
</para>
<programlisting><code>adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,
    &amp;cb_rotate_picture), picture));</code></programlisting>

<para>
What if a widget reconfigures the <parameter>upper</parameter> or
<parameter>lower</parameter> fields of its <classname>Adjustment</classname>,
such as when a user adds more text to a text widget?  In this case, it emits
the <literal>changed</literal> signal.
</para>

<para>
<classname>Range</classname> widgets typically connect a handler to this
signal, which changes their appearance to reflect the change - for example, the
size of the slider in a scrollbar will grow or shrink in inverse proportion to
the difference between the <parameter>lower</parameter> and
<parameter>upper</parameter> values of its
<classname>Adjustment</classname>.
</para>

<para>
You probably won't ever need to attach a handler to this signal, unless you're
writing a new type of range widget.
</para>
<programlisting><code>adjustment-&gt;signal_changed();</code></programlisting>

</section>

</chapter>

<chapter xml:id="chapter-dialogs">
<title>Dialogs</title>

<note><para><classname>Gtk::Dialog</classname> and the classes derived from it,
are deprecated since &gtkmm; 4.10. They can still be used in &gtkmm;4 applications,
provided GTKMM_DISABLE_DEPRECATED and GDKMM_DISABLE_DEPRECATED are not defined.
Some of the dialog classes are replaced by classes that are available since &gtkmm; 4.10.
</para>
<para>The examples in this chapter use classes that are available since &gtkmm; 4.10.
Similar examples with the deprecated classes are available in the
<link xlink:href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/tree/gtkmm-4-0/examples/book/dialogs/">
gtkmm-4-0 branch</link> in the git repository.
</para></note>

<para>
Dialogs are used as secondary windows, to provide specific information or to
ask questions. <classname>Gtk::Dialog</classname> windows contain a few pre-packed
widgets to ensure consistency, and a <literal>response</literal> signal which
is emitted when the user dismisses the dialog.
</para>

<para>
There are several derived <classname>Dialog</classname> classes which you might
find useful. <classname>Gtk::MessageDialog</classname> is used for most simple
notifications. But at other times you might need to derive your own dialog
class to provide more complex functionality.
</para>

<para>
To pack widgets into a custom dialog, you should pack them into the
<classname>Gtk::Box</classname>, available via
<methodname>get_content_area()</methodname>. To just add a <classname>Button</classname>
to the bottom of the <classname>Dialog</classname>, you could use the
<methodname>add_button()</methodname> method.
</para>

<para>
The <literal>response</literal> signal handler receives an <literal>int</literal>. This
may be a value from the <type>Gtk::ResponseType</type> if the user
closed the dialog by clicking a standard button, or it could be the custom
response value that you specified when using <methodname>add_button()</methodname>.
</para>

<para>
To show the dialog, call <methodname>set_visible(true)</methodname>. If the same dialog instance
will be shown several times, you must also call <methodname>set_hide_on_close()</methodname>,
or else the dialog will be destroyed when it's closed.
Connect to the <literal>response</literal> signal, if you want to know which button
was pressed. The <literal>response</literal> signal handler is also where you
should hide the dialog.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Dialog.html">Reference</link></para>

<section xml:id="sec-dialogs-alertdialog">
<title>AlertDialog and MessageDialog</title>
<para>
<classname>MessageDialog</classname> (deprecated since &gtkmm; 4.10) and
<classname>AlertDialog</classname> (available since &gtkmm; 4.10) are convenience
classes, used to create simple, standard message dialogs, with a message and buttons
for user response.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;AlertDialog.html">AlertDialog Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;MessageDialog.html">MessageDialog Reference</link></para>

<section xml:id="alertdialog-example">
<title>Example</title>

<figure xml:id="figure-dialogs-alertdialog">
  <title>AlertDialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dialogs_alertdialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dialogs/alertdialog">Source Code</link></para>
</section>
</section>

<section xml:id="sec-dialogs-filedialog">
<title>FileDialog and FileChooserDialog</title>
<para>
The <classname>FileChooserDialog</classname> (deprecated since &gtkmm; 4.10) and
<classname>FileDialog</classname> (available since &gtkmm; 4.10) are suitable
for use with "Open" or "Save" menu items.
</para>
<para>
Most of the useful member methods for <classname>FileChooserDialog</classname>
are actually in the <classname>Gtk::FileChooser</classname> base class.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;FileDialog.html">FileDialog Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;FileChooserDialog.html">FileChooserDialog Reference</link></para>

<section xml:id="filedialog-example">
<title>Example</title>

<figure xml:id="figure-dialogs-filedialog">
  <title>FileDialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dialogs_filedialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dialogs/filedialog">Source Code</link></para>
</section>
</section>

<section xml:id="sec-dialogs-colordialog">
<title>ColorDialog and ColorChooserDialog</title>
<para>
The <classname>ColorChooserDialog</classname> (deprecated since &gtkmm; 4.10) and
<classname>ColorDialog</classname> (available since &gtkmm; 4.10) allow the user
to choose a color. The <classname>ColorButton</classname> (deprecated since &gtkmm; 4.10)
and <classname>ColorDialogButton</classname> (available since &gtkmm; 4.10) open
a color selection dialog when it is clicked.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;ColorDialog.html">ColorDialog Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;ColorChooserDialog.html">ColorChooserDialog Reference</link></para>

<section xml:id="colordialog-example">
<title>Example</title>

<figure xml:id="figure-dialogs-colordialog">
  <title>ColorDialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dialogs_colordialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dialogs/colordialog">Source Code</link></para>
</section>
</section>

<section xml:id="sec-dialogs-fontdialog">
<title>FontDialog and FontChooserDialog</title>
<para>
The <classname>FontChooserDialog</classname> (deprecated since &gtkmm; 4.10) and
<classname>FontDialog</classname> (available since &gtkmm; 4.10) allow the user
to choose a font. The <classname>FontButton</classname> (deprecated since &gtkmm; 4.10)
and <classname>FontDialogButton</classname> (available since &gtkmm; 4.10) open
a font chooser dialog when it is clicked.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;FontDialog.html">FontDialog Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;FontChooserDialog.html">FontChooserDialog Reference</link></para>

<section xml:id="fontdialog-example">
<title>Example</title>

<figure xml:id="figure-dialogs-fontdialog">
  <title>FontDialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dialogs_fontdialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dialogs/fontdialog">Source Code</link></para>
</section>
</section>

<section xml:id="sec-about-dialog">
<title>Non-modal AboutDialog</title>
<para>
The <classname>AboutDialog</classname> offers a simple way to display information
about a program, like its logo, name, copyright, website and license.
</para>
<para>
Most dialogs in this chapter are modal, that is, they freeze the rest of
the application while they are shown. It's also possible to create a non-modal
dialog, which does not freeze other windows in the application.
The following example shows a non-modal <classname>AboutDialog</classname>. This is
perhaps not the kind of dialog you would normally make non-modal, but non-modal
dialogs can be useful in other cases. E.g. <application>gedit</application>'s
search-and-replace dialog is non-modal.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;AboutDialog.html">Reference</link></para>

<section xml:id="aboutdialog-example">
<title>Example</title>

<figure xml:id="figure-dialogs-about">
  <title>AboutDialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dialogs_about.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dialogs/aboutdialog">Source Code</link></para> <!-- Insert aboutdialog.gresource.xml -->
</section>
</section>

<section xml:id="sec-dialogs-windowdialog">
<title>Custom Dialog</title>
<para>
When none of the predefined dialog classes suit your needs, you can make your own
dialog by deriving a class from <classname>Window</classname> and fill it with
the widgets you need.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Window.html">Window Reference</link></para>

<section xml:id="windowdialog-example">
<title>Example</title>

<figure xml:id="figure-dialogs-windowdialog">
  <title>Window Dialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;dialogs_windowdialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;dialogs/windowdialog">Source Code</link></para>
</section>
</section>

</chapter>

<chapter xml:id="chapter-drawingarea">
<title>The DrawingArea Widget</title>
  <para>
    The <classname>DrawingArea</classname> widget is a blank window that gives
    you the freedom to create any graphic you desire. Along with that freedom
    comes the responsibility to draw on the widget. When a
    widget is first shown, or when it is covered and then uncovered again it
    needs to redraw itself. Most widgets have code to do this, but the
    <classname>DrawingArea</classname> does not, allowing you to write your own
    draw function to determine how the contents of the widget will be drawn.
    This is done by setting a draw function with a call to the
    <methodname>set_draw_func()</methodname> member function.
  </para>

  <para>
      GTK uses the <link xlink:href="http://cairographics.org">Cairo</link> drawing API.
      With &gtkmm;, you may use the <link xlink:href="http://www.cairographics.org/cairomm/">cairomm</link> &cpp; API for cairo.
  </para>

  <para>
      You can draw very sophisticated shapes using Cairo, but the methods to do
      so are quite basic. Cairo provides methods for drawing straight lines,
      curved lines, and arcs (including circles). These basic shapes can be
      combined to create more complex shapes and paths which can be filled with
      solid colors, gradients, patterns, and other things. In addition, Cairo
      can perform complex transformations, do compositing of images, and render
      antialiased text.
  </para>
  <note>
      <title>Cairo and Pango</title>
      <para>Although Cairo can render text, it's not meant to be a replacement for
      Pango. Pango is a better choice if you need to perform more advanced
      text rendering such as wrapping or ellipsizing text. Drawing text with
      Cairo should only be done if the text is part of a graphic.</para>
  </note>
  <para>
      In this section of the tutorial, we'll cover the basic Cairo drawing
      model, describe each of the basic drawing elements in some detail (with
      examples), and then present a simple application that uses Cairo to draw
      a custom clock widget.
  </para>

  <section xml:id="sec-cairo-drawing-model">
  <title>The Cairo Drawing Model</title>
    <para>
        The basic concept of drawing in Cairo involves defining 'invisible'
        paths and then stroking or filling them to make them visible.
    </para>
    <para>
        To do any drawing in &gtkmm; with Cairo, you must first get a
        <classname>Cairo::Context</classname> object. This class holds all of the graphics state parameters that
        describe how drawing is to be done. This includes information such as
        line width, color, the surface to draw to, and many other things. This
        allows the actual drawing functions to take fewer arguments to simplify
        the interface. Usually, you use the <classname>Cairo::Context</classname>
        that you get as input data to the draw function that you set with the call to
        <methodname>set_draw_func()</methodname>. It's also possible to create
        a <classname>Cairo::Context</classname> by calling the
        <methodname>Gdk::Surface::create_cairo_context()</methodname> and
        <methodname>Gdk::CairoContext::cairo_create()</methodname> functions.
        Since Cairo contexts are reference-counted objects, <methodname>cairo_create()</methodname>
        returns a <classname>Cairo::RefPtr&lt;Cairo::Context&gt;</classname> object.
        (Note the difference between <classname>Gdk::CairoContext</classname>
        and <classname>Cairo::Context</classname>.)
    </para>
    <para>
        The following example shows  how to set up a Cairo context with a
        foreground color of red and a width of 2. Any drawing functions that
        use this context will use these settings.
    </para>
    <programlisting><code>Gtk::DrawingArea myArea;
auto gdkCairoContext = myArea.get_surface()-&gt;create_cairo_context();
auto myContext = gdkCairoContext-&gt;cairo_create();
myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);
myContext-&gt;set_line_width(2.0);
    </code></programlisting>
    <para>
        Each <classname>Cairo::Context</classname> is associated with a
        particular <classname>Gdk::Surface</classname>, so the first line of the
        above example creates a <classname>Gtk::DrawingArea</classname> widget
        and the next two lines use its associated <classname>Gdk::Surface</classname>
        to create a <classname>Cairo::Context</classname> object. The final
        two lines change the graphics state of the context.
    </para>
    <para>
        There are a number of graphics state variables that can be set for a
        Cairo context. The most common context attributes are color (using
        <methodname>set_source_rgb()</methodname> or
        <methodname>set_source_rgba()</methodname> for translucent colors), line
        width (using <methodname>set_line_width()</methodname>), line dash pattern
        (using <methodname>set_dash()</methodname>), line cap style (using
        <methodname>set_line_cap()</methodname>), and line join style (using
        <methodname>set_line_join()</methodname>), and font styles (using
        <methodname>set_font_size()</methodname>,
        <methodname>set_font_face()</methodname> and others).
        There are many other settings as well, such as transformation matrices,
        fill rules, whether to perform antialiasing, and others. For further
        information, see the <link xlink:href="http://www.cairographics.org/cairomm/">cairomm</link> API documentation.
    </para>
    <para>
        The current state of a <classname>Cairo::Context</classname> can be
        saved to an internal stack of saved states and later be restored to the
        state it was in when you saved it. To do this, use the
        <methodname>save()</methodname>
        method and the <methodname>restore()</methodname> method. This can be
        useful if you need to temporarily change the line width and color (or
        any other graphics setting) in order to draw something and then return
        to the previous settings. In this situation, you could call
        <methodname>Cairo::Context::save()</methodname>, change the graphics
        settings, draw the lines, and then call
        <methodname>Cairo::Context::restore()</methodname> to restore the original
        graphics state. Multiple calls to <methodname>save()</methodname> and
        <methodname>restore()</methodname> can be nested; each call to
        <methodname>restore()</methodname> restores the state from the
        matching paired <methodname>save()</methodname>.
        <tip>
            <para>It is good practice to put all modifications to the graphics state
            between <methodname>save()</methodname>/<methodname>restore()</methodname>
            function calls. For example, if you have a function that takes a
            <classname>Cairo::Context</classname> reference as an argument, you
            might implement it as follows:
          </para>
          <programlisting><code>void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)
{
    context-&gt;save();
    // change graphics state
    // perform drawing operations
    context-&gt;restore();
}</code></programlisting>
        </tip>
    </para>
    <para>
        The draw function that you set with a call to <methodname>set_draw_func()</methodname>
        is called with a Cairo context that you shall use for drawing in the
        <classname>Gtk::DrawingArea</classname> widget. It is not necessary to
        save and restore this Cairo context in the draw function.
    </para>
  </section>
  <section xml:id="sec-cairo-drawing-lines">
  <title>Drawing Straight Lines</title>
    <para>
        Now that we understand the basics of the Cairo graphics library, we're
        almost ready to start drawing. We'll start with the simplest of
        drawing elements: the straight line. But first you need to know a
        little bit about Cairo's coordinate system. The origin of the Cairo
        coordinate system is located in the upper-left corner of the window
        with positive x values to the right and positive y values going down.
        <tip>
            <para>Since the Cairo graphics library was written with support for
            multiple output targets (the X window system, PNG images, OpenGL,
            etc), there is a distinction between user-space and device-space
            coordinates. The mapping between these two coordinate systems
            defaults to one-to-one so that integer values map roughly to pixels
            on the screen, but this setting can be adjusted if desired.
            Sometimes it may be useful to scale the coordinates so that the
            full width and height of a window both range from 0 to 1 (the 'unit
            square') or some other mapping that works for your application.
            This can be done with the
            <methodname>Cairo::Context::scale()</methodname> function.</para>
        </tip>
    </para>

    <section xml:id="cairo-example-lines">
    <title>Example</title>
    <para>
        In this example, we'll construct a small but fully functional &gtkmm;
        program and draw some lines into the window. The lines are drawn by
        creating a path and then stroking it. A path is created using the
        functions <methodname>Cairo::Context::move_to()</methodname> and
        <methodname>Cairo::Context::line_to()</methodname>. The function
        <methodname>move_to()</methodname> is similar to the act of lifting your
        pen off of the paper and placing it somewhere else -- no line is drawn
        between the point you were at and the point you moved to. To draw a
        line between two points, use the <methodname>line_to()</methodname>
        function.
    </para>
    <para>
        After you've finished creating your path, you still haven't
        drawn anything visible yet. To make the path visible, you must use the
        function <methodname>stroke()</methodname> which will stroke the current
        path with the line width and style specified in your
        <classname>Cairo::Context</classname> object. After stroking, the
        current path will be cleared so that you can start on your next path.
    </para>
        <tip>
            <para>Many Cairo drawing functions have a <methodname>_preserve()</methodname>
            variant. Normally drawing functions such as
            <methodname>clip()</methodname>, <methodname>fill()</methodname>, or
            <methodname>stroke()</methodname> will clear the current path. If you
            use the <methodname>_preserve()</methodname> variant, the current path
            will be retained so that you can use the same path with the next
            drawing function.</para>
        </tip>

    <figure xml:id="figure-drawingarea-lines">
      <title>Drawing Area - Lines</title>
      <screenshot>
        <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drawingarea_lines.png"/></imageobject></mediaobject>
      </screenshot>
    </figure>

    <para><link xlink:href="&url_examples_base;drawingarea/simple">Source Code</link></para>

    <para>
        This program contains a single class, <classname>MyArea</classname>,
        which is a subclass of <classname>Gtk::DrawingArea</classname> and
        contains an <methodname>on_draw()</methodname> member function.
        This function becomes the draw function by a call to <methodname>set_draw_func()</methodname>
        in <classname>MyArea</classname>'s constructor. <methodname>on_draw()</methodname>
        is then called whenever the image in the drawing area needs to
        be redrawn. It is passed a <classname>Cairo::RefPtr</classname>
        pointer to a <classname>Cairo::Context</classname> that we use
        for the drawing.
        The actual drawing code sets the color we want to use for drawing by
        using <methodname>set_source_rgb()</methodname> which takes arguments
        defining the Red, Green, and Blue components of the desired color
        (valid values are between 0 and 1). After setting the color, we
        created a new path using the functions <methodname>move_to()</methodname>
        and <methodname>line_to()</methodname>, and then stroked this path with
        <methodname>stroke()</methodname>.
    </para>
    <tip>
        <title>Drawing with relative coordinates</title>
        <para>In the example above we drew everything using absolute coordinates. You can also draw using
        relative coordinates. For a straight line, this is done with the
        function <methodname>Cairo::Context::rel_line_to()</methodname>.</para>
    </tip>
    </section>

    <section xml:id="cairo-line-styles">
    <title>Line styles</title>
        <para>
            In addition to drawing basic straight lines, there are a number of
            things that you can customize about a line. You've already seen
            examples of setting a line's color and width, but there are others
            as well.
        </para>
        <para>
            If you've drawn a series of lines that form a path, you may
            want them to join together in a certain way. Cairo offers
            three different ways to join lines together: Miter, Bevel, and
            Round. These are show below:
        </para>
        <figure xml:id="figure-cairo-joins">
          <title>Different join types in Cairo</title>
            <screenshot>
                <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;cairo_joins.png"/></imageobject></mediaobject>
            </screenshot>
        </figure>
        <para>
            The line join style is set using the function
            <methodname>Cairo::Context::set_line_join()</methodname>.
        </para>
        <para>
            Line ends can have different styles as well. The default style
            is for the line to start and stop exactly at the destination
            points of the line. This is called a Butt cap. The other
            options are Round (uses a round ending, with the center of the
            circle at the end point) or Square (uses a squared ending, with
            the center of the square at the end point). This setting is set
            using the function
            <methodname>Cairo::Context::set_line_cap()</methodname>.
        </para>
        <para>
            There are other things you can customize as well, including
            creating dashed lines and other things. For more information, see
            the Cairo API documentation. Dashed lines are shown in the example
            in the <link linkend="cairo-example-curves">Drawing Curved Lines</link>
            section.
        </para>
    </section>

    <section xml:id="sec-cairo-thin-lines">
    <title>Drawing thin lines</title>
      <para>
        If you try to draw one pixel wide lines, you may notice that the line
        sometimes comes up blurred and wider than it ought to be.
        This happens because Cairo will try to draw from the selected position,
        to both sides (half to each), so if you're positioned right on the
        intersection of the pixels, and want a one pixel wide line, Cairo will try
        to use half of each adjacent pixel, which isn't possible (a pixel is the
        smallest unit possible). This happens when the width of the line is an
        odd number of pixels (not just one pixel).
      </para>
      <para>
        The trick is to position in the middle of the pixel where you want the
        line to be drawn, and thus guaranteeing you get the desired results.
        See <link xlink:href="http://cairographics.org/FAQ/#sharp_lines">Cairo FAQ</link>.
      </para>

      <figure xml:id="figure-drawingarea-thin-lines">
        <title>Drawing Area - Thin Lines</title>
        <screenshot>
          <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drawingarea_thin_lines.png"/></imageobject></mediaobject>
        </screenshot>
      </figure>

      <para><link xlink:href="&url_examples_base;drawingarea/thin_lines">Source Code</link></para>
    </section>
  </section>

    <section xml:id="sec-cairo-curved-lines">
    <title>Drawing Curved Lines</title>
        <para>
            In addition to drawing straight lines Cairo allows you to easily
            draw curved lines (technically a cubic Bézier spline) using the
            <methodname>Cairo::Context::curve_to()</methodname> and
            <methodname>Cairo::Context::rel_curve_to()</methodname> functions.
            These functions take coordinates for a destination point as well as
            coordinates for two 'control' points. This is best explained using
            an example, so let's dive in.
        </para>

        <section xml:id="cairo-example-curves">
        <title>Example</title>
            <para>
                This simple application draws a curve with Cairo and displays
                the control points for each end of the curve.
            </para>
        <figure xml:id="figure-drawingarea-curve">
          <title>Drawing Area - Curve</title>
            <screenshot>
                <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drawingarea_curve.png"/></imageobject></mediaobject>
            </screenshot>
        </figure>

        <para><link xlink:href="&url_examples_base;drawingarea/curve">Source Code</link></para>
        <para>
            The only difference between this example and the straight line
            example is in the <methodname>on_draw()</methodname> function,
            but there are a few new concepts and functions introduced here, so
            let's examine them briefly.
        </para>
        <para>
            We make a call to
            <methodname>Cairo::Context::scale()</methodname>, passing in the width
            and height of the drawing area. This scales the user-space
            coordinate system such that the width and height of the widget
            are both equal to 1.0 'units'. There's no particular reason to
            scale the coordinate system in this case, but sometimes it can make
            drawing operations easier.
        </para>
        <para>
            The call to <methodname>Cairo::Context::curve_to()</methodname> should
            be fairly self-explanatory. The first pair of coordinates define
            the control point for the beginning of the curve. The second set
            of coordinates define the control point for the end of the curve,
            and the last set of coordinates define the destination point. To
            make the concept of control points a bit easier to visualize, a
            line has been drawn from each control point to the end-point on the
            curve that it is associated with. Note that these control point
            lines are both translucent. This is achieved with a variant of
            <methodname>set_source_rgb()</methodname> called
            <methodname>set_source_rgba()</methodname>. This function takes a
            fourth argument specifying the alpha value of the color (valid
            values are between 0 and 1).
        </para>
        <para>
            The control point lines are dashed lines. These are just two possible
            variations. Dashed lines can be more complicated. For instance the
            dashes can have different lengths like in dash-dotted lines.
        </para>
        </section>
  </section>

  <section xml:id="sec-cairo-drawing-arcs">
  <title>Drawing Arcs and Circles</title>
      <para>
          With Cairo, the same function is used to draw arcs, circles, or
          ellipses: <methodname>Cairo::Context::arc()</methodname>. This function
          takes five arguments. The first two are the coordinates of the
          center point of the arc, the third argument is the radius of the arc,
          and the final two arguments define the start and end angle of the
          arc. All angles are defined in radians, so drawing a circle is the
          same as drawing an arc from 0 to 2 * M_PI radians.
          An angle of 0 is in the direction of the positive X axis (in user-space). An
          angle of M_PI/2 radians (90 degrees) is in the direction of the positive Y axis
          (in user-space). Angles increase in the direction from the positive X axis
          toward the positive Y axis. So with the default transformation matrix, angles
          increase in a clockwise direction. (Remember that the positive Y axis
          points downwards.)
      </para>
      <para>
          To draw an ellipse, you can scale the current transformation matrix
          by different amounts in the X and Y directions. For example, to draw
          an ellipse with center at <varname>x</varname>, <varname>y</varname>
          and size <varname>width</varname>, <varname>height</varname>:
      </para>
      <programlisting><code>context-&gt;save();
context-&gt;translate(x, y);
context-&gt;scale(width / 2.0, height / 2.0);
context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);
context-&gt;restore();</code></programlisting>

      <section xml:id="cairo-example-arcs">
      <title>Example</title>
          <para>
              Here's an example of a simple program that draws an arc, a circle
              and an ellipse into a drawing area.
          </para>
          <figure xml:id="figure-drawingarea-arc">
            <title>Drawing Area - Arcs</title>
              <screenshot>
                  <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drawingarea_arcs.png"/></imageobject></mediaobject>
              </screenshot>
          </figure>

          <para><link xlink:href="&url_examples_base;drawingarea/arcs">Source Code</link></para>

          <para>
              There are a couple of things to note about this example code.
              Again, the only real difference between this example and the
              previous ones is the <methodname>on_draw()</methodname>
              function, so we'll limit our focus to that function. In
              addition, the first part of the function is nearly identical to
              the previous examples, so we'll skip that portion.
          </para>
          <para>
              Note that in this case, we've expressed nearly everything in
              terms of the height and width of the window, including the width
              of the lines. Because of this, when you resize the window,
              everything scales with the window. Also note that there are
              three drawing sections in the function and each is wrapped with a
              <methodname>save()</methodname>/<methodname>restore()</methodname> pair
              so that we're back at a known state after each drawing.
          </para>
          <para>
              The section for drawing an arc introduces one new function,
              <methodname>close_path()</methodname>. This function will in effect
              draw a straight line from the current point back to the first
              point in the path. There is a significant difference between
              calling <methodname>close_path()</methodname> and manually drawing a
              line back to the starting point, however. If you use
              <methodname>close_path()</methodname>, the lines will be nicely
              joined together. If you use <methodname>line_to()</methodname>
              instead, the lines will end at the same point, but Cairo won't do
              any special joining.
          </para>
          <note>
              <title>Drawing counter-clockwise</title>
              <para>
                  The function
                  <methodname>Cairo::Context::arc_negative()</methodname> is
                  exactly the same as
                  <methodname>Cairo::Context::arc()</methodname> but the angles go
                  the opposite direction.
              </para>
          </note>

      </section>
  </section>
  <section xml:id="sec-drawing-text">
  <title>Drawing Text</title>

      <section xml:id="drawing-text-pango">
      <title>Drawing Text with Pango</title>
          <para>
              Text is drawn via Pango Layouts. The easiest way to create a
              <classname>Pango::Layout</classname> is to use
              <methodname>Gtk::Widget::create_pango_layout()</methodname>.
              Once created, the layout can be manipulated in various ways,
              including changing the text, font, etc. Finally, the layout can
              be rendered using the
              <methodname>Pango::Layout::show_in_cairo_context()</methodname> method.
          </para>
      </section>
      <section xml:id="pango-text-example">
      <title>Example</title>

        <para>
           Here is an example of a program that draws some text, some of it
           upside-down. The Printing chapter contains another
           <link linkend="sec-printing-examples">example</link> of drawing text.
        </para>
        <figure xml:id="figure-drawingarea-pango-text">
          <title>Drawing Area - Text</title>
            <screenshot>
                <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drawingarea_pango_text.png"/></imageobject></mediaobject>
            </screenshot>
        </figure>

        <para><link xlink:href="&url_examples_base;drawingarea/pango_text">Source Code</link></para>
      </section>

      <!--
      <sect2 id="drawing-text-cairo">
          <title>Drawing Text with Cairo</title>
          <warning>TODO: Add Cairo content.</warning>
      </sect2>
      -->
  </section>

  <section xml:id="sec-draw-images">
  <title>Drawing Images</title>
          <para>
              There is a method for drawing from a
              <classname>Gdk::Pixbuf</classname> to a <classname>Cairo::Context</classname>.
              A <classname>Gdk::Pixbuf</classname> buffer is a useful wrapper
              around a collection of pixels, which can be read from files, and
              manipulated in various ways.
          </para>
          <para>
              Probably the most common way of creating
              <classname>Gdk::Pixbuf</classname>s is to use
              <methodname>Gdk::Pixbuf::create_from_file()</methodname> or
              <methodname>Gdk::Pixbuf::create_from_resource()</methodname>,
              which can read an image file, such as a png file into a pixbuf
              ready for rendering.
          </para>
          <para>
              The <classname>Gdk::Pixbuf</classname> can be rendered by setting
              it as the source pattern of the Cairo context with
              <methodname>Gdk::Cairo::set_source_pixbuf()</methodname>.
              Then draw the image with either <methodname>Cairo::Context::paint()</methodname>
              (to draw the whole image), or <methodname>Cairo::Context::rectangle()</methodname>
              and <methodname>Cairo::Context::fill()</methodname> (to fill the
              specified rectangle). <methodname>set_source_pixbuf()</methodname>
              is not a member of <classname>Cairo::Context</classname>. It takes
              a <classname>Cairo::Context</classname> as its first parameter.
          </para>
          <para>
              Here is a small bit of code to tie it all together: (Note that
              usually you wouldn't load the image every time in the draw
              signal handler! It's just shown here to keep it all together.)
          </para>
          <programlisting><code>void MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr, int width, int height)
{
  auto image = Gdk::Pixbuf::create_from_file("myimage.png");
  // Draw the image at 110, 90, except for the outermost 10 pixels.
  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);
  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);
  cr-&gt;fill();
}</code></programlisting>

        <section xml:id="cairo-example-image">
        <title>Example</title>
            <para>
                Here is an example of a simple program that draws an image.
                The program loads the image from a resource file. See the <link linkend="sec-gio-resource">Gio::Resource and glib-compile-resources</link>
                section. Use <application>glib-compile-resources</application> to compile
                the resources into a C source file that can be compiled and
                linked with the &cpp; code. E.g.
                <screen>$ glib-compile-resources --target=resources.c --generate-source image.gresource.xml</screen>
            </para>
        <figure xml:id="figure-drawingarea-image">
          <title>Drawing Area - Image</title>
            <screenshot>
                <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drawingarea_image.png"/></imageobject></mediaobject>
            </screenshot>
        </figure>

        <para><link xlink:href="&url_examples_base;drawingarea/image">Source Code</link></para> <!-- Insert image.gresource.xml -->
        </section>
  </section>
  <!--
  <sect1 id="sec-drawing-fill">
      <title>Gradients and other fill techniques</title>
      <warning>TODO: Add content.</warning>
  </sect1>
  <sect1 id="sec-drawing-transformations">
      <title>Transformations with Cairo</title>
      <warning>TODO: Add content.</warning>
  </sect1>
  -->
  <section xml:id="sec-drawing-clock-example">
  <title>Example Application: Creating a Clock with Cairo</title>

      <para>
          Now that we've covered the basics of drawing with Cairo, let's try to
          put it all together and create a simple application that actually
          does something. The following example uses Cairo to create a custom
          <classname>Clock</classname> widget. The clock has a second hand, a
          minute hand, and an hour hand, and updates itself every second.
      </para>
      <screenshot>
          <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;cairo_clock.png"/></imageobject></mediaobject>
      </screenshot>
      <para><link xlink:href="&url_examples_base;drawingarea/clock">Source Code</link></para>
      <para>
          As before, almost all of the interesting stuff is done in the draw
          function <methodname>on_draw()</methodname>. Before we dig
          into the draw function, notice that the constructor for the
          <classname>Clock</classname> widget connects a handler function
          <methodname>on_timeout()</methodname> to a timer with a timeout
          period of 1000 milliseconds (1 second). This means that
          <methodname>on_timeout()</methodname> will get called once per
          second. The sole responsibility of this function is to invalidate
          the window so that &gtkmm; will be forced to redraw it.
      </para>
      <para>
          Now let's take a look at the code that performs the actual drawing.
          The first section of <methodname>on_draw()</methodname> should be
          pretty familiar by now. This example again scales the coordinate system
          to be a unit square so that it's easier to draw the clock as a
          percentage of window size so that it will automatically scale when
          the window size is adjusted. Furthermore, the coordinate system is
          scaled over and down so that the (0, 0) coordinate is in the very
          center of the window.
      </para>
      <para>
          The function <methodname>Cairo::Context::paint()</methodname> is used here
          to set the background color of the window. This function takes no
          arguments and fills the current surface (or the clipped portion of
          the surface) with the source color currently active. After setting
          the background color of the window, we draw a circle for the clock
          outline, fill it with white, and then stroke the outline in black.
          Notice that both of these actions use the
          <methodname>_preserve</methodname> variant to preserve the current path,
          and then this same path is clipped to make sure that our next lines
          don't go outside the outline of the clock.
      </para>
      <para>
          After drawing the outline, we go around the clock and draw ticks for
          every hour, with a larger tick at 12, 3, 6, and 9. Now we're finally
          ready to implement the time-keeping functionality of the clock, which
          simply involves getting the current values for hours, minutes and
          seconds, and drawing the hands at the correct angles.
      </para>
  </section>
</chapter>

<chapter xml:id="chapter-draganddrop">
<title>Drag and Drop</title>
<para>
The <classname>Gtk::DragSource</classname> and <classname>Gtk::DropTarget</classname>
event controllers have methods and signals which are used for Drag and Drop.
</para>

<section xml:id="sec-dnd-sources-targets">
<title>Sources and Targets</title>
<para>
Things are dragged from <literal>sources</literal> to be dropped on
<literal>targets</literal>. Each source and target has information
about the data formats that it can send or receive, provided by
<classname>Gdk::ContentFormats</classname>. A drop target will only
accept a dragged item if they both share a compatible format. Appropriate
signals will then be emitted, telling the signal handlers which format was used.
</para>
<para>
<classname>Gdk::ContentFormats</classname> objects contain information about
available <type>GType</type>s and mime types (media types).
</para>

</section>

<section xml:id="sec-dnd-methods">
<title>Methods</title>

<para>
<classname>Widget</classname>s can be identified as sources or targets using
<classname>Gtk::DragSource</classname> and <classname>Gtk::DropTarget</classname>
event controllers.
</para>
<programlisting><code>auto source = Gtk::DragSource::create();
m_source_widget.add_controller(source);</code></programlisting>

<para>
Some <classname>DragSource</classname> methods:
<itemizedlist>
<listitem>
    <para>
        <literal>void set_content(const Glib::RefPtr&lt;Gdk::ContentProvider&gt;&amp; content)</literal>:
        Sets a content provider on the drag source.
    </para>
</listitem>
<listitem>
    <para>
        <literal>void set_actions(Gdk::DragAction actions)</literal>:
        Sets the actions on the drag source. For instance <literal>Gdk::DragAction::COPY
        | Gdk::DragAction::MOVE</literal>.
    </para>
</listitem>
<listitem>
    <para>
        <literal>void set_icon(const Glib::RefPtr&lt;const Gdk::Paintable&gt;&amp; paintable, int hot_x, int hot_y)</literal>:
        Sets a paintable to use as icon during DND operations.
    </para>
</listitem>
</itemizedlist>
</para>

<programlisting><code>auto target = Gtk::DropTarget::create(gtype, actions);
m_target_widget.add_controller(target);</code></programlisting>

<para>
Some <classname>DropTarget</classname> methods:
<itemizedlist>
<listitem>
    <para>
        <literal>void set_gtypes(const std::vector&lt;GType&gt;&amp; types)</literal>:
        Sets the supported types for this drop target.
    </para>
</listitem>
<listitem>
    <para>
        <literal>void set_actions(Gdk::DragAction actions)</literal>:
        Sets the actions that this drop target supports.
    </para>
</listitem>
<listitem>
    <para>
        <literal>Glib::ValueBase get_value() const</literal>:
        Gets the current drop data, as a <classname>Glib::Value</classname>.
    </para>
</listitem>
<listitem>
    <para>
        <literal>void reject()</literal>:
        Rejects the ongoing drop operation. This function should be used when
        delaying the decision on whether to accept a drag or not until after
        reading the data. 
    </para>
</listitem>
</itemizedlist>
</para>
</section>

<section xml:id="sec-dnd-signals">
<title>Signals</title>

<para>
When a drop target has accepted a dragged item, certain signals will be
emitted, depending on what action has been selected. For instance, the user
might have held down the <keycap>Shift</keycap> key to specify a
<literal>move</literal> rather than a <literal>copy</literal>. Remember that
the user can only select the actions which you have specified in your calls to
<methodname>Gtk::DragSource::set_actions()</methodname> and
<methodname>Gtk::DropTarget::set_actions()</methodname>.
</para>

<para>
The source widget will emit these <classname>DragSource</classname> signals:
<itemizedlist>
<listitem><para><literal>drag_begin</literal>: Provides a <classname>Gdk::Drag</classname>.</para></listitem>
<listitem><para><literal>prepare</literal>: Shall return a <classname>Gdk::ContentProvider</classname>,
  with the data to use for the drag that is about to start.</para></listitem>
<listitem><para><literal>drag_end</literal>: Provides a <classname>Gdk::Drag</classname>,
  and a <type>bool</type> that tells if the drag was performing a <literal>move</literal>
  and the data should be deleted.</para></listitem>
<listitem><para><literal>drag_cancel</literal>: Emitted on the drag source when a drag has failed.</para></listitem>
</itemizedlist>
</para>
<para>
The target widget will emit these <classname>DropTarget</classname> signals:
<itemizedlist>
<listitem><para><literal>enter</literal>: Provides coordinates.
  Shall return the preferred <type>Gdk::DragAction</type>.</para></listitem>
<listitem><para><literal>motion</literal>: Provides coordinates.
  Shall return the preferred <type>Gdk::DragAction</type>.</para></listitem>
<listitem><para><literal>leave</literal>: Emitted on the drop site when the pointer
  leaves the widget.</para></listitem>
<listitem><para><literal>accept</literal>: Provides a <classname>Gdk::Drop</classname>.
  You can call the <methodname>status()</methodname> method of the
  <classname>Gdk::Drop</classname> to indicate which actions will be accepted.</para></listitem>
<listitem><para><literal>drop</literal>: Provides the data being dropped and coordinates.
  Shall return a <type>bool</type> indicating whether the drop was accepted.</para></listitem>
</itemizedlist>
</para>
<para>
  The following signals call only one signal handler when emitted. When you connect
  a handler to such a signal, your signal handler must be called before (instead of)
  the default handler, otherwise it won't be called. Set the <literal>after</literal>
  parameter in <methodname>connect()</methodname> to <literal>false</literal>.
<itemizedlist>
<listitem><para><methodname>Gtk::DragSource::signal_prepare()</methodname></para></listitem>
<listitem><para><methodname>Gtk::DropTarget::signal_enter()</methodname></para></listitem>
<listitem><para><methodname>Gtk::DropTarget::signal_motion()</methodname></para></listitem>
<listitem><para><methodname>Gtk::DropTarget::signal_accept()</methodname></para></listitem>
<listitem><para><methodname>Gtk::DropTarget::signal_drop()</methodname></para></listitem>
</itemizedlist>
</para>

</section>

<section xml:id="sec-dnd-example">
<title>Example</title>

<para>Here is a very simple example, demonstrating a drag and drop <literal>Copy</literal> operation:</para>

<figure xml:id="figure-drag-and-drop">
  <title>Drag and Drop</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;drag_and_drop.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;drag_and_drop">Source Code</link></para>

<para>
There is a more complex example in examples/others/dnd.
</para>

</section>

</chapter>

<chapter xml:id="chapter-clipboard">
<title>The Clipboard</title>

<para>Simple text copy-paste functionality is provided for free by widgets such as
<classname>Gtk::Entry</classname> and <classname>Gtk::TextView</classname>,
but you might need special code to deal with your own data formats. For instance,
a drawing program would need special code to allow copy and paste within a view,
or between documents.</para>

<para>
You can get a clipboard instance with <methodname>Gtk::Widget::get_clipboard()</methodname>
or <methodname>Gdk::Display::get_clipboard()</methodname>.
</para>

<para>
Your application doesn't need to wait for clipboard operations, particularly
between the time when the user chooses Copy and then later chooses Paste. Many
<classname>Gdk::Clipboard</classname> methods take <classname>sigc::slot</classname>s
which specify callback methods. When <classname>Gdk::Clipboard</classname> is ready,
it will call these methods, providing the requested data.
</para>

<para><link xlink:href="&url_refdocs_base_gdk;Clipboard.html">Reference</link></para>

<section xml:id="sec-clipboard-formats">
<title>Formats</title>

<para>
Different applications contain different types of data, and they might make that data available in
a variety of formats. &gtkmm; calls these data types <literal>format</literal>s.</para>

<para>
For instance, <application>gedit</application> can supply and receive the <literal>text/plain</literal> mime type,
so you can paste data into <application>gedit</application> from any application that supplies that format.
Or two different image editing applications might supply and receive a variety of image formats.
As long as one application can receive one of the formats that the other supplies
then you will be able to copy data from one to the other.
</para>

<para>
Clipboard data can be in a variety of binary formats. This chapter, and the examples,
assume that the data is 8-bit text. This would allow us to use an XML format
for the clipboard data. However this would probably not be appropriate for
binary data such as images.
</para>

<para>The <link linkend="chapter-draganddrop">Drag and Drop</link> API uses the same mechanism.
You should probably use the same data formats for both Clipboard and Drag and Drop operations.</para>
</section>

<section xml:id="sec-clipboard-copy">
<title>Copy</title>

<para>
When the user asks to copy some data, you should copy the data to the
<classname>Clipboard</classname>. For instance,
</para>
<programlisting><code>void ExampleWindow::on_button_copy()
{
  get_clipboard()-&gt;set_text("example_custom_target");
}</code></programlisting>

</section>

<section xml:id="sec-clipboard-paste">
<title>Paste</title>

<para>
When the user asks to paste data from the <classname>Clipboard</classname>, you
should request a specific format and provide a callback method which will be
called with the actual data. For instance:
</para>
<programlisting><code>void ExampleWindow::on_button_paste()
{
  get_clipboard()-&gt;read_text_async(sigc::mem_fun(*this,
              &amp;ExampleWindow::on_clipboard_received));
}</code></programlisting>

<para>Here is an example callback method:
</para>
<programlisting><code>void ExampleWindow::on_clipboard_received(Glib::RefPtr&lt;Gio::AsyncResult&gt;&amp; result)
{
  auto text = get_clipboard()-&gt;read_text_finish(result);
  //Do something with the pasted data.
}</code></programlisting>

<section xml:id="sec-clipboard-discovering-formats">
<title>Discovering the available formats</title>

<para>
To find out what formats are currently available on the <classname>Clipboard</classname>
for pasting, call the <methodname>get_formats()</methodname> method. Then call a
<classname>Gdk::ContentFormats</classname> method to find out if a format that
your application supports is available.
</para>
</section>

</section>

<section xml:id="sec-clipboard-examples">
<title>Examples</title>

<section xml:id="sec-clipboard-example-simple">
<title>Simple</title>
<para>
This example allows copy and pasting of application-specific data, using the
standard text format. Although this is simple, it's not ideal because it does
not identify the <classname>Clipboard</classname> data as being of a particular
type.
</para>

<figure xml:id="figure-clipboard-simple">
  <title>Clipboard - Simple</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;clipboard_simple.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;clipboard/simple/">Source Code</link></para>

</section>

<section xml:id="sec-clipboard-example-ideal">
<title>Ideal</title>
<para>This is like the simple example, but it
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><simpara>Defines a custom clipboard target, though the format is still text.</simpara></listitem>
<listitem><simpara>It uses the <methodname>Gdk::ContentFormats::signal_changed()</methodname>
  signal and disables the Paste button if it can't use anything on the clipboard.</simpara></listitem>
</orderedlist>
</para>

<figure xml:id="figure-clipboard-ideal">
  <title>Clipboard - Ideal</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;clipboard_ideal.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;clipboard/ideal/">Source Code</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-printing">
<title>Printing</title>

<para>
At the application development level, &gtkmm;'s printing API
provides dialogs that are consistent across applications and allows use of Cairo's common drawing API, with Pango-driven text rendering. In the implementation of this common API, platform-specific backends and printer-specific drivers are used.
</para>

<section xml:id="sec-printoperation">
<title>PrintOperation</title>

<para>
The primary object is <classname>Gtk::PrintOperation</classname>, allocated
for each print operation. To handle page drawing connect to its signals,
or inherit from it and override the default virtual signal handlers.
<classname>PrintOperation</classname> automatically handles all the settings
affecting the print loop.
</para>

<section xml:id="sec-printoperation-signals">
<title>Signals</title>

<para>
The <methodname>PrintOperation::run()</methodname> method starts the print loop,
during which various signals are emitted:

<itemizedlist>
  <listitem>
    <para>
      <literal>begin_print</literal>:
      You must handle this signal, because this is where you
      create and set up a <classname>Pango::Layout</classname> using the
      provided <classname>Gtk::PrintContext</classname>, and break up your
      printing output into pages.
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>paginate</literal>: Pagination is potentially slow so if you
      need to monitor it you can call the
      <methodname>PrintOperation::set_show_progress()</methodname> method and
      handle this signal.
    </para>
  </listitem>

  <listitem>
    <para>
      For each page that needs to be rendered, the following signals
      are emitted:
      <itemizedlist>
        <listitem>
          <para>
            <literal>request_page_setup</literal>: Provides a
            <classname>PrintContext</classname>, page number and
            <classname>Gtk::PageSetup</classname>. Handle this signal if you
            need to modify page setup on a per-page basis.
          </para>
        </listitem>

        <listitem>
          <para>
            <literal>draw_page</literal>: You must handle this signal, which provides a
            <classname>PrintContext</classname> and a page number.
            The <classname>PrintContext</classname> should be used
            to create a <classname>Cairo::Context</classname> into which
            the provided page should be drawn. To render text, iterate over
            the <classname>Pango::Layout</classname> you created in the
            <literal>begin_print</literal> handler.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>end_print</literal>: A handler for it is a safe place to free
      any resources related to a <classname>PrintOperation</classname>.
      If you have your custom class that inherits from
      <classname>PrintOperation</classname>, it is naturally simpler to do it
      in the destructor.
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>done</literal>: This signal is emitted when printing is finished, meaning when the
      print data is spooled. Note that the provided
      <literal>Gtk::PrintOperation::Result</literal> may indicate that
      an error occurred. In any case you probably want to notify the user
      about the final status.
    </para>
  </listitem>

  <listitem>
    <para>
      <literal>status_changed</literal>: Emitted whenever a print job's
      status changes, until it is finished. Call the
      <methodname>PrintOperation::set_track_print_status()</methodname> method to
      monitor the job status after spooling. To see the status, use
      <methodname>get_status()</methodname> or
      <methodname>get_status_string()</methodname>.
    </para>
  </listitem>
</itemizedlist>

</para>

<para>
<link xlink:href="&url_refdocs_base_gtk;PrintOperation.html">Reference</link>
</para>

</section>

</section>

<section xml:id="sec-page-setup">
<title>Page setup</title>

<para>
The <classname>PrintOperation</classname> class has a method called
<methodname>set_default_page_setup()</methodname> which selects the default
paper size, orientation and margins. To show a page setup dialog from your
application, use the <methodname>Gtk::run_page_setup_dialog()</methodname> method,
which returns a <classname>Gtk::PageSetup</classname> object with the chosen
settings. Use this object to update a <classname>PrintOperation</classname>
and to access the selected <classname>Gtk::PaperSize</classname>,
<literal>Gtk::PageOrientation</literal> and printer-specific margins.
</para>
<para>You should save the chosen <classname>Gtk::PageSetup</classname>
so you can use it again if the page setup dialog is shown again.</para>

<para>For instance,</para>
<programlisting><code>// Within a class that inherits from Gtk::Window and keeps m_refPageSetup
// and m_refSettings as members...
auto new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);
m_refPageSetup = new_page_setup;
</code></programlisting>

<para>
<link xlink:href="&url_refdocs_base_gtk;PageSetup.html">Reference</link>
</para>

<para>
The Cairo coordinate system, in the <literal>draw_page</literal> handler,
is automatically rotated to the current page orientation. It is normally
within the printer margins, but you can change that via the
<methodname>PrintOperation::set_use_full_page()</methodname>
method. The default measurement unit is device pixels. To select other units,
use the <methodname>PrintOperation::set_unit()</methodname> method.
</para>

</section>

<section xml:id="sec-printing-rendering-text">
<title>Rendering text</title>

<para>
Text rendering is done using Pango.
The <classname>Pango::Layout</classname> object for printing should be created by calling
the <methodname>PrintContext::create_pango_layout()</methodname> method.
The <classname>PrintContext</classname> object also provides the page metrics,
via <methodname>get_width()</methodname> and <methodname>get_height()</methodname>.
The number of pages can be set with
<methodname>PrintOperation::set_n_pages()</methodname>. To actually render the
 Pango text in <literal>on_draw_page</literal>, get a
<classname>Cairo::Context</classname> with
<methodname>PrintContext::get_cairo_context()</methodname> and show the
<classname>Pango::LayoutLine</classname>s that appear within the requested
page number.
</para>

<para>
See <link linkend="sec-printing-examples-simple">an example</link>
of exactly how this can be done.
</para>

</section>

<section xml:id="sec-async-printing-ops">
<title>Asynchronous operations</title>

<para>
By default, <methodname>PrintOperation::run()</methodname> returns when a print
operation is completed. If you need to run a non-blocking print operation,
call <methodname>PrintOperation::set_allow_async()</methodname>. Note that <methodname>set_allow_async()</methodname> is not supported
on all platforms, however the <literal>done</literal> signal will still be emitted.
</para>

<para>
<methodname>run()</methodname> may return
<literal>PrintOperation::Result::IN_PROGRESS</literal>. To track status
and handle the result or error you need to implement signal handlers for
the <literal>done</literal> and <literal>status_changed</literal> signals:
</para>

<para>For instance,</para>
<programlisting><code>// in class ExampleWindow's method...
auto op = PrintOperation::create();
// ...set up op...
op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(
  *this, &amp;ExampleWindow::on_printoperation_done), op));
// run the op
</code></programlisting>

<para>Second, check for an error and connect to the <literal>status_changed</literal> signal. For instance:
</para>
<programlisting><code>void ExampleWindow::on_printoperation_done(Gtk::PrintOperation::Result result,
  const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)
{
  if (result == Gtk::PrintOperation::Result::ERROR)
    //notify user
  else if (result == Gtk::PrintOperation::Result::APPLY)
    //Update PrintSettings with the ones used in this PrintOperation

  if (! op-&gt;is_finished())
    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(
      *this, &amp;ExampleWindow::on_printoperation_status_changed), op));
}
</code></programlisting>

<para>Finally, check the status. For instance,</para>
<programlisting><code>void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)
{
  if (op-&gt;is_finished())
    //the print job is finished
  else
    //get the status with get_status() or get_status_string()

  //update UI
}
</code></programlisting>

</section>

<section xml:id="sec-printing-export-to-pdf">
<title>Export to PDF</title>

<para>
The 'Print to file' option is available in the print dialog, without the need for extra implementation. However, it is sometimes useful to generate a pdf file directly from code. For instance,
</para>
<programlisting><code>auto op = Gtk::PrintOperation::create();
// ...set up op...
op-&gt;set_export_filename("test.pdf");
auto res = op-&gt;run(Gtk::PrintOperation::Action::EXPORT);
</code></programlisting>

</section>

<section xml:id="sec-extending-print-dialog">
<title>Extending the print dialog</title>

<para>
You may add a custom tab to the print dialog:

<itemizedlist>
  <listitem>
    <para>
      Set the title of the tab via
      <methodname>PrintOperation::set_custom_tab_label()</methodname>,
      create a new widget and return it from the
      <literal>create_custom_widget</literal> signal handler. You'll probably
      want this to be a container widget, packed with some others.
    </para>
  </listitem>

  <listitem>
    <para>
      Get the data from the widgets in the
      <literal>custom_widget_apply</literal> signal handler.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>
Although the <literal>custom_widget_apply</literal> signal provides the widget you
previously created, to simplify things you can keep the widgets you expect
to contain some user input as class members. For example, let's say you have
a <classname>Gtk::Entry</classname> called <literal>m_Entry</literal> as
a member of your <classname>CustomPrintOperation</classname> class:
</para>
<programlisting><code>Gtk::Widget* CustomPrintOperation::on_create_custom_widget()
{
  set_custom_tab_label("My custom tab");

  auto hbox = new Gtk::Box(Gtk::Orientation::HORIZONTAL, 8);
  hbox-&gt;set_margin(6);

  auto label = Gtk::make_managed&lt;Gtk::Label&gt;("Enter some text: ");
  hbox-&gt;append(*label);

  hbox-&gt;append(m_Entry);

  return hbox;
}

void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)
{
  auto user_input = m_Entry.get_text();
  //...
}
</code></programlisting>

<para>
The example in examples/book/printing/advanced demonstrates this.
</para>

</section>

<section xml:id="sec-printing-preview">
<title>Preview</title>

<para>
The native GTK print dialog has a preview button, but you may also start
a preview directly from an application:</para>

<programlisting><code>// in a class that inherits from Gtk::Window...
auto op = PrintOperation::create();
// ...set up op...
op-&gt;run(Gtk::PrintOperation::Action::PREVIEW, *this);
</code></programlisting>

<para>
On Unix, the default preview handler uses an external viewer program.
On Windows, the native preview dialog will be shown. If necessary you may
override this behavior and provide a custom preview dialog. See the example
located in /examples/book/printing/advanced.
</para>

</section>

<section xml:id="sec-printing-printdialog">
<title>PrintDialog</title>

<para>
Since &gtkmm; 4.14 <classname>Gtk::PrintDialog</classname> is an alternative
to <classname>Gtk::PrintOperation</classname>. <classname>PrintDialog</classname>
uses the same <classname>PageSetup</classname> and <classname>PrintSettings</classname>
classes as <classname>PrintOperation</classname>. The rendering with Cairo and
Pango is also similar.
</para>

</section>

<section xml:id="sec-printing-examples">
<title>Examples</title>

<section xml:id="sec-printing-examples-simple">
<title>Simple</title>

<para>
The following example demonstrates how to print some input from a user interface
using <classname>PrintOperation</classname>. It shows how to implement
<literal>on_begin_print</literal> and <literal>on_draw_page</literal>,
as well as how to track print status and update the print settings.
</para>

<figure xml:id="figure-printing-simple">
  <title>Printing - Simple</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;printing_simple.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;printing/simple/">Source Code</link></para>

</section>

<section xml:id="sec-printing-examples-printdialog">
<title>PrintDialog</title>

<para>
The following example demonstrates how to print some input from a user
interface using <classname>PrintDialog</classname>. The user interface is
similar to the previous example.
</para>

<figure xml:id="figure-printing-printdialog">
  <title>Printing - PrintDialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;printing_printdialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;printing/print_dialog/">Source Code</link></para>

</section>
</section>
</chapter>

<chapter xml:id="chapter-recent-documents">
<title>Recently Used Documents</title>

  <para>
    &gtkmm; provides an easy way to manage recently used documents. This functionality
    is implemented in the <classname>Gtk::RecentManager</classname> class.
  </para>
  <para>
    Each item in the list of recently used files is identified by its URI, and
    can have associated metadata. The metadata can be used to specify how the
    file should be displayed, a description of the file, its mime type, which
    application registered it, whether it's private to the registering
    application, and several other things.
  </para>

  <section xml:id="sec-recentmanager">
  <title>RecentManager</title>
    <para>
      <classname>RecentManager</classname> acts as a database of
      recently used files. You use this class to register new files, remove
      files from the list, or look up recently used files. There is one list
      of recently used files per user.
    </para>
    <para>
      You can create a new <classname>RecentManager</classname>, but you'll most
      likely just want to use the default one. You can get a reference to the
      default <classname>RecentManager</classname> with
      <methodname>get_default()</methodname>.
    </para>

    <section xml:id="recent-files-adding">
    <title>Adding Items to the List of Recent Files</title>
      <para>
        To add a new file to the list of recent documents, in the simplest case,
        you only need to provide the URI. For example:
      </para>
      <programlisting><code>auto recent_manager = Gtk::RecentManager::get_default();
recent_manager-&gt;add_item(uri);</code></programlisting>
      <para>
        If you want to register a file with metadata, you can pass a
        <classname>RecentManager::Data</classname> parameter to
        <methodname>add_item()</methodname>. The metadata that can be set on a
        particular file item is as follows:
      </para>
      <itemizedlist xml:id="list-file-metadata">
        <listitem>
          <para><varname>app_exec</varname>: The command line to be used to launch
            this resource. This string may contain the "f" and "u" escape
            characters which will be expanded to the resource file path and URI
            respectively</para>
        </listitem>
        <listitem>
          <para><varname>app_name</varname>: The name of the application that
            registered the resource</para>
        </listitem>
        <listitem>
          <para><varname>description</varname>: A short description of the
            resource as a UTF-8 encoded string</para>
        </listitem>
        <listitem>
          <para><varname>display_name</varname>: The name of the resource to be
            used for display as a UTF-8 encoded string</para>
        </listitem>
        <listitem>
          <para><varname>groups</varname>: A list of groups associated with this
            item. Groups are essentially arbitrary strings associated with a
            particular resource. They can be thought of as 'categories' (such
            as "email", "graphics", etc) or tags for the resource.</para>
        </listitem>
        <listitem>
          <para><varname>is_private</varname>: Whether this resource should be
            visible only to applications that have registered it or not</para>
        </listitem>
        <listitem>
          <para><varname>mime_type</varname>: The MIME type of the resource</para>
        </listitem>
      </itemizedlist>
      <para>
        In addition to adding items to the list, you can also look up items from
        the list and modify or remove items.
      </para>
    </section>

    <section xml:id="recent-files-lookup">
    <title>Looking up Items in the List of Recent Files</title>
      <para>
        To look up recently used files, <classname>RecentManager</classname>
        provides several functions. To look up a specific item by its URI, you
        can use the <methodname>lookup_item()</methodname> function, which will
        return a <classname>RecentInfo</classname> class. If the specified URI
        did not exist in the list of recent files,
        <methodname>lookup_item()</methodname> throws a
        <classname>RecentManagerError</classname> exception. For example:
      </para>
<programlisting><code>Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;
try
{
  info = recent_manager-&gt;lookup_item(uri);
}
catch(const Gtk::RecentManagerError&amp; ex)
{
  std::cerr &lt;&lt; "RecentManagerError: " &lt;&lt; ex.what() &lt;&lt; std::endl;
}
if (info)
{
  // item was found
}</code></programlisting>
      <para>
        A <classname>RecentInfo</classname> object is essentially an object
        containing all of the metadata about a single recently-used file. You
        can use this object to look up any of the properties listed
        <link linkend="list-file-metadata">above</link>.
      </para>
      <para>
        If you don't want to look for a specific URI, but instead want to get a
        list of all recently used items, <classname>RecentManager</classname>
        provides the <methodname>get_items()</methodname> function. The return
        value of this function is a <classname>std::vector</classname> of all
        recently used files. The following code demonstrates how you might get a
        list of recently used files:
      </para>
      <programlisting><code>auto info_list = recent_manager-&gt;get_items();</code></programlisting>
      <para>
        The maximum age of items in the recently used files list can be set with
        <methodname>Gtk::Settings::property_gtk_recent_files_max_age()</methodname>.
        Default value: 30 days.
      </para>
    </section>

    <section xml:id="recent-files-modifying">
    <title>Modifying the List of Recent Files</title>
      <para>
        There may be times when you need to modify the list of recent files.
        For instance, if a file is moved or renamed, you may need to update the
        file's location in the recent files list so that it doesn't point to an
        incorrect location. You can update an item's location by using
        <methodname>move_item()</methodname>.
      </para>
      <para>
        In addition to changing a file's URI, you can also remove items from the
        list, either one at a time or by clearing them all at once. The former
        is accomplished with <methodname>remove_item()</methodname>, the latter with
        <methodname>purge_items()</methodname>.
      </para>
      <note>
        <para>
        The functions <methodname>move_item()</methodname>,
        <methodname>remove_item()</methodname> and
        <methodname>purge_items()</methodname> have no effect on the actual files
        that are referred to by the URIs, they only modify the list of recent
        files.
        </para>
      </note>
    </section>
  </section>

  <section xml:id="sec-filechooser-filedialog">
  <title>FileChooser and FileDialog</title>

    <para>
      <classname>FileChooser</classname> is an interface that can be
      implemented by widgets displaying a list of files.
      &gtkmm; provides three built-in implementations for choosing recent files
      or other files:
      <classname>FileChooserWidget</classname>,
      <classname>FileChooserDialog</classname>, and
      <classname>FileChooserNative</classname>.
    </para>
    <para>
      <classname>FileChooserWidget</classname> is a simple widget for
      displaying a list of recently used files or other files.
      <classname>FileChooserWidget</classname> is the basic building block for
      <classname>FileChooserDialog</classname>, but you can embed it into your
      user interface if you want to.
    </para>
    <note><para><classname>FileChooser</classname> and the classes that
      implement it are deprecated since &gtkmm; 4.10. They have been replaced
      by <classname>FileDialog</classname>, which is available since &gtkmm; 4.10.
    </para></note>

    <section xml:id="recentfiles-example">
    <title>Simple FileDialog example</title>

      <para>
        Shown below is a simple example of how to use the
        <classname>FileDialog</classname> class in a program.
        This simple program has a menubar with a
        <guimenuitem>File Dialog</guimenuitem> menu item.
        When you select this menu item, a dialog pops up showing a list of files.
        If you select <guimenuitem>Recent</guimenuitem> in the sidebar,
        the list of recently used files is shown.
      </para>
      <note>
        <para>
          If this is the first time you're using a program that uses the Recent
          Files framework, the dialog may be empty at first. Otherwise it
          should show the list of recently used documents registered by other
          applications.
        </para>
      </note>
      <para>
        After selecting the <guimenuitem>File Dialog</guimenuitem> menu
        item and the <guimenuitem>Recent</guimenuitem> sidebar item, you should
        see something similar to the following window.
      </para>
      <screenshot>
          <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;recentfiles.png"/></imageobject></mediaobject>
      </screenshot>
      <para><link xlink:href="&url_examples_base;recent_files">Source Code</link></para>
      <para>
        The constructor for <classname>ExampleWindow</classname> creates the
        menu and the toolbar using <classname>Builder</classname> (see <xref linkend="chapter-menus-and-toolbars"/> for more information). It then adds
        the menu and the toolbar to the window.
      </para>
    </section>

    <section xml:id="recent-files-filtering">
    <title>Filtering Files</title>
      <para>
        For any of the <classname>FileChooser</classname> classes, if you
        don't wish to display all of the items in the list of files, you
        can filter the list to show only those that you want. You can filter
        the list with the help of the <classname>FileFilter</classname> class.
        This class allows you to filter files by their name
        (<methodname>add_pattern()</methodname>), or their mime type
        (<methodname>add_mime_type()</methodname>).
      </para>
      <para>
        After you've created and set up the filter to match only the items you
        want, you can apply a filter to a chooser widget with the
        <methodname>FileChooser::add_filter()</methodname> function.
      </para>
    </section>
  </section>
</chapter>

<chapter xml:id="chapter-keyboardevents">
<title>Keyboard and Mouse Events</title>
  <para>
    Event signals differ in some ways from other signals. These differences are described
    in the <link linkend="sec-eventsignals">Event signals</link> section in
    the appendix. Here we will use keyboard events and mouse events to show how
    events can be used in a program.
  </para>
  <section xml:id="sec-keyboardevents-overview">
  <title>Overview</title>

    <para>
      Whenever you press or release a key, an event is emitted. You can add an
      event controller and connect a signal handler to handle such events.
    </para>
    <para>
      The event signal handler will receive arguments that depend on the type of event.
      For key press events the arguments are (<type>guint</type> <varname>keyval</varname>,
      <type>guint</type> <varname>keycode</varname>, <type>Gdk::ModifierType</type> <varname>state</varname>).
      As described in the <link linkend="sec-eventsignals">appendix</link>,
      the key press event signal handler returns a <type>bool</type> value, to indicate that
      the signal is fully handled (<literal>true</literal>) or allow event propagation
      (<literal>false</literal>).
    </para>
    <para>
      To determine which key was pressed or released, you read the value of
      the <varname>keyval</varname> argument and compare it with a constant in the
      <link xlink:href="https://gitlab.gnome.org/GNOME/gtk/tree/main/gdk/gdkkeysyms.h">
      <filename>&lt;gdk/gdkkeysyms.h&gt;</filename></link> header file. The states of
      modifier keys (shift, ctrl, etc.) are available as bit-flags in
      <varname>state</varname>.
    </para>
    <para>
      Here's a simple example:
    </para>
<programlisting><code><![CDATA[
bool MyClass::on_key_pressed(guint keyval, guint, Gdk::ModifierType state)
{
  if (keyval == GDK_KEY_1 &&
    (state & (Gdk::ModifierType::SHIFT_MASK | Gdk::ModifierType::CONTROL_MASK |
     Gdk::ModifierType::ALT_MASK)) == Gdk::ModifierType::ALT_MASK)
  {
    handle_alt_press();
    return true;
  }
  return false;
}

// in MyClass constructor
auto controller = Gtk::EventControllerKey::create();
controller->signal_key_pressed().connect(
  sigc::mem_fun(*this, &MyClass::on_key_pressed), false);
add_controller(controller);
]]></code></programlisting>

    <section xml:id="keyboardevents-simple-example">
    <title>Example</title>

      <para>
        In this example there are three keyboard shortcuts:
        <keycap>Alt</keycap>+<keycap>1</keycap> selects the first radio button,
        <keycap>Alt</keycap>+<keycap>2</keycap> selects the second one, and the
        <keycap>Esc</keycap> key hides (closes) the window.
      </para>

      <figure xml:id="figure-keyboardevents-simple">
        <title>Keyboard Events - Simple</title>
        <screenshot>
          <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;events_simple.png"/></imageobject></mediaobject>
        </screenshot>
      </figure>

      <para><link xlink:href="&url_examples_base;events/keyboard_simple/">Source Code</link></para>
    </section>
  </section>

  <section xml:id="sec-keyboardevents-propagation">
  <title>Event Propagation</title>

    <para>
      As described in the <link linkend="signal-handler-sequence">appendix</link>
      event signals are propagated in 3 phases:
      <orderedlist inheritnum="ignore" continuation="restarts">
      <listitem><simpara>Capture phase - runs from the toplevel down to the event widget.</simpara></listitem>
      <listitem><simpara>Target phase - runs only on the event widget.</simpara></listitem>
      <listitem><simpara>Bubble phase - runs from the event widget up to the toplevel.</simpara></listitem>
      </orderedlist>
    </para>
    <para>
      A keyboard event is first sent to the toplevel window
      (<classname>Gtk::Window</classname>), where it will be checked
      for any keyboard shortcuts that may be set (accelerator keys and mnemonics,
      used for selecting menu items from the keyboard). After this (and assuming
      the event wasn't handled), it is propagated down until it reaches the widget
      which has keyboard focus. The event will then propagate up until it reaches
      the top-level widget, or until you stop the propagation by returning
      <literal>true</literal> from an event handler.
    </para>
    <para>
      Notice, that after canceling an event, no other function will be called
      (even if it is from the same widget).
    </para>

    <section xml:id="keyboardevents-propagation-example">
    <title>Example</title>

      <para>
        In this example there are 9 <classname>EventControllerKey</classname>s,
        3 in each of a <classname>Gtk::Window</classname>, a <classname>Gtk::Box</classname>
        and a <classname>Gtk::Label</classname>. In each of the widgets there is
        one event controller for each propagation phase.
      </para>
      <para>
        The purpose of this example is to show the steps the event takes when it is emitted.
      </para>
      <para>
        When you write in the label, a key press event will be emitted,
        which will go first, in the capture phase, to the toplevel window
        (<classname>Gtk::Window</classname>), then down to its child, the
        box, then to the box's child, the label with the keyboard focus.
        In the target phase the event goes only to the widget with the keyboard
        focus (the label). In the bubble phase the event goes first to the widget
        with the keyboard focus (the label), then to its parent (the box), then
        to the box's parent (the window). If the event propagates all the way
        down to the label and then up to the window without being stopped,
        the text you're writing will appear in the <classname>Label</classname>
        above the <classname>Label</classname> you're writing in.
      </para>

      <figure xml:id="figure-keyboardevents-propagation">
        <title>Keyboard Events - Event Propagation</title>
        <screenshot>
          <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;events_propagation.png"/></imageobject></mediaobject>
        </screenshot>
      </figure>

      <para><link xlink:href="&url_examples_base;events/keyboard_propagation/">Source Code</link></para>
    </section>
  </section>

  <section xml:id="sec-keyboardevents-mouse">
  <title>Mouse Events</title>

  <para>
    Mouse events are similar to keyboard events. There are some differences, though.
    <itemizedlist>
      <listitem><para>You use <classname>Gtk::GestureClick</classname> instead of
        <classname>Gtk::EventControllerKey</classname>.</para></listitem>
      <listitem><para>There are other event classes that can be used for handling
        mouse events, for instance <classname>Gtk::EventControllerMotion</classname> and
        <classname>Gtk::EventControllerScroll</classname>.</para></listitem>
      <listitem><para>Many signal handlers don't return a <literal>bool</literal>.
        You can't stop those events from propagating.</para></listitem>
    </itemizedlist>
  </para>

  <para>
    The event classes that handle mouse events are also useful for handling
    events from touchscreens. There are also many subclasses of
    <classname>Gtk::EventController</classname> which are only (or mainly) useful
    for touchscreens. Examples: <classname>Gtk::GestureRotate</classname>,
    <classname>Gtk::GestureZoom</classname>, <classname>Gtk::GestureSwipe</classname>,
    <classname>Gtk::GestureLongPress</classname>.
  </para>

  <para><link xlink:href="&url_refdocs_base_gtk;EventController.html">Reference</link></para>

    <section xml:id="keyboardevents-mouse-example">
    <title>Example</title>
      <para>
        This is an expanded version of the simple keyboard events example.
      </para>

      <figure xml:id="figure-keyboardevents-mouse">
        <title>Keyboard and Mouse Events</title>
        <screenshot>
          <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;events_mouse.png"/></imageobject></mediaobject>
        </screenshot>
      </figure>

      <para><link xlink:href="&url_examples_base;events/mouse/">Source Code</link></para>
    </section>
  </section>
</chapter>

<chapter xml:id="chapter-chapter-timeouts">
<title>Timeouts, I/O and Idle Functions </title>

<section xml:id="sec-timeouts">
<title>Timeouts</title>

<para>
You may be wondering how to make &gtkmm; do useful work while it's idling along. Happily,
you have several options. Using the following methods you can create a timeout
method that will be called every few milliseconds.
</para>

<programlisting><code>sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool()&gt;&amp; slot,
                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);
</code></programlisting>

<para>
The first argument is a <classname>slot</classname> you wish to have called
when the timeout occurs. The second argument is the number of milliseconds
between calls to that method. You receive a
<classname>sigc::connection</classname> object that can be used to deactivate
the connection using its <methodname>disconnect()</methodname> method:
</para>

<programlisting><code>my_connection.disconnect();
</code></programlisting>

<para>
Another way of destroying the connection is your signal handler.
It has to be of the type <classname>sigc::slot&lt;bool()&gt;</classname>.
As you see from the definition your signal handler has to return a value of
the type <literal>bool</literal>. A definition of a sample method might
look like this:
</para>

<programlisting><code>bool MyCallback() { std::cout &lt;&lt; "Hello World!\n" &lt;&lt; std::endl; return true; }
</code></programlisting>

<para>
You can stop the timeout method by returning <literal>false</literal> from
your signal handler. Therefore, if you want your
method to be called repeatedly, it should return <literal>true</literal>.
</para>

<para>
Here's an example of this technique:
</para>

<para><link xlink:href="&url_examples_base;timeout/">Source Code</link></para>

</section>

<section xml:id="sec-monitoring-io">
<title>Monitoring I/O</title>

<para>
A nifty feature of Glib (one of the libraries underlying
&gtkmm;) is the ability to have it check for data on a file descriptor
for you. This is especially useful for networking applications. The
following method is used to do this:
</para>

<programlisting><code>sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool(Glib::IOCondition)&gt;&amp; slot,
                                 Glib::PollFD::fd_t fd, Glib::IOCondition condition,
                                 int priority = Glib::PRIORITY_DEFAULT);
</code></programlisting>

<para>
The first argument is a slot you wish to have called when
the specified event (see argument 3) occurs on the file descriptor you specify
using argument two. Argument three may be one or more (using
<literal>|</literal>) of:
</para>

<itemizedlist>
<listitem>
<para>
Glib::IOCondition::IO_IN - Call your method when there is data ready for
reading on your file descriptor.
</para>
</listitem>
<listitem>
<para>
Glib::IOCondition::IO_OUT - Call your method when the file descriptor is
ready for writing.
</para>
</listitem>
<listitem>
<para>
Glib::IOCondition::IO_PRI - Call your method when the file descriptor has urgent data to be read.
</para>
</listitem>
<listitem>
<para>
Glib::IOCondition::IO_ERR - Call your method when an error has occurred on the file descriptor.
</para>
</listitem>
<listitem>
<para>
Glib::IOCondition::IO_HUP - Call your method when hung up (the connection has been broken usually for pipes and sockets).
</para>
</listitem>
</itemizedlist>

<para>
    The return value is a <classname>sigc::connection</classname> that may be used to stop monitoring
this file descriptor using its <methodname>disconnect()</methodname> method. The
<parameter>slot</parameter> signal handler should be declared as follows:
</para>

<programlisting><code>bool input_callback(Glib::IOCondition condition);
</code></programlisting>

<para>
where <parameter>condition</parameter> is as
specified above. As usual the slot is created with
<function>sigc::mem_fun()</function> (for a member method of an object), or
<function>sigc::ptr_fun()</function> (for a function). A lambda expression can
be used, if you don't need the automatic disconnection that <function>sigc::mem_fun()</function>
provides when the object goes out of scope.
</para>

<para>
A little example follows. To use the example just execute it from a terminal;
it doesn't create a window. It will create a pipe named
<literal>testfifo</literal> in the current directory. Then start another shell
and execute <literal>echo "Hello" &gt; testfifo</literal>. The example will
print each line you enter until you execute <literal>echo "Q" &gt;
testfifo</literal>.
</para>

<para><link xlink:href="&url_examples_base;input/">Source Code</link></para>

</section>

<section xml:id="sec-idle-functions">
<title>Idle Functions</title>

<para>
If you want to specify a method that gets called when nothing else is happening, use the following:
</para>

<programlisting><code>sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool()&gt;&amp; slot,
                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);
</code></programlisting>

<para>
This causes &gtkmm; to call the specified method whenever nothing else is
happening. You can add a priority (lower numbers are higher priorities). There are two ways to remove the signal handler: calling
<methodname>disconnect()</methodname> on the
<classname>sigc::connection</classname> object, or returning
<literal>false</literal> in the signal handler, which should be declared
as follows:
</para>

<programlisting><code>bool idleFunc();
</code></programlisting>

<para>
Since this is very similar to the methods above this explanation should
be sufficient to understand what's going on. However, here's a little example:
</para>

<para><link xlink:href="&url_examples_base;idle/">Source Code</link></para>

<para>
This example points out the difference of idle and timeout methods a
little. If you need methods that are called periodically, and speed
is not very important, then you want timeout methods. If
you want methods that are called as often as possible (like
calculating a fractal in background), then use idle methods.
</para>

<para>
Try executing the example and increasing the system load. The upper
progress bar will increase steadily; the lower one will slow down.
</para>

</section>

</chapter>

<chapter xml:id="chapter-memory">
<title>Memory management</title>

<section xml:id="sec-memory-widgets">
<title>Widgets</title>

<section xml:id="memory-normal">
<title>Normal C++ memory management</title>

<para>
&gtkmm; allows the programmer to control the lifetime (that is, the construction
and destruction) of any widget in the same manner as any other &cpp; object.
This flexibility allows you to use <literal>new</literal> and
<literal>delete</literal> to create and destroy objects dynamically
or to use regular class members (that are destroyed automatically when the
class is destroyed) or to use local instances (that are destroyed when the
instance goes out of scope). This flexibility is not present in some &cpp; GUI
toolkits, which restrict the programmer to only a subset of &cpp;'s memory
management features.
</para>
<para>
An important difference in &gtkmm;-4.0 vs. older versions is that a &cpp; widgetʼs
destruction no longer causes the widget to be destroyed if itʼs within a parent;
in that case the C GtkWidget stays alive. If you had relied on that behavior in
an older version, in &gtkmm;-4.0 you must now remove the widget from its parent
first. See <link linkend="changes-gtkmm4">Changes in &gtkmm;-4.0</link>.
</para>
<para>Here are some examples of normal &cpp; memory management:</para>

<section xml:id="memory-class-scope">
<title>Class Scope widgets</title>
<para>
If a programmer does not need dynamic memory allocation, automatic widgets in class
scope may be used. One advantage of automatic widgets in class scope is that
memory management is grouped in one place. The programmer does not
risk memory leaks from failing to <literal>delete</literal> a widget.
</para>
<para>
The primary disadvantage of using class scope widgets is revealing
the class implementation rather than the class interface in the class header.
</para>
<programlisting><code>#include &lt;gtkmm/button.h&gt;
#include &lt;gtkmm/window.h&gt;
class Foo : public Gtk::Window
{
private:
  Gtk::Button theButton;
  // will be destroyed when the Foo object is destroyed
};
</code></programlisting>
</section>

<section xml:id="memory-function-scope">
<title>Function scope widgets</title>
<para>
If a programmer does not need a class scope widget, a function scope widget
may also be used. The advantages to function scope over class scope are the
increased data hiding and reduced dependencies.
</para>
<programlisting><code>{
  Gtk::Button aButton;
  aButton.set_visible(true);
  ...
  app-&gt;run();
}
</code></programlisting>
<para>
However, this technique is rarely useful. Most widgets can't safely be created
before the application has been registered or activated. They can't safely be
deleted after <methodname>Gtk::Application::run()</methodname> or
<methodname>Gtk::Application::make_window_and_run()</methodname> returns.
</para>

</section>

<section xml:id="memory-dynamic-allocation">
<title>Dynamic allocation with new and delete</title>
<para>
Usually, the programmer will prefer to allow containers to automatically destroy
their children by creating them using <function>Gtk::make_managed()</function>
(see below). This is not strictly required, as the <literal>new</literal> and
<literal>delete</literal> operators may also be used, but modern &cpp; style
discourages those in favor of safer models of memory management, so it is
better to create widgets using <function>Gtk::make_managed()</function> and
let their parent destroy them, than to manually perform dynamic allocation.
</para>
<programlisting><code>auto pButton = new Gtk::Button("Test");
// do something useful with pButton
delete pButton;
</code></programlisting>
<para>Here, the programmer deletes <varname>pButton</varname> to prevent a memory leak.
</para>
</section>

</section>

<section xml:id="memory-managed-widgets">
<title>Managed Widgets</title>

<para>
Alternatively, you can let a widget's container control when the widget is
destroyed. In most cases, you want a widget to last only as long as the
container it is in. To delegate the management of a widget's lifetime to its
container, create it with <function>Gtk::make_managed()</function> and then
pack it into its container with <methodname>Gtk::Box::append()</methodname> or
a similar method. Now the widget will be destroyed whenever its container is destroyed.
</para>

<section xml:id="memory-managed-dynamic">
<title>Dynamic allocation with make_managed() and append()</title>

<para>
&gtkmm; provides ways including the <function>make_managed()</function> function
and <methodname>Gtk::Box::append()</methodname> method to simplify creation
and destruction of widgets whose lifetime can be managed by a parent.
</para>

<para>
Every widget except a top-level window must be added to a parent container in
order to be displayed. The <function>manage()</function> function marks a widget
so that when that widget is added to a parent container, said container becomes
responsible for deleting the widget, meaning the user no longer needs to do so.
The original way to create widgets whose lifetime is managed by their parent in
this way was to call <function>manage()</function>, passing in the result of a
<literal>new</literal> expression that created a dynamically allocated widget.
</para>

<para>
However, usually, when you create such a widget, you will already know that its
parent container should be responsible for destroying it. In addition, modern
&cpp; style discourages use of the <literal>new</literal> operator, which was
required when passing a newly created widget to <function>manage()</function>.
Therefore, &gtkmm; has added <function>make_managed()</function>, which combines
creation and marking with <function>manage()</function> into a single step. This
avoids you having to write <literal>new</literal>, which is discouraged in
modern &cpp; style, and more clearly expresses intent to create a managed widget.
</para>

<programlisting><code>MyContainer::MyContainer()
{
  auto pButton = Gtk::make_managed&lt;Gtk::Button&gt;("Test");
  append(*pButton); //add *pButton to MyContainer
}
</code></programlisting>
<para>
Now, when objects of type <classname>MyContainer</classname> are destroyed, the
button will also be deleted. It is no longer necessary to delete <varname>pButton</varname>
to free the button's memory; its deletion has been delegated to the
<classname>MyContainer</classname> object.
</para>

<para>
If you never added the widget to any parent container, it's your responsibility
to delete it. If you add it to a container widget, and later
remove it (for instance with <methodname>Gtk::Box::remove()</methodname>),
it's deleted by the container.
</para>

<para>
Of course, a top-level container will not be added to another container. The
programmer is responsible for destroying the top-level container using one of
the traditional &cpp; techniques. Or you can let <methodname>Gtk::Application::make_window_and_run()</methodname>
create a top-level window and delete it when it's hidden.
</para>

</section>
</section>
</section>

<section xml:id="sec-memory-shared-resources">
<title>Shared resources</title>

<para>
Some objects, such as <classname>Gdk::Pixbuf</classname>s and
<classname>Pango::Font</classname>s, are obtained from a shared store.
Therefore you cannot instantiate your own instances. These classes typically
inherit from <classname>Glib::Object</classname>. Rather than requiring you to
reference and unreference these objects, &gtkmm; uses the
<classname>Glib::RefPtr&lt;&gt;</classname> smartpointer. Cairomm has its own
smartpointer, <classname>Cairo::RefPtr&lt;&gt;</classname>.
</para>

<para>
Objects such as <classname>Gdk::Pixbuf</classname> can only be instantiated
with a <methodname>create()</methodname> function. For instance,
</para>
<programlisting><code>auto pixbuf = Gdk::Pixbuf::create_from_file(filename);
</code></programlisting>

<para>
You have no way of getting a bare <classname>Gdk::Pixbuf</classname>. In the
example, <varname>pixbuf</varname> is a smart pointer, so you can do this, much
like a normal pointer:
</para>
<programlisting><code>auto width = 0;
if(pixbuf)
{
  width = pixbuf-&gt;get_width();
}
</code></programlisting>

<para>
When <varname>pixbuf</varname> goes out of scope an
<methodname>unref()</methodname> will happen in the background and you don't need
to worry about it anymore. There's no <literal>new</literal> so there's no
<literal>delete</literal>.
</para>
<para>
If you copy a <classname>RefPtr</classname>, for instance</para>
<programlisting><code>auto pixbuf2 = pixbuf;
</code></programlisting>
<para>or if you pass it as a method argument or a return type, then
<classname>RefPtr</classname> will do any necessary referencing to ensure that
the instance will not be destroyed until the last <classname>RefPtr</classname>
has gone out of scope.
</para>
<para>See the <link linkend="chapter-refptr">appendix</link> for detailed information about RefPtr.</para>
<para>
If you wish to learn more about smartpointers, you might look in these
books:
<itemizedlist>
<listitem><para>
Bjarne Stroustrup, "The C++ Programming Language" Fourth Edition - section 34.3
</para></listitem>
<listitem><para>
Nicolai M. Josuttis, "The C++ Standard Library" - section 4.2
</para></listitem>
</itemizedlist>
</para>

</section>

</chapter>

<chapter xml:id="chapter-builder">
<title>Gtk::Builder</title>

<para>
Although you can use &cpp; code to instantiate and arrange widgets, this can soon
become tedious and repetitive. And it requires a recompilation to show changes.
The <link xlink:href="https://gitlab.gnome.org/jpu/cambalache">Cambalache</link>
application allows you to layout widgets on screen and then save an XML description
of the arrangement. Your application can then use the <application>Gtk::Builder</application>
API to load that XML file at runtime and obtain a pointer to specifically named
widget instances.
</para>

<para>
This has the following advantages:
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><simpara>Less C++ code is required.</simpara></listitem>
<listitem><simpara>UI changes can be seen more quickly, so UIs are able to improve.</simpara></listitem>
<listitem><simpara>Designers without programming skills can create and edit UIs.</simpara></listitem>
</orderedlist>
</para>

<para>
You still need &cpp; code to deal with User Interface changes triggered by user
actions, but using <application>Gtk::Builder</application> for the widget
layout allows you to focus on implementing that functionality.
</para>

<para>
<application>Cambalache</application> replaces the <application>Glade</application>
application. <application>Glade</application> can generate XML files to be used
with gtk3/&gtkmm;3, but it does not support gtk4/&gtkmm;4.
</para>

<section xml:id="sec-builder-loading-ui-file">
<title>Loading the .ui file</title>

<para>
<classname>Gtk::Builder</classname> must be used via a
<classname>Glib::RefPtr</classname>. Like all such classes, you need to use a
<methodname>create()</methodname> method to instantiate it. For instance,</para>
<programlisting><code>auto builder = Gtk::Builder::create_from_file("basic.ui");
</code></programlisting>
<para>This will instantiate the windows defined in the <filename class="extension">.ui</filename> file.
</para>

<para>To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance,
</para>
<programlisting><code>auto builder = Gtk::Builder::create_from_file("basic.ui", "treeview_products");
</code></programlisting>

</section>

<section xml:id="sec-builder-accessing-widgets">
<title>Accessing widgets</title>

<para>
To access a widget, for instance to show a dialog, use
the <methodname>get_widget()</methodname> method, providing the widget's name.
This name should be specified in the <application>Cambalache</application>
window. If the widget could not be found, or is of the wrong type, then the
pointer will be set to <literal>nullptr</literal>.
</para>
<para>
The dialogs in this chapter are derived from <classname>Gtk::Window</classname>
because <classname>Gtk::Dialog</classname> is deprecated since &gtkmm; 4.10.
</para>
<programlisting><code>auto pDialog = builder-&gt;get_widget&lt;Gtk::Window&gt;("DialogBasic");
</code></programlisting>

<para>
<classname>Gtk::Builder</classname> checks for a null pointer, and checks
that the widget is of the expected type, and will show warnings on the command
line about these.
</para>

<para>
Remember that you are not instantiating a widget with
<methodname>get_widget()</methodname>, you are just obtaining a pointer to one that
already exists. You will always receive a pointer to the same instance when you
call <methodname>get_widget()</methodname> on the same
<classname>Gtk::Builder</classname>, with the same widget name. The
widgets are instantiated during <methodname>Gtk::Builder::create_from_file()</methodname>.
</para>

<para>
<methodname>get_widget()</methodname> returns child widgets that are
<function>manage()</function>ed (see the <link linkend="chapter-memory">Memory
Management</link> chapter), so they will be deleted when their parent
container is deleted. <classname>Window</classname>s (such as <classname>Dialog</classname>s)
cannot be managed because they have no parent container, so you must delete them at
some point. The documentation of <classname>Gtk::Builder</classname> has more to say
about the memory management of different kinds of objects.
</para>

<para><link xlink:href="&url_refdocs_base_gtk;Builder.html">Reference</link></para>

<section xml:id="builder-example-basic">
<title>Example</title>

<para>
This simple example shows how to load a <filename class="extension">.ui</filename>
file at runtime and access the widgets with <classname>Gtk::Builder</classname>.
</para>

<para><link xlink:href="&url_examples_base;builder/basic">Source Code</link></para>

</section>

</section>

<section xml:id="sec-builder-using-derived-widgets">
<title>Using derived widgets</title>

<para>
You can use <application>Cambalache</application> and
<classname>Gtk::Builder</classname> to layout your own custom widgets
derived from &gtkmm; widget classes. This keeps your code organized and
encapsulated, separating declarative presentation from business logic, avoiding
having most of your source just be setting properties and packing in containers.
</para>

<para>Use <methodname>Gtk::Builder::get_widget_derived()</methodname> like so:
</para>
<programlisting><code>auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, "DialogDerived");
</code></programlisting>

<para>
Your derived class must have a constructor that takes a pointer to the
underlying C type, and the <classname>Gtk::Builder</classname> instance.
All relevant classes of &gtkmm; typedef their underlying C type as
<classname>BaseObjectType</classname> (<classname>Gtk::Window</classname>
typedefs <classname>BaseObjectType</classname> as <type>GtkWindow</type>, for instance).
</para>
<para>
You must call the base class's constructor in the initialization list, providing the C pointer. For
instance,
</para>
<programlisting><code>DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Gtk::Window(cobject)
{
}
</code></programlisting>

<para>
You could then encapsulate the manipulation of the child widgets in the
constructor of the derived class, maybe using <methodname>get_widget()</methodname>
or <methodname>get_widget_derived()</methodname> again. For instance,
</para>
<programlisting><code>DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Gtk::Window(cobject),
  m_builder(builder),
  // Get the GtkBuilder-instantiated Button, and connect a signal handler:
  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;("quit_button"))
{
  if (m_pButton)
  {
    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );
  }
}
</code></programlisting>

<para>
It's possible to pass additional arguments from
<methodname>get_widget_derived()</methodname> to the constructor of the derived
widget. For instance, this call to <methodname>get_widget_derived()</methodname>
</para>
<programlisting><code>auto pDialog = Gtk::Builder::get_widget_derived&lt;DerivedDialog&gt;(builder, "DialogDerived", true);
</code></programlisting>
<para>can invoke this constructor
</para>
<programlisting><code>DerivedDialog::DerivedDialog(BaseObjectType* cobject,
  const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder, bool warning)
: Gtk::Window(cobject),
  m_builder(builder),
  m_pButton(m_builder-&gt;get_widget&lt;Gtk::Button&gt;("quit_button"))
{
  // ....
}
</code></programlisting>

<section xml:id="sec-builder-and-property">
<title>Gtk::Builder and Glib::Property</title>

<para>
If your derived widget uses <classname>Glib::Property</classname>, it becomes slightly
more complicated. A derived widget that contains <classname>Glib::Property</classname>
members must be registered with its own name in the <type>GType</type> system.
It must be registered before any of the <methodname>create_from_*()</methodname> or
<methodname>add_from_*()</methodname> methods are called, meaning that you may have
to create an instance of your derived widget just to have its class registered.
Your derived widget must have a constructor that has the parameters required by
<methodname>get_widget_derived()</methodname> and calls the <classname>Glib::ObjectBase</classname>
constructor to register the <type>GType</type>.
</para>
<programlisting><code>DerivedButton::DerivedButton(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)
: Glib::ObjectBase("MyButton"), // The GType name will be gtkmm__CustomObject_MyButton.
  Gtk::Button(cobject),
  prop_ustring(*this, "button-ustring"),
  prop_int(*this, "button-int", 10)
{
  // ....
}
</code></programlisting>
<para>
It is possible also to specify properties of derived widgets, declared in &cpp;
using &gtkmm;, within <filename class="extension">.ui</filename> files and load/set
these using <classname>Gtk::Builder</classname>. See the documentation of
<classname>Gtk::Builder</classname> for more details on how to achieve this.
<application>Cambalache</application> won’t recognize such properties as-is,
but you should be able to add a few lines of hand-coded XML to the XML code
generated by <application>Cambalache</application>.
</para>
</section>

<section xml:id="builder-example-derived">
<title>Example</title>

<para>
This example shows how to load a <filename class="extension">.ui</filename> file
at runtime and access the widgets via derived classes.
</para>

<para><link xlink:href="&url_examples_base;builder/derived">Source Code</link></para>

</section>

</section>

</chapter>

<chapter xml:id="chapter-internationalization">
<title>Internationalization and Localization</title>

  <para>
    &gtkmm; applications can easily support multiple languages, including
    non-European languages such as Chinese and right-to-left languages such as
    Arabic. An appropriately-written and translated &gtkmm; application will use
    the appropriate language at runtime based on the user's environment.
  </para>
  <para>
    You might not anticipate the need to support additional languages, but
    you can never rule it out. And it's easier to develop the application
    properly in the first place rather than retrofitting later.
  </para>

  <para>
    The process of writing source code that allows for translation is called
    <literal>internationalization</literal>, often abbreviated to
    <literal>i18n</literal>. The <literal>Localization</literal> process,
    sometimes abbreviated as <literal>l10n</literal>, provides translated text
    for other languages, based on that source code.
  </para>

  <para>
    The main activity in the internationalization process is finding strings
    seen by users and marking them for translation. You do not need to do it all
    at once - if you set up the necessary project infrastructure correctly then
    your application will work normally regardless of how many strings you've
    covered.
  </para>

  <para>
    String literals should be typed in the source code in English, but
    surrounded by a macro. The <application>gettext</application> (or intltool)
    utility can then extract the marked strings for translation, and substitute
    the translated text at runtime.
  </para>

  <section xml:id="sec-internationalization-intro">
  <title>Preparing your project</title>

    <note>
      <para>
        In the instructions below we will assume that you will not be using
        <application>gettext</application> directly, but
        <application>intltool</application>, which was written specifically for
        <literal>GNOME</literal>. <application>intltool</application> uses
        <function>gettext()</function>, which extracts strings from source code,
        but <application>intltool</application> can also combine strings from
        other files, for example from desktop menu details, and GUI resource
        files such as <filename class="extension">.ui</filename> files, into standard
        <application>gettext</application> <filename>.pot/.po</filename> files.
      </para>
      <para>
        We also assume that you are using autotools (<application>automake</application>
        and <application>autoconf</application>) to build your project (although
        autotools is not recommended for new applications), and
        that you are using <link xlink:href="https://gitlab.gnome.org/Archive/gnome-common/-/blob/master/autogen.sh">
          <literal>./autogen.sh</literal> from <application>gnome-common</application></link>
        or a similar <literal>autogen.sh</literal> file, which, among other
        things, takes care of some <application>intltool</application>
        initialization.
      </para>
    </note>
    <note>
      <para>
        If you are using <application>meson</application> (recommended), see the
        <link xlink:href="https://mesonbuild.com/Localisation.html">Localisation</link>
        chapter in Meson's manual. You can then skip this section.
      </para>
    </note>

    <para>
      An alternative to <application>gnome-common</application>'s
      <literal>autogen.sh</literal> may look like this:
    </para>
    <programlisting><code>#! /bin/sh -e
test -n "$srcdir" || srcdir=`dirname "$0"`
test -n "$srcdir" || srcdir=.

autoreconf --force --install --verbose --warnings=all "$srcdir"
echo "Running intltoolize --copy --force --automake"
intltoolize --copy --force --automake
test -n "$NOCONFIGURE" || "$srcdir/configure" "$@"</code></programlisting>

    <para>
      Create a sub-directory named <literal>po</literal> in your project's root
      directory. This directory will eventually contain all of your
      translations. Within it, create a file named <literal>LINGUAS</literal>
      and a file named <literal>POTFILES.in</literal>.
    </para>

    <para>
      <literal>LINGUAS</literal> contains an alphabetically sorted list of codes
      identifying the languages for which your program is translated (comment
      lines starting with a <literal>#</literal> are ignored). Each language
      code listed in the <literal>LINGUAS</literal> file must have a
      corresponding <literal>.po</literal> file. So, if your program has German
      and Japanese translations, your <literal>LINGUAS</literal> file would
      look like this:
    </para>
    <programlisting><code># keep this file sorted alphabetically, one language code per line
de
ja</code></programlisting>
    <para>
      (In addition, you'd have the files <literal>de.po</literal> and
      <literal>ja.po</literal> in your
      <literal>po</literal> directory which contain the German and Japanese
      translations, respectively.)
    </para>

    <para>
      <literal>POTFILES.in</literal> is a list of paths to all files which
      contain strings marked up for translation, starting from the project root
      directory. So for example, if your project sources were located in a
      subdirectory named <literal>src</literal>, and you had two files that
      contained strings that should be translated, your
      <literal>POTFILES.in</literal> file might look like this:
    </para>

    <programlisting><code>src/main.cc
src/other.cc</code></programlisting>

    <para>
      If you are using <application>gettext</application> directly, you can only
      mark strings for translation if they are in source code file. However, if
      you use <application>intltool</application>, you can mark strings for
      translation in a variety of other file formats, including
      <filename class="extension">.ui</filename> files, xml,
      <link xlink:href="http://standards.freedesktop.org/desktop-entry-spec/latest/">.desktop files</link>
      and several more. So, if you have designed some of the
      application UI in xml files then also add your
      <filename class="extension">.ui</filename> files to the list in
      <literal>POTFILES.in</literal>.
    </para>

    <para>
      Now that there is a place to put your translations, you need to initialize
      <application>intltool</application> and <application>gettext</application>.
      Add the following code to your <literal>configure.ac</literal>,
      substituting 'programname' with the name of your program:
    </para>

    <programlisting><code>IT_PROG_INTLTOOL([0.35.0])

GETTEXT_PACKAGE=programname
AC_SUBST(GETTEXT_PACKAGE)
AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], ["$GETTEXT_PACKAGE"],
                   [The domain to use with gettext])
AM_GNU_GETTEXT([external])
AM_GNU_GETTEXT_VERSION([0.17])

PROGRAMNAME_LOCALEDIR=[${datadir}/locale]
AC_SUBST(PROGRAMNAME_LOCALEDIR)</code></programlisting>

    <para>
      This <varname>PROGRAMNAME_LOCALEDIR</varname> variable will be used later
      in the <literal>Makefile.am</literal> file, to define a macro that will be
      used when you initialize <application>gettext</application> in your source
      code.
    </para>

    <para>
      <literal>AM_GLIB_GNU_GETTEXT</literal> has been an alternative to
      <literal>AM_GNU_GETTEXT</literal> and <literal>AM_GNU_GETTEXT_VERSION</literal>,
      but <literal>AM_GLIB_GNU_GETTEXT</literal> is now deprecated, and shall
      not be used in new code.
    </para>

    <para>
      In the top-level Makefile.am:
      <itemizedlist>
        <listitem>
          <para>Add <literal>po</literal> to the <literal>SUBDIRS</literal>
            variable. Without this, your translations won't get built and
            installed when you build the program</para>
        </listitem>
        <listitem>
          <para>
            Define <literal>INTLTOOL_FILES</literal> as:</para>
            <programlisting><code>INTLTOOL_FILES = intltool-extract.in \
                 intltool-merge.in \
                 intltool-update.in</code></programlisting>
        </listitem>
        <listitem>
          <para>
            Add <literal>INTLTOOL_FILES</literal> to the
            <literal>EXTRA_DIST</literal> list of files. This ensures that when
            you do a <command>make dist</command>, these files will be
            included in the source tarball.
          </para>
        </listitem>
        <listitem>
          <para>
            Update your <literal>DISTCLEANFILES</literal>:</para>
            <programlisting><code>DISTCLEANFILES = ... intltool-extract \
                 intltool-merge \
                 intltool-update \
                 po/.intltool-merge-cache</code></programlisting>
        </listitem>
        <listitem>
          <para>
            Depending on the types of files that contain translatable strings,
            add code such as</para>
            <programlisting><code>desktopdir = $(datadir)/applications
desktop_in_files = programname.desktop.in
desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
@INTLTOOL_DESKTOP_RULE@</code></programlisting>
        </listitem>
      </itemizedlist>
    </para>

    <para>
      In your <literal>src/Makefile.am</literal>, update your
      <literal>AM_CPPFLAGS</literal> to add the following preprocessor macro
      definition:
    </para>
    <programlisting><code>AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\"${PROGRAMNAME_LOCALEDIR}\"</code></programlisting>
    <para>
      This macro will be used when you initialize <literal>gettext</literal> in
      your source code.
    </para>
  </section>

<section xml:id="sec-i18n-marking-strings">
<title>Marking strings for translation</title>

  <para>
    String literals should be typed in the source code in English, but
    they should be surrounded by a call to the <function>gettext()</function>
    function. These strings will be extracted for translation and the
    translations may be used at runtime instead of the original English
    strings.
  </para>

  <para>
    The <application>GNU gettext</application> package allows you to mark
    strings in source code, extract those strings for translation, and use
    the translated strings in your application.
  </para>

  <para>
    However, <application>Glib</application> defines
    <function>gettext()</function>
    support macros which are shorter wrappers in an easy-to-use form.
    To use these macros, include <literal>&lt;glibmm/i18n.h&gt;</literal>,
    and then, for example, substitute:</para>
    <programlisting><code>display_message("Getting ready for i18n.");</code></programlisting>
    <para>with:</para>
    <programlisting><code>display_message(_("Getting ready for i18n."));</code></programlisting>

  <para>
    For reference, it is possible to generate a file which contains all
    strings which appear in your code, even if they are not marked for translation,
    together with file name and line
    number references. To generate such a file named
    <literal>my-strings</literal>, execute the following command,
    within the source code directory:
  </para>

  <programlisting><code>xgettext -a -o my-strings --omit-header *.cc *.h</code></programlisting>

  <para>
    Finally, to let your program use the translation for the current locale,
    add this code to the beginning of your <filename>main.cc</filename> file, to initialize gettext.
  </para>

<programlisting><code>bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);
bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
textdomain(GETTEXT_PACKAGE);</code></programlisting>

  <section xml:id="sec-i18n-gettext">
  <title>How gettext works</title>

    <para>
      The <application>intltool-update</application> or
      <application>xgettext</application> script extracts the strings
      and puts them in a <filename>mypackage.pot</filename> file.
      The translators of your application create their translations by
      first copying this <filename>.pot</filename> file to a
      <filename>localename.po</filename> file. A locale identifies a
      language and an encoding for that language, including date and numerical
      formats. Later, when the text in your source code has changed, the
      <application>msgmerge</application> or <application>intltool-update</application>
      script is used to update the <filename>localename.po</filename> files from
      the regenerated <filename>.pot</filename> file.
    </para>

    <para>
      At install time, the <filename>.po</filename> files are converted to
      a binary format (with the extension <filename>.mo</filename>) and
      placed in a system-wide directory for locale files, for example
      <filename>/usr/share/locale/</filename>.
    </para>

    <para>
      When the application runs, the <application>gettext</application>
      library checks the system-wide directory to see if there is a
      <filename>.mo</filename> file for the user's locale environment
      (you can set the locale with, for instance, "export LANG=de_DE.UTF-8"
      from a bash console). Later, when the program reaches a
      <literal>gettext</literal> call, it looks for a translation of a
      particular string. If none is found, the original string is used.
    </para>
  </section>

  <section xml:id="sec-i18n-testing">
  <title>Testing and adding translations</title>

    <para>
      To convince yourself that you've done well, you may wish to add a
      translation for a new locale. In order to do that, go to the
      <filename>po</filename> subdirectory of your project and
      execute the following command:
    </para>
    <programlisting><code>intltool-update --pot --gettext-package programname</code></programlisting>

    <para>
      That will create a file named <filename>programname.pot</filename>.
      Now copy that file to <filename>languagecode.po</filename>, such as
      <filename>de.po</filename> or <filename>hu.po</filename>. Also add
      that language code to <literal>LINGUAS</literal>. The
      <filename>.po</filename> file contains a header and a list of English strings,
      with space for the translated strings to be entered. Make sure you set the
      encoding of the <filename>.po</filename> file to <literal>UTF-8</literal>.
    </para>
    <programlisting><code>"Content-Type: text/plain; charset=UTF-8\n"</code></programlisting>

    <!-- TODO: This need more explanation. What's the point of the fuzzy tag then? murrayc -->
    <note>
      <para>
      It's possible that certain strings will be marked as
      <literal>fuzzy</literal> in the <filename>.po</filename> file.
      These translations will not substitute the original string. To make
      them appear, simply remove the <literal>fuzzy</literal> tag.
      A <literal>fuzzy</literal> tag appears if a string content changed,
      but the location is still the same.
      </para>
    </note>
  </section>

  <section xml:id="sec-i18n-resources">
  <title>Resources</title>

    <para>
      More information about what lies behind the internationalization and localization process
      is presented and demonstrated in:

      <itemizedlist>
        <listitem>
          <para>
            <link xlink:href="https://wiki.gnome.org/TranslationProject/DevGuidelines">
              L10N Guidelines for Developers</link>
          </para>
        </listitem>

        <listitem>
          <para>
            <link xlink:href="http://bazaar.launchpad.net/~intltool/intltool/trunk/view/head:/README">Intltool README</link>
          </para>
        </listitem>

        <listitem>
          <para>
            <link xlink:href="https://wiki.gnome.org/TranslationProject/GitHowTo">How to use Git for GNOME translators</link>
          </para>
        </listitem>

        <listitem>
          <para>
            <link xlink:href="http://www.gnu.org/software/gettext/manual/gettext.html">gettext manual</link>
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </section>

</section>

<section xml:id="sec-i18n-expecting-utf8">
<title>Expecting UTF8</title>

<para>
A properly internationalized application will not make assumptions about the
number of bytes in a character. That means that you shouldn't use pointer
arithmetic to step through the characters in a string, and it means you
shouldn't use <classname>std::string</classname> or standard C functions such
as <function>strlen()</function> because they make the same assumption.
</para>
<para>
However, you probably already avoid bare char* arrays and pointer arithmetic by
using <classname>std::string</classname>, so you just need to start using
<classname>Glib::ustring</classname> instead. See the <link linkend="sec-basics-ustring">Basics</link> chapter about
<classname>Glib::ustring</classname>.
</para>

<section xml:id="i18n-ustring-iostreams">
<title>Glib::ustring and std::iostreams</title>

<!-- <para>TODO: This section is not clear - it needs to spell things out more clearly and obviously.</para> -->
<para>
Unfortunately, the integration with the standard iostreams is not completely
foolproof. &gtkmm; converts <classname>Glib::ustring</classname>s to a
locale-specific encoding (which usually is not UTF-8) if you output them to an
<classname>ostream</classname> with <function>operator&lt;&lt;</function>.
Likewise, retrieving <classname>Glib::ustring</classname>s from
<classname>istream</classname> with <function>operator&gt;&gt;</function>
causes a conversion in the opposite direction. But this scheme breaks down if
you go through a <classname>std::string</classname>, e.g. by inputting text
from a stream to a <classname>std::string</classname> and then implicitly
converting it to a <classname>Glib::ustring</classname>. If the string
contained non-ASCII characters and the current locale is not UTF-8 encoded, the
result is a corrupted <classname>Glib::ustring</classname>. You can work around
this with a manual conversion. For instance, to retrieve the
<classname>std::string</classname> from a <classname>ostringstream</classname>:
</para>
<programlisting><code>std::locale::global(std::locale("")); // Set the global locale to the user's preferred locale.
                                      // Usually unnecessary here, because Glib::init()
                                      // or Gtk::Application::create() does it for you.
std::ostringstream output;
output &lt;&lt; percentage &lt;&lt; " % done";
label-&gt;set_text(Glib::locale_to_utf8(output.str()));</code></programlisting>
</section>

</section>

<section xml:id="sec-i18n-pitfalls">
<title>Pitfalls</title>

      <para>There are a few common mistakes that you would discover eventually yourself. But this section might help you to avoid them.</para>

<section xml:id="i18n-string-semantics">
<title>Same strings, different semantics</title>

        <para>Sometimes two English strings are identical but have different meanings in
different contexts, so they would probably not be identical when translated. Since the English strings are
          used as look-up keys, this causes problems.</para>

<para>
In these cases, you should add extra characters to the strings. For instance,
use <literal>"jumps[noun]"</literal> and <literal>"jumps[verb]"</literal>
instead of just <literal>"jumps"</literal> and strip them again outside the
<function>gettext</function> call. If you add extra characters you should also
add a comment for the translators before the <function>gettext</function> call.
Such comments will be shown in the <filename>.po</filename> files. For
instance:
</para>
<programlisting><code>// note to translators: don't translate the "[noun]" part - it is
// just here to distinguish the string from another "jumps" string
text = strip(gettext("jumps[noun]"), "[noun]");</code></programlisting>

<para>
If you use <application>Glib</application>'s support macros, it's easier. Use
<function>C_()</function> instead of <function>_()</function>. For instance:
</para>
<programlisting><code>GLib::ustring text(C_("noun", "jumps"));</code></programlisting>

</section>

<section xml:id="i18n-composition">
<title>Composition of strings</title>

<para>
C programmers use <function>sprintf()</function> to compose and concatenate
strings. &cpp; favors streams, but unfortunately, this approach makes
translation difficult, because each fragment of text is translated separately,
without allowing the translators to rearrange them according to the grammar of
the language.</para>

<para>For instance, this code would be problematic:</para>

<programlisting><code>std::cout &lt;&lt; _("Current amount: ") &lt;&lt; amount
          &lt;&lt; _(" Future: ") &lt;&lt; future &lt;&lt; std::endl;

label.set_text(_("Really delete ") + filename + _(" now?"));</code></programlisting>

<para>
So you should either avoid this situation or use
<link xlink:href="&url_refdocs_base_glib;ustring.html"><function>Glib::ustring::compose()</function></link>
which supports syntax such as:
</para>
<programlisting><code>std::cout &lt;&lt; Glib::ustring::compose(
             _("Current amount: %1 Future: %2"), amount, future) &lt;&lt; std::endl;

label.set_text(Glib::ustring::compose(_("Really delete %1 now?"), filename));</code></programlisting>
</section>

<section xml:id="i18n-display-size">
<title>Assuming the displayed size of strings</title>

        <para>You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English string. Luckily, most &gtkmm; widgets will expand at runtime to the required size.</para>
</section>

<section xml:id="i18n-unusual-words">
<title>Unusual words</title>

        <para>You should avoid cryptic abbreviations, slang, or jargon.
          They are usually difficult to translate, and are often difficult
          for even native speakers to understand.</para>
</section>

<section xml:id="i18n-non-ascii-characters">
<title>Using non-ASCII characters in strings</title>

<para>
Currently, <application>gettext</application> does not support non-ASCII
characters (i.e. any characters with a code above 127) in source code. For
instance, you cannot use the copyright sign (&copy;).
</para>

        <para>To work around this, you could write a comment in the
          source code just before the string, telling the translators to
          use the special character if it is available in their languages. For English, you could then make an American English
          <filename>en_US.po</filename> translation which used that special character.</para>
      </section>
    </section>

    <section xml:id="sec-i18n-getting-help-with-translations">
    <title>Getting help with translations</title>

      <para>If your program is free software, there is a whole <literal>GNOME</literal>
        subproject devoted to helping you make translations, the
        <link xlink:href="https://wiki.gnome.org/TranslationProject/"><literal>GNOME</literal>
        Translation Project</link>.</para>

      <para>The way it works is that you upload your source code to a git
        repository where translators can access it, then file an
        <link xlink:href="https://gitlab.gnome.org/Infrastructure/damned-lies/-/issues">
        issue to the damned-lies project</link> and ask to have your program added to the
        <link xlink:href="http://l10n.gnome.org/module/">list of modules to translate</link>.</para>

      <para>Then you make sure you update the file
        <filename>POTFILES.in</filename> in the
        <filename>po/</filename> subdirectory
        (<command>intltool-update -m</command> can help with this) so
        that the translators always access updated
        <filename>myprogram.pot</filename> files, and simply freeze
        the strings at least a couple of days before you make a new
        release. Depending on the number
        of strings your program contains and how popular it is, the
        translations will then start to tick in as
        <filename>.po</filename> files.</para>

      <para>Note that most language teams only consist of 1-3 persons,
        so if your program contains a lot of strings, it might last a
        while before anyone has the time to look at it. Also, most
        translators do not want to waste their time (translating is
        a very time-consuming task) so if they do not assess your
        project as being really serious (in the sense that it is
        polished and being maintained) they may decide to spend their
        time on some other project.</para>
    </section>

<section xml:id="sec-i18n-example">
<title>Example</title>

<para>Here is a simple example with translatable strings in &cpp; code. It shows what
you can do if you don't use autotools or <application>meson</application>.
It is also an example of using the <classname>Gtk::TextView</classname> widget.</para>

<para>This program can set the locale, if it's specified in a configuration file.
This is not normal behavior. Most programs accept the locale that the user
has selected, for instance with an environment variable.</para>

<figure xml:id="figure-i18n">
  <title>Translatable Strings</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;i18n.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;i18n">Source Code</link></para>
</section>
</chapter>

<chapter xml:id="chapter-customwidgets">
<title>Custom Widgets</title>

    <para>&gtkmm; makes it very easy to derive new widgets by inheriting from an
      existing widget class, either by deriving from a container and adding child
      widgets, or by deriving from a single-item widget, and changing its behavior.
      But you might occasionally find that no suitable starting point already exists.
      In this case, you can implement a widget from scratch.</para>

    <section xml:id="sec-custom-containers">
    <title>Custom Containers</title>

    <para>When deriving a custom container widget directly from <classname>Gtk::Widget</classname>,
      you should override the following virtual methods:
    <itemizedlist>
      <listitem><para><methodname>get_request_mode_vfunc()</methodname>: Return what <literal>Gtk::SizeRequestMode</literal> is preferred by the container.</para></listitem>
      <listitem><para><methodname>measure_vfunc()</methodname>: Calculate the minimum and natural width or height of the container.</para></listitem>
      <listitem><para><methodname>size_allocate_vfunc()</methodname>: Position the child widgets, given the height and width that the container has actually been given.</para></listitem>
    </itemizedlist>
    </para>

    <para>The <methodname>get_request_mode_vfunc()</methodname>,
        <methodname>measure_vfunc()</methodname>, and
        <methodname>size_allocate_vfunc()</methodname> virtual methods control the
        layout of the child widgets. For instance, if your container has 2
        child widgets, with one below the other, your
        <methodname>get_request_mode_vfunc()</methodname> might request
        height-for-width layout. Then your
        <methodname>measure_vfunc()</methodname>
        might report the maximum of the widths of the child widgets when asked
        to report width, and it might report the sum of their heights when asked
        to report height. If you want padding between
        the child widgets then you would add that to the width and height too.
        Your widget's container will use this result to ensure that your widget
        gets enough space, and not less. By examining each widget's parent, and
        its parent, this logic will eventually decide the size of the top-level
        window.</para>

    <para>You are not guaranteed to get the <literal>Gtk::SizeRequestMode</literal>
        that you request. Therefore <methodname>measure_vfunc()</methodname> must
        return sensible values for all reasonable values of its input parameters.
        For a description of <methodname>measure_vfunc()</methodname>'s parameters see
        also the description of <methodname>Gtk::Widget::measure()</methodname>, which
        may be better documented than <methodname>measure_vfunc()</methodname>.</para>

   <para><methodname>size_allocate_vfunc()</methodname> receives the actual
       height and width that the parent container has decided to give to your
       widget. This might be more than the minimum, or even more than the natural
       size, for instance if the
       top-level window has been expanded. You might choose to ignore the extra
       space and leave a blank area, or you might choose to expand your child
       widgets to fill the space, or you might choose to expand the padding
       between your widgets. It's your container, so you decide.</para>

   <para>Your container must unparent its children before the underlying C object
       (a <classname>gtkmm__GtkWidget</classname>) is finalized. If your container
       is used as a managed widget, it shall unparent its children in a
       <methodname>Gtk::Widget::signal_destroy()</methodname> handler (available
       since &gtkmm; 4.8). If your container is not managed, that signal handler
       is not called. Instead the children shall be unparented in the &cpp; destructor.
       If you want your container to be useful both ways, unparent the children
       both in the destructor and in a signal handler. See the example code.</para>

<section xml:id="custom-container-example">
<title>Example</title>

    <para>This example implements a container with child widgets, one above
        the other. Of course, in this case it would be far simpler just to use
        a vertical <classname>Gtk::Box</classname> or <classname>Gtk::Grid</classname>.</para>

<figure xml:id="figure-custom-container">
  <title>Custom Container</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;custom_container.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;custom/custom_container/">Source Code</link></para>
</section>

    </section>

    <section xml:id="sec-custom-widgets">
    <title>Custom Widgets</title>

    <para>By deriving directly from <classname>Gtk::Widget</classname> you can
        do all the drawing for your widget directly, instead of just arranging
        child widgets. For instance, a <classname>Gtk::Label</classname> draws
        the text of the label, but does not do this by using other
        widgets.</para>

    <para>When deriving from <classname>Gtk::Widget</classname>, you should
        override the following virtual methods. The methods marked (optional)
        need not be overridden in all custom widgets. The base class's methods
        may be appropriate.
    <itemizedlist>
      <listitem><para><methodname>get_request_mode_vfunc()</methodname>: (optional) Return what <literal>Gtk::SizeRequestMode</literal> is preferred by the widget.</para></listitem>
      <listitem><para><methodname>measure_vfunc()</methodname>: Calculate the minimum and natural width or height of the widget.</para></listitem>
      <listitem><para><methodname>size_allocate_vfunc()</methodname>: (optional) Position the widget, given the height and width that it has actually been given.</para></listitem>
      <listitem><para><methodname>on_realize()</methodname>:  (optional)</para></listitem>
      <listitem><para><methodname>on_unrealize()</methodname>: (optional)</para></listitem>
      <listitem><para><methodname>on_map()</methodname>: (optional)</para></listitem>
      <listitem><para><methodname>on_unmap()</methodname>: (optional)</para></listitem>
      <listitem><para><methodname>snapshot_vfunc()</methodname>: Create a render node, e.g. a <classname>Cairo::Context</classname> node, and draw on it.</para></listitem>
    </itemizedlist>
    </para>

    <para>The first 3 methods in the previous table are also overridden in custom
        containers. They are briefly described in the
        <link linkend="sec-custom-containers">Custom Containers</link> section.
    </para>

<section xml:id="custom-init-functions">
<title>Class Init and Instance Init Functions</title>

<para>Some <application>GTK</application> functions, if called at all, must be
called from the class init function. Some other <application>GTK</application>
functions, if called, must be called from the instance init function.
If your custom widget must call any of those functions, you can derive a class
from <classname>Glib::ExtraClassInit</classname> and derive your custom class
from that class. The <link linkend="custom-css-name-example">custom CSS name example</link>
shows how that's done.</para>
</section>

<section xml:id="custom-widget-example">
<title>Example</title>

<para>This example implements a widget which draws Penrose triangles.</para>

<figure xml:id="figure-custom-widget">
  <title>Custom Widget</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;custom_widget.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;custom/custom_widget/">Source Code</link></para>
</section>
</section>

<section xml:id="sec-custom-css-names">
<title>Custom CSS Names</title>

<para>Many aspects of the look of widgets are controlled by CSS (Cascading Style
Sheet) files. With CSS files you can choose color, font, line thickness, etc.
If you give some widgets their own names or their own CSS classes, you can define
CSS rules that apply only to those widgets, for instance certain buttons,
without affecting other similar widgets.</para>

<section xml:id="css-widget-class-name">
<title>CSS Node Name, Widget Name, CSS Class Name</title>

<para>There are three ways of referring from a widget to data in a CSS file:
  <itemizedlist>
    <listitem><para><methodname>gtk_widget_class_set_css_name()</methodname>
    can only be called from the class init function. It sets the CSS node name
    of all instances of a class (a GType). See the <link linkend="custom-init-functions">
    Class Init and Instance Init Functions</link> section.</para></listitem>
    <listitem><para><methodname>Gtk::Widget::set_name()</methodname>
    can be called from a &cpp; constructor. It sets the name of
    a widget instance.</para></listitem>
    <listitem><para><methodname>Gtk::Widget::add_class_name()</methodname>
    can be called from a &cpp; constructor. It adds the name of a CSS class,
    used by a widget instance.</para></listitem>
  </itemizedlist>
The following example shows a button with its own CSS node name, a label with
a widget name and a label that uses its own CSS class.</para>
</section>

<section xml:id="custom-style-information">
<title>Custom Style Information</title>

<para>To add a style sheet to an application, use one of the
<methodname>Gtk::CssProvider::load_from_*()</methodname> methods.
Then add it with <methodname>Gtk::StyleProvider::add_provider_for_display()</methodname>
(available since &gtkmm; 4.10) or <methodname>Gtk::StyleContext::add_provider_for_display()</methodname>.
<classname>Gtk::StyleContext</classname> also contains methods to read some style
information, but this class is deprecated since &gtkmm; 4.10.</para>

<para>CSS files are described in the documentation of GTK.</para>
</section>

<section xml:id="custom-css-name-example">
<title>Example</title>

<para>This example implements a button and two labels with custom style information.</para>

<figure xml:id="figure-custom-css-name">
  <title>Custom CSS Name</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;custom_css_name.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;custom/custom_css_name/">Source Code</link></para> <!-- Insert custom_gtkmm.css -->
</section>
</section>

</chapter>

<chapter xml:id="chapter-multi-threaded-programs">
<title>Multi-threaded programs</title>

<section xml:id="sec-the-constraints">
<title>The constraints</title>

<para>
Care is required when writing programs based on &gtkmm; using
multiple threads of execution, arising from the fact that
<application>libsigc++</application>, and in particular
<classname>sigc::trackable</classname>, are not thread-safe. That's
because none of the complex interactions that occur behind the scenes
when using <application>libsigc++</application> are protected by a
mutex or other means of synchronization.
<footnote>
<para>
These interactions arise from the fact that, amongst other things, a
class inheriting from <classname>sigc::trackable</classname> will, via
that inheritance, have a <classname>std::list</classname> object
keeping track of slots created by calls to
<function>sigc::mem_fun()</function> representing any of its
non-static methods (more particularly it keeps a list of callbacks
which will null the connected slots on its destruction). Each
<classname>sigc::slot</classname> object also keeps, via
<classname>sigc::slot_rep</classname>, its own
<classname>sigc::trackable</classname> object to track any
<classname>sigc::connection</classname> objects which it needs to
inform about its demise, and also has a function to deregister itself
from any <classname>sigc::trackable</classname> on disconnection or
destruction. <classname>sigc::signal</classname> objects also keep
lists of slots, which will be updated by a call to their
<methodname>connect()</methodname> method or calls to any
<classname>sigc::connection</classname> object relating to such a
connection.
</para>
</footnote>
</para>

<section xml:id="the-rules">
<title>The rules</title>

<para>
This requires a number of rules to be observed when writing
multi-threaded programs using &gtkmm;. These are set out below, but
one point to note is that extra care is required when deriving classes
from <classname>sigc::trackable</classname>, because the effects are
unintuitive (see particularly points 4 and 5 below).
</para>

<orderedlist inheritnum="ignore" continuation="restarts">

<listitem>
<para>
Use <classname>Glib::Dispatcher</classname> to invoke &gtkmm; functions
from worker threads (this is dealt with in more detail in the next
section).
</para>
</listitem>

<listitem>
<para>
A <classname>sigc::signal</classname> object should be regarded as
owned by the thread which created it. Only that thread should connect
a <classname>sigc::slot</classname> object to the signal object, and
only that thread should <methodname>emit()</methodname> or call
<methodname>operator()()</methodname> on the signal, or null any
connected <classname>sigc::slot</classname> object. It follows
(amongst other things) that any signal object provided by a &gtkmm;
widget should only be operated on in the main GUI thread and any
object deriving from <classname>sigc::trackable</classname> having its
non-static methods referenced by slots connected to the signal object
should only be destroyed in that thread.
</para>
</listitem>

<listitem>
<para>
Any <classname>sigc::connection</classname> object should be regarded
as owned by the thread in which the method returning the
<classname>sigc::connection</classname> object was called. Only that
thread should call <classname>sigc::connection</classname> methods on
the object.
</para>
</listitem>

<listitem>
<para>
A <classname>sigc::slot</classname> object created by a call to
<function>sigc::mem_fun()</function> which references a method of a
class deriving from <classname>sigc::trackable</classname> should
never be copied to another thread, nor destroyed by a different thread
than the one which created it.
</para>
</listitem>

<listitem>
<para>
If a particular class object derives from
<classname>sigc::trackable</classname>, only one thread should create
<classname>sigc::slot</classname> objects representing any of the
class's non-static methods by calling
<function>sigc::mem_fun()</function>. The first thread to create such
a slot should be regarded as owning the relevant object for the
purpose of creating further slots referencing <emphasis>any</emphasis>
of its non-static methods using that function, or nulling those slots
by disconnecting them or destroying the trackable object.
</para>
</listitem>

<listitem>
<para>
Although <application>glib</application> is itself thread-safe, any
<application>glibmm</application> wrappers which use
<application>libsigc++</application> will not be. So for example, only
the thread in which a main loop runs should call
<methodname>Glib::SignalIdle::connect()</methodname>,
<methodname>Glib::SignalIO::connect()</methodname>,
<methodname>Glib::SignalTimeout::connect()</methodname>,
<methodname>Glib::SignalTimeout::connect_seconds</methodname>
for that main loop, or manipulate any
<classname>sigc::connection</classname> object returned by them.
</para>
<para>
The connect*_once() variants,
<methodname>Glib::SignalIdle::connect_once()</methodname>,
<methodname>Glib::SignalTimeout::connect_once()</methodname>,
<methodname>Glib::SignalTimeout::connect_seconds_once()</methodname>,
are thread-safe for any case where the slot is not created by a call to
<function>sigc::mem_fun()</function> which represents a method of a class
deriving from <classname>sigc::trackable</classname>.
</para>
</listitem>

</orderedlist>

</section>

</section>

<section xml:id="sec-using-glib-dispatcher">
<title>Using Glib::Dispatcher</title>

<para>
The slots connected to <classname>sigc::signal</classname> objects
execute in the thread which calls <methodname>emit()</methodname> or
<methodname>operator()()</methodname> on the signal.
<classname>Glib::Dispatcher</classname> does not behave this way:
instead its connected slots execute in the thread in which the
<classname>Glib::Dispatcher</classname> object was constructed (which
must have a glib main loop). If a
<classname>Glib::Dispatcher</classname> object is constructed in the
main GUI thread (which will therefore be the receiver thread), any
worker thread can emit on it and have the connected slots safely
execute &gtkmm; functions.
</para>

<para>
Some thread safety rules on the use of
<classname>Glib::Dispatcher</classname> still apply. As mentioned, a
<classname>Glib::Dispatcher</classname> object must be constructed in
the receiver thread (the thread in whose main loop it will execute its
connected slots). By default this is the main program thread, although
there is a <classname>Glib::Dispatcher</classname> constructor which
can take the <classname>Glib::MainContext</classname> object of any
thread which has a main loop. Only the receiver thread should call
<methodname>connect()</methodname> on the
<classname>Glib::Dispatcher</classname> object, or manipulate any
related <classname>sigc::connection</classname> object, unless
additional synchronization is employed. However, any worker thread can
safely emit on the <classname>Glib::Dispatcher</classname> object
without any locking once the receiver thread has connected the slots,
provided that it is constructed before the worker thread is started
(if it is constructed after the thread has started, additional
synchronization will normally be required to ensure visibility).
</para>

<para>
Aside from the fact that connected slots always execute in the
receiver thread, <classname>Glib::Dispatcher</classname> objects are
similar to <classname>sigc::signal&lt;void()&gt;</classname> objects.
They therefore cannot pass unbound arguments nor return a value. The
best way to pass unbound arguments is with a thread-safe
(asynchronous) queue. At the time of writing
<application>glibmm</application> does not have one, although most
people writing multi-threaded code will have one available to them
(they are relatively easy to write although there are subtleties in
combining thread safety with strong exception safety).
</para>

<para>
A <classname>Glib::Dispatcher</classname> object can be emitted on by
the receiver thread as well as by a worker thread, although this
should be done within reasonable bounds. On unix-like systems
<classname>Glib::Dispatcher</classname> objects share a single common
pipe, which could in theory at least fill up on a very heavily loaded
system running a program with a very large number of
<classname>Dispatcher</classname> objects in use. Were the pipe to
fill up before the receiver thread's main loop has had an opportunity
to read from it to empty it, and the receiver thread attempt to emit
and so write to it when it is in that condition, the receiver thread
would block on the write, so deadlocking. Where the receiver thread is
to emit, a normal <classname>sigc::signal&lt;void()&gt;</classname>
object could of course be used instead.
</para>

</section>

<section xml:id="sec-multithread-example">
<title>Example</title>

<para>
This is an example program with two threads, one GUI thread, like in all
&gtkmm; programs, and one worker thread. The worker thread is created when you
press the <literal>Start work</literal> button. It is deleted when the work is
finished, when you press the <literal>Stop work</literal> button, or when you
press the <literal>Quit</literal> button.
</para>

<para>
A <classname>Glib::Dispatcher</classname> is used for sending notifications
from the worker thread to the GUI thread. The <classname>ExampleWorker</classname>
class contains data which is accessed by both threads. This data is protected
by a <classname>std::mutex</classname>.
Only the GUI thread updates the GUI.
</para>

<para>
Compiling and linking a multi-threaded program can require special compiler and
linker options. If you use the <application>g++</application> compiler, add the
<literal>-pthread</literal> option. Other compilers may require other options.
If you build with <application>meson</application>, it handles the multi-threading
complications for you, if you add <function>dependency('threads')</function>.
</para>

<figure xml:id="figure-multithread">
  <title>Multi-Threaded Program</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;multithread.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;multithread">Source Code</link></para>

</section>

</chapter>

<chapter xml:id="chapter-recommended-techniques">
<title>Recommended Techniques</title>

<para>This section is simply a gathering of wisdom, general style guidelines
and hints for creating &gtkmm; applications.
</para>

<para>Use <application>Meson</application>! It is your friend :)
    It examines C and &cpp; files, determines how they depend on each other,
    and generates <filename>build.ninja</filename> or an equivalent file so the
    files can be compiled in the correct order. <application>Meson</application>
    permits automatic configuration of software installation, handling a large
    number of system quirks to increase portability.
</para>

<para>Subclass Widgets to better organize your code. You should probably
    subclass your main <classname>Window</classname> at least. Then you can
    make your child Widgets and signal handlers members of that class.
</para>

<para>Create your own signals instead of passing pointers around. Objects can
    communicate with each other via signals and signal handlers. This is much
    simpler than objects holding pointers to each other and calling each
    other's methods. &gtkmm;'s classes use special versions of
    <classname>sigc::signal</classname>, but you should use normal
    <classname>sigc::signal</classname>s, as described in the
    <application>libsigc++</application> documentation.</para>

<section xml:id="sec-application-lifetime">
<title>Application Lifetime</title>
<para>Most applications will have only one <classname>Window</classname>, or
    only one main window. These applications can use
    <methodname>Gtk::Application::make_window_and_run(int argc, char** argv, T_Args&amp;&amp;... args)</methodname>.
    It creates and shows a window. When the window is hidden, <methodname>make_window_and_run()</methodname>
    deletes the window and returns to the caller.
    This might happen when the user closes the window, or when your code decides to
    hide the window with <methodname>set_visible(false)</methodname>. You can prevent the user from
    closing the window (for instance, if there are unsaved changes) by
    overriding <methodname>Gtk::Window::on_close_request()</methodname>.</para>
<para>Most of our examples use this technique.</para>
</section>

<section xml:id="sec-using-a-gtkmm-widget">
<title>Using a &gtkmm; widget</title>

<para>
    Our examples all tend to have the same structure. They follow these steps
    for using a <classname>Widget</classname>:
</para>

<para>

<orderedlist inheritnum="ignore" continuation="restarts">
<listitem>
<para>
Declare a variable of the type of <classname>Widget</classname> you wish to
use, generally as member variable of a derived container class. You could also
declare a pointer to the widget type, and then create it with
<literal>new</literal> or <function>Gtk::make_managed()</function> in your code.
</para>
</listitem>

<listitem>
<para>
 Set the attributes of the widget. If the widget has no default constructor,
 then you will need to initialize the widget in the initializer list of your
 container class's constructor.
</para>
</listitem>

<listitem>
<para>
Connect any signals you wish to use to the appropriate handlers.
</para>
</listitem>

<listitem>
<para>
Pack the widget into a container using the appropriate call,
e.g. <methodname>Gtk::Box::append()</methodname>.
</para>
</listitem>

</orderedlist>

</para>

<para>
If you don't want all widgets to be shown, call <methodname>Gtk::Widget::set_visible(false)</methodname>
on the widgets that you don't want to show. If a container widget is hidden, all
of its child widgets are also hidden, even if <methodname>set_visible(false)</methodname> is
not called on the child widgets.
</para>

</section>
</chapter>

<chapter xml:id="chapter-building-applications">
<title>Building applications</title>

<para>
This chapter is similar to <emphasis>Building applications</emphasis> and following sections in the
<link xlink:href="https://docs.gtk.org/gtk4/getting_started.html">Getting Started</link>
chapter in the GTK documentation.
The same application is built, but &gtkmm; is used instead of <application>GTK</application>.
</para>
<para>
An application consists of a number of files:
<variablelist>
  <varlistentry>
    <term>The binary file</term>
    <listitem><para>This gets installed in <filename>/usr/bin</filename>.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term>A desktop file</term>
    <listitem><para>The desktop file provides important information about the application
      to the desktop shell, such as its name, icon, D-Bus name, commandline to launch it,
      etc. It is installed in <filename>/usr/share/applications</filename>.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term>An icon</term>
    <listitem><para>The icon gets installed in <filename>/usr/share/icons/hicolor/48x48/apps</filename>,
      where it will be found regardless of the current theme.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term>A settings schema</term>
    <listitem><para>If the application uses <classname>Gio::Settings</classname>,
      it will install its schema in <filename>/usr/share/glib-2.0/schemas</filename>,
      so that tools like dconf-editor can find it.</para></listitem>
  </varlistentry>
  <varlistentry>
    <term>Other resources</term>
    <listitem><para>Other files, such as <classname>Gtk::Builder</classname> ui files,
      are best loaded from resources stored in the application binary itself. This
      eliminates the need for most of the files that would traditionally be installed
      in an application-specific location in <filename>/usr/share</filename>.</para></listitem>
  </varlistentry>
</variablelist>
</para>

<para>
&gtkmm; includes application support that is built on top of <classname>Gio::Application</classname>.
In this chapter we'll build a simple application by starting from scratch, adding more
and more pieces over time. Along the way, we'll learn about <classname>Gtk::Application</classname>,
<classname>Gtk::Builder</classname>, resources, menus, settings,
<classname>Gtk::HeaderBar</classname>, <classname>Gtk::Stack</classname>,
<classname>Gtk::SearchBar</classname>, <classname>Gtk::ListBox</classname>, and more.
</para>

<para>
The full, buildable sources for these examples can be found in the
<filename>examples/book/buildapp</filename> directory of the
<application>gtkmm-documentation</application> source distribution, or online in the
<link xlink:href="&url_examples_base;buildapp"><application>gtkmm-documentation</application>
git repository</link>. You can build each example separately by using <command>meson</command>
and <command>ninja</command> with the <filename>meson.build</filename> file or by using
<command>make</command> with the <filename>Makefile.example</filename> file. For more
information, see the <filename>README</filename> included in the <filename>buildapp</filename>
directory.
</para>

<section xml:id="sec-buildapp-trivial-app">
<title>A trivial application</title>

<para>
When using <classname>Gtk::Application</classname>, the <function>main()</function> function
can be very simple. We just call <methodname>Gtk::Application::run()</methodname> on an
instance of our application class.
</para>

<para>
All the application logic is in the application class, which is a subclass of
<classname>Gtk::Application</classname>. Our example does not yet have any interesting
functionality. All it does is open a window when it is activated without arguments,
and open the files it is given, if it is started with arguments. (Or rather, our
application class tries to open the files, but our subclassed application window
does not yet do what it's told to do.)
</para>

<para>
To handle these two cases, we override <methodname>signal_activate()</methodname>'s
default handler, which gets called when the application is launched without commandline
arguments, and <methodname>signal_open()</methodname>'s default handler, which gets
called when the application is launched with commandline arguments.
</para>

<para><link xlink:href="&url_refdocs_base_gio;Application.html">Gio::Application Reference</link></para>
<para><link xlink:href="&url_refdocs_base_gtk;Application.html">Gtk::Application Reference</link></para>

<para>
Another important class that is part of the application support in &gtkmm; is
<classname>Gtk::ApplicationWindow</classname>. It is typically subclassed as well.
Our subclass does not do anything yet, so we will just get an empty window.
</para>

<para>
As part of the initial setup of our application, we also create an icon and a desktop file.
Note that @bindir@ in the desktop file needs to be replaced with the actual path
to the binary before this desktop file can be used.
</para>

<para>
Here is what we've achieved so far:
</para>

<figure xml:id="figure-buildapp-trivial-app">
  <title>A trivial application</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_trivial_app.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para>
This does not look very impressive yet, but our application is already presenting itself
on the session bus, it has single-instance semantics, and it accepts files as commandline arguments.
</para>

<para><link xlink:href="&url_examples_base;buildapp/step1">Source Code</link></para> <!-- Insert exampleapp.desktop.in -->

</section>

<section xml:id="sec-buildapp-populating-window">
<title>Populating the window</title>

<para>
In this step, we use a <classname>Gtk::Builder</classname> instance to associate a
<classname>Gtk::Builder</classname> ui file with our application window class.
</para>

<para>
Our simple ui file gives the window a title, and puts a <classname>Gtk::Stack</classname>
widget as the main content.
</para>

<para>
To make use of this file in our application, we revisit our
<classname>Gtk::ApplicationWindow</classname> subclass, and call
<methodname>Gtk::Builder::create_from_resource()</methodname> and
<methodname>Gtk::Builder::get_widget_derived()</methodname> from the
<methodname>ExampleAppWindow::create()</methodname> method to get an instance of
our subclassed <classname>Gtk::ApplicationWindow</classname>. See the
<link linkend="sec-builder-using-derived-widgets">Using derived widgets</link> section
for more information about <methodname>get_widget_derived()</methodname>.
</para>

<para>
You may have noticed that we use the <methodname>_from_resource()</methodname> variant
of the method that reads the ui file. Now we need to use <application>GLib</application>'s
resource functionality to include the ui file in the binary. This is commonly done by
listing all resources in a .gresource.xml file.
This file has to be converted into a C source file that will be compiled and linked
into the application together with the other source files. To do so, we use the
<application>glib-compile-resources</application> utility:
<screen>$ glib-compile-resources --target=resources.c --generate-source exampleapp.gresource.xml</screen>
The <link linkend="sec-gio-resource">Gio::Resource and glib-compile-resources</link>
section contains more information about resource files. If you build with Meson,
use the <function>compile_resources()</function> function in Meson's
<link xlink:href="https://mesonbuild.com/Gnome-module.html">GNOME module</link>.
</para>

<para>
Our application now looks like this:
</para>

<figure xml:id="figure-buildapp-populating-window">
  <title>Populating the window</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_populating_window.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step2">Source Code</link></para> <!-- Insert exampleapp.gresource.xml window.ui -->

</section>

<section xml:id="sec-buildapp-opening-files">
<title>Opening files</title>

<para>
In this step, we make our application show the contents of all the files that it is
given on the commandline.
</para>

<para>
To this end, we add a data member to our application window and keep a pointer to the
<classname>Gtk::Stack</classname> there. We get the pointer with a call to
<methodname>Gtk::Builder::get_widget()</methodname> in the application window's constructor.
</para>

<para>
Now we revisit the <methodname>ExampleAppWindow::open_file_view()</methodname> method
that is called for each commandline argument, and construct a <classname>Gtk::TextView</classname>
that we then add as a page to the stack.
</para>

<para>
Lastly, we add a <classname>Gtk::StackSwitcher</classname> to the titlebar area
in the ui file, and we tell it to display information about our stack.
</para>

<para>
The stack switcher gets all its information it needs to display tabs from
the stack that it belongs to. Here, we are passing the label to show for
each file as the last argument to the <methodname>Gtk::Stack::add()</methodname>
method.
</para>

<para>
Our application is beginning to take shape:
</para>

<figure xml:id="figure-buildapp-opening-files">
  <title>Opening files</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_opening_files.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step3">Source Code</link></para> <!-- Insert window.ui -->

</section>

<section xml:id="sec-buildapp-menu">
<title>A menu</title>

<para>
The menu is shown at the right side of the headerbar. It is meant to collect
infrequently used actions that affect the whole application.
</para>

<para>
Just like the application window, we specify our menu in a ui file, and add it
as a resource to our binary.
</para>

<para>
To make the menu appear, we have to load the ui file and associate the
resulting menu model with the menu button that we've added to the headerbar.
Since menus work by activating <classname>Gio::Action</classname>s, we also
have to add a suitable set of actions to our application.
</para>

<para>
Adding the actions is best done in the <methodname>on_startup()</methodname> default
signal handler, which is guaranteed to be called once for each primary application instance.
</para>

<para>
Our preferences menu item does not do anything yet, but the Quit menu item is fully
functional. It can also be activated by the usual Ctrl-Q shortcut. The shortcut
is added with <methodname>Gtk::Application::set_accel_for_action()</methodname>.
</para>

<para>
The menu looks like this:
</para>

<figure xml:id="figure-buildapp-menu">
  <title>A menu</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_menu.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step4">Source Code</link></para> <!-- Insert exampleapp.gresource.xml gears_menu.ui window.ui -->

</section>

<section xml:id="sec-buildapp-pref-dialog">
<title>A preference dialog</title>

<para>
A typical application will have some preferences that should be remembered from one run
to the next. Even for our simple example application, we may want to change the font
that is used for the content.
</para>

<para>
We are going to use <classname>Gio::Settings</classname> to store our preferences.
<classname>Gio::Settings</classname> requires a schema that describes our settings,
in our case the <filename>org.gtkmm.exampleapp.gschema.xml</filename> file.
</para>

<para>
Before we can make use of this schema in our application, we need to compile it into
the binary form that <classname>Gio::Settings</classname> expects. GIO provides macros
to do this in autotools-based projects. See the description of
<link xlink:href="https://docs.gtk.org/gio/class.Settings.html">GSettings</link>.
Meson provides the <function>compile_schemas()</function> function in the
<link xlink:href="https://mesonbuild.com/Gnome-module.html">GNOME module</link>.
</para>

<para>
Next, we need to connect our settings to the widgets that they are supposed to control.
One convenient way to do this is to use <methodname>Gio::Settings::bind()</methodname>
to bind settings keys to object properties, as we do for the transition setting in
<classname>ExampleAppWindow</classname>'s constructor.
</para>
<programlisting><code>m_settings = Gio::Settings::create("org.gtkmm.exampleapp");
m_settings-&gt;bind("transition", m_stack-&gt;property_transition_type());
</code></programlisting>

<para>
The code to connect the font setting is a little more involved, since it corresponds to
an object property in a <classname>Gtk::TextTag</classname> that we must first create.
The code is in <methodname>ExampleAppWindow::open_file_view()</methodname>.
</para>
<programlisting><code>auto tag = buffer-&gt;create_tag();
m_settings-&gt;bind("font", tag-&gt;property_font());
buffer-&gt;apply_tag(tag, buffer-&gt;begin(), buffer-&gt;end());
</code></programlisting>

<para>
At this point, the application will already react if you change one of the settings,
e.g. using the <command>gsettings</command> commandline tool. Of course, we expect
the application to provide a preference dialog for these. So lets do that now.
Our preference dialog will be a subclass of <classname>Gtk::Window</classname>, and
we'll use the same techniques that we've already seen in <classname>ExampleAppWindow</classname>:
a <classname>Gtk::Builder</classname> ui file and settings bindings.
In this case the bindings are more involved, though. We use
<classname>Gtk::FontDialogButton</classname> and <classname>Gtk::DropDown</classname>
in the preference dialog. The types of the properties in these classes can't be
automatically converted to the string type that <classname>Gio::Settings</classname> requires.
</para>

<para>
When we've created the <filename>prefs.ui</filename> file and the <classname>ExampleAppPrefs</classname>
class, we revisit the <methodname>ExampleApplication::on_action_preferences()</methodname>
method in our application class, and make it open a new preference dialog.
</para>
<programlisting><code>auto prefs_dialog = ExampleAppPrefs::create(*get_active_window());
prefs_dialog-&gt;present();
</code></programlisting>

<para>
After all this work, our application can now show a preference dialog like this:
</para>

<figure xml:id="figure-buildapp-pref-dialog">
  <title>A preference dialog</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_pref_dialog.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step5">Source Code</link></para> <!-- Insert exampleapp.gresource.xml prefs.ui org.gtkmm.exampleapp.gschema.xml -->

</section>

<section xml:id="sec-buildapp-search-bar">
<title>Adding a search bar</title>

<para>
We continue to flesh out the functionality of our application. For now, we add search.
&gtkmm; supports this with <classname>Gtk::SearchEntry</classname> and <classname>Gtk::SearchBar</classname>.
The search bar is a widget that can slide in from the top to present a search entry.
</para>

<para>
We add a toggle button to the header bar, which can be used to slide out the search bar
below the header bar. The new widgets are added in the <filename>window.ui</filename> file.
</para>

<para>
Implementing the search needs quite a few code changes that we are not going to completely
go over here. The central piece of the search implementation is a signal handler that
listens for text changes in the search entry, shown here without error handling.
</para>
<programlisting><code>void ExampleAppWindow::on_search_text_changed()
{
  const auto text = m_searchentry-&gt;get_text();
  auto tab = dynamic_cast&lt;Gtk::ScrolledWindow*&gt;(m_stack-&gt;get_visible_child());
  auto view = dynamic_cast&lt;Gtk::TextView*&gt;(tab-&gt;get_child());

  // Very simple-minded search implementation.
  auto buffer = view-&gt;get_buffer();
  Gtk::TextIter match_start;
  Gtk::TextIter match_end;
  if (buffer-&gt;begin().forward_search(text, Gtk::TextSearchFlags::CASE_INSENSITIVE,
      match_start, match_end))
  {
    buffer-&gt;select_range(match_start, match_end);
    view-&gt;scroll_to(match_start);
  }
}
</code></programlisting>

<para>
With the search bar, our application now looks like this:
</para>

<figure xml:id="figure-buildapp-search-bar">
  <title>Adding a search bar</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_search_bar.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step6">Source Code</link></para> <!-- Insert window.ui -->

</section>

<section xml:id="sec-buildapp-side-bar">
<title>Adding a side bar</title>

<para>
As another piece of functionality, we are adding a sidebar, which demonstrates
<classname>Gtk::Revealer</classname> and <classname>Gtk::ListBox</classname>.
The new widgets are added in the <filename>window.ui</filename> file.
</para>

<para>
The code to populate the sidebar with buttons for the words found in each
file is a little too involved to go into here. But we'll look at the code
to add a checkbutton for the new feature to the menu. A menu item is added to
the ui file <filename>gears_menu.ui</filename>.
</para>

<para>
To connect the menu item to the new <literal>show-words</literal> setting, we use a
<classname>Gio::Action</classname> corresponding to the given <classname>Gio::Settings</classname>
key. In <classname>ExampleAppWindow</classname>'s constructor:
</para>
<programlisting><code>// Connect the menu to the MenuButton m_gears, and bind the show-words setting
// to the win.show-words action and the "Words" menu item.
// (The connection between action and menu item is specified in gears_menu.ui.)
auto menu_builder = Gtk::Builder::create_from_resource("/org/gtkmm/exampleapp/gears_menu.ui");
auto menu = menu_builder-&gt;get_object&lt;Gio::MenuModel&gt;("menu");
m_gears-&gt;set_menu_model(menu);
add_action(m_settings-&gt;create_action("show-words"));
</code></programlisting>

<para>
What our application looks like now:
</para>

<figure xml:id="figure-buildapp-side-bar">
  <title>Adding a side bar</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_side_bar.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step7">Source Code</link></para> <!-- Insert gears_menu.ui window.ui org.gtkmm.exampleapp.gschema.xml -->

</section>

<section xml:id="sec-buildapp-properties">
<title>Properties</title>

<para>
Widgets and other objects have many useful properties. Here we show some ways to use
them in new and flexible ways, by wrapping them in actions with <classname>Gio::PropertyAction</classname>
or by binding them with <classname>Glib::Binding</classname>.
</para>

<para>
To set this up, we add two labels to the header bar in our <filename>window.ui</filename> file,
named <literal>lines_label</literal> and <literal>lines</literal>, and get pointers to them
in the application window's constructor, as we've seen a couple of times by now.
We add a new "Lines" menu item to the gears menu, which triggers the
<literal>show-lines</literal> action.
</para>

<para>
To make this menu item do something, we create a property action for the <literal>visible</literal>
property of the <literal>lines</literal> label, and add it to the actions of the window.
The effect of this is that the visibility of the label gets toggled every time the action
is activated.
Since we want both labels to appear and disappear together, we bind the <literal>visible</literal>
property of the <literal>lines_label</literal> widget to the same property of the
<literal>lines</literal> widget.
In <classname>ExampleAppWindow</classname>'s constructor:
</para>
<programlisting><code>add_action(Gio::PropertyAction::create("show-lines", m_lines-&gt;property_visible()));
m_binding_lines_visible = Glib::Binding::bind_property(m_lines-&gt;property_visible(),
  m_lines_label-&gt;property_visible());

</code></programlisting>

<para>
We also need a function that counts the lines of the currently active tab, and updates
the <literal>lines</literal> label. See the full source if you are interested in the details.
</para>

<para>
This brings our example application to this appearance:
</para>

<figure xml:id="figure-buildapp-properties">
  <title>Properties</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_properties.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para><link xlink:href="&url_examples_base;buildapp/step8">Source Code</link></para> <!-- Insert gears_menu.ui window.ui -->

</section>

<section xml:id="sec-buildapp-header-bar">
<title>Header bar</title>

<para>
Our application already uses a <classname>Gtk::HeaderBar</classname> instead of
a 'normal' window titlebar. The header bar is a direct child of the window,
and its type is <literal>titlebar</literal>. This is set in the
<filename>window.ui</filename> file.
</para>

<para>
Here we'll just make two small changes to the header bar. The <literal>decoration-layout</literal>
property is set in the <filename>window.ui</filename> file, to show only the close
button, and hide the minimize and maximize buttons. We also include an icon in the
resource file, and set up this icon as the window icon.
In <classname>ExampleAppWindow</classname>'s constructor:
</para>
<programlisting><code>Gtk::IconTheme::get_for_display(get_display())-&gt;add_resource_path("/org/gtkmm/exampleapp");
set_icon_name("exampleapp");

</code></programlisting>

<para>
Here is how the application now looks:
</para>

<figure xml:id="figure-buildapp-header-bar">
  <title>Header bar</title>
  <screenshot>
    <mediaobject><imageobject><imagedata format="PNG" fileref="&url_figures_base;buildapp_header_bar.png"/></imageobject></mediaobject>
  </screenshot>
</figure>

<para>
The <filename>window.ui</filename> file sets a header bar title, but this title is not shown.
That's because the stack switcher is a child of type <literal>title</literal>. The stack
switcher becomes a custom title that hides the title label.
</para>

<para><link xlink:href="&url_examples_base;buildapp/step9">Source Code</link></para> <!-- Insert exampleapp.gresource.xml window.ui -->

</section>

</chapter>

<chapter xml:id="chapter-contributing">
<title>Contributing</title>

<para>
This document, like so much other great software out there, was
created for free by volunteers. If you are at all knowledgeable about
any aspect of &gtkmm; that does not already have documentation, please
consider contributing to this document.
</para>
<para>
Ideally, we would like you to <link xlink:href="https://gitlab.gnome.org/GNOME/gtkmm-documentation/-/merge_requests">
provide a merge request</link> to the <filename>docs/tutorial/C/index-in.docbook</filename> file.
This file is in the <literal>gtkmm-documentation</literal> module in GNOME git.
</para>

<para>
If you do decide to contribute, please post your contribution as an issue or merge request
to <link xlink:href="https://gitlab.gnome.org/GNOME/gtkmm-documentation">GitLab</link>.
You can also discuss your ideas on GNOME's <link xlink:href="https://discourse.gnome.org">Discourse</link>
instance, under the <link xlink:href="https://discourse.gnome.org/c/platform/language-bindings">
Platform/Language bindings</link> category with a <literal>cplusplus</literal> tag.
Also, be aware that the entirety of this document is free, and any addition you provide
must also be free. That is, people must be able to use any portion of
your examples in their programs, and copies of this document
(including your contribution) may be distributed freely.
</para>

</chapter>

<appendix xml:id="chapter-refptr">
<title>The RefPtr smartpointer</title>

<para>
<classname>Glib::RefPtr</classname> is a smartpointer. Specifically, it is a
reference-counting smartpointer. You might be familiar with
<classname>std::unique_ptr&lt;&gt;</classname>
and <classname>std::shared_ptr&lt;&gt;</classname>, which are also smartpointers.
In &gtkmm;-4.0 <classname>Glib::RefPtr&lt;&gt;</classname> is an alias for
<classname>std::shared_ptr&lt;&gt;</classname>,
which is reference-counting. <classname>Glib::RefPtr&lt;&gt;</classname> was introduced
long before there was a reference-counting smartpointer in the &cpp; Standard Library.
</para>

<para>
If you make your own <classname>Glib::ObjectBase</classname>-derived classes with
<methodname>create()</methodname> methods that return a <classname>Glib::RefPtr</classname>,
you must use <function>Glib::make_refptr_for_instance()</function> in your
<methodname>create()</methodname> methods. This function creates a <classname>std::shared_ptr</classname>
with a special deleter, which handles the reference-count for the wrapped C object.
</para>

<para>
<classname>Glib::RefPtr</classname> is not used for storing widgets derived from
<classname>Gtk::Widget</classname>. Widgets have public constructors instead of
protected constructors and <methodname>create()</methodname> methods.
</para>

<para><link xlink:href="&url_refdocs_base_glib_html;group__RefPtr.html">Reference</link></para>

<para>A smartpointer acts much like a normal pointer. Here are a few examples.</para>

<section xml:id="sec-refptr-copying">
<title>Copying</title>
<para>
You can copy <classname>RefPtr</classname>s, just like normal pointers. But
unlike normal pointers, you don't need to worry about deleting the underlying
instance.
</para>
<programlisting><code>auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
auto refPixbuf2 = refPixbuf;
</code></programlisting>
<para>
Of course this means that you can store <classname>RefPtr</classname>s in
standard containers, such as <classname>std::vector</classname> or
<classname>std::list</classname>.</para>
<programlisting><code>std::list&lt;Glib::RefPtr&lt;Gdk::Pixbuf&gt;&gt; listPixbufs;
auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
listPixbufs.push_back(refPixbuf);
</code></programlisting>
</section>

<section xml:id="sec-refptr-dereferencing">
<title>Dereferencing</title>
<para>You can dereference a smartpointer with the -&gt; operator, to
call the methods of the underlying instance, just like a normal pointer.
</para>
<programlisting><code>auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
auto width = refPixbuf-&gt;get_width();
</code></programlisting>
<para>You can also use the * operator and the <methodname>get()</methodname> method
to access the underlying instance, but it's usually a bad idea to do so. Unless
you are careful, you can end up with a pointer or a reference which is not included
in the reference count.
</para>
<programlisting><code>auto refPixbuf = Gdk::Pixbuf::create_from_file(filename);
auto&amp; underlying = *refPixbuf; // Possible, but not recommended
</code></programlisting>
</section>

<section xml:id="sec-refptr-casting">
<title>Casting</title>
<para>
You can cast <classname>RefPtr</classname>s to base types, just like normal
pointers.
</para>
<programlisting><code>auto refStore = Gtk::TreeStore::create(columns);
Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;
</code></programlisting>
<para>This means that any method which takes a <type>const
Glib::RefPtr&lt;BaseType&gt;&amp;</type> argument can also take a
<type>const Glib::RefPtr&lt;DerivedType&gt;&amp;</type>. The cast is
implicit, just as it would be for a normal pointer.</para>
<para>You can also cast to a derived type, but the syntax is
a little different than with a normal pointer.
</para>
<programlisting><code>auto refStore = std::dynamic_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);
auto refStore2 = std::static_pointer_cast&lt;Gtk::TreeStore&gt;(refModel);
</code></programlisting>
</section>

<section xml:id="sec-refptr-checking-for-null">
<title>Checking for nullptr</title>
<para>
Just like normal pointers, you can check whether a
<classname>RefPtr</classname> points to anything.
</para>
<programlisting><code>auto refModel = m_TreeView.get_model();
if (refModel)
{
  auto cols_count = refModel-&gt;get_n_columns();
  ...
}
</code></programlisting>
<para>
But unlike normal pointers, <classname>RefPtr</classname>s are automatically
initialized to <literal>nullptr</literal> so you don't need to remember to do that yourself.
</para>
</section>

<section xml:id="sec-refptr-constness">
<title>Constness</title>
<para>
The use of the <literal>const</literal> keyword in &cpp; is not always clear. You
might not realize that <type>const Something*</type> declares a pointer to a
<type>const Something</type>. The pointer can be changed, but not the
<type>Something</type> that it points to.
</para>
<para>
Therefore, the <classname>RefPtr</classname> equivalent of
<type>Something*</type> for a method parameter is <type>const
    Glib::RefPtr&lt;Something&gt;&amp;</type>, and the equivalent of
<type>const Something*</type> is <type>const Glib::RefPtr&lt;const
    Something&gt;&amp;</type>.
</para>
<para>
The <literal>const ... &amp;</literal> around both is just for efficiency, like
using <classname>const std::string&amp;</classname> instead of
<classname>std::string</classname> for a method parameter to avoid unnecessary
copying.
</para>
</section>

</appendix>

<appendix xml:id="chapter-signals">
<title>Signals</title>

<section xml:id="sec-connecting-signal-handlers">
<title>Connecting signal handlers</title>

<para>
&gtkmm; widget classes have signal accessor methods, such as
<methodname>Gtk::Button::signal_clicked()</methodname>, which allow you to connect
your signal handler. Thanks to the flexibility of
<application>libsigc++</application>, the callback library used by &gtkmm;, the
signal handler can be almost any kind of function, but you will probably want
to use a class method. Among <application>GTK</application> C coders, these
signal handlers are often named callbacks.
</para>

<para>
Here's an example of a signal handler being connected to a signal:
</para>

<programlisting><code><![CDATA[
#include <gtkmm/button.h>

void on_button_clicked()
{
  std::cout << "Hello World" << std::endl;
}

class some_class
{
public:
  some_class
  {
    button.signal_clicked().connect(sigc::ptr_fun(&on_button_clicked));
  }
private:
  Gtk::Button button {"Hello World"};
};
]]></code></programlisting>

<para>
There's rather a lot to think about in this (non-functional) code.
First let's identify the parties involved:
</para>

<itemizedlist>
<listitem>

<para>
The signal handler is <methodname>on_button_clicked()</methodname>.
</para>
</listitem>
<listitem>

<para>
We're hooking it up to the <classname>Gtk::Button</classname> object called
<varname>button</varname>.
</para>
</listitem>
<listitem>

<para>
When the Button emits its <literal>clicked</literal> signal,
<methodname>on_button_clicked()</methodname> will be called.
</para>
</listitem>

</itemizedlist>

<para>
Now let's look at the connection again:
</para>

<programlisting><code>    ...
    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));
    ...
</code></programlisting>

<para>
Note that we don't pass a pointer to <methodname>on_button_clicked()</methodname>
directly to the signal's <methodname>connect()</methodname> method. Instead, we
call <function>sigc::ptr_fun()</function>, and pass the result to
<methodname>connect()</methodname>.
</para>

<para>
<function>sigc::ptr_fun()</function>  generates a <classname>sigc::slot</classname>.
A slot is an object which
looks and feels like a function, but is actually an object. These are also
known as function objects, or functors.
<function>sigc::ptr_fun()</function> generates a slot for a standalone function or static method.
<function>sigc::mem_fun()</function> generates a slot for a member method of a particular instance.
</para>

<para>
A &cpp; lambda expression is a functor which can be implicitly converted to a
<classname>sigc::slot</classname> in the call to <methodname>connect()</methodname>.
A lambda expression can be used instead of <function>sigc::ptr_fun()</function>.
It's also possible to use a lambda expression instead of <function>sigc::mem_fun()</function>,
but then you won't get automatic disconnection of the signal handler when a
<classname>sigc::trackable</classname>-derived object goes out of scope.
</para>

<para>
Here's a slightly larger example of slots in action:
</para>

<programlisting><code><![CDATA[
#include <gtkmm/button.h>

void on_button_clicked()
{
  std::cout << "Hello World" << std::endl;
}

class some_class
{
public:
  some_class
  {
    button.signal_clicked().connect(sigc::ptr_fun(&on_button_clicked));
    button.signal_clicked().connect(sigc::mem_fun(*this, &some_class::on_button_clicked));
  }
  void on_button_clicked();
private:
  Gtk::Button button {"Hello World"};
};
]]></code></programlisting>

<para>
The first call to <methodname>connect()</methodname> is just like the one we saw
last time; nothing new here.</para>
<para>The next is more interesting.
<function>sigc::mem_fun()</function> is called with two arguments. The first
argument is <parameter>*this</parameter>, which is the object that our
new slot will be pointing at. The second argument is a pointer to one of its
methods. This particular version of <function>sigc::mem_fun()</function>
creates a slot which will, when "called", call the pointed-to method of the
specified object.
</para>

<para>
Another thing to note about this example is that we made the call to
<methodname>connect()</methodname> twice for the same signal object. This is
perfectly fine - when the button is clicked, both signal handlers will be
called.
</para>

<para>
We just told you that the button's <literal>clicked</literal> signal is expecting
to call a method with no arguments. All signals have
requirements like this - you can't hook a function with two arguments
to a signal expecting none (unless you use an adapter, such as
<function>sigc::bind()</function>, of course). Therefore, it's important to
know what type of signal handler you'll be expected to connect to a given
signal.
</para>
</section>

<section xml:id="sec-writing-signal-handlers">
<title>Writing signal handlers</title>

<para>
To find out what type of signal handler you can connect to a signal, you can
look it up in the reference documentation or the header file. Here's an example of a signal declaration you
might see in the &gtkmm; headers:
</para>

<programlisting><code>Glib::SignalProxy&lt;bool(Gtk::DirectionType)&gt; signal_focus()
</code></programlisting>

<para>
Other than the signal's name (<literal>focus</literal>), the template arguments are
important to note here. The first argument, <type>bool</type>, is the type that
the signal handler should return; and the type within parentheses,
<type>Gtk::DirectionType</type>, is the type of this signal's first, and only,
argument. By looking at the reference documentation, you can
see the names of the arguments too.
</para>

<para>
The same principles apply for signals which have more arguments. Here's one
with three (taken from <filename>&lt;gtkmm/textbuffer.h&gt;</filename>):
</para>

<programlisting><code>Glib::SignalProxy&lt;void(TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int)&gt; signal_insert();
</code></programlisting>

<para>
It follows the same form. The first type is <type>void</type>, so that should be
our signal handler's return type.
The following three types are the argument types, in order. Our signal
handler's prototype could look like this:
</para>

<programlisting><code>void on_insert(TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)
</code></programlisting>
</section>

<section xml:id="sec-disconnecting-signal-handlers">
<title>Disconnecting signal handlers</title>

<para>
Let's take another look at a Signal's <literal>connect</literal> method:
</para>

<programlisting><code>sigc::connection signal&lt;void(int)&gt;::connect(const sigc::slot&lt;void(int)&gt;&amp;);
</code></programlisting>

<para>
The returned <classname>sigc::connection</classname> can be used to control the
connection. By keeping a connection object you can disconnect its associated signal
handler using the <methodname>sigc::connection::disconnect()</methodname> method.
</para>

</section>
<section xml:id="sec-overriding-default-signal-handlers">
<title>Overriding default signal handlers</title>

<para>
So far we've told you to perform actions in
response to button-presses and the like by handling signals.
That's certainly a good way to do things, but it's not the only
way.
</para>

<para>
Instead of laboriously connecting signal handlers to signals,
you can simply make a new class which inherits from a widget - say, a
Button - and then override the default signal handler, such as Button::on_clicked(). This can be a
lot simpler than hooking up signal handlers for everything.
</para>

<para>
Subclassing isn't always the best way to accomplish
things. It is only useful when you want the widget to handle its own signal by itself. If you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects.
</para>

<para>
&gtkmm; classes are designed with overriding in mind; they contain
virtual member methods specifically intended to be overridden.
</para>

<para>
Let's look at an example of overriding:
</para>

<programlisting><code>#include &lt;gtkmm/button.h&gt;

class OverriddenButton : public Gtk::Button
{
protected:
  void on_clicked() override;
}

void OverriddenButton::on_clicked()
{
  std::cout &lt;&lt; "Hello World" &lt;&lt; std::endl;

  // call the base class's version of the method:
  Gtk::Button::on_clicked();
}
</code></programlisting>

<para>
Here  we define a new class called <classname>OverriddenButton</classname>,
which inherits from <classname>Gtk::Button</classname>. The only thing we
change is the <methodname>on_clicked()</methodname> method, which is called
whenever <classname>Gtk::Button</classname> emits the
<literal>clicked</literal> signal. This method prints "Hello World" to
<literal>stdout</literal>, and then calls the original, overridden method, to
let <classname>Gtk::Button</classname> do what it would have done had we not
overridden.
</para>

<para>
You don't always need to call the parent's method; there are times
when you might not want to. Note that we called the parent method
<emphasis>after</emphasis> writing "Hello World", but we could have called it before.
In this simple example, it hardly matters much, but there are times
when it will. With connected signal handlers, it's not quite so easy to change details
like this, and you can do something here which you can't do at all
with connected signal handlers: you can call the parent method in the <emphasis>middle</emphasis> of
your custom code.
</para>

</section>

<section xml:id="sec-binding-extra-arguments">
<title>Binding extra arguments</title>

<para>
If you use one signal handler to catch the same signal from several widgets,
you might like that signal handler to receive some extra information. For
instance, you might want to know which button was clicked. You can do this with
<function>sigc::bind()</function>. Here's some code from the <link linkend="sec-helloworld2">helloworld2</link> example.
</para>
<programlisting><code>m_button1.signal_clicked().connect(sigc::bind(sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), "button 1"));
</code></programlisting>
<para>This says that we want the signal to send an extra
<classname>Glib::ustring</classname> argument to the signal handler, and that
the value of that argument should be "button 1". Of course we will need to add
that extra argument to the declaration of our signal handler:
</para>
<programlisting><code>void on_button_clicked(const Glib::ustring&amp; data);
</code></programlisting>
<para>Of course, a normal "clicked" signal handler would have no arguments.
</para>
<para>
<function>sigc::bind()</function> is not commonly used, but you might find it
helpful sometimes. If you are familiar with <application>GTK</application>
programming then you have probably noticed that this is similar to the extra
<literal>gpointer data</literal> arguments which all GTK callbacks have. This
is generally overused in <application>GTK</application> to pass information
that should be stored as member data in a derived widget, but widget derivation
is very difficult in C. We have far less need of this hack in &gtkmm;.
</para>
</section>

<section xml:id="sec-eventsignals">
<title>Event signals</title>

<para>
Event signals are emitted as a result of some user input, for instance a key press
or a mouse motion. Usually you don't handle these events directly. Instead, you use
a subclass of <classname>Gtk::EventController</classname>, such as <classname>Gtk::EventControllerKey</classname>
or <classname>Gtk::GestureClick</classname>. Event controllers can be added to a
widget with <methodname>Gtk::Widget::add_controller()</methodname>.
</para>
<para>
You might occasionally find it useful to handle events when there's something
you can't accomplish with normal signals. <classname>Gtk::Button</classname>,
for example, does not send mouse-pointer coordinates with its
<literal>clicked</literal> signal, but you could handle
<methodname>Gtk::GestureClick::signal_pressed()</methodname> if you needed this
information. <methodname>Gtk::EventControllerKey::signal_key_pressed()</methodname>
is often used to handle key-presses.
</para>

<para>
Some event controller signals behave slightly differently. The value returned from
the signal handler indicates whether it has fully "handled" the event. If the value
is <literal>false</literal> then &gtkmm; will pass the event on to the next
signal handler. If the value is <literal>true</literal> then no other signal handlers
will need to be called.
</para>

<para>
Handling an event doesn't affect the Widget's other signals. If you handle
<methodname>Gtk::GestureClick::signal_pressed()</methodname> for
<classname>Gtk::Button</classname>, you'll still be able to get the
<literal>clicked</literal> signal. They are emitted at (nearly) the same time.
</para>

<para>
Here's a simple example:</para>
<programlisting><code>void on_button_press(int n_press, double x, double y);
Gtk::Button button("label");
auto controller = Gtk::GestureClick::create();
controller->set_propagation_phase(Gtk::PropagationPhase::CAPTURE);
controller->signal_pressed().connect(sigc::ptr_fun(&amp;on_button_press));
button.add_controller(controller);
</code></programlisting>
<para>
When the mouse is over the button and a mouse button is pressed,
<methodname>on_button_press()</methodname> will be called.
</para>
<para>
The call to <methodname>set_propagation_phase()</methodname> is necessary in
this case because the <classname>GtkButton</classname> C class adds an event
controller, handling button clicks in the capture phase. <classname>GtkButton</classname>
claims the event, meaning that the event is not propagated in the bubble phase,
where event controllers handle events by default.
</para>

<section xml:id="signal-handler-sequence">
<title>Signal Handler sequence</title>

<para>By default, signal handlers that return <type>void</type> are called after
any previously-connected signal handlers. However, this can be a problem with
event signals that can stop event propagation by returning <literal>true</literal>.
For instance, the existing signal handlers, or the default signal handler, might return
<literal>true</literal> to stop other signal handlers from being called.
To specify that your signal handler should be called before the other signal handlers,
you can specify <literal>false</literal> for the <literal>after</literal> parameter.
This <methodname>connect()</methodname> parameter is optional, if the signal handler
returns <type>void</type>. For instance,
</para>
<programlisting><code>key_controller->signal_key_pressed().connect(sigc::ptr_fun(&amp;on_mywindow_key_pressed), false);
</code></programlisting>
<para>The event is propagated between widgets in 3 phases.
<orderedlist inheritnum="ignore" continuation="restarts">
<listitem><simpara>Capture phase - runs from the toplevel down to the event widget.</simpara></listitem>
<listitem><simpara>Target phase - runs only on the event widget.</simpara></listitem>
<listitem><simpara>Bubble phase - runs from the event widget up to the toplevel.</simpara></listitem>
</orderedlist>
</para>
<para>
The <link xlink:href="https://docs.gtk.org/gtk4/input-handling.html">Input Handling</link>
chapter in the GTK documentation describes user input handling in more detail.
</para>
</section>

</section>

<section xml:id="sec-exceptions-in-signal-handlers">
<title>Exceptions in signal handlers</title>

<para>
When a program is aborted because of an unhandled &cpp; exception, it's sometimes
possible to use a debugger to find the location where the exception was thrown.
This is more difficult than usual if the exception was thrown from a signal handler.
</para>
<para>
This section describes primarily what you can expect on a Linux system, when you
use <link xlink:href="http://www.gnu.org/software/gdb/">the gdb debugger</link>.
</para>
<para>
First, let's look at a simple example where an exception is thrown from a normal
function (no signal handler).
</para>
<programlisting><code>// without_signal.cc
#include &lt;gtkmm.h&gt;

bool throwSomething()
{
  throw "Something";
  return true;
}

int main(int argc, char** argv)
{
  throwSomething();
  auto app = Gtk::Application::create("org.gtkmm.without_signal");
  return app-&gt;run();
}
</code></programlisting>
<para>
Here is an excerpt from a <application>gdb</application> session. Only the most
interesting parts of the output are shown.
</para>
<programlisting><code>&gt; gdb without_signal
(gdb) run
terminate called after throwing an instance of 'char const*'

Program received signal SIGABRT, Aborted.
(gdb) backtrace
#7  0x08048864 in throwSomething () at without_signal.cc:6
#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12
</code></programlisting>
<para>You can see that the exception was thrown from <filename>without_signal.cc</filename>,
line 6 (<code>throw "Something";</code>).
</para>
<para>
Now let's see what happens when an exception is thrown from a signal handler.
Here's the source code.
</para>
<programlisting><code>// with_signal.cc
#include &lt;gtkmm.h&gt;

bool throwSomething()
{
  throw "Something";
  return true;
}

int main(int argc, char** argv)
{
  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);
  auto app = Gtk::Application::create("org.gtkmm.with_signal");
  app-&gt;hold();
  return app-&gt;run();
}
</code></programlisting>
<para>
And here's an excerpt from a <application>gdb</application> session.
</para>
<programlisting><code>&gt; gdb with_signal
(gdb) run
(with_signal:2703): glibmm-ERROR **:
unhandled exception (type unknown) in signal handler

Program received signal SIGTRAP, Trace/breakpoint trap.
(gdb) backtrace
#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77
#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150
#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212
#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178
#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16
</code></programlisting>
<para>The exception is caught in <application>glibmm</application>, and the program
ends with a call to <function>g_error()</function>. Other exceptions may result
in different behavior, but in any case the exception from a signal handler is
caught in <application>glibmm</application> or &gtkmm;, and
<application>gdb</application> can't see where it was thrown.
</para>
<para>
To see where the exception is thrown, you can use the <application>gdb</application>
command <userinput>catch throw</userinput>.
</para>
<programlisting><code>&gt; gdb with_signal
(gdb) catch throw
Catchpoint 1 (throw)
(gdb) run
Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()
(gdb) backtrace
#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#1  0x08048bd4 in throwSomething () at with_signal.cc:6
(gdb) continue
Continuing.
(with_signal:2375): glibmm-ERROR **
unhandled exception (type unknown) in signal handler

Program received signal SIGTRAP, Trace/breakpoint trap.
</code></programlisting>
<para>
If there are many caught exceptions before the interesting uncaught one, this
method can be tedious. It can be automated with the following
<application>gdb</application> commands.
</para>
<programlisting><code>(gdb) catch throw
(gdb) commands
(gdb)   backtrace
(gdb)   continue
(gdb)   end
(gdb) set pagination off
(gdb) run
</code></programlisting>
<para>These commands will print a backtrace from each <code>throw</code> and continue.
The backtrace from the last (or possibly the last but one) <code>throw</code>
before the program stops, is the interesting one.
</para>
</section>

</appendix>

<appendix xml:id="chapter-custom-signals">
<title>Creating your own signals</title>

<para>
Now that you've seen signals and signal handlers in &gtkmm;, you
might like to use the same technique to allow interaction between your
own classes. That's actually very simple by using the
<application>libsigc++</application> library directly.
</para>
<para>
This isn't purely a &gtkmm; or GUI issue. &gtkmm; uses
<application>libsigc++</application> to implement its proxy wrappers for the
<application>GTK</application> signal system, but for new,
non-GTK signals, you can create pure &cpp; signals, using the
<classname>sigc::signal&lt;&gt;</classname> template.
</para>
<para>
For instance, to create a signal that sends 2 parameters, a <type>bool</type>
and an <type>int</type>, just declare a <classname>sigc::signal</classname>,
like so:
</para>
<programlisting><code>sigc::signal&lt;void(bool, int)&gt; signal_something;
</code></programlisting>
<para>
You could just declare that signal as a public member variable, but
some people find that distasteful and prefer to make it available via
an accessor method, like so:
</para>
<programlisting><code>class Server
{
public:
  //signal accessor:
  using type_signal_something = sigc::signal&lt;void(bool, int)&gt;;
  type_signal_something signal_something();

protected:
  type_signal_something m_signal_something;
};

Server::type_signal_something Server::signal_something()
{
  return m_signal_something;
}
</code></programlisting>

<para>
You can then connect to the signal using the same syntax used when
connecting to &gtkmm; signals. For instance,
</para>
<programlisting><code>server.signal_something().connect(
  sigc::mem_fun(client, &amp;Client::on_server_something) );
</code></programlisting>

<section xml:id="chapter-custom-signals-example">
<title>Example</title>

<para>
This is a full working example that defines and uses custom signals.
</para>

<para><link xlink:href="&url_examples_base;signals/custom/">Source Code</link></para>

</section>

</appendix>


<appendix xml:id="sec-signals-comparison">
<title>Comparison with other signalling systems</title>

<para>
<!-- TODO: Rewrite this paragraph and talk about Qt's moc. -->
(An aside: <application>GTK</application> calls this scheme "signalling"; the
sharp-eyed reader with GUI toolkit experience will note that this same design
is often
seen under the name of "broadcaster-listener" (e.g., in Metrowerks'
PowerPlant framework for the Macintosh). It works in much the same
way: one sets up <literal>broadcasters</literal>, and then connects
<literal>listeners</literal> to them; the broadcaster keeps a list of the
objects listening to it, and when someone gives the broadcaster a
message, it calls all of its objects in its list with the message. In
&gtkmm;, signal objects play the role of broadcasters, and slots
play the role of listeners - sort of. More on this later.)
</para>
<para>
&gtkmm; signal handlers are strongly-typed, whereas
<application>GTK</application> C code allows you to connect a callback with
the wrong number and type of arguments, leading to a segfault at runtime. And,
unlike <application>Qt</application>, &gtkmm; achieves this without modifying
the &cpp; language.</para>
<para>
Re. Overriding signal handlers: You can do this in the straight-C world of GTK too; that's what GTK's
object system is for. But in GTK, you have to go through some
complicated procedures to get object-oriented features like
inheritance and overloading. In &cpp;, it's simple, since those
features are supported in the language itself; you can let the
compiler do the dirty work.
</para>
<para>
This is one of the places where the beauty of &cpp; really comes out.
One wouldn't think of subclassing a GTK widget simply to override its
action method; it's just too much trouble. In GTK, you almost always
use signals to get things done, unless you're writing a new widget.
But because overriding methods is so easy in &cpp;, it's entirely
practical - and sensible - to subclass a button for that purpose.
</para>
</appendix>

<appendix xml:id="sec-windows-installation">
<title>&gtkmm; and Win32</title>
    <para>
      One of the major advantages of &gtkmm; is that it is crossplatform. &gtkmm; programs written on other platforms such as
      GNU/Linux can generally be transferred to Windows (and vice
      versa) with few modifications to the source.
    </para>
    <para>
      &gtkmm; currently works with the
      <link xlink:href="http://mingw.org/">MinGW/GCC compiler</link> with a compiler version
      that supports <phrase role="nowrap">C++17</phrase>, such as gcc 7 or later. It also works with Microsoft
      Visual &cpp; 2017 15.7.x or later (including the freely available express/community
      editions) on the Windows platform. There is an
      <link xlink:href="https://download.gnome.org/binaries/win32/gtkmm">installer</link>
      available for &gtkmm; on Microsoft Windows, but as of this writing
      (December 2024) it only contains an installer for gtkmm2.
      Please be aware that although normally it is fine to mix builds done with
      Visual Studio 2017 and 2019, please do not do so when building
      &gtkmm; with its -mm dependencies.
    </para>
    <para>There are README files, describing how to build &gtkmm; and its dependencies
      on Windows:
    </para>
    <itemizedlist>
    <listitem>
    <para>libsigc++: <link xlink:href="https://github.com/libsigcplusplus/libsigcplusplus/blob/master/MSVC_NMake/MSVC-Builds.md">MSVC_NMake/MSVC-Builds.md</link></para>
    </listitem>
    <listitem>
    <para>glibmm: <link xlink:href="https://gitlab.gnome.org/GNOME/glibmm/tree/master/README.win32.md">README.win32.md</link></para>
    </listitem>
    <listitem>
    <para>cairomm: <link xlink:href="https://gitlab.freedesktop.org/cairo/cairomm/-/blob/master/MSVC_NMake/MSVC-Builds.md">MSVC_NMake/MSVC-Builds.md</link></para>
    </listitem>
    <listitem>
    <para>pangomm: <link xlink:href="https://gitlab.gnome.org/GNOME/pangomm/tree/master/README.win32.md">README.win32.md</link></para>
    </listitem>
    <listitem>
    <para>gtkmm: <link xlink:href="&url_gtkmm_base;README.win32.md">README.win32.md</link>,
      <link xlink:href="&url_gtkmm_base;MSVC_NMake/README">MSVC_NMake/README</link></para>
    </listitem>
    </itemizedlist>
</appendix>

<appendix xml:id="chapter-working-with-source">
<title>Working with gtkmm's Source Code</title>
  <para>
    If you are interested in helping out with the development of &gtkmm;, or
    fixing a bug in &gtkmm;, you'll probably need to build the development
    version of &gtkmm;. However, you should not install a development version over
    your stable version. Instead, you should install it alongside your existing &gtkmm;
    installation, in a separate path.
  </para>
  <para>
    The easiest way to do this is using <link xlink:href="https://wiki.gnome.org/Projects/Jhbuild">jhbuild</link>.
    <application>jhbuild</application> is a program that makes building GNOME
    software much easier by calculating dependencies and building things in the
    correct order. This section will give a brief explanation of how to set up
    <application>jhbuild</application> to build and install &gtkmm; from the
    source repository (git). For up-to-date information
    on <application>jhbuild</application>, please refer to the <link xlink:href="https://gnome.pages.gitlab.gnome.org/jhbuild/">jhbuild manual</link>.
  </para>
  <note>
    <para>
    Note that to build &gtkmm; from git, you'll often need to build many of its
    dependencies from git as well. <application>jhbuild</application> makes
    this easier than it would normally be, but it will take quite a while to
    build and install them all. You will probably encounter build problems,
    though these will usually be corrected quickly if you report them.
    </para>
  </note>
  <para>
    <application>gnome-build-meta</application> is an alternative to
    <application>jhbuild</application>. It is described at the
    <link xlink:href="https://wiki.gnome.org/Newcomers/BuildSystemComponent">Building system components</link>
    wiki page, but here we concentrate on <application>jhbuild</application>.
  </para>
  <section xml:id="sec-setting-up-jhbuild">
  <title>Setting up jhbuild</title>

    <para>
      To set up <application>jhbuild</application>, follow the basic
      installation instructions from the <link xlink:href="https://gnome.pages.gitlab.gnome.org/jhbuild/">jhbuild manual</link>.
      After you have installed <application>jhbuild</application>, you
      should copy the sample <application>jhbuild</application> configuration
      file into your home directory by executing the following command from the
      <application>jhbuild</application> directory:
      <screen>$ cp examples/sample.jhbuildrc ~/.config/jhbuildrc</screen>
    </para>
    <para>
      The &gtkmm; module is defined in the
      <filename>gnome-suites-core-deps-latest.modules</filename> moduleset. So edit your
      <filename>jhbuildrc</filename> file and set your moduleset setting like so:
    </para>
    <programlisting><code>moduleset = 'gnome-suites-core-deps-latest'</code></programlisting>
    <para>
      After setting the correct moduleset, you need to tell
      <application>jhbuild</application> which module or modules to build. To
      build &gtkmm; and all of its dependencies, set <varname>modules</varname>
      like so:
    </para>
    <programlisting><code>modules = [ 'gtkmm' ]</code></programlisting>
    <para>
      You can build several modules by setting the
      <varname>modules</varname> variable to a meta-package, e.g.
      <literal>meta-gnome-core</literal>, or listing more than one module name.
      The <varname>modules</varname> variable specifies which modules will be
      built when you don't explicitly specify anything on the command line. You
      can always build a different moduleset later by specifying it on the
      commandline (e.g. <command>jhbuild build gtkmm</command>).
    </para>
    <important>
      <title>Setting a prefix</title>
      <para>
        By default, <application>jhbuild</application>'s configuration is
        configured to install all software built with
        <application>jhbuild</application> under the
        <filename>~/jhbuild/install</filename> prefix. You can choose a different
        prefix, but it is recommended that you keep this prefix different from
        other software that you've installed (don't set it to
        <filename>/usr</filename>!) If you've followed the jhbuild instructions
        then this prefix belongs to your user, so you don't need to run jhbuild
        as <literal>root</literal>.
      </para>
    </important>
    <para>
      You should also set <varname>buildroot</varname> in <filename>jhbuildrc</filename>.
      <application>jhbuild</application> builds &gtkmm; and many of its dependencies
      with Meson. Meson does not allow building in the source tree.
      <application>jhbuild</application>'s default action is to build in a
      <filename>build</filename> directory directly below the source root directory.
      Some modules have a <filename>build</filename> directory with files
      used when building with Autotools. Those files can be destroyed if you
      let <application>jhbuild</application> build in that directory.
    </para>
    <para>
      When you downloaded <application>jhbuild</application> from the git repository,
      you got a number of <filename>.modules</filename> files, specifying
      dependencies between modules. By default <application>jhbuild</application>
      does not use the downloaded versions of these files, but reads the
      latest versions in the git repository. This is usually what you want.
      If you don't want it, use the <varname>use_local_modulesets</varname>
      variable in <filename>jhbuildrc</filename>.
    </para>
  </section>
  <section xml:id="sec-installing-jhbuild">
  <title>Installing and Using the git version of &gtkmm;</title>

    <para>
      Once you've configured <application>jhbuild</application> as described
      above, building &gtkmm; should be relatively straightforward. The first
      time you run <application>jhbuild</application>, you should run the
      following sequence of commands to ensure that
      <application>jhbuild</application> has the required tools and verify that
      it is set up correctly:
      <screen>$ jhbuild bootstrap
$ jhbuild sanitycheck</screen>
    </para>
    <section xml:id="jhbuild-installing-gtkmm">
    <title>Installing &gtkmm; with <application>jhbuild</application></title>

      <para>
        If everything worked correctly, you should be able to build &gtkmm; and
        all of its dependencies from git by executing <command>jhbuild
          build</command> (or, if you didn't specify &gtkmm; in the
        <varname>modules</varname> variable, with the command <command>jhbuild
          build gtkmm</command>).
      </para>
      <para>
        This command will build and install a series of modules and will probably
        take quite a long time the first time through. After the first time,
        however, it should go quite a bit faster since it only needs to rebuild
        files that changed since the last build. Alternatively, after you've
        built and installed &gtkmm; the first time, you can rebuild &gtkmm; by
        itself (without rebuilding all of its dependencies) with the command
        <command>jhbuild buildone gtkmm</command>.
      </para>
    </section>
    <section xml:id="jhbuild-using-gtkmm">
    <title>Using the git version of &gtkmm;</title>

      <para>
        After you've installed the git version of &gtkmm;, you're ready to start
        using and experimenting with it. In order to use the new version of
        &gtkmm; you've just installed, you need to set some environment
        variables so that your <filename>configure</filename> or <filename>meson.build</filename>
        script knows where to find the new libraries. Fortunately,
        <application>jhbuild</application> offers an easy solution to this
        problem. Executing the command <command>jhbuild shell</command> will
        start a new shell with all of the correct environment variables set.
        Now if you re-configure and build your project just as you usually do,
        it should link against the newly installed libraries. To return to your
        previous environment, simply exit the <application>jhbuild</application>
        shell.
      </para>
      <para>
        Once you've built your software, you'll need to run your program within
        the jhbuild environment as well. To do this, you can again use the
        <command>jhbuild shell</command> command to start a new shell with the
        <application>jhbuild</application> environment set up. Alternatively,
        you can execute a one-off command in the
        <application>jhbuild</application> environment using the following
        command: <command>jhbuild run command-name</command>. In this case,
        the command will be run with the correct environment variables set, but
        will return to your previous environment after the program exits.
      </para>

    </section>
  </section>
</appendix>

<appendix xml:id="chapter-wrapping-c-libraries">
<title>Wrapping C Libraries with gmmproc</title>

<para>&gtkmm; uses the <command>gmmproc</command> tool to generate most of its
    source code, using .defs files that define the APIs of
    <classname>GObject</classname>-based libraries. So it's quite easy to create
    additional gtkmm-style wrappers of other glib/GObject-based
    libraries.</para>
<para>This involves a variety of tools, some of them crufty, but at least
    they work, and has been used successfully by several
    projects.</para>

<section xml:id="sec-wrapping-build-structure">
<title>The build structure</title>

<para>Generation of the source code for a gtkmm-style wrapper API requires use
    of tools such as <command>gmmproc</command> and
    <filename>generate_wrap_init.pl</filename>, which are included in
    <application>glibmm</application>. In theory you could write your
    own build files to use these appropriately, but a much better option is to
    make use of the build infrastructure provided by the <application>mm-common</application>
    module. To get started, it helps a lot to pick an existing binding module as an example
    to look at.</para>
<para>For instance, let's pretend that we are wrapping a C library called
    libsomething. It provides a <classname>GObject</classname>-based API with
    types named, for instance, <classname>SomeWidget</classname> and
    <classname>SomeStuff</classname>.</para>

<section xml:id="copying-skeleton-project">
<title>Copying the skeleton project</title>

<para>Typically our wrapper library would be called libsomethingmm. We can start by
  copying the <link xlink:href="https://gitlab.gnome.org/GNOME/mm-common/tree/master/skeletonmm">
  skeleton source tree</link> from the <application>mm-common</application> module.
  Starting with <application>mm-common</application> 1.0.0 this skeleton application
  is built with the <link xlink:href="https://mesonbuild.com/">Meson build system</link>.
</para>
<programlisting><code>  $ git clone https://gitlab.gnome.org/GNOME/mm-common.git
  $ cp -a mm-common/skeletonmm libsomethingmm
</code></programlisting>
<para>This provides a directory structure for the source .hg and .ccg files and the hand-written
  .h and .cc files, with <filename>meson.build</filename> files that can specify the
  various files in use, in terms of Meson variables. The directory structure usually
  looks like this, after we have renamed the directories appropriately:
<itemizedlist>
    <listitem><para><filename>libsomethingmm</filename>: The top-level directory.</para>
     <itemizedlist>
         <listitem><para><filename>libsomething</filename>: Contains the main include file and the pkg-config .pc file.</para>
         <itemizedlist>
             <listitem><para><filename>src</filename>: Contains .hg and .ccg source files.</para></listitem>
             <listitem><para><filename>libsomethingmm</filename>: Contains hand-written .h and .cc files.</para>
           </listitem>
         </itemizedlist>
       </listitem>
    </itemizedlist>
  </listitem>
</itemizedlist>
</para>

<para>As well as renaming the directories, we should rename some of the source
    files. For instance:</para>
<programlisting><code>$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \
    d="${f%/*}"; b="${f##*/}"; mv "$f" "$d/${b//skeleton/libsomething}"; \
  done
</code></programlisting>
<para>A number of the skeleton files must still be filled in with project-specific content later.
</para>
<para>Note that files ending in <filename>.in</filename> will be used to generate
    files with the same name but without the <filename>.in</filename> suffix, by
    replacing some variables with actual values during the configure stage.</para>
<para>Generated files are saved in the build tree, which is separated from the
    source tree when <command>meson</command> and <command>ninja</command> are used.</para>
</section>

<section xml:id="modifying-build-files">
<title>Modifying build files</title>

<para>Now we edit the files to adapt them to our needs. You might prefer to use a multiple-file
  search-replace utility for this, such as <command>regexxer</command>. Note that nearly all of the
  files provided with the skeleton source tree contain placeholder text. Thus, the substitutions
  should be performed globally, and not be limited to the Meson files.</para>
<para>All mentions of <varname>skeleton</varname> should be replaced by the correct name of the C
  library you are wrapping, such as "something" or "libsomething". In the same manner, all
  instances of <varname>SKELETON</varname> should be replaced by "SOMETHING" or "LIBSOMETHING", and
  all occurrences of <varname>Skeleton</varname> changed to "Something".</para>
<para>Likewise, replace all instances of <varname>Joe Hacker</varname> by the name of the intended
  copyright holder, which is probably you. Do the same for the <varname>joe@example.com</varname>
  email address.</para>

<section xml:id="modifying-top-meson.build">
<title>meson.build in the top-level directory</title>

<para>
  <itemizedlist>
    <listitem><para>It is common for binding modules to track the version number
        of the library they are wrapping. So, for instance, if the C library is
        at version 1.23.4, then the initial version of the binding module would
        be 1.23.0. However, avoid starting with an even minor version number as
        that usually indicates a stable release.</para></listitem>
    <listitem><para>In the <function>project()</function> function, change the
    license and the &cpp; version, if necessary.</para></listitem>
    <listitem><para>You probably need to add more required modules than
    <application>glibmm</application> and <application>skeleton</application>
    (<application>libsomething</application>).</para></listitem>
  </itemizedlist>
</para>
</section>

<section xml:id="modifying-other-meson.build">
<title>Other meson.build files</title>

<para>Next we must adapt the other <filename>meson.build</filename> files:
  <itemizedlist>
    <listitem><para><filename>skeleton/meson.build</filename>: Perhaps not much
    to change here more than the global name substitutions.</para>
    </listitem>
    <listitem><para><filename>skeleton/skeletonmm/meson.build</filename></para>
      <variablelist>
        <varlistentry>
          <term><varname>defs_basefiles</varname></term>
          <listitem><para>If we have more .defs and docs.xml files,
          we add them here.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>hg_ccg_basenames</varname></term>
          <listitem><para>We must mention all of our <filename>.hg</filename> and
          <filename>.ccg</filename> files here.</para></listitem>
        </varlistentry>
        <varlistentry>
          <term><varname>extra_cc_files, extra_h_files</varname></term>
          <listitem><para>Any additional hand-written <filename>.h</filename> and
          <filename>.cc</filename> source files go here.</para></listitem>
        </varlistentry>
      </variablelist>
    </listitem>
  </itemizedlist>
</para>
</section>

<section xml:id="creating-hg-ccg">
<title>Creating .hg and .ccg files</title>

<para>We should now create our first <filename>.hg</filename> and <filename>.ccg</filename> files,
  to wrap one of the objects in the C library. One pair of example source files already exists:
  <filename>skeleton.ccg</filename> and <filename>skeleton.hg</filename>. Create copies of these
  files as necessary.</para>
<para>In the <link linkend="sec-wrapping-hg-files">.hg and .ccg files</link>
  section you can learn about the syntax used in these files.</para>
</section>
</section>
</section>

<section xml:id="sec-wrapping-defs-files">
<title>Generating the .defs files.</title>

<para>The <filename>.defs</filename> files are text files, in a lisp format, that describe the API
  of a C library, including its
<itemizedlist>
  <listitem><para>objects (GObjects, widgets, interfaces, boxed-types and plain structs)</para></listitem>
  <listitem><para>functions</para></listitem>
  <listitem><para>enums</para></listitem>
  <listitem><para>signals</para></listitem>
  <listitem><para>properties</para></listitem>
  <listitem><para>vfuncs</para></listitem>
</itemizedlist>
</para>
<para>At the moment, we have separate tools for generating different parts of
  these <filename>.defs</filename>, so we split them up into separate files.
  For instance, in the <filename>gtk/src</filename> directory of the &gtkmm;
  sources, you will find these files:
    <variablelist>
        <varlistentry>
            <term><filename>gtk.defs</filename></term>
            <listitem><para>Includes the other files.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_methods.defs</filename></term>
            <listitem><para>Objects and functions.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_enums.defs</filename></term>
            <listitem><para>Enumerations.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_signals.defs</filename></term>
            <listitem><para>Signals and properties.</para></listitem>
        </varlistentry>
        <varlistentry>
            <term><filename>gtk_vfuncs.defs</filename></term>
            <listitem><para>vfuncs (function pointer member fields in structs), written by hand.</para></listitem>
        </varlistentry>
    </variablelist>
</para>
<para>The <filename>skeletonmm/tools/generate_defs_and_docs.sh</filename> script
generates all <filename>.defs</filename> files and the <filename>*_docs.xml</filename> file,
described in the <link linkend="sec-wrapping-documentation">Documentation</link> section.
</para>

<section xml:id="generating-defs-methods">
<title>Generating the methods .defs</title>

<para>This <filename>.defs</filename> file describes objects and their functions.
  It is generated by the <command>h2def.py</command> script which you can find in
  glibmm's <filename>tools/defs_gen</filename> directory. For instance,
</para>
<programlisting><code>$ ./h2def.py /usr/include/gtk-4.0/gtk/*.h &gt; gtk_methods.defs
</code></programlisting>
</section>

<section xml:id="generating-defs-enums">
<title>Generating the enums .defs</title>

<para>This <filename>.defs</filename> file describes enum types and their possible
  values. It is generated by the <filename>enumextract.py</filename> script which you can
  also find in glibmm's <filename>tools/defs_gen</filename> directory. For instance,
</para>
<programlisting><code>$ ./enumextract.py /usr/include/gtk-4.0/gtk/*.h &gt; gtk_enums.defs
</code></programlisting>
</section>

<section xml:id="generating-defs-signals-properties">
<title>Generating the signals and properties .defs</title>

<para>This <filename>.defs</filename> file describes signals and properties. It is
  generated by the special <filename>generate_extra_defs</filename> utility that is in every
  wrapping project, such as <filename>gtkmm/tools/extra_defs_gen/</filename>.
  For instance
</para>
<programlisting><code>$ cd tools/extra_defs_gen
$ ./generate_extra_defs &gt; gtk_signals.defs
</code></programlisting>
<para>You must edit the source code of your own <filename>generate_extra_defs</filename> tool
  in order to generate the <filename>.defs</filename> for the GObject C types that you wish to
  wrap. In the skeleton source tree, the source file is named
  <filename>tools/extra_defs_gen/generate_defs_skeleton.cc</filename>. If not done so
  already, the file should be renamed, with the basename of your new binding substituted
  for the <varname>skeleton</varname> placeholder. The <filename>tools/extra_defs_gen/meson.build</filename>
  file should also mention the new source filename.</para>
<para>Then edit the <filename>.cc</filename> file to specify the correct types.
  For instance, your <function>main()</function> function might look like this:
</para>
<programlisting><code>#include &lt;glibmm_generate_extra_defs/generate_extra_defs.h&gt;
#include &lt;libsomething.h&gt;
#include &lt;iostream&gt;

int main(int, char**)
{
  something_init();

  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)
            &lt;&lt; get_defs(SOME_TYPE_STUFF);
  return 0;
}
</code></programlisting>
</section>

<section xml:id="writing-defs-vfuncs">
<title>Writing the vfuncs .defs</title>

<para>
  This <filename>.defs</filename> file describes virtual functions (vfuncs).
  It must be written by hand. There is the skeleton file
  <filename>skeleton/src/skeleton_vfunc.defs</filename> to start from. You can also look
  at &gtkmm;'s <filename>gtk/src/gtk_vfuncs.defs</filename> file.
</para>
</section>

</section>

<section xml:id="sec-wrapping-hg-files">
<title>The .hg and .ccg files</title>
    <para>The .hg and .ccg source files are very much like
        .h and .cc &cpp; source files, but they contain extra macros, such as
        <function>_CLASS_GOBJECT()</function> and
        <function>_WRAP_METHOD()</function>, from which
        <command>gmmproc</command> generates appropriate &cpp; source code,
        usually at the same position in the header. Any additional &cpp; source
        code will be copied verbatim into the corresponding
        .h or .cc file.</para>
    <para>A .hg file will typically include some headers
        and then declare a class, using some macros to add API or behavior to
        this class. For instance, &gtkmm;'s <filename>button.hg</filename> looks
        roughly like this:</para>

<programlisting><code>#include &lt;gtkmm/widget.h&gt;
#include &lt;gtkmm/actionable.h&gt;
_DEFS(gtkmm,gtk)
_PINCLUDE(gtkmm/private/widget_p.h)

namespace Gtk
{

class GTKMM_API Button
  : public Widget,
    public Actionable
{
  _CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Widget, GtkWidget, , , GTKMM_API)
  _IMPLEMENTS_INTERFACE(Actionable)
public:

  _CTOR_DEFAULT
  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);

  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)

  ...

  _WRAP_SIGNAL(void clicked(), "clicked")

  ...

  _WRAP_PROPERTY("label", Glib::ustring)
};

} // namespace Gtk
</code></programlisting>
<para>The macros in this example do the following:
<variablelist>
    <varlistentry>
        <term><function>_DEFS()</function></term>
        <listitem><para>Specifies the destination directory for generated sources, and the name of the main .defs file that <command>gmmproc</command> should parse.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_PINCLUDE()</function></term>
        <listitem><para>Tells <command>gmmproc</command> to include a header in the generated <filename>private/button_p.h</filename> file.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_CLASS_GTKOBJECT()</function></term>
        <listitem><para>Tells <command>gmmproc</command> to add some typedefs, constructors, and standard methods to this class, as appropriate when wrapping a widget.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_IMPLEMENTS_INTERFACE()</function></term>
        <listitem><para>Tells <command>gmmproc</command> to add initialization code for the interface.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_CTOR_DEFAULT</function></term>
        <listitem><para>Adds a default constructor.</para></listitem>
    </varlistentry>
    <varlistentry>
        <term><function>_WRAP_METHOD()</function>,
            <function>_WRAP_SIGNAL()</function>, and
            <function>_WRAP_PROPERTY()</function></term>
        <listitem><para>Add methods to wrap parts of the C API.</para></listitem>
    </varlistentry>
</variablelist>
</para>
<para>The .h and .cc files will be generated from the .hg and .ccg files by
    processing them with <command>gmmproc</command> like so, though this happens
    automatically when using the above build structure:
</para>
<programlisting><code>$ cd gtk/src
$ /usr/lib/glibmm-2.68/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm
</code></programlisting>
<para>Notice that we provided <command>gmmproc</command> with the path to the
    .m4 convert files, the path to the .defs file, the name of a .hg file, the
    source directory, and the destination directory.</para>
<para>You should avoid including the C header from your &cpp; header, to avoid
    polluting the global namespace, and to avoid exporting unnecessary public
    API. But you will need to include the necessary C headers from your
    .ccg file.</para>

<para>The macros are explained in more detail in the following sections.</para>

<section xml:id="gmmproc-m4-conversions">
<title>m4 Conversions</title>

<para>The macros that you use in the .hg and .ccg files often need to know how
to convert a &cpp; type to a C type, or vice-versa. <command>gmmproc</command> takes this information
from an .m4 file in your <literal>tools/m4/</literal> or <literal>codegen/m4/</literal> directory.
This allows it to call a C function in the implementation of your &cpp; method,
passing the appropriate parameters to that C function. For instance, this
tells <command>gmmproc</command> how to convert a <classname>GtkTreeView</classname>
pointer to a <classname>Gtk::TreeView</classname> pointer:
</para>
<programlisting><code>_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')
</code></programlisting>

<para><literal>$3</literal> will be replaced by the parameter name when this
conversion is used by <command>gmmproc</command>.
</para>

<para>
Some extra macros make this easier and consistent. Look in &gtkmm;'s .m4 files
for examples. For instance:
</para>
<programlisting><code>_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)
_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)
_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))
</code></programlisting>
</section>

<section xml:id="gmmproc-m4-initializations">
<title>m4 Initializations</title>

<para>
  Often when wrapping methods, it is desirable to store the return of the C
  function in what is called an output parameter.  In this case, the &cpp; method
  returns <type>void</type> but an output parameter in which to store the value
  of the C function is included in the argument list of the &cpp; method.
  <command>gmmproc</command> allows such functionality, but appropriate initialization macros must
  be included to tell <command>gmmproc</command> how to initialize the &cpp; parameter from the
  return of the C function.
</para>
<para>
  For example, if there was a C function that returned a
  <type>GtkWidget*</type> and for some reason, instead of having the &cpp; method
  also return the widget, it was desirable to have the &cpp; method place the
  widget in a specified output parameter, an initialization macro such as the
  following would be necessary:
</para>
<programlisting><code>_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')
</code></programlisting>

<para>
  <literal>$3</literal> will be replaced by the output parameter name of the
  &cpp; method and <literal>$4</literal> will be replaced by the return of the C
  function when this initialization is used by <command>gmmproc</command>.  For convenience,
  <literal>$1</literal> will also be replaced by the &cpp; type without the
  ampersand (&amp;) and <literal>$2</literal> will be replaced by the C type.
</para>
</section>

<section xml:id="gmmproc-class-macros">
<title>Class macros</title>

<para>The class macro declares the class itself and its relationship with the
    underlying C type. It generates some internal constructors, the member
    <varname>gobject_</varname>, typedefs, the <function>gobj()</function>
    accessors, type registration, and the <function>Glib::wrap()</function>
    method, among other things.</para>
<para>Other macros, such as <function>_WRAP_METHOD()</function> and
    <function>_WRAP_SIGNAL()</function> may only be used after a call to a
    <function>_CLASS_*</function> macro.</para>
<para>Most class macros take an optional argument, <parameter>declaration prefix</parameter>.
    It's typically used for a C preprocessor macro defined as <literal>__declspec(dllexport)</literal>
    or <literal>__declspec(dllimport)</literal> when building with MSVC on Windows,
    defined as an empty string otherwise.</para>

<section xml:id="gmmproc-class-gobject">
<title>_CLASS_GOBJECT</title>

<para>This macro declares a wrapper for a type that is derived from
    <classname>GObject</classname>, but whose wrapper is not derived from
    <classname>Gtk::Object</classname>.</para>
<para><function>_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class,
    C base class, real C class, real C base class, declaration prefix )</function></para>
<para><parameter>real C class</parameter> and <parameter>real C base class</parameter>
    are optional. They are seldom used. For instance, from <filename>adjustment.hg</filename>:</para>
<programlisting><code>_CLASS_GOBJECT(Adjustment, GtkAdjustment, GTK_ADJUSTMENT, Glib::Object, GObject, , , GTKMM_API)
</code></programlisting>
</section>

<section xml:id="gmmproc-class-gtkobject">
<title>_CLASS_GTKOBJECT</title>

<para>This macro declares a wrapper for a type whose wrapper is derived from
    <classname>Gtk::Object</classname>, such as a widget or dialog.</para>
<para><function>_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class,
    C base class, real C class, real C base class, declaration prefix )</function></para>
<para><parameter>real C class</parameter> and <parameter>real C base class</parameter>
    are optional. They are seldom used. For instance, from <filename>button.hg</filename>:</para>
<programlisting><code>_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Widget, GtkWidget, , , GTKMM_API)
</code></programlisting>
<para>You will typically use this macro when the class already derives from
    <classname>Gtk::Object</classname>. For instance, you will use it when wrapping
    a GTK Widget, because <classname>Gtk::Widget</classname> derives from
    <classname>Gtk::Object</classname>.</para>
<para>You might also derive non-widget classes from
    <classname>Gtk::Object</classname> so they can be used without
    <classname>Glib::RefPtr</classname>. For instance, they could then be
    instantiated with <function>Gtk::make_managed()</function> or on the stack
    as a member variable. This is convenient, but you should use this only when
    you are sure that true reference-counting is not needed. We consider it
    useful for widgets.</para>
</section>

<section xml:id="gmmproc-class-boxedtype">
<title>_CLASS_BOXEDTYPE</title>

<para>This macro declares a wrapper for a non-<classname>GObject</classname>
    struct, registered with
    <function>g_boxed_type_register_static()</function>.</para>
<para><function>_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function,
    free function, declaration prefix )</function></para>
<para>For instance, from <classname>Gdk::RGBA</classname>:</para>
<programlisting><code>_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free, GDKMM_API)
</code></programlisting>
</section>

<section xml:id="gmmproc-class-boxedtype-static">
<title>_CLASS_BOXEDTYPE_STATIC</title>

<para>This macro declares a wrapper for a simple assignable struct such as
    <classname>GdkRectangle</classname>. It is similar to
    <function>_CLASS_BOXEDTYPE</function>, but the C struct is not allocated
    dynamically.</para>
<para><function>_CLASS_BOXEDTYPE_STATIC( C++ class, C class, declaration prefix )</function></para>
<para>For instance, for <classname>Gdk::Rectangle</classname>:</para>
<programlisting><code>_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle, GDKMM_API)
</code></programlisting>
</section>

<section xml:id="gmmproc-class-opaque-copyable">
<title>_CLASS_OPAQUE_COPYABLE</title>

<para>This macro declares a wrapper for an opaque struct that has copy and free
    functions. The new, copy and free functions will be used to instantiate the
    default constructor, copy constructor and destructor.</para>
<para><function>_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function,
    free function, declaration prefix )</function></para>
<para>For instance, from <classname>Glib::VariantType</classname>:</para>
<programlisting><code>_CLASS_OPAQUE_COPYABLE(VariantType, GVariantType, NONE, g_variant_type_copy, g_variant_type_free, GLIBMM_API)
</code></programlisting>
</section>

<section xml:id="gmmproc-class-opaque-refcounted">
<title>_CLASS_OPAQUE_REFCOUNTED</title>

<para>This macro declares a wrapper for a reference-counted opaque struct. The
    &cpp; wrapper cannot be directly instantiated and can only be used with
    <classname>Glib::RefPtr</classname>.</para>
<para><function>_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function,
    unref function, declaration prefix )</function></para>
<para>For instance, for <classname>Gtk::CssSection</classname>:</para>
<programlisting><code>_CLASS_OPAQUE_REFCOUNTED(CssSection, GtkCssSection, NONE, gtk_css_section_ref, gtk_css_section_unref, GTKMM_API)
</code></programlisting>
</section>

<section xml:id="gmmproc-class-generic">
<title>_CLASS_GENERIC</title>

<para>This macro can be used to wrap structs which don't fit into any
    specialized category.</para>
<para><function>_CLASS_GENERIC( C++ class, C class )</function></para>
<para>Note: No <parameter>declaration prefix</parameter> argument. For instance,
    for <classname>Gdk::TimeCoord</classname>:</para>
<programlisting><code>_CLASS_GENERIC(TimeCoord, GdkTimeCoord)
</code></programlisting>
</section>

<section xml:id="gmmproc-class-interface">
<title>_CLASS_INTERFACE</title>

<para>This macro declares a wrapper for a type that is derived from
    <classname>GTypeInterface</classname>.
</para>
<para><function>_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct,
    Base C++ class (optional), Base C class (optional), declaration prefix (optional) )</function></para>
<para>
For instance, from <filename>celleditable.hg</filename>:</para>
<programlisting><code>_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface, , , GTKMM_API)
</code></programlisting>
<para>Two extra optional parameters were once added, for the case that the interface derives
from another interface, which was believed to be the case when the GInterface has another
GInterface as a prerequisite. This is a misunderstanding, though.
When GInterface A has GInterface B as a prerequisite, it means that every class
that implements A shall also implement B.
For instance, from <filename>loadableicon.hg</filename> in glibmm-2.4:</para>
<programlisting><code>_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon, GIOMM_API)
</code></programlisting>
</section>

</section>

<section xml:id="gmmproc-constructor-macros">
<title>Constructor macros</title>

<para>The <function>_CTOR_DEFAULT()</function> and
    <function>_WRAP_CTOR()</function> macros add constructors, wrapping the
    specified <function>*_new()</function> C functions. These macros assume that
    the C object has properties with the same names as the function parameters,
    as is usually the case, so that it can supply the parameters directly to a
    <function>g_object_new()</function> call. These constructors never actually
    call the <function>*_new()</function> C functions,
    because &gtkmm; must actually instantiate derived GTypes, and the
    <function>*_new()</function> C functions are meant only as convenience
    functions for C programmers.</para>
<para>When using <function>_CLASS_GOBJECT()</function>, the constructors should
    be protected (rather than public) and each constructor should have a
    corresponding <function>_WRAP_CREATE()</function> in the public section.
    This prevents the class from being instantiated without using a
    <classname>RefPtr</classname>. For instance:</para>
<programlisting><code>class GTKMM_API TextMark : public Glib::Object
{
  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject, , , GTKMM_API)

protected:
  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)

public:
  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)
</code></programlisting>

<section xml:id="gmmproc-ctor-default">
<title>_CTOR_DEFAULT</title>

<para>This macro creates a default constructor with no arguments.
</para>
</section>

<section xml:id="gmmproc-wrap-ctor">
<title>_WRAP_CTOR</title>

<para>This macro creates a constructor with arguments, equivalent to a
  <function>*_new()</function> C function. It won't actually call the
  <function>*_new()</function> function, but will simply create an equivalent
  constructor with the same argument types. It takes a &cpp; constructor
  signature, and a C function name.
</para>

<para>It also takes an optional extra argument:
  <variablelist>
    <varlistentry>
        <term>errthrow</term>
        <listitem>
          <para>This tells <command>gmmproc</command> that the C <function>*_new()</function> has
            a final <type>GError**</type> parameter which should be ignored.</para>
        </listitem>
    </varlistentry>
  </variablelist>
</para>
</section>

<section xml:id="gmmproc-ctor-manual">
<title>Hand-coding constructors</title>

<para>When a constructor must be partly hand written because, for instance, the
    <function>*_new()</function> C function's parameters do not correspond
    directly to object properties, or because the <function>*_new()</function> C
    function does more than call <function>g_object_new()</function>, the
    <function>_CONSTRUCT()</function> macro may be used in the
    .ccg file to save some work. The <function>_CONSTRUCT</function> macro takes
    a series of property names and values. For instance, from
    <filename>button.ccg</filename>:</para>
<programlisting><code>Button::Button(const Glib::ustring&amp; label, bool mnemonic)
:
  _CONSTRUCT("label", label.c_str(), "use_underline", gboolean(mnemonic))
{}
</code></programlisting>
</section>

</section>

<section xml:id="gmmproc-suppressing-macros">
<title>Macros that suppress generation of some code</title>

<para>Some macros suppress the generation of some code when they are used after
a <function>_CLASS_*</function> macro. Some suppress the definition in the
generated .cc file, others suppress both the declaration in the .h file and
the definition in the .cc file.
</para>

<section xml:id="gmmproc-custom-default-ctor">
<title>_CUSTOM_DEFAULT_CTOR</title>

<para>Suppresses declaration and definition of default constructor in
<function>_CLASS_BOXEDTYPE</function>, <function>_CLASS_BOXEDTYPE_STATIC</function>
and <function>_CLASS_OPAQUE_COPYABLE</function>.
</para>
</section>

<section xml:id="gmmproc-custom-ctor-cast">
<title>_CUSTOM_CTOR_CAST</title>

<para>Suppresses declaration and definition of the constructor that takes a pointer
to the wrapped C object in <function>_CLASS_BOXEDTYPE</function> and
<function>_CLASS_BOXEDTYPE_STATIC</function>.
</para>
<para>Suppresses definition of the constructor that takes a pointer to the
wrapped C object in <function>_CLASS_INTERFACE</function> and
<function>_CLASS_OPAQUE_COPYABLE</function>.
</para>
<para>Suppresses definition of the constructor that takes a pointer to the
wrapped C object and the constructor that takes construct_params in
<function>_CLASS_GOBJECT</function> and <function>_CLASS_GTKOBJECT</function>.
</para>
</section>

<section xml:id="gmmproc-custom-dtor">
<title>_CUSTOM_DTOR</title>

<para>Suppresses definition of destructor in
<function>_CLASS_GOBJECT</function> and <function>_CLASS_GTKOBJECT</function>.
</para>
</section>

<section xml:id="gmmproc-custom-move-operations">
<title>_CUSTOM_MOVE_OPERATIONS</title>

<para>Suppresses declaration and definition of move constructor and move
assignment operator in <function>_CLASS_GOBJECT</function> and
<function>_CLASS_GTKOBJECT</function>.
</para>
<para>For example:</para>
<programlisting><code>class Derived : public Glib::Object
{
  _CLASS_GOBJECT(Derived, GDerived, G_DERIVED, Glib::Object, GObject)

  _CUSTOM_MOVE_OPERATIONS

public:
  Derived(Derived&amp;&amp; src) noexcept;
  Derived&amp; operator=(Derived&amp;&amp; src) noexcept;
  // ...
};
</code></programlisting>
</section>

<section xml:id="gmmproc-custom-wrap-new">
<title>_CUSTOM_WRAP_NEW</title>

<para>Suppresses definition of <function>Glib::wrap_new()</function> function in
<function>_CLASS_GOBJECT</function>.
</para>
</section>

<section xml:id="gmmproc-custom-wrap-function">
<title>_CUSTOM_WRAP_FUNCTION</title>

<para>Suppresses definition of <function>Glib::wrap()</function> function in
<function>_CLASS_GOBJECT</function> and <function>_CLASS_GTKOBJECT</function>.
</para>
</section>

<section xml:id="gmmproc-no-wrap-function">
<title>_NO_WRAP_FUNCTION</title>

<para>Suppresses declaration and definition of <function>Glib::wrap()</function>
function in <function>_CLASS_GOBJECT</function>, <function>_CLASS_BOXEDTYPE</function>,
<function>_CLASS_BOXEDTYPE_STATIC</function>, <function>_CLASS_OPAQUE_COPYABLE</function>,
<function>_CLASS_INTERFACE</function> and <function>_CLASS_GTKOBJECT</function>.
</para>
</section>

</section>

<section xml:id="gmmproc-method-macros">
<title>Method macros</title>

<section xml:id="gmmproc-wrap-method">
<title>_WRAP_METHOD</title>

<para>This macro generates the &cpp; method to wrap a C function.</para>
<para><function>_WRAP_METHOD( C++ method signature, C function name)</function></para>
<para>For instance, from <filename>entry.hg</filename>:</para>
<programlisting><code>_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)
</code></programlisting>
<para>The C function (e.g. <function>gtk_entry_set_text</function>) is described
    more fully in the .defs file, and the <filename>convert*.m4</filename> files
    contain the necessary conversion from the &cpp; parameter type to the C
    parameter type. This macro also generates doxygen documentation comments
    based on the <filename>*_docs.xml</filename> and
    <filename>*_docs_override.xml</filename> files.</para>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>refreturn</term>
        <listitem>
            <para>Do an extra <function>reference()</function> on the return value,
                in case the C function does not provide a reference.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>errthrow ["&lt;exceptions&gt;"]</term>
        <listitem>
            <para>Use the last GError** parameter of the C function to
                throw an exception.
                The optional "&lt;exceptions&gt;" is a comma-separated list
                of exceptions that can be thrown. It determines which @throws
                Doxygen commands are added to the documentation. Default value
                is <classname>Glib::Error</classname>. If you want a comma in
                the description of an exception, precede it by a backslash. Example:
                <code>errthrow&nbsp;"Glib::OptionError&nbsp;Hello\,&nbsp;world,&nbsp;Glib::ConvertError"</code></para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>deprecated ["&lt;text&gt;"]</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional
                parameter.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>ignore_deprecations</term>
        <listitem>
            <para>Puts the generated code in the .cc file in a
                G_GNUC_BEGIN_IGNORE_DEPRECATIONS / G_GNUC_END_IGNORE_DEPRECATIONS
                block. (Only in glibmm&nbsp;>=&nbsp;2.70.1)</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>constversion</term>
        <listitem>
            <para>Just call the non-const version of the same function,
                instead of generating almost duplicate code.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>newin "&lt;version&gt;"</term>
        <listitem>
            <para>Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>ifdef &lt;identifier&gt;</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>slot_name &lt;parameter_name&gt;</term>
        <listitem>
          <para>Specifies the name of the slot parameter of the method, if it
            has one.  This enables <command>gmmproc</command> to generate code
            to copy the slot and pass the copy on to the C function in its
            final <literal>gpointer user_data</literal> parameter.  The
            <literal>slot_callback</literal> option must also be used to
            specify the name of the glue callback function to also pass on to
            the C function.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>slot_callback &lt;function_name&gt;</term>
        <listitem>
          <para>Used in conjunction with the <literal>slot_name</literal>
            option to specify the name of the glue callback function that
            handles extracting the slot and then calling it.  The address of
            this callback is also passed on to the C function that the method
            wraps.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>no_slot_copy</term>
        <listitem>
          <para>Tells <command>gmmproc</command> not to pass a copy of the slot
            to the C function, if the method has one.  Instead the slot itself
            is passed.  The slot parameter name and the glue callback function
            must have been specified with the <literal>slot_name</literal> and
            <literal>slot_callback</literal> options respectively.</para>
        </listitem>
    </varlistentry>
</variablelist>
</para>
<para>Selecting which &cpp; types should be used is also important when wrapping
  C API.  Though it's usually obvious what &cpp; types should be used in the &cpp;
  method, here are some hints:
<itemizedlist>
    <listitem><para>Objects used via <classname>RefPtr</classname>: Pass the
            <classname>RefPtr</classname> as a const reference. For instance,
            <code>const Glib::RefPtr&lt;Gtk::FileFilter&gt;&amp;
                filter</code>.</para></listitem>
    <listitem><para>Const Objects used via <classname>RefPtr</classname>: If the
            object should not be changed by the function, then make sure that
            the object is const, even if the <classname>RefPtr</classname> is
            already const. For instance, <code>const Glib::RefPtr&lt;const
            Gtk::FileFilter&gt;&amp; filter</code>.</para></listitem>
<listitem><para>Wrapping <classname>GList*</classname> and
        <classname>GSList*</classname> parameters: First, you need to discover
        what objects are contained in the list's data field for each item,
        usually by reading the documentation for the C function. The list can
        then be wrapped by a <classname>std::vector</classname> type.
        For instance, <code>std::vector&lt;Glib::RefPtr&lt;Gdk::Pixbuf&gt;&gt;</code>.
        You may need to define a Traits type to specify how the C
        and &cpp; types should be converted.</para></listitem>
<listitem><para>Wrapping <classname>GList*</classname> and
        <classname>GSList*</classname> return types: You must discover whether
        the caller should free the list and whether it should release the items
        in the list, again by reading the documentation of the C function. With
        this information you can choose the ownership (none, shallow or deep)
        for the m4 conversion rule, which you should probably put directly into
        the .hg file because the ownership depends on the
        function rather than the type. For instance:</para>
<programlisting><code>#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')</code></programlisting></listitem>
</itemizedlist>
</para>
</section>

<section xml:id="gmmproc-wrap-method-docs-only">
<title>_WRAP_METHOD_DOCS_ONLY</title>

<para>This macro is like <function>_WRAP_METHOD()</function>, but it generates
    only the documentation for a  &cpp; method that wraps a C function. Use this
    when you must hand-code the method, but you want to use the documentation
    that would be generated if the method was generated.</para>
<para><function>_WRAP_METHOD_DOCS_ONLY(C function name)</function></para>
<para>For instance, from <filename>recentinfo.hg</filename>:</para>
<programlisting><code>_WRAP_METHOD_DOCS_ONLY(gtk_recent_info_get_applications)
</code></programlisting>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>errthrow ["&lt;exceptions&gt;"]</term>
        <listitem>
            <para>Excludes documentation of the last GError** parameter of
                the C function.
                The optional "&lt;exceptions&gt;" is a comma-separated list
                of exceptions that can be thrown. It determines which @throws
                Doxygen commands are added to the documentation. Default value
                is <classname>Glib::Error</classname>. If you want a comma in
                the description of an exception, precede it by a backslash. Example:
                <code>errthrow&nbsp;"Glib::OptionError&nbsp;Hello\,&nbsp;world,&nbsp;Glib::ConvertError"</code></para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>newin "&lt;version&gt;"</term>
        <listitem>
            <para>Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>voidreturn</term>
        <listitem>
            <para>Don't include a @return Doxygen command in the documentation.
                Useful if the wrapped C function returns a value, but the corresponding
                &cpp; method returns <type>void</type>.</para>
        </listitem>
    </varlistentry>
</variablelist>
</para>
</section>

<section xml:id="gmmproc-ignore">
<title>_IGNORE, _IGNORE_SIGNAL, _IGNORE_PROPERTY</title>

<para><command>gmmproc</command> will warn you on stdout about functions, signals,
    properties and child properties that you have forgotten to wrap, helping to
    ensure that you are wrapping the complete API. But if you don't want to wrap
    some functions, signals, properties or child properties, or if you chose
    to hand-code some methods then you can use the _IGNORE(), _IGNORE_SIGNAL()
    or _IGNORE_PROPERTY() macro to make <command>gmmproc</command> stop complaining.
</para>
<para>
<literallayout class="normal"><function>_IGNORE(C function name 1, C function name 2, etc)
_IGNORE_SIGNAL(C signal name 1, C signal name 2, etc)
_IGNORE_PROPERTY(C property name 1, C property name 2, etc)</function></literallayout>
</para>
<para>For instance, from <filename>flowbox.hg</filename>:</para>
<programlisting><code>_IGNORE(gtk_flow_box_set_filter_func, gtk_flow_box_set_sort_func)
_IGNORE_SIGNAL(activate-cursor-child, toggle-cursor-child, move-cursor)
</code></programlisting>
</section>

<section xml:id="gmmproc-wrap-signal">
<title>_WRAP_SIGNAL</title>

<para>This macro generates the &cpp; libsigc++-style signal to wrap a C GObject
    signal. It actually generates a public accessor method, such as
    <function>signal_clicked()</function>, which returns a proxy object.
    <command>gmmproc</command> uses the .defs file to discover the C parameter
    types and the .m4 convert files to discover appropriate type
    conversions.</para>
<para><function>_WRAP_SIGNAL( C++ signal handler signature, C signal name)</function></para>
<para>For instance, from <filename>button.hg</filename>:</para>
<programlisting><code>_WRAP_SIGNAL(void clicked(),"clicked")
</code></programlisting>
<para>Signals usually have function pointers in the GTK struct, with a
    corresponding enum value and a <function>g_signal_new()</function> in the
    .c file.</para>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>no_default_handler</term>
        <listitem>
            <para>Do not generate an <function>on_something()</function> virtual
                method to allow easy overriding of the default signal handler.
                Use this when adding a signal with a default signal handler
                would break the ABI by increasing the size of the class's
                virtual function table, and when adding a signal without a public
                C default handler.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>custom_default_handler</term>
        <listitem>
            <para>Generate a declaration of the <function>on_something()</function>
                virtual method in the <filename>.h</filename> file, but do not
                generate a definition in the <filename>.cc</filename> file.
                Use this when you must generate the definition by hand.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>custom_c_callback</term>
        <listitem>
            <para>Do not generate a C callback function for the signal.
                Use this when you must generate the callback function by hand.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>refreturn</term>
        <listitem>
            <para>Do an extra <function>reference()</function> on the return value
                of the <function>on_something()</function> virtual method, in
                case the C function does not provide a reference.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>deprecated ["&lt;text&gt;"]</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional parameter.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>newin "&lt;version&gt;"</term>
        <listitem>
            <para>Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>ifdef &lt;identifier&gt;</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>exception_handler &lt;method_name&gt;</term>
	      <listitem>
	        <para>Allows to use custom exception handler instead of default one.
	            Exception might be rethrown by user-defined handler, and it will be
	            caught by default handler.</para>
	      </listitem>
    </varlistentry>
    <varlistentry>
        <term>detail_name &lt;parameter_name&gt;</term>
	      <listitem>
	        <para>Adds a <type>const Glib::ustring&amp;</type> parameter to the
	            <methodname>signal_something()</methodname> method. Use it, if the signal
	            accepts a detailed signal name, i.e. if the underlying C code registers
	            the signal with the <literal>G_SIGNAL_DETAILED</literal> flag.</para>
	      </listitem>
    </varlistentry>
    <varlistentry>
        <term>two_signal_methods</term>
	      <listitem>
	        <para>Used in conjunction with the <literal>detail_name</literal>
              option to generate two <methodname>signal_something()</methodname>
              methods, one without a parameter and one with a parameter without
              a default value. With only the <literal>detail_name</literal> option
              one method is generated, with a parameter with default value.
              Use the <literal>two_signal_methods</literal> option, if it's
              necessary in order to preserve ABI.</para>
	      </listitem>
    </varlistentry>
</variablelist>
</para>
</section>

<section xml:id="gmmproc-wrap-property">
<title>_WRAP_PROPERTY</title>

<para>This macro generates the &cpp; method to wrap a C GObject property. You must
    specify the property name and the wanted &cpp; type for the property. <command>gmmproc</command>
    uses the .defs file to discover the C type and the .m4 convert files to
    discover appropriate type conversions.</para>
<para><function>_WRAP_PROPERTY(C property name, C++ type)</function></para>
<para>For instance, from <filename>button.hg</filename>:</para>
<programlisting><code>_WRAP_PROPERTY("label", Glib::ustring)
</code></programlisting>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>deprecated ["&lt;text&gt;"]</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks. Text about the
                deprecation can be specified as an optional parameter.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>newin "&lt;version&gt;"</term>
        <listitem>
            <para>Adds a @newin Doxygen command to the documentation, or replaces
                the @newin command generated from the C documentation.</para>
        </listitem>
    </varlistentry>
</variablelist>
</para>
</section>

<section xml:id="gmmproc-wrap-vfunc">
<title>_WRAP_VFUNC</title>

<para>This macro generates the &cpp; method to wrap a virtual C function.</para>
<para><function>_WRAP_VFUNC( C++ method signature, C function name)</function></para>
<para>For instance, from <filename>widget.hg</filename>:</para>
<programlisting><code>_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)
</code></programlisting>
<para>The C function (e.g. <function>get_request_mode</function>) is described
    more fully in the <filename>*_vfuncs.defs</filename> file, and the
    <filename>convert*.m4</filename> files contain the necessary conversion from
    the &cpp; parameter type to the C parameter type. Conversions can also be
    written in the .hg file. Virtual functions often require special conversions
    that are best kept local to the .hg file where they are used.</para>
<para>There are some optional extra arguments:
<variablelist>
    <varlistentry>
        <term>refreturn</term>
        <listitem>
            <para>Do an extra <function>reference()</function> on the return value
                of the <function>something_vfunc()</function> function,
                in case the virtual C function does not provide a reference.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>refreturn_ctype</term>
        <listitem>
            <para>Do an extra <function>reference()</function> on the return value
                of an overridden <function>something_vfunc()</function> function
                in the C callback function, in case the calling C function
                expects it to provide a reference.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>keep_return</term>
        <listitem>
            <para>Keep a copy of the return value in the C callback function,
                in case the calling C function does not expect to get its own
                reference.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>errthrow</term>
        <listitem>
            <para>Use the last GError** parameter of the C virtual function (if
              there is one) to throw an exception.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>custom_vfunc</term>
        <listitem>
            <para>Do not generate a definition of the vfunc in the
               <filename>.cc</filename> file. Use this when you must generate
               the vfunc by hand.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>custom_vfunc_callback</term>
        <listitem>
            <para>Do not generate a C callback function for the vfunc.
                Use this when you must generate the callback function by hand.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>ifdef &lt;identifier&gt;</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>slot_name &lt;parameter_name&gt;</term>
        <listitem>
          <para>Specifies the name of the slot parameter of the method, if it
            has one.  This enables <command>gmmproc</command> to generate code
            to copy the slot and pass the copy on to the C function in its
            final <literal>gpointer user_data</literal> parameter.  The
            <literal>slot_callback</literal> option must also be used to
            specify the name of the glue callback function to also pass on to
            the C function.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>slot_callback &lt;function_name&gt;</term>
        <listitem>
          <para>Used in conjunction with the <literal>slot_name</literal>
            option to specify the name of the glue callback function that
            handles extracting the slot and then calling it.  The address of
            this callback is also passed on to the C function that the method
            wraps.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>no_slot_copy</term>
        <listitem>
          <para>Tells <command>gmmproc</command> not to pass a copy of the slot
            to the C function, if the method has one.  Instead the slot itself
            is passed.  The slot parameter name and the glue callback function
            must have been specified with the <literal>slot_name</literal> and
            <literal>slot_callback</literal> options respectively.</para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term>return_value &lt;value&gt;</term>
	      <listitem>
	        <para>Defines a non-default return value.</para>
	      </listitem>
    </varlistentry>
    <varlistentry>
        <term>err_return_value &lt;value&gt;</term>
	      <listitem>
	        <para>Defines a non-default return value, used only if the &cpp;
	          <function>something_vfunc()</function> function throws an exception
	          which is propagated to the C callback function. If return_value is
	          specified, but err_return_value is not, then return_value is used
	          also when an exception is propagated.</para>
	      </listitem>
    </varlistentry>
    <varlistentry>
        <term>exception_handler &lt;method_name&gt;</term>
	      <listitem>
	        <para>Allows to use custom exception handler instead of default one.
	            Exception might be rethrown by user-defined handler, and it will be
	            caught by default handler.</para>
	      </listitem>
    </varlistentry>
</variablelist>
</para>
<para>A rule to which there may be exceptions: If the virtual C function returns
    a pointer to an object derived from <classname>GObject</classname>, i.e. a
    reference-counted object, then the virtual &cpp; function shall return a
    <classname>Glib::RefPtr&lt;&gt;</classname> object. One of the extra
    arguments <parameter>refreturn</parameter> or
    <parameter>refreturn_ctype</parameter> is required.</para>
</section>

</section>

<section xml:id="gmmproc-other-macros">
<title>Other macros</title>

<section xml:id="gmmproc-implements-interface">
<title>_IMPLEMENTS_INTERFACE</title>

<para>This macro generates initialization code for the interface.</para>
<para><function>_IMPLEMENTS_INTERFACE(C++ interface name)</function></para>
<para>For instance, from <filename>grid.hg</filename>:</para>
<programlisting><code>_IMPLEMENTS_INTERFACE(Orientable)
</code></programlisting>
<para>There is one optional extra argument:
<variablelist>
    <varlistentry>
        <term>ifdef &lt;identifier&gt;</term>
        <listitem>
            <para>Puts the generated code in #ifdef blocks.</para>
        </listitem>
    </varlistentry>
</variablelist>
</para>
</section>

<section xml:id="gmmproc-wrap-enum">
<title>_WRAP_ENUM</title>

<para>This macro generates a &cpp; enum to wrap a C enum. You must specify the desired &cpp; name and
    the name of the underlying C enum.</para>
<para>For instance, from <filename>enums.hg</filename>:</para>
<programlisting><code>_WRAP_ENUM(Orientation, GtkOrientation, decl_prefix GTKMM_API)
</code></programlisting>
<para>There are some optional extra arguments:
<variablelist>
  <varlistentry>
    <term>NO_GTYPE</term>
    <listitem>
      <para>Use this option, if the enum is not a <classname>GType</classname>.
        This is the case when there is no <function>*_get_type()</function>
        function for the C enum, but be careful that you don't just need to
        include an extra header for that function. You should also file a bug
        against the C API, because all enums should be registered as GTypes.</para>
      <para>If you specify <literal>NO_GTYPE</literal>, don't use that enum as the
        type in _WRAP_PROPERTY. It would cause a runtime error, when the generated
        <methodname>property_*()</methodname> method is called.</para>
      <para>For example, from <filename>icontheme.hg</filename>:</para>
      <programlisting><code>_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE, decl_prefix GTKMM_API)
      </code></programlisting>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>gtype_func &lt;function_name&gt;</term>
    <listitem>
      <para>Specifies the name of the <function>*_get_type()</function> function
        for the C enum. Use this parameter if <command>gmmproc</command> can't
        deduce the correct function name from the name of the C enum type.</para>
      <para>For example, from <filename>dbusproxy.hg</filename> in glibmm:</para>
      <programlisting><code>_WRAP_ENUM(ProxyFlags, GDBusProxyFlags, gtype_func g_dbus_proxy_flags_get_type, decl_prefix GIOMM_API)
      </code></programlisting>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>CONV_TO_INT</term>
    <listitem>
      <para>"Convertible to int." Generates a plain enum (not an enum class)
        within a class. Such an enum is scoped like an enum class, but unlike an
        enum class, it can be implicitly converted to <type>int</type>.</para>
      <para>For example, from <filename>dialog.hg</filename>:</para>
      <programlisting><code>_WRAP_ENUM(ResponseType, GtkResponseType, CONV_TO_INT, decl_prefix GTKMM_API)
      </code></programlisting>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>s#&lt;from&gt;#&lt;to&gt;#</term>
    <listitem>
      <para>Substitutes (part of) the name of one or more enum constants.
        You can add any number of substitutions.</para>
      <para>For example, from <filename>toplevel.hg</filename>:</para>
      <programlisting><code>_WRAP_ENUM(FullscreenMode, GdkFullscreenMode,
  s#^CURRENT_MONITOR$#ON_CURRENT_MONITOR#, s#^ALL_MONITORS$#ON_ALL_MONITORS#,
  decl_prefix GDKMM_API)
      </code></programlisting>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>decl_prefix &lt;declaration_prefix&gt;</term>
    <listitem>
      <para>Typically used for a C preprocessor macro defined as <literal>__declspec(dllexport)</literal>
        or <literal>__declspec(dllimport)</literal> when building with MSVC on Windows,
        defined as an empty string otherwise.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>deprecated ["&lt;text&gt;"]</term>
    <listitem>
      <para>Puts the generated code in #ifdef blocks. Text about the
        deprecation can be specified as an optional parameter.</para>
    </listitem>
  </varlistentry>
  <varlistentry>
    <term>newin "&lt;version&gt;"</term>
    <listitem>
      <para>Adds a @newin Doxygen command to the documentation, or replaces
        the @newin command generated from the C documentation.</para>
    </listitem>
  </varlistentry>
</variablelist>
</para>
</section>

<section xml:id="gmmproc-wrap-enum-docs-only">
<title>_WRAP_ENUM_DOCS_ONLY</title>

<para>This macro just generates a Doxygen documentation block for the enum.
  This is useful for enums that can't be wrapped with
  <function>_WRAP_ENUM()</function> because they are complexly defined (maybe
  using C macros) but including the generated enum documentation is still
  desired. It is used with the same syntax as
  <function>_WRAP_ENUM()</function> and also processes the same options (though
  NO_GTYPE, gtype_func &lt;function_name&gt; and CONV_TO_INT are ignored because
  they make no difference when just generating the enum's documentation).
</para>
</section>

<section xml:id="gmmproc-wrap-gerror">
<title>_WRAP_GERROR</title>

<para>This macro generates a &cpp; exception class, derived from <classname>Glib::Error</classname>, with
a <type>Code</type> enum and a <methodname>code()</methodname> method. You must specify the desired &cpp; name, the name
of the corresponding C enum, and the prefix for the C enum values.</para>
<para>This exception can then be thrown by methods which are generated from
_WRAP_METHOD() with the errthrow option.</para>
<para>For instance, from <filename>pixbuf.hg</filename>:</para>
<programlisting><code>_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR, decl_prefix GDKMM_API)
</code></programlisting>
<para>_WRAP_GERROR() accepts the same optional arguments as _WRAP_ENUM() (though
CONV_TO_INT is ignored because all exception class enums are plain enums within a class).
</para>
</section>

<section xml:id="gmmproc-member-set-get">
<title>_MEMBER_GET / _MEMBER_SET</title>
  <para>
    Use these macros if you're wrapping a simple struct or boxed type that provides
    direct access to its data members, to create getters and setters for the data members.
  </para>
  <para><function>_MEMBER_GET(C++ name, C name, C++ type, C type)</function></para>
  <para><function>_MEMBER_SET(C++ name, C name, C++ type, C type)</function></para>
  <para>
    For example, in <filename>rectangle.hg</filename>:
  </para>
  <programlisting><code>_MEMBER_GET(x, x, int, int)</code></programlisting>
</section>

<section xml:id="gmmproc-member-get-set-ptr">
<title>_MEMBER_GET_PTR / _MEMBER_SET_PTR</title>
  <para>
    Use these macros to automatically provide getters and setters for a data
    member that is a pointer type. For the getter function, it will
    create two methods, one const and one non-const.
  </para>
  <para><function>_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)</function></para>
  <para><function>_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)</function></para>
  <para>For example, for <classname>Pango::Analysis</classname> in <filename>item.hg</filename>:
  </para>
<programlisting><code>// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)
// It's just a comment. It's difficult to find a real-world example.
</code></programlisting>
</section>

<section xml:id="gmmproc-member-get-set-gobject">
<title>_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT</title>
  <para>
    Use these macros to provide getters and setters for a data member that is a
    <classname>GObject</classname> type that must be referenced before being
    returned.
  </para>
  <para><function>_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)</function></para>
  <para><function>_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)</function></para>
  <para>For example, in Pangomm, <filename>layoutline.hg</filename>:</para>
<programlisting><code>_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)
</code></programlisting>
</section>

</section>

<section xml:id="gmmproc-parameter-processing">
<title>gmmproc Parameter Processing</title>
  <para><command>gmmproc</command> allows processing the parameters in a method
    signature for the macros that process method signatures (like
    <function>_WRAP_METHOD()</function>, <function>_WRAP_CTOR()</function> and
    <function>_WRAP_CREATE()</function>) in a variety of ways:
  </para>

  <section xml:id="gmmproc-parameter-reordering">
  <title>Parameter Reordering</title>

    <para>
      For all the macros that process method signatures, it is possible to
      specify a different order for the &cpp; parameters than the existing order
      in the C function, virtual function or signal.  For example, say that the
      following C function were being wrapped as a &cpp; method for the
      <classname>Gtk::Widget</classname> class:</para>
<programlisting><code>void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,
  GdkEventMask events);
</code></programlisting>
    <para>
      However, changing the order of the &cpp; method's two parameters is
      necessary.  Something like the following would wrap the function as a &cpp;
      method with a different order for the two parameters:</para>
<programlisting><code>_WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},
  const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),
  gtk_widget_set_device_events)
</code></programlisting>
      <para>The <literal>{c_param_name}</literal> following the method parameter
      names tells <command>gmmproc</command> to map the &cpp; parameter to the
      specified C parameter within the <literal>{}</literal>.  Since the &cpp;
      parameter names correspond to the C ones, the above could be re-written
      as:</para>
<programlisting><code>_WRAP_METHOD(void set_device_events(Gdk::EventMask events{.},
  const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),
  gtk_widget_set_device_events)
</code></programlisting>
    <warning>
      <para>
        Please note that when reordering parameters for a
        <function>_WRAP_SIGNAL()</function> method signature, the C parameter
        names would always be <literal>p0</literal>, <literal>p1</literal>,
        etc. because the <filename>generate_extra_defs</filename> utility uses those
        parameter names no matter what the C API's parameter names may be.
        It's how the utility is written presently.
      </para>
    </warning>
  </section>

  <section xml:id="gmmproc-optional-parameter-processing">
  <title>Optional Parameter Processing</title>

    <para>
      For all macros processing method signatures except
      <function>_WRAP_SIGNAL()</function> and
      <function>_WRAP_VFUNC()</function> it is also possible to make the
      parameters optional so that extra &cpp; methods are generated without the
      specified optional parameter.  For example, say that the following
      <function>*_new()</function> function were being wrapped as a constructor
      in the <classname>Gtk::ToolButton</classname> class:</para>
<programlisting><code>GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar* label);
</code></programlisting>
      <para>Also, say that the C API allowed NULL for the function's
      <parameter>label</parameter> parameter so that that parameter is optional.
      It would be possible to have <command>gmmproc</command> generate the
      original constructor (with all the parameters) along with an additional
      constructor without that optional parameter by appending a
      <literal>{?}</literal> to the parameter name like so:</para>
<programlisting><code>_WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp; label{?}),
  gtk_tool_button_new)
</code></programlisting>
      <para>In this case, two constructors would be generated: One with the optional
      parameter and one without it.
    </para>
  </section>

  <section xml:id="gmmproc-output-parameter-processing">
  <title>Output Parameter Processing</title>

    <para>
      With <function>_WRAP_METHOD()</function> it is also possible for the
      return of the wrapped C function (if it has one) to be placed in an
      output parameter of the &cpp; method instead of having the &cpp; method also
      return a value like the C function does.  To do that, simply include the
      output parameter in the &cpp; method parameter list appending a
      <literal>{OUT}</literal> to the output parameter name.  For example, if
      <function>gtk_widget_get_request_mode()</function> is declared as the
      following:</para>
<programlisting><code>GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);
</code></programlisting>
      <para>And having the &cpp; method set an output parameter is desired instead of
      returning a <type>SizeRequestMode</type>, something like the following
      could be used:</para>
<programlisting><code>_WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT}) const,
  gtk_widget_get_request_mode)
</code></programlisting>
      <para>The <literal>{OUT}</literal> appended to the name of the
      <parameter>mode</parameter> output parameter tells
      <command>gmmproc</command> to place the return of the C function in that
      output parameter.  In this case, however, a necessary initialization
      macro like the following would also have to be specified:</para>
<programlisting><code>_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = (SizeRequestMode)($4)')
</code></programlisting>
      <para>Which could also be written as:</para>
<programlisting><code>_INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 = ($1)($4)')
</code></programlisting>
    <para>
      <function>_WRAP_METHOD()</function> also supports setting &cpp; output
      parameters from C output parameters if the C function being wrapped has
      any.  Suppose, for example, that we want to wrap the following C function
      that returns a value in its C output parameter
      <parameter>out_mime_type</parameter>:</para>
<programlisting><code>GInputStream* gdk_clipboard_read_finish(GdkClipboard* clipboard,
  GAsyncResult* result, const char** out_mime_type, GError** error)
</code></programlisting>
      <para>To have <command>gmmproc</command> place the value returned in the &cpp;
      <parameter>out_mime_type</parameter> output parameter, something like the
      following <function>_WRAP_METHOD()</function> macro could be used:
      </para>
<programlisting><code><![CDATA[
_WRAP_METHOD(Glib::RefPtr<Gio::InputStream> read_finish(
  const Glib::RefPtr<Gio::AsyncResult>& result,
  Glib::ustring& out_mime_type{>>}), gdk_clipboard_read_finish, errthrow)
]]></code></programlisting>
      <para>The <literal>{&gt;&gt;}</literal> following the <parameter>out_mime_type</parameter>
      parameter name indicates that the &cpp; output parameter should be set from
      the value returned in the C parameter from the C function.
      <command>gmmproc</command> will generate a declaration of a temporary
      variable in which to store the value of the C output parameter and a
      statement that sets the &cpp; output parameter from the temporary variable.
      In this case it may be necessary to have an
      <function>_INITIALIZATION()</function> describing how to set a
      <classname>Glib::ustring&amp;</classname> from a
      <classname>const char**</classname> such as the following:</para>
<programlisting><code><![CDATA[
_INITIALIZATION(`Glib::ustring&',`const char*',`$3 = Glib::convert_const_gchar_ptr_to_ustring($4)')
]]></code></programlisting>
  </section>

  <section xml:id="gmmproc-string-parameter-processing">
  <title>String Parameter Processing</title>

    <para>
      A string-valued input parameter in a &cpp; method is usually a
      <type>const Glib::ustring&amp;</type> or a <type>const std::string&amp;</type>.
      In C code it's a <type>const gchar*</type>. When an empty string is converted
      to <type>const gchar*</type>, it can be converted either to <literal>nullptr</literal>
      or to a pointer to an empty string (with <methodname>c_str()</methodname>).
      Some parameters in some C functions accept a <literal>nullptr</literal>, and
      interpret it in a special way. Other parameters must not be <literal>nullptr</literal>.
    </para>
    <para>
      The default conversion in <function>_WRAP_METHOD()</function> and similar
      macros is
      <itemizedlist>
        <listitem><para>for mandatory parameters (with or without default values):
          empty string to empty string,</para></listitem>
        <listitem><para>for optional parameters (with appended <literal>{?}</literal>):
          empty string to <literal>nullptr</literal>.</para></listitem>
      </itemizedlist>
      If the default conversion is not the best conversion, append <literal>{NULL}</literal>
      to a mandatory parameter or <literal>{?!NULL}</literal> to an optional
      parameter (<literal>!NULL</literal> = not <literal>NULL</literal>). If you
      append both a C parameter name and <literal>NULL</literal>, separate them
      with a space: <literal>{c_param_name&nbsp;NULL}</literal>.
    </para>
  </section>

</section>

<section xml:id="gmmproc-basic-types">
<title>Basic Types</title>
  <para>Some of the basic types that are used in C APIs have better alternatives
    in &cpp;. For example, there's no need for a <type>gboolean</type> type since
    &cpp; has <type>bool</type>. The following list shows some commonly-used
    types in C APIs and what you might convert them to in a &cpp; wrapper library.
  </para>
  <segmentedlist>
    <?dbhtml list-presentation="table"?>
    <segtitle>C type</segtitle>
    <segtitle>C++ type</segtitle>
    <seglistitem><seg><type>gboolean</type></seg><seg><type>bool</type></seg></seglistitem>
    <seglistitem><seg><type>gint</type></seg><seg><type>int</type></seg></seglistitem>
    <seglistitem><seg><type>guint</type></seg><seg><type>guint</type></seg></seglistitem>
    <seglistitem><seg><type>gdouble</type></seg><seg><type>double</type></seg></seglistitem>
    <seglistitem><seg><type>gunichar</type></seg><seg><type>gunichar</type></seg></seglistitem>
    <seglistitem><seg><type>gchar*</type></seg><seg><classname>Glib::ustring</classname> (or <classname>std::string</classname> for filenames)</seg></seglistitem>
  </segmentedlist>
</section>
</section>

<section xml:id="sec-wrapping-hand-coded-files">
<title>Hand-coded source files</title>

<para>You might want to include additional source files that will not be
  generated by <command>gmmproc</command> from <filename>.hg</filename> and
  <filename>.ccg</filename> files. You can simply place these in your
  <filename>libsomething/libsomethingmm</filename> directory and mention them
  in the <filename>meson.build</filename> in the
  <varname>extra_h_files</varname> and <varname>extra_cc_files</varname>
  variables.</para>
</section>

<section xml:id="sec-wrapping-initialization">
<title>Initialization</title>

<para>Your library must be initialized before it can be used, to register the
    new types that it makes available. Also, the C library that you are wrapping
    might have its own initialization function that you should call. You can do
    this in an <function>init()</function> function that you can place in
    hand-coded <filename>init.h</filename> and <filename>init.cc</filename>
    files. This function should initialize your dependencies (such as the C
    function, and &gtkmm;) and call your generated
    <function>wrap_init()</function> function. For instance:</para>
<programlisting><code>void init()
{
  Gtk::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.
  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.
}
</code></programlisting>
<para>The implementation of the <function>wrap_init()</function> method in
    <filename>wrap_init.cc</filename> is generated by
    <filename>generate_wrap_init.pl</filename>, but the declaration in
    <filename>wrap_init.h</filename> is hand-coded, so you will need to adjust
    <filename>wrap_init.h</filename> so that the <function>wrap_init()</function>
    function appears in the correct &cpp; namespace.</para>
</section>

<section xml:id="sec-wrapping-problems">
<title>Problems in the C API.</title>

<para>You are likely to encounter some problems in the library that you are wrapping, particularly if it is a new project. Here are some common problems, with solutions.</para>
<section xml:id="wrapping-predeclare-structs">
<title>Unable to predeclare structs</title>

<para>By convention, structs are declared in glib/GTK-style headers like so:</para>
<programlisting><code>typedef struct _ExampleWidget ExampleWidget;

struct _ExampleWidget
{
  ...
};
</code></programlisting>
<para>The extra typedef allows the struct to be used in a header without including
  its full definition, simply by predeclaring it, by repeating that typedef.
  This means that you don't have to include the C library's header in your &cpp; header,
  thus keeping it out of your public API. <command>gmmproc</command> assumes that
  this technique was used, so you will see compiler errors if that is not the case.</para>
<para>
This compiler error might look like this:</para>
<programlisting><code>example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'
../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here
make[4]: *** [example-widget.lo] Error 1
</code></programlisting>
<para>or this:</para>
<programlisting><code>example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol
../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'
</code></programlisting>
<para>This is easy to correct in the C library, so do send a patch to the relevant maintainer.</para>
</section>

<section xml:id="wrapping-no-properties">
<title>Lack of properties</title>

<para>By convention, glib/GTK-style objects have <function>*_new()</function>
    functions, such as <function>example_widget_new()</function> that do nothing
    more than call <function>g_object_new()</function> and return the result.
    The input parameters are supplied to <function>g_object_new()</function>
    along with the names of the properties for which they are values. For
    instance,</para>
<programlisting><code>GtkWidget* example_widget_new(int something, const char* thing)
{
        return g_object_new (EXAMPLE_TYPE_WIDGET, "something", something, "thing", thing, NULL);
}
</code></programlisting>
<para>This allows language bindings to implement their own equivalents (such as
    &cpp; constructors), without using the <function>*_new()</function> function.
    This is often necessary so that they can actually instantiate a derived
    GType, to add their own hooks for signal handlers and vfuncs.</para>
<para>At the least, the <function>_new()</function> function should not use any
    private API (functions that are only in a .c file). Even when there are no
    functions, we can sometimes reimplement 2 or 3 lines of code in a
    <function>_new()</function> function as long as those lines of code use API
    that is available to us.</para>
<para>Another workaround is to add a <function>*_construct()</function> function
    that the &cpp; constructor can call after instantiating its own type. For
    instance,</para>
<programlisting><code>GtkWidget* example_widget_new(int something, const char* thing)
{
        ExampleWidget* widget;
        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);
        example_widget_construct(widget, "something", something, "thing", thing);
}

void example_widget_construct(ExampleWidget* widget, int something, const char* thing)
{
        //Do stuff that uses private API:
        widget-&gt;priv-&gt;thing = thing;
        do_something(something);
}
</code></programlisting>
<para>Adding properties, and ensuring that they interact properly with each
    other, is relatively difficult to correct in the C library, but it is
    possible, so do file a bug and try to send a patch to the relevant
    maintainer.</para>
</section>
</section>

<section xml:id="sec-wrapping-documentation">
<title>Documentation</title>

<para>In general, gtkmm-style projects use Doxygen, which reads specially formatted &cpp; comments and generates HTML documentation. You may write these doxygen comments directly in the header files.</para>

<section xml:id="wrapping-reusing-c-documentation">
<title>Reusing C documentation</title>

<para>You might wish to reuse documentation that exists for the C library that
  you are wrapping. GTK-style C libraries typically use gtk-doc or gi-docgen and therefore
  have source code comments formatted for gtk-doc or gi-docgen and some extra documentation
  in .sgml and .xml files. The docextract_to_xml.py script, from glibmm's
  <filename>tools/defs_gen</filename> directory, can read these files and
  generate an .xml file that <command>gmmproc</command> can use to generate
  doxygen comments. <command>gmmproc</command> will even try to transform the
  documentation to make it more appropriate for a &cpp; API.</para>
<para>
For instance,</para>
<programlisting><code>./docextract_to_xml.py -s ~/checkout/gnome/gtk/gtk/ &gt; gtk_docs.xml
</code></programlisting>
<para>Because this automatic transformation is not always appropriate, you might
    want to provide hand-written text for a particular method. You can do this
    by copying the XML node for the function from your
    <filename>something_docs.xml</filename> file to the
    <filename>something_docs_override.xml</filename> file and changing the
    contents. Alternatively you can write your own documentation in the
    <filename>.hg</filename> file.</para>
</section>

<section xml:id="wrapping-documentation-build-structure">
<title>Documentation build structure</title>

<para>If you copied the skeleton source tree in <application>mm-common</application> and substituted the
  placeholder text, then you will already have suitable <filename>meson.build</filename>
  and <filename>Doxyfile.in</filename> files in the <filename>doc/reference/</filename>
  directory. You probably need to modify the <varname>tag_file_modules</varname>
  variable in <filename>meson.build</filename>, though.
  With the <application>mm-common</application> build setup, the list
  of Doxygen input files is not defined in the Doxygen configuration file, but passed
  along from <command>meson/ninja</command> to the standard input of <command>doxygen</command>.
</para>
</section>
</section>
</appendix>

<!-- Copied from https://www.gnu.org/licenses/old-licenses/fdl-1.2.dbk
  and updated from Docbook 4 to Docbook 5. -->
<appendix xml:id="chapter-gfdl">
  <title>GNU Free Documentation License</title>
  <para>
    Copyright (C) 2000, 2001, 2002 Free Software Foundation,
    <link xlink:href="https://fsf.org/">https://fsf.org/</link>.
    Everyone is permitted to copy and
    distribute verbatim copies of this license document, but changing it is
    not allowed.
  </para>
  <bridgehead xml:id="Preamble" renderas="sect1">
    0. PREAMBLE
  </bridgehead>
  <para>
    The purpose of this License is to make a manual, textbook, or other
    functional and useful document "free" in the sense of freedom: to assure
    everyone the effective freedom to copy and redistribute it, with or
    without modifying it, either commercially or noncommercially.
    Secondarily, this License preserves for the author and publisher a way to
    get credit for their work, while not being considered responsible for
    modifications made by others.
  </para>
  <para>
    This License is a kind of "copyleft", which means that derivative works of
    the document must themselves be free in the same sense.  It complements
    the GNU General Public License, which is a copyleft license designed for
    free software.
  </para>
  <para>
    We have designed this License in order to use it for manuals for free
    software, because free software needs free documentation: a free program
    should come with manuals providing the same freedoms that the software
    does.  But this License is not limited to software manuals; it can be used
    for any textual work, regardless of subject matter or whether it is
    published as a printed book.  We recommend this License principally for
    works whose purpose is instruction or reference.</para>
  <bridgehead xml:id="Definitions" renderas="sect1">
    1. APPLICABILITY AND DEFINITIONS
  </bridgehead>
  <para>
    This License applies to any manual or other work, in any medium, that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  Such a notice grants a
    world-wide, royalty-free license, unlimited in duration, to use that work
    under the conditions stated herein.  The "Document", below, refers to any
    such manual or work.  Any member of the public is a licensee, and is
    addressed as "you".  You accept the license if you copy, modify or
    distribute the work in a way requiring permission under copyright
    law.
  </para>
  <para>
    A "Modified Version" of the Document means any work containing the
    Document or a portion of it, either copied verbatim, or with modifications
    and/or translated into another language.
  </para>
  <para>
    A "Secondary Section" is a named appendix or a front-matter section of the
    Document that deals exclusively with the relationship of the publishers or
    authors of the Document to the Document's overall subject (or to related
    matters) and contains nothing that could fall directly within that overall
    subject.  (Thus, if the Document is in part a textbook of mathematics, a
    Secondary Section may not explain any mathematics.)  The relationship
    could be a matter of historical connection with the subject or with
    related matters, or of legal, commercial, philosophical, ethical or
    political position regarding them.
  </para>
  <para>
    The "Invariant Sections" are certain Secondary Sections whose titles are
    designated, as being those of Invariant Sections, in the notice that says
    that the Document is released under this License.  If a section does not
    fit the above definition of Secondary then it is not allowed to be
    designated as Invariant.  The Document may contain zero Invariant
    Sections.  If the Document does not identify any Invariant Sections then
    there are none.
  </para>
  <para>
    The "Cover Texts" are certain short passages of text that are listed, as
    Front-Cover Texts or Back-Cover Texts, in the notice that says that the
    Document is released under this License.  A Front-Cover Text may be at
    most 5 words, and a Back-Cover Text may be at most 25 words.
  </para>
  <para>
    A "Transparent" copy of the Document means a machine-readable copy,
    represented in a format whose specification is available to the general
    public, that is suitable for revising the document straightforwardly with
    generic text editors or (for images composed of pixels) generic paint
    programs or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic translation to a
    variety of formats suitable for input to text formatters.  A copy made in
    an otherwise Transparent file format whose markup, or absence of markup,
    has been arranged to thwart or discourage subsequent modification by
    readers is not Transparent.  An image format is not Transparent if used
    for any substantial amount of text.  A copy that is not "Transparent" is
    called "Opaque".
  </para>
  <para>
    Examples of suitable formats for Transparent copies include plain ASCII
    without markup, Texinfo input format, LaTeX input format, SGML or XML
    using a publicly available DTD, and standard-conforming simple HTML,
    PostScript or PDF designed for human modification.  Examples of
    transparent image formats include PNG, XCF and JPG.  Opaque formats
    include proprietary formats that can be read and edited only by
    proprietary word processors, SGML or XML for which the DTD and/or
    processing tools are not generally available, and the machine-generated
    HTML, PostScript or PDF produced by some word processors for output
    purposes only.
  </para>
  <para>
    The "Title Page" means, for a printed book, the title page itself, plus
    such following pages as are needed to hold, legibly, the material this
    License requires to appear in the title page.  For works in formats which
    do not have any title page as such, "Title Page" means the text near the
    most prominent appearance of the work's title, preceding the beginning of
    the body of the text.
  </para>
  <para>
    A section "Entitled XYZ" means a named subunit of the Document whose title
    either is precisely XYZ or contains XYZ in parentheses following text that
    translates XYZ in another language.  (Here XYZ stands for a specific
    section name mentioned below, such as "Acknowledgements", "Dedications",
    "Endorsements", or "History".)  To "Preserve the Title" of such a section
    when you modify the Document means that it remains a section "Entitled
    XYZ" according to this definition.
  </para>
  <para>
    The Document may include Warranty Disclaimers next to the notice which
    states that this License applies to the Document.  These Warranty
    Disclaimers are considered to be included by reference in this License,
    but only as regards disclaiming warranties: any other implication that
    these Warranty Disclaimers may have is void and has no effect on the
    meaning of this License.
  </para>
  <bridgehead xml:id="VerbatimCopying" renderas="sect1">
    2. VERBATIM COPYING
  </bridgehead>
  <para>
    You may copy and distribute the Document in any medium, either
    commercially or noncommercially, provided that this License, the copyright
    notices, and the license notice saying this License applies to the
    Document are reproduced in all copies, and that you add no other
    conditions whatsoever to those of this License.  You may not use technical
    measures to obstruct or control the reading or further copying of the
    copies you make or distribute.  However, you may accept compensation in
    exchange for copies.  If you distribute a large enough number of copies
    you must also follow the conditions in section 3.
  </para>
  <para>
    You may also lend copies, under the same conditions stated above, and you
    may publicly display copies.
  </para>
  <bridgehead xml:id="QuantityCopying" renderas="sect1">
    3. COPYING IN QUANTITY
  </bridgehead>
  <para>
    If you publish printed copies (or copies in media that commonly have
    printed covers) of the Document, numbering more than 100, and the
    Document's license notice requires Cover Texts, you must enclose the
    copies in covers that carry, clearly and legibly, all these Cover Texts:
    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
    cover.  Both covers must also clearly and legibly identify you as the
    publisher of these copies.  The front cover must present the full title
    with all words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes limited to
    the covers, as long as they preserve the title of the Document and satisfy
    these conditions, can be treated as verbatim copying in other
    respects.
  </para>
  <para>
    If the required texts for either cover are too voluminous to fit legibly,
    you should put the first ones listed (as many as fit reasonably) on the
    actual cover, and continue the rest onto adjacent pages.
  </para>
  <para>
    If you publish or distribute Opaque copies of the Document numbering more
    than 100, you must either include a machine-readable Transparent copy
    along with each Opaque copy, or state in or with each Opaque copy a
    computer-network location from which the general network-using public has
    access to download using public-standard network protocols a complete
    Transparent copy of the Document, free of added material.  If you use the
    latter option, you must take reasonably prudent steps, when you begin
    distribution of Opaque copies in quantity, to ensure that this Transparent
    copy will remain thus accessible at the stated location until at least one
    year after the last time you distribute an Opaque copy (directly or
    through your agents or retailers) of that edition to the public.
  </para>
  <para>
    It is requested, but not required, that you contact the authors of the
    Document well before redistributing any large number of copies, to give
    them a chance to provide you with an updated version of the
    Document.
  </para>
  <bridgehead xml:id="Modifications" renderas="sect1">
    4. MODIFICATIONS
  </bridgehead>
  <para>
    You may copy and distribute a Modified Version of the Document under the
    conditions of sections 2 and 3 above, provided that you release the
    Modified Version under precisely this License, with the Modified Version
    filling the role of the Document, thus licensing distribution and
    modification of the Modified Version to whoever possesses a copy of it.
    In addition, you must do these things in the Modified Version:
  </para>
  <orderedlist numeration="upperalpha">
    <listitem>
      <simpara>
        Use in the Title Page (and on the covers, if any) a title distinct
        from that of the Document, and from those of previous versions (which
        should, if there were any, be listed in the History section of the
        Document).  You may use the same title as a previous version if the
        original publisher of that version gives permission.
        </simpara>
    </listitem>
    <listitem>
      <simpara>
        List on the Title Page, as authors, one or more persons or entities
        responsible for authorship of the modifications in the Modified
        Version, together with at least five of the principal authors of the
        Document (all of its principal authors, if it has fewer than five),
        unless they release you from this requirement.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        State on the Title page the name of the publisher of the Modified
        Version, as the publisher.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Preserve all the copyright notices of the Document.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Add an appropriate copyright notice for your modifications adjacent to
        the other copyright notices.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Include, immediately after the copyright notices, a license notice
        giving the public permission to use the Modified Version under the
        terms of this License, in the form shown in the Addendum below.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Preserve in that license notice the full lists of Invariant Sections
        and required Cover Texts given in the Document's license notice.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Include an unaltered copy of this License.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Preserve the section Entitled "History", Preserve its Title, and add
        to it an item stating at least the title, year, new authors, and
        publisher of the Modified Version as given on the Title Page.  If
        there is no section Entitled "History" in the Document, create one
        stating the title, year, authors, and publisher of the Document as
        given on its Title Page, then add an item describing the Modified
        Version as stated in the previous sentence.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Preserve the network location, if any, given in the Document for
        public access to a Transparent copy of the Document, and likewise the
        network locations given in the Document for previous versions it was
        based on.  These may be placed in the "History" section.  You may omit
        a network location for a work that was published at least four years
        before the Document itself, or if the original publisher of the
        version it refers to gives permission.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        For any section Entitled "Acknowledgements" or "Dedications", Preserve
        the Title of the section, and preserve in the section all the
        substance and tone of each of the contributor acknowledgements and/or
        dedications given therein.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Preserve all the Invariant Sections of the Document, unaltered in
        their text and in their titles.  Section numbers or the equivalent are
        not considered part of the section titles.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Delete any section Entitled "Endorsements".  Such a section may not be
        included in the Modified Version.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Do not retitle any existing section to be Entitled "Endorsements" or
        to conflict in title with any Invariant Section.
      </simpara>
    </listitem>
    <listitem>
      <simpara>
        Preserve any Warranty Disclaimers.
      </simpara>
    </listitem>
  </orderedlist>
  <para>
    If the Modified Version includes new front-matter sections or appendices
    that qualify as Secondary Sections and contain no material copied from the
    Document, you may at your option designate some or all of these sections
    as invariant.  To do this, add their titles to the list of Invariant
    Sections in the Modified Version's license notice.  These titles must be
    distinct from any other section titles.
  </para>
  <para>
    You may add a section Entitled "Endorsements", provided it contains
    nothing but endorsements of your Modified Version by various parties--for
    example, statements of peer review or that the text has been approved by
    an organization as the authoritative definition of a standard.
  </para>
  <para>
    You may add a passage of up to five words as a Front-Cover Text, and a
    passage of up to 25 words as a Back-Cover Text, to the end of the list of
    Cover Texts in the Modified Version.  Only one passage of Front-Cover Text
    and one of Back-Cover Text may be added by (or through arrangements made
    by) any one entity.  If the Document already includes a cover text for the
    same cover, previously added by you or by arrangement made by the same
    entity you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous publisher
    that added the old one.
  </para>
  <para>
    The author(s) and publisher(s) of the Document do not by this License give
    permission to use their names for publicity for or to assert or imply
    endorsement of any Modified Version.
  </para>
  <bridgehead xml:id="Combining" renderas="sect1">
    5. COMBINING DOCUMENTS
  </bridgehead>
  <para>
    You may combine the Document with other documents released under this
    License, under the terms defined in section 4 above for modified versions,
    provided that you include in the combination all of the Invariant Sections
    of all of the original documents, unmodified, and list them all as
    Invariant Sections of your combined work in its license notice, and that
    you preserve all their Warranty Disclaimers.
  </para>
  <para>
    The combined work need only contain one copy of this License, and multiple
    identical Invariant Sections may be replaced with a single copy.  If there
    are multiple Invariant Sections with the same name but different contents,
    make the title of each such section unique by adding at the end of it, in
    parentheses, the name of the original author or publisher of that section
    if known, or else a unique number.  Make the same adjustment to the
    section titles in the list of Invariant Sections in the license notice of
    the combined work.
  </para>
  <para>
    In the combination, you must combine any sections Entitled "History" in
    the various original documents, forming one section Entitled "History";
    likewise combine any sections Entitled "Acknowledgements", and any
    sections Entitled "Dedications".  You must delete all sections Entitled
    "Endorsements".
  </para>
  <bridgehead xml:id="Collections" renderas="sect1">
    6. COLLECTIONS OF DOCUMENTS
  </bridgehead>
  <para>
    You may make a collection consisting of the Document and other documents
    released under this License, and replace the individual copies of this
    License in the various documents with a single copy that is included in
    the collection, provided that you follow the rules of this License for
    verbatim copying of each of the documents in all other respects.
  </para>
  <para>
    You may extract a single document from such a collection, and distribute
    it individually under this License, provided you insert a copy of this
    License into the extracted document, and follow this License in all other
    respects regarding verbatim copying of that document.
  </para>
  <bridgehead xml:id="Aggregation" renderas="sect1">
    7. AGGREGATION WITH INDEPENDENT WORKS
  </bridgehead>
  <para>
    A compilation of the Document or its derivatives with other separate and
    independent documents or works, in or on a volume of a storage or
    distribution medium, is called an "aggregate" if the copyright resulting
    from the compilation is not used to limit the legal rights of the
    compilation's users beyond what the individual works permit.  When the
    Document is included in an aggregate, this License does not apply to the
    other works in the aggregate which are not themselves derivative works of
    the Document.
  </para>
  <para>
    If the Cover Text requirement of section 3 is applicable to these copies
    of the Document, then if the Document is less than one half of the entire
    aggregate, the Document's Cover Texts may be placed on covers that bracket
    the Document within the aggregate, or the electronic equivalent of covers
    if the Document is in electronic form.  Otherwise they must appear on
    printed covers that bracket the whole aggregate.
  </para>
  <bridgehead xml:id="Translation" renderas="sect1">
    8. TRANSLATION
  </bridgehead>
  <para>
    Translation is considered a kind of modification, so you may distribute
    translations of the Document under the terms of section 4.  Replacing
    Invariant Sections with translations requires special permission from
    their copyright holders, but you may include translations of some or all
    Invariant Sections in addition to the original versions of these Invariant
    Sections.  You may include a translation of this License, and all the
    license notices in the Document, and any Warranty Disclaimers, provided
    that you also include the original English version of this License and the
    original versions of those notices and disclaimers.  In case of a
    disagreement between the translation and the original version of this
    License or a notice or disclaimer, the original version will prevail.
  </para>
  <para>
    If a section in the Document is Entitled "Acknowledgements",
    "Dedications", or "History", the requirement (section 4) to Preserve its
    Title (section 1) will typically require changing the actual title.
  </para>
  <bridgehead xml:id="Termination" renderas="sect1">
    9. TERMINATION
  </bridgehead>
  <para>
    You may not copy, modify, sublicense, or distribute the Document except as
    expressly provided for under this License.  Any other attempt to copy,
    modify, sublicense or distribute the Document is void, and will
    automatically terminate your rights under this License.  However, parties
    who have received copies, or rights, from you under this License will not
    have their licenses terminated so long as such parties remain in full
    compliance.
  </para>
  <bridgehead xml:id="FutureRevisions" renderas="sect1">
    10. FUTURE REVISIONS OF THIS LICENSE
  </bridgehead>
  <para>
    The Free Software Foundation may publish new, revised versions of the GNU
    Free Documentation License from time to time.  Such new versions will be
    similar in spirit to the present version, but may differ in detail to
    address new problems or concerns.  See <link
    xlink:href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</link>.
  </para>
  <para>
    Each version of the License is given a distinguishing version number.  If
    the Document specifies that a particular numbered version of this License
    "or any later version" applies to it, you have the option of following the
    terms and conditions either of that specified version or of any later
    version that has been published (not as a draft) by the Free Software
    Foundation.  If the Document does not specify a version number of this
    License, you may choose any version ever published (not as a draft) by the
    Free Software Foundation.
  </para>
  <bridgehead xml:id="HowToUse" renderas="sect1">
    ADDENDUM: How to use this License for your documents
  </bridgehead>
  <para>
    To use this License in a document you have written, include a copy of the
    License in the document and put the following copyright and license
    notices just after the title page:
  </para>
  <blockquote>
    <para>
      Copyright (C) YEAR YOUR NAME.
    </para>
    <para>
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.2 or
      any later version published by the Free Software Foundation; with no
      Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
      copy of the license is included in the section entitled "GNU Free
      Documentation License".
    </para>
  </blockquote>
  <para>
    If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
    replace the "with...Texts." line with this:
  </para>
  <blockquote>
    <para>
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
    </para>
  </blockquote>
  <para>
    If you have Invariant Sections without Cover Texts, or some other
    combination of the three, merge those two alternatives to suit the
    situation.
  </para>
  <para>
    If your document contains nontrivial examples of program code, we
    recommend releasing these examples in parallel under your choice of free
    software license, such as the GNU General Public License, to permit their
    use in free software.
  </para>
</appendix>

</book>
