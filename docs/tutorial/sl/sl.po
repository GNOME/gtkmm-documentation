# Slovenian translation for gtkmm-documentation.
# Copyright (C) 2010 gtkmm-documentation's COPYRIGHT HOLDER
# This file is distributed under the same license as the gtkmm-documentation package.
#
# Ime Priimek <email>, leto
#
msgid ""
msgstr ""
"Project-Id-Version: gtkmm-documentation help master\n"
"POT-Creation-Date: 2010-11-05 16:21+0000\n"
"PO-Revision-Date: 2010-11-06 15:36+0100\n"
"Last-Translator: Matej Urbančič <mateju@svn.gnome.org>\n"
"Language-Team: Slovenian GNOME Translation Team <gnome-si@googlegroups.com>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=4; plural=(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0);\n"
"X-Poedit-Country: SLOVENIA\n"
"X-Poedit-Language: Slovenian\n"
"X-Poedit-SourceCharset: utf-8\n"

#: C/gtkmm-tutorial-in.xml:34(title)
#, fuzzy
msgid "Programming with <application>gtkmm</application>"
msgstr "Odpri s privzetim programom"

#: C/gtkmm-tutorial-in.xml:38(firstname)
msgid "Murray"
msgstr "Murray"

#: C/gtkmm-tutorial-in.xml:39(surname)
msgid "Cumming"
msgstr "Cumming"

#: C/gtkmm-tutorial-in.xml:42(firstname)
msgid "Bernhard"
msgstr "Bernhard"

#: C/gtkmm-tutorial-in.xml:43(surname)
msgid "Rieder"
msgstr "Rieder"

#: C/gtkmm-tutorial-in.xml:44(contrib)
#, fuzzy
msgid "Chapter on \"Timeouts\"."
msgstr "Na tem računalniku"

#: C/gtkmm-tutorial-in.xml:47(firstname)
msgid "Jonathon"
msgstr "Jonathon"

#: C/gtkmm-tutorial-in.xml:48(surname)
msgid "Jongsma"
msgstr "Jongsma"

#: C/gtkmm-tutorial-in.xml:49(contrib)
msgid "Chapter on \"Drawing with Cairo\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:50(contrib)
msgid "Chapter on \"Working with gtkmm's Source Code\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:51(contrib)
#, fuzzy
msgid "Chapter on \"Recent Files\"."
msgstr "Nedavna največja starost datotek"

#: C/gtkmm-tutorial-in.xml:54(firstname)
msgid "Jason"
msgstr "Jason"

#: C/gtkmm-tutorial-in.xml:55(surname)
msgid "M'Sadoques"
msgstr "M'Sadoques"

#: C/gtkmm-tutorial-in.xml:56(contrib)
msgid "Chapter on \"Drawing Area\" with GDK."
msgstr ""

#: C/gtkmm-tutorial-in.xml:59(firstname)
msgid "Ole"
msgstr "Ole"

#: C/gtkmm-tutorial-in.xml:60(surname)
msgid "Laursen"
msgstr "Laursen"

#: C/gtkmm-tutorial-in.xml:61(contrib)
#: C/gtkmm-tutorial-in.xml:77(contrib)
msgid "Parts of chapter on \"Internationalization\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:64(firstname)
msgid "Gene"
msgstr "Gene"

#: C/gtkmm-tutorial-in.xml:65(surname)
msgid "Ruebsamen"
msgstr "Ruebsamen"

#: C/gtkmm-tutorial-in.xml:66(contrib)
#: C/gtkmm-tutorial-in.xml:71(contrib)
#, fuzzy
msgid "Chapter on \"Win32 Installation\"."
msgstr "Spreminjanje asociativnih povezav ni podprto na win32 sistemih"

#: C/gtkmm-tutorial-in.xml:69(firstname)
msgid "Cedric"
msgstr "Cedric"

#: C/gtkmm-tutorial-in.xml:70(surname)
msgid "Gustin"
msgstr "Gustin"

#: C/gtkmm-tutorial-in.xml:74(firstname)
msgid "Marko"
msgstr "Marko"

#: C/gtkmm-tutorial-in.xml:75(surname)
msgid "Anastasov"
msgstr "Anastasov"

#: C/gtkmm-tutorial-in.xml:76(contrib)
#, fuzzy
msgid "Chapter on \"Printing\"."
msgstr "Določi območje tiskanja"

#: C/gtkmm-tutorial-in.xml:80(firstname)
msgid "Daniel"
msgstr "Daniel"

#: C/gtkmm-tutorial-in.xml:81(surname)
msgid "Elstner"
msgstr "Elstner"

#: C/gtkmm-tutorial-in.xml:82(contrib)
msgid "Section \"Build Structure\" of chapter on \"Wrapping C Libraries with gmmproc\"."
msgstr ""

#. This text is copied from the introduction.
#: C/gtkmm-tutorial-in.xml:90(para)
msgid "This book explains key concepts of the <application>gtkmm</application> C++ API for creating user interfaces. It also introduces the main user interface elements (\"widgets\")."
msgstr ""

#: C/gtkmm-tutorial-in.xml:96(year)
msgid "2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010"
msgstr "2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010"

#: C/gtkmm-tutorial-in.xml:97(holder)
msgid "Murray Cumming"
msgstr "Murray Cumming"

#: C/gtkmm-tutorial-in.xml:101(para)
msgid "Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts. You may obtain a copy of the GNU Free Documentation License from the Free Software Foundation by visiting their Web site or by writing to: Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."
msgstr ""

#: C/gtkmm-tutorial-in.xml:113(title)
msgid "Introduction"
msgstr "Uvod"

#: C/gtkmm-tutorial-in.xml:116(title)
#, fuzzy
msgid "This book"
msgstr "Imenik"

#: C/gtkmm-tutorial-in.xml:118(para)
msgid "This book explains key concepts of the <application>gtkmm</application> C++ API for creating user interfaces. It also introduces the main user interface elements (\"widgets\"). Although it mentions classes, constructors, and methods, it does not go into great detail. Therefore, for full API information you should follow the links into the reference documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:120(para)
msgid "This book assumes a good understanding of C++, and how to create C++ programs."
msgstr ""

#: C/gtkmm-tutorial-in.xml:122(para)
msgid "We would very much like to hear of any problems you have learning <application>gtkmm</application> with this document, and would appreciate input regarding improvements. Please see the <link linkend=\"chapter-contributing\">Contributing</link> section for further information."
msgstr ""

#: C/gtkmm-tutorial-in.xml:129(title)
msgid "gtkmm"
msgstr "gtkmm"

#: C/gtkmm-tutorial-in.xml:130(para)
msgid "<application>gtkmm</application> is a C++ wrapper for <ulink url=\"http://www.gtk.org/\">GTK+</ulink>, a library used to create graphical user interfaces. It is licensed using the LGPL license, so you can develop open software, free software, or even commercial non-free software using <application>gtkmm</application> without purchasing licenses."
msgstr ""

#: C/gtkmm-tutorial-in.xml:138(para)
msgid "<application>gtkmm</application> was originally named gtk-- because GTK+ already has a + in the name. However, as -- is not easily indexed by search engines the package generally went by the name <application>gtkmm</application>, and that's what we stuck with."
msgstr ""

#: C/gtkmm-tutorial-in.xml:141(title)
msgid "Why use <application>gtkmm</application> instead of GTK+?"
msgstr ""

#: C/gtkmm-tutorial-in.xml:142(para)
msgid "<application>gtkmm</application> allows you to write code using normal C++ techniques such as encapsulation, derivation, and polymorphism. As a C++ programmer you probably already realise that this leads to clearer and better organized code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:143(para)
msgid "<application>gtkmm</application> is more type-safe, so the compiler can detect errors that would only be detected at run time when using C. This use of specific types also makes the API clearer because you can see what types should be used just by looking at a method's declaration."
msgstr ""

#: C/gtkmm-tutorial-in.xml:144(para)
msgid "Inheritance can be used to derive new widgets. The derivation of new widgets in GTK+ C code is so complicated and error prone that almost no C coders do it. As a C++ developer you know that derivation is an essential Object Orientated technique."
msgstr ""

#: C/gtkmm-tutorial-in.xml:145(para)
msgid "Member instances can be used, simplifying memory management. All GTK+ C widgets are dealt with by use of pointers. As a C++ coder you know that pointers should be avoided where possible."
msgstr ""

#: C/gtkmm-tutorial-in.xml:146(para)
msgid "<application>gtkmm</application> involves less code compared to GTK+, which uses prefixed function names and lots of cast macros."
msgstr ""

#: C/gtkmm-tutorial-in.xml:150(title)
msgid "<application>gtkmm</application> compared to Qt"
msgstr ""

#: C/gtkmm-tutorial-in.xml:151(para)
msgid "Trolltech's Qt is the closest competition to <application>gtkmm</application>, so it deserves discussion."
msgstr ""

#: C/gtkmm-tutorial-in.xml:153(para)
msgid "<application>gtkmm</application> developers tend to prefer <application>gtkmm</application> to Qt because <application>gtkmm</application> does things in a more C++ way. Qt originates from a time when C++ and the standard library were not standardised or well supported by compilers. It therefore duplicates a lot of stuff that is now in the standard library, such as containers and type information. Most significantly, Trolltech modified the C++ language to provide signals, so that Qt classes cannot be used easily with non-Qt classes. <application>gtkmm</application> was able to use standard C++ to provide signals without changing the C++ language. See the FAQ for more detailed differences."
msgstr ""

#: C/gtkmm-tutorial-in.xml:157(title)
#, fuzzy
msgid "<application>gtkmm</application> is a wrapper"
msgstr "Conduit je program za usklajevanje."

#: C/gtkmm-tutorial-in.xml:158(para)
msgid "<application>gtkmm</application> is not a native C++ toolkit, but a C++ wrapper of a C toolkit. This separation of interface and implementation has advantages. The <application>gtkmm</application> developers spend most of their time talking about how <application>gtkmm</application> can present the clearest API, without awkward compromises due to obscure technical details. We contribute a little to the underlying GTK+ code base, but so do the C coders, and the Perl coders and the Python coders, etc. Therefore GTK+ benefits from a broader user base than language-specific toolkits - there are more implementers, more developers, more testers, and more users."
msgstr ""

#: C/gtkmm-tutorial-in.xml:166(title)
msgid "Installation"
msgstr "Namestitev"

#: C/gtkmm-tutorial-in.xml:168(title)
msgid "Dependencies"
msgstr "Odvisnosti"

#: C/gtkmm-tutorial-in.xml:169(para)
msgid "Before attempting to install <application>gtkmm</application> 2.4, you might first need to install these other packages."
msgstr ""

#: C/gtkmm-tutorial-in.xml:174(application)
msgid "libsigc++ 2.0"
msgstr "libsigc++ 2.0"

#: C/gtkmm-tutorial-in.xml:175(application)
msgid "GTK+ 2.4"
msgstr "GTK+ 2.4"

#: C/gtkmm-tutorial-in.xml:176(application)
msgid "cairomm"
msgstr "cairomm"

#: C/gtkmm-tutorial-in.xml:178(para)
msgid "These dependencies have their own dependencies, including the following applications and libraries:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:183(application)
#, fuzzy
msgid "pkg-config"
msgstr "pkg-config"

#: C/gtkmm-tutorial-in.xml:184(application)
msgid "glib"
msgstr "glib"

#: C/gtkmm-tutorial-in.xml:185(application)
msgid "ATK"
msgstr "ATK"

#: C/gtkmm-tutorial-in.xml:186(application)
msgid "Pango"
msgstr "Pango"

#: C/gtkmm-tutorial-in.xml:187(application)
msgid "cairo"
msgstr "cairo"

#: C/gtkmm-tutorial-in.xml:192(title)
#, fuzzy
msgid "Unix and Linux"
msgstr "Dostop do Unix/Linux terminalov"

#: C/gtkmm-tutorial-in.xml:195(title)
#, fuzzy
msgid "Prebuilt Packages"
msgstr "Modul/paketi"

#: C/gtkmm-tutorial-in.xml:197(para)
msgid "Recent versions of <application>gtkmm</application> are packaged by nearly every major Linux distribution these days. So, if you use Linux, you can probably get started with <application>gtkmm</application> by installing the package from the official repository for your distribution. Distributions that include <application>gtkmm</application> in their repositories include Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and many others."
msgstr ""

#: C/gtkmm-tutorial-in.xml:205(para)
msgid "The names of the <application>gtkmm</application> packages vary from distribution to distribution (e.g. <application>libgtkmm2.4-dev</application> on Debian and Ubuntu or <application>gtkmm24-devel</application> on Red Hat Fedora), so check with your distribution's package management program for the correct package name and install it like you would any other package."
msgstr ""

#: C/gtkmm-tutorial-in.xml:213(para)
msgid "The package names will not change when new API/ABI-compatible versions of <application>gtkmm</application> are released. Otherwise they would not be API/ABI-compatible. So don't be surprised, for instance, to find <application>gtkmm</application> 2.8 supplied by Debian's <application>libgtkmm2.4-dev</application> package."
msgstr ""

#: C/gtkmm-tutorial-in.xml:223(title)
#, fuzzy
msgid "Installing From Source"
msgstr "Ni mogoče namestiti paketov iz nezaupljivih virov"

#: C/gtkmm-tutorial-in.xml:225(para)
msgid "If your distribution does not provide a pre-built <application>gtkmm</application> package, or if you want to install a different version than the one provided by your distribution, you can also install <application>gtkmm</application> from source. The source code for <application>gtkmm</application> can be downloaded from <ulink url=\"http://www.gtkmm.org/\"/>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:231(para)
msgid "After you've installed all of the dependencies, download the <application>gtkmm</application> source code, unpack it, and change to the newly created directory. <application>gtkmm</application> can be built and installed with the following sequence of commands:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:236(screen)
#, fuzzy, no-wrap
msgid ""
"\n"
"# ./configure\n"
"# make\n"
"# make install\n"
msgstr "Ali ste opravili namestitev?\n"

#: C/gtkmm-tutorial-in.xml:242(para)
msgid "Remember that on a Unix or Linux operating system, you will probably need to be <literal>root</literal> to install software. The <command>su</command> command will allow you to enter the <literal>root</literal> password and have <literal>root</literal> status temporarily."
msgstr ""

#: C/gtkmm-tutorial-in.xml:249(para)
msgid "The <filename>configure</filename> script will check to make sure all of the required dependencies are already installed. If you are missing any dependencies, it will exit and display an error."
msgstr ""

#: C/gtkmm-tutorial-in.xml:254(para)
msgid ""
"By default, <application>gtkmm</application> will be installed under the <filename>/usr/local</filename> directory. On some systems you may need to install to a different location. For instance, on Red Hat Linux systems you might use the <literal>--prefix</literal> option with configure, like so: <screen>\n"
"# ./configure --prefix=/usr\n"
"</screen>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:265(para)
msgid "You should be very careful when installing to standard system prefixes such as <filename>/usr</filename>. Linux distributions install software packages to <filename>/usr</filename>, so installing a source package to this prefix could corrupt or conflict with software installed using your distribution's package-management system. Ideally, you should use a separate prefix for all software you install from source."
msgstr ""

#: C/gtkmm-tutorial-in.xml:274(para)
msgid "If you want to help develop <application>gtkmm</application> or experiment with new features, you can also install <application>gtkmm</application> from git. Most users will never need to do this, but if you're interested in helping with <application>gtkmm</application> development, see the <link linkend=\"chapter-working-with-source\">Working with gtkmm's Source Code</link> appendix."
msgstr ""

#: C/gtkmm-tutorial-in.xml:285(title)
#, fuzzy
msgid "Microsoft Windows"
msgstr "Ali želite onemogočiti združljivost z Microsoft Okni?"

#: C/gtkmm-tutorial-in.xml:286(para)
msgid "GTK+ and <application>gtkmm</application> were designed to work well with Microsoft Windows, and the developers encourage its use on the win32 platform. However, Windows has no standard installation system for development libraries. Please see the <ulink url=\"http://live.gnome.org/gtkmm/MSWindows\">Windows Installation</ulink> page for Windows-specific installation instructions and notes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:293(title)
msgid "Basics"
msgstr "Osnove"

#: C/gtkmm-tutorial-in.xml:295(para)
msgid "This chapter will introduce some of the most important aspects of <application>gtkmm</application> coding. These will be demonstrated with simple working example code. However, this is just a taster, so you need to look at the other chapters for more substantial information."
msgstr ""

#: C/gtkmm-tutorial-in.xml:298(para)
msgid "Your existing knowledge of C++ will help you with <application>gtkmm</application> as it would with any library. Unless we state otherwise, you can expect <application>gtkmm</application> classes to behave like any other C++ class, and you can expect to use your existing C++ techniques with <application>gtkmm</application> classes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:303(title)
#: C/gtkmm-tutorial-in.xml:3346(title)
#, fuzzy
msgid "Simple Example"
msgstr "Primer Bakery"

#: C/gtkmm-tutorial-in.xml:305(para)
msgid "To begin our introduction to <application>gtkmm</application>, we'll start with the simplest program possible. This program will create an empty 200 x 200 pixel window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:310(ulink)
#: C/gtkmm-tutorial-in.xml:487(ulink)
#: C/gtkmm-tutorial-in.xml:703(ulink)
#: C/gtkmm-tutorial-in.xml:811(ulink)
#: C/gtkmm-tutorial-in.xml:920(ulink)
#: C/gtkmm-tutorial-in.xml:1085(ulink)
#: C/gtkmm-tutorial-in.xml:1139(ulink)
#: C/gtkmm-tutorial-in.xml:1194(ulink)
#: C/gtkmm-tutorial-in.xml:1241(ulink)
#: C/gtkmm-tutorial-in.xml:1268(ulink)
#: C/gtkmm-tutorial-in.xml:1293(ulink)
#: C/gtkmm-tutorial-in.xml:1441(ulink)
#: C/gtkmm-tutorial-in.xml:1507(ulink)
#: C/gtkmm-tutorial-in.xml:1531(ulink)
#: C/gtkmm-tutorial-in.xml:1606(ulink)
#: C/gtkmm-tutorial-in.xml:1647(ulink)
#: C/gtkmm-tutorial-in.xml:1692(ulink)
#: C/gtkmm-tutorial-in.xml:1727(ulink)
#: C/gtkmm-tutorial-in.xml:1766(ulink)
#: C/gtkmm-tutorial-in.xml:1895(ulink)
#: C/gtkmm-tutorial-in.xml:2023(ulink)
#: C/gtkmm-tutorial-in.xml:2066(ulink)
#: C/gtkmm-tutorial-in.xml:2225(ulink)
#: C/gtkmm-tutorial-in.xml:2273(ulink)
#: C/gtkmm-tutorial-in.xml:2313(ulink)
#: C/gtkmm-tutorial-in.xml:2909(ulink)
#: C/gtkmm-tutorial-in.xml:2928(ulink)
#: C/gtkmm-tutorial-in.xml:2947(ulink)
#: C/gtkmm-tutorial-in.xml:2969(ulink)
#: C/gtkmm-tutorial-in.xml:2991(ulink)
#: C/gtkmm-tutorial-in.xml:3064(ulink)
#: C/gtkmm-tutorial-in.xml:3077(ulink)
#: C/gtkmm-tutorial-in.xml:3111(ulink)
#: C/gtkmm-tutorial-in.xml:3124(ulink)
#: C/gtkmm-tutorial-in.xml:3355(ulink)
#: C/gtkmm-tutorial-in.xml:3530(ulink)
#: C/gtkmm-tutorial-in.xml:3543(ulink)
#: C/gtkmm-tutorial-in.xml:3599(ulink)
#: C/gtkmm-tutorial-in.xml:3857(ulink)
#: C/gtkmm-tutorial-in.xml:3919(ulink)
#: C/gtkmm-tutorial-in.xml:3946(ulink)
#: C/gtkmm-tutorial-in.xml:3968(ulink)
#: C/gtkmm-tutorial-in.xml:3991(ulink)
#: C/gtkmm-tutorial-in.xml:4187(ulink)
#: C/gtkmm-tutorial-in.xml:4284(ulink)
#: C/gtkmm-tutorial-in.xml:4365(ulink)
#: C/gtkmm-tutorial-in.xml:4533(ulink)
#: C/gtkmm-tutorial-in.xml:4749(ulink)
#: C/gtkmm-tutorial-in.xml:4909(ulink)
#: C/gtkmm-tutorial-in.xml:4929(ulink)
#: C/gtkmm-tutorial-in.xml:5307(ulink)
#: C/gtkmm-tutorial-in.xml:5522(ulink)
#: C/gtkmm-tutorial-in.xml:5656(ulink)
#: C/gtkmm-tutorial-in.xml:5762(ulink)
#: C/gtkmm-tutorial-in.xml:5859(ulink)
#: C/gtkmm-tutorial-in.xml:5896(ulink)
#: C/gtkmm-tutorial-in.xml:6247(ulink)
#: C/gtkmm-tutorial-in.xml:6315(ulink)
#: C/gtkmm-tutorial-in.xml:6931(ulink)
#: C/gtkmm-tutorial-in.xml:6955(ulink)
#: C/gtkmm-tutorial-in.xml:7704(ulink)
#, fuzzy
msgid "Source Code"
msgstr "<b>Izvorna koda</b>"

#: C/gtkmm-tutorial-in.xml:312(para)
msgid "We will now explain each line of the example"
msgstr ""

#: C/gtkmm-tutorial-in.xml:313(programlisting)
#, fuzzy, no-wrap
msgid "#include &lt;gtkmm.h&gt;"
msgstr "Z &lt;\\|&gt; tipkami"

#: C/gtkmm-tutorial-in.xml:314(para)
msgid "All <application>gtkmm</application> programs must include certain <application>gtkmm</application> headers; <literal>gtkmm.h</literal> includes the entire <application>gtkmm</application> kit. This is usually not a good idea, because it includes a megabyte or so of headers, but for simple programs, it suffices."
msgstr ""

#: C/gtkmm-tutorial-in.xml:324(programlisting)
#, no-wrap
msgid "Gtk::Main kit(argc, argv);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:321(para)
msgid "The next line: <placeholder-1/> creates a <classname>Gtk::Main</classname> object. This is needed in all <application>gtkmm</application> applications. The constructor for this object initializes <application>gtkmm</application>, and checks the arguments passed to your application on the command line, looking for standard options such as <literal>-display</literal>. It takes these from the argument list, leaving anything it does not recognize for your application to parse or ignore. This ensures that all <application>gtkmm</application> applications accept the same set of standard arguments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:334(para)
msgid "The next two lines of code create and display a window:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:337(programlisting)
#, fuzzy, no-wrap
msgid "Gtk::Window window;"
msgstr "Skrij okno"

#: C/gtkmm-tutorial-in.xml:338(para)
msgid "The last line shows the window and enters the <application>gtkmm</application> main processing loop, which will finish when the window is closed."
msgstr ""

#: C/gtkmm-tutorial-in.xml:342(programlisting)
#, fuzzy, no-wrap
msgid "Gtk::Main::run(window);"
msgstr "Zaženite Anjal v oknu"

#: C/gtkmm-tutorial-in.xml:346(programlisting)
#, no-wrap
msgid "g++ simple.cc -o simple `pkg-config gtkmm-2.4 --cflags --libs`"
msgstr ""

#: C/gtkmm-tutorial-in.xml:344(para)
msgid "After putting the source code in <literal>simple.cc</literal> you can compile the above program with gcc using: <placeholder-1/> Note that you must surround the <literal>pkg-config</literal> invocation with backquotes. Backquotes cause the shell to execute the command inside them, and to use the command's output as part of the command line."
msgstr ""

#: C/gtkmm-tutorial-in.xml:355(title)
#, fuzzy
msgid "Headers and Linking"
msgstr "Opozorila in napake"

#: C/gtkmm-tutorial-in.xml:356(para)
msgid "Although we have shown the compilation command for the simple example, you really should use the automake and autoconf tools, as described in \"Autoconf, Automake, Libtool\", by G. V. Vaughan et al. The examples used in this book are included in the <application>gtkmm</application> package, with appropriate build files, so we won't show the build commands in future. You'll just need to find the appropriate directory and type <literal>make</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:359(para)
msgid "To simplify compilation, we use <literal>pkg-config</literal>, which is present in all (properly installed) <application>gtkmm</application> installations. This program 'knows' what compiler switches are needed to compile programs that use <application>gtkmm</application>. The <literal>--cflags</literal> option causes <literal>pkg-config</literal> to output a list of include directories for the compiler to look in; the <literal>--libs</literal> option requests the list of libraries for the compiler to link with and the directories to find them in. Try running it from your shell-prompt to see the results on your system."
msgstr ""

#: C/gtkmm-tutorial-in.xml:372(programlisting)
#, no-wrap
msgid "PKG_CHECK_MODULES([MYAPP], [gtkmm-2.4 &gt;= 2.8.0])"
msgstr ""

#: C/gtkmm-tutorial-in.xml:369(para)
msgid "However, this is even simpler when using the <function>PKG_CHECK_MODULES()</function> macro in a standard configure.ac file with autoconf and automake. For instance: <placeholder-1/> This checks for the presence of gtkmm and defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile.am files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:375(para)
msgid "gtkmm-2.4 is the name of the current stable API. There was an older API called gtkmm-2-0 which installs in parallel when it is available. There are several versions of gtkmm-2.4, such as gtkmm 2.10. Note that the API name does not change for every version because that would be an incompatible API and ABI break. Theoretically, there might be a future gtkmm-3.0 API which would install in parallel with gtkmm-2.4 without affecting existing applications."
msgstr ""

#: C/gtkmm-tutorial-in.xml:378(para)
msgid "Note that if you mention extra modules in addition to gtkmm-2.4, they should be separated by spaces, not commas."
msgstr ""

#: C/gtkmm-tutorial-in.xml:380(para)
msgid "Openismus has more <ulink url=\"http://www.openismus.com/documents/linux/automake/automake.shtml\">basic help with automake and autoconf</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:387(title)
#: C/gtkmm-tutorial-in.xml:5919(title)
#, fuzzy
msgid "Widgets"
msgstr "Gradniki"

#: C/gtkmm-tutorial-in.xml:388(para)
msgid "<application>gtkmm</application> applications consist of windows containing widgets, such as buttons and text boxes. In some other systems, widgets are called \"controls\". For each widget in your application's windows, there is a C++ object in your application's code. So you just need to call a method of the widget's class to affect the visible widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:390(programlisting)
#, no-wrap
msgid ""
"m_box.pack_start(m_Button1);\n"
"m_box.pack_start(m_Button2);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:393(programlisting)
#, fuzzy, no-wrap
msgid "m_frame.add(m_box);"
msgstr "Nariši oris okna"

#: C/gtkmm-tutorial-in.xml:389(para)
msgid "Widgets are arranged inside container widgets such as frames and notebooks, in a hierarchy of widgets within widgets. Some of these container widgets, such as Gtk::VBox, are not visible - they exist only to arrange other widgets. Here is some example code that adds 2 Gtk::Button widgets to a Gtk::VBox container widgets: <placeholder-1/> and here is how to add the Gtk::VBox, containing those buttons, to a Gtk::Frame, which has a visible frame and title: <placeholder-2/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:395(para)
msgid "Most of the chapters in this book deal with specific widgets. See the <link linkend=\"chapter-container-widgets\">Container Widgets</link> section for more details about adding widgets to container widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:399(para)
msgid "Although you can specify the layout and appearance of windows and widgets with C++ code, you will probably find it more convenient to design your user interfaces with <literal>Glade</literal> and load them at runtime with <literal>Gtk::Builder</literal>. See the <link linkend=\"chapter-builder\">Glade and Gtk::Builder</link> chapter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:402(para)
msgid "Although <application>gtkmm</application> widget instances have lifetimes and scopes just like those of other C++ classes, <application>gtkmm</application> has an optional time-saving feature that you will see in some of the examples. <function>Gtk::manage()</function> allows you to say that a child widget is owned by the container into which you place it. This allows you to <function>new</function> the widget, add it to the container and forget about deleting it. You can learn more about <application>gtkmm</application> memory management techniques in the <link linkend=\"chapter-memory\">Memory Management chapter</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:408(title)
#: C/gtkmm-tutorial-in.xml:707(title)
#: C/gtkmm-tutorial-in.xml:4667(title)
#: C/gtkmm-tutorial-in.xml:4962(title)
#: C/gtkmm-tutorial-in.xml:7240(title)
#, fuzzy
msgid "Signals"
msgstr "Signali"

#: C/gtkmm-tutorial-in.xml:410(para)
msgid "<application>gtkmm</application>, like most GUI toolkits, is <emphasis>event-driven</emphasis>. When an event occurs, such as the press of a mouse button, the appropriate signal will be <emphasis>emitted</emphasis> by the Widget that was pressed. Each Widget has a different set of signals that it can emit. To make a button click result in an action, we set up a <emphasis>signal handler</emphasis> to catch the button's \"clicked\" signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:418(programlisting)
#, no-wrap
msgid ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:417(para)
msgid "<application>gtkmm</application> uses the libsigc++ library to implement signals. Here is an example line of code that connects a Gtk::Button's \"clicked\" signal with a signal handler called \"on_button_clicked\": <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:422(para)
msgid "For more detailed information about signals, see the <link linkend=\"chapter-signals\">appendix</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:423(para)
msgid "For information about implementing your own signals rather than just connecting to the existing <application>gtkmm</application> signals, see the <link linkend=\"chapter-custom-signals\">appendix</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:429(title)
#: C/gtkmm-tutorial-in.xml:8788(classname)
msgid "Glib::ustring"
msgstr "Glib::ustring"

#: C/gtkmm-tutorial-in.xml:430(para)
msgid "You might be surprised to learn that <application>gtkmm</application> doesn't use <classname>std::string</classname> in it its interfaces. Instead it uses <classname>Glib::ustring</classname>, which is so similar and unobtrusive that you could actually pretend that each Glib::ustring is a <classname>std::string</classname> and ignore the rest of this section. But read on if you want to use languages other than English in your application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:431(para)
msgid "std::string uses 8 bit per character, but 8 bits aren't enough to encode languages such as Arabic, Chinese, and Japanese. Although the encodings for these languages has now been specified by the Unicode Constortium, the C and C++ languages do not yet provide any standardised Unicode support. GTK+ and GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by Glib::ustring. It provides almost exactly the same interface as std::string, along with automatic conversions to and from std::string."
msgstr ""

#: C/gtkmm-tutorial-in.xml:432(para)
msgid "One of the benefits of UTF-8 is that you don't need to use it unless you want to, so you don't need to retrofit all of your code at once. <classname>std::string</classname> will still work for 7-bit ASCII strings. But when you try to localize your application for languages like Chinese, for instance, you will start to see strange errors, and possible crashes. Then all you need to do is start using <classname>Glib::ustring</classname> instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:433(para)
msgid "Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For instance, German umlauts are not in the ASCII range and need more than 1 byte in the UTF-8 encoding. If your code contains 8-bit string literals, you have to convert them to UTF-8 (e.g. the Bavarian greeting \"Grüß Gott\" would be \"Gr\\xC3\\xBC\\xC3\\x9F Gott\")."
msgstr ""

#: C/gtkmm-tutorial-in.xml:434(para)
msgid "You should avoid C-style pointer arithmetic, and functions such as strlen(). In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not possible to assume that the next byte is another character. <classname>Glib::ustring</classname> worries about the details of this for you so you can use methods such as Glib::ustring::substr() while still thinking in terms of characters instead of bytes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:436(para)
msgid "Unlike the Windows UCS-2 Unicode solution, this does not require any special compiler options to process string literals, and it does not result in Unicode executables and libraries which are incompatible with ASCII ones."
msgstr ""

#: C/gtkmm-tutorial-in.xml:438(ulink)
#: C/gtkmm-tutorial-in.xml:687(ulink)
#: C/gtkmm-tutorial-in.xml:785(ulink)
#: C/gtkmm-tutorial-in.xml:800(ulink)
#: C/gtkmm-tutorial-in.xml:903(ulink)
#: C/gtkmm-tutorial-in.xml:957(ulink)
#: C/gtkmm-tutorial-in.xml:975(ulink)
#: C/gtkmm-tutorial-in.xml:1021(ulink)
#: C/gtkmm-tutorial-in.xml:1123(ulink)
#: C/gtkmm-tutorial-in.xml:1178(ulink)
#: C/gtkmm-tutorial-in.xml:1224(ulink)
#: C/gtkmm-tutorial-in.xml:1424(ulink)
#: C/gtkmm-tutorial-in.xml:1472(ulink)
#: C/gtkmm-tutorial-in.xml:1520(ulink)
#: C/gtkmm-tutorial-in.xml:1595(ulink)
#: C/gtkmm-tutorial-in.xml:1636(ulink)
#: C/gtkmm-tutorial-in.xml:1677(ulink)
#: C/gtkmm-tutorial-in.xml:1710(ulink)
#: C/gtkmm-tutorial-in.xml:1750(ulink)
#: C/gtkmm-tutorial-in.xml:1987(ulink)
#: C/gtkmm-tutorial-in.xml:2054(ulink)
#: C/gtkmm-tutorial-in.xml:2207(ulink)
#: C/gtkmm-tutorial-in.xml:2262(ulink)
#: C/gtkmm-tutorial-in.xml:2302(ulink)
#: C/gtkmm-tutorial-in.xml:2349(ulink)
#: C/gtkmm-tutorial-in.xml:2365(ulink)
#: C/gtkmm-tutorial-in.xml:2383(ulink)
#: C/gtkmm-tutorial-in.xml:2491(ulink)
#: C/gtkmm-tutorial-in.xml:3010(ulink)
#: C/gtkmm-tutorial-in.xml:3163(ulink)
#: C/gtkmm-tutorial-in.xml:3191(ulink)
#: C/gtkmm-tutorial-in.xml:3220(ulink)
#: C/gtkmm-tutorial-in.xml:3272(ulink)
#: C/gtkmm-tutorial-in.xml:3292(ulink)
#: C/gtkmm-tutorial-in.xml:3340(ulink)
#: C/gtkmm-tutorial-in.xml:3839(ulink)
#: C/gtkmm-tutorial-in.xml:3896(ulink)
#: C/gtkmm-tutorial-in.xml:3907(ulink)
#: C/gtkmm-tutorial-in.xml:3934(ulink)
#: C/gtkmm-tutorial-in.xml:3956(ulink)
#: C/gtkmm-tutorial-in.xml:3979(ulink)
#: C/gtkmm-tutorial-in.xml:4777(ulink)
#: C/gtkmm-tutorial-in.xml:5052(ulink)
#: C/gtkmm-tutorial-in.xml:5084(ulink)
#: C/gtkmm-tutorial-in.xml:7108(ulink)
#, fuzzy
msgid "Reference"
msgstr "Sklic"

#: C/gtkmm-tutorial-in.xml:440(para)
msgid "See the <link linkend=\"chapter-internationalization\">Internationalization</link> section for information about providing the UTF-8 string literals."
msgstr ""

#: C/gtkmm-tutorial-in.xml:445(title)
#, fuzzy
msgid "Intermediate types"
msgstr "Vrste prejemanja"

#: C/gtkmm-tutorial-in.xml:448(para)
msgid "<classname>Glib::StringArrayHandle</classname> or <classname>Glib::ArrayHandle&lt;Glib::ustring&gt;</classname>: Use <classname>std::vector&lt;Glib::ustring&gt;</classname>, <classname>std::list&lt;Glib::ustring&gt;</classname>, <type>const char*[]</type>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:449(para)
msgid "<classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>: Use <classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::list&lt;Gtk::Widget*&gt;</classname>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:450(para)
msgid "<classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>: Use <classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::list&lt;Gtk::Widget*&gt;</classname>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:446(para)
msgid "Some parts of the <application>gtkmm</application> API use intermediate data containers, such as <classname>Glib::StringArrayHandle</classname> instead of a specific Standard C++ container such as <classname>std::vector</classname> or <classname>std::list</classname>. You should not declare these types yourself -- you should use whatever Standard C++ container you prefer instead. <application>gtkmm</application> will do the conversion for you. Here are some of these intermediate types: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:458(title)
#, fuzzy
msgid "Mixing C and C++ APIs"
msgstr "Opozorila in napake"

#: C/gtkmm-tutorial-in.xml:459(para)
msgid "You can use C APIs which do not yet have convenient C++ interfaces. It is generally not a problem to use C APIs from C++, and <application>gtkmm</application> helps by providing access to the underlying C object, and providing an easy way to create a C++ wrapper object from a C object, provided that the C API is also based on the GObject system."
msgstr ""

#: C/gtkmm-tutorial-in.xml:461(para)
msgid "To use a <application>gtkmm</application> instance with a C function that requires a C GObject instance, use the <function>gobj()</function> function to obtain a pointer to the underlying GObject instance. For instance"
msgstr ""

#: C/gtkmm-tutorial-in.xml:464(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Button* button = new Gtk::Button(\"example\");\n"
"gtk_button_do_something_new(button-&gt;gobj());\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:470(para)
msgid "To obtain a <application>gtkmm</application> instance from a C GObject instance, use the Glib::wrap() function. For instance"
msgstr ""

#: C/gtkmm-tutorial-in.xml:472(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:480(title)
msgid "Hello World in <application>gtkmm</application>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:482(para)
msgid "We've now learned enough to look at a real example. In accordance with an ancient tradition of computer science, we now introduce Hello World, a la <application>gtkmm</application>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:489(para)
msgid "Try to compile and run it before going on. You should see something like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:494(title)
#, fuzzy
msgid "Hello World"
msgstr "Pozdravljen svet!"

#: C/gtkmm-tutorial-in.xml:500(para)
msgid "Pretty thrilling, eh? Let's examine the code. First, the <classname>HelloWorld</classname> class:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:505(programlisting)
#, no-wrap
msgid ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"\n"
"public:\n"
"  HelloWorld();\n"
"  virtual ~HelloWorld();\n"
"\n"
"protected:\n"
"  //Signal handlers:\n"
"  virtual void on_button_clicked();\n"
"\n"
"  //Member widgets:\n"
"  Gtk::Button m_button;\n"
"};"
msgstr ""

#: C/gtkmm-tutorial-in.xml:520(para)
msgid "This class implements the \"Hello World\" window. It's derived from <classname>Gtk::Window</classname>, and has a single <classname>Gtk::Button</classname> as a member. We've chosen to use the constructor to do all of the initialisation work for the window, including setting up the signals. Here it is, with the comments omitted:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:529(programlisting)
#, no-wrap
msgid ""
"HelloWorld::HelloWorld()\n"
":\n"
"  m_button (\"Hello World\")\n"
"{\n"
"  set_border_width(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  add(m_button);.\n"
"  m_button.show();\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:540(para)
msgid "Notice that we've used an initialiser statement to give the <literal>m_button</literal> object the label \"Hello World\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:545(para)
msgid "Next we call the Window's <methodname>set_border_width()</methodname> method. This sets the amount of space between the sides of the window and the widget it contains."
msgstr ""

#: C/gtkmm-tutorial-in.xml:551(para)
msgid "We then hook up a signal handler to <literal>m_button</literal>'s <literal>clicked</literal> signal. This prints our friendly greeting to <literal>stdout</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:556(para)
msgid "Next, we use the Window's <methodname>add()</methodname> method to put <literal>m_button</literal> in the Window. (<methodname>add()</methodname> comes from <classname>Gtk::Container</classname>, which is described in the chapter on container widgets.) The <methodname>add()</methodname> method places the Widget in the Window, but it doesn't display the widget. <application>gtkmm</application> widgets are always invisible when you create them - to display them, you must call their <methodname>show()</methodname> method, which is what we do in the next line."
msgstr ""

#: C/gtkmm-tutorial-in.xml:566(para)
msgid "Now let's look at our program's <function>main()</function> function. Here it is, without comments:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:571(programlisting)
#, no-wrap
msgid ""
"int main(int argc, char** argv)\n"
"{\n"
"  Gtk::Main kit(argc, argv);\n"
"\n"
"  HelloWorld helloworld;\n"
"  Gtk::Main::run(helloworld);\n"
"\n"
"  return 0;\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:581(para)
msgid "First we instantiate an object called <literal>kit</literal>. This is of type <classname>Gtk::Main</classname>. Every <application>gtkmm</application> program must have one of these. We pass our command-line arguments to its constructor. It takes the arguments it wants, and leaves you the rest, as we described earlier."
msgstr ""

#: C/gtkmm-tutorial-in.xml:588(para)
msgid "Next we make an object of our <classname>HelloWorld</classname> class, whose constructor takes no arguments, but it isn't visible yet. When we call Gtk::Main::run(), giving it the helloworld Window, it shows the Window and starts the <application>gtkmm</application><emphasis>event loop</emphasis>. During the event loop <application>gtkmm</application> idles, waiting for actions from the user, and responding appropriately. When the user closes the Window, run() will return, causing the final line of our main() function be to executed. The application will then finish."
msgstr ""

#: C/gtkmm-tutorial-in.xml:598(title)
#, fuzzy
msgid "Buttons"
msgstr "Opozorilni gumbi"

#: C/gtkmm-tutorial-in.xml:600(para)
msgid "<application>gtkmm</application> provides four basic types of buttons:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:607(term)
#, fuzzy
msgid "Push-Buttons"
msgstr "Opozorilni gumbi"

#: C/gtkmm-tutorial-in.xml:609(para)
msgid "<ulink url=\"http://library.gnome.org/devel/gtkmm/unstable/classGtk_1_1Button.html\"><classname>Gtk::Button</classname></ulink>. Standard buttons, usually marked with a label or picture. Pushing one triggers an action. See the <link linkend=\"sec-pushbuttons\">Button</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:616(term)
#, fuzzy
msgid "Toggle buttons"
msgstr "Opozorilni gumbi"

#: C/gtkmm-tutorial-in.xml:618(para)
msgid "<ulink url=\"http://library.gnome.org/devel/gtkmm/unstable/classGtk_1_1ToggleButton.html\"><classname>Gtk::ToggleButton</classname></ulink>. Unlike a normal Button, which springs back up, a ToggleButton stays down until you press it again. It might be useful as an on/off switch. See the <link linkend=\"sec-toggle-buttons\">ToggleButton</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:626(term)
msgid "Checkboxes"
msgstr ""

#: C/gtkmm-tutorial-in.xml:628(para)
msgid "<ulink url=\"http://library.gnome.org/devel/gtkmm/unstable/classGtk_1_1CheckButton.html\"><classname>Gtk::CheckButton</classname></ulink>. These act like ToggleButtons, but show their state in small squares, with their label at the side. They should be used in most situations which require an on/off setting. See the <link linkend=\"sec-checkboxes\">CheckBox</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:638(term)
#, fuzzy
msgid "Radio buttons"
msgstr "Ni več radijskih gumbov"

#: C/gtkmm-tutorial-in.xml:640(para)
msgid "<ulink url=\"http://library.gnome.org/devel/gtkmm/unstable/classGtk_1_1RadioButton.html\"><classname>Gtk::RadioButton</classname></ulink>. Named after the station selectors on old car radios, these buttons are used in groups for options which are mutually exclusive. Pressing one causes all the others in its group to turn off. They are similar to CheckBoxes (a small widget with a label at the side), but usually look different. See the <link linkend=\"sec-radio-buttons\">RadioButton</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:654(para)
msgid "Note that, due to GTK+'s theming system, the appearance of these widgets will vary. In the case of checkboxes and radio buttons, they may vary considerably."
msgstr ""

#: C/gtkmm-tutorial-in.xml:661(title)
#, fuzzy
msgid "Button"
msgstr "Gumb"

#: C/gtkmm-tutorial-in.xml:663(title)
#, fuzzy
msgid "Constructors"
msgstr "Konstruktorji"

#: C/gtkmm-tutorial-in.xml:665(para)
msgid "There are two ways to create a Button. You can specify a label string in the <classname>Gtk::Button</classname> constructor, or set it later with <methodname>set_label()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:671(para)
msgid "To define an accelerator key for keyboard navigation, place an underscore before one of the label's characters and specify <literal>true</literal> for the optional <literal>mnemonic</literal> parameter. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:673(programlisting)
#, no-wrap
msgid "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:677(programlisting)
#, no-wrap
msgid "Gtk::Button* pButton = new Gtk::Button(Gtk::Stock::OK);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:675(para)
msgid "Wherever possible you should use Stock items, to ensure consistency with other applications, and to improve the appearance of your applications by using icons. For instance, <placeholder-1/> This will use standard text, in all languages, with standard keyboard accelerators, with a standard icon."
msgstr ""

#: C/gtkmm-tutorial-in.xml:681(para)
msgid "<classname>Gtk::Button</classname> is also a container so you could put any other widget, such as a <classname>Gtk::Image</classname> into it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:690(title)
#: C/gtkmm-tutorial-in.xml:802(title)
#: C/gtkmm-tutorial-in.xml:907(title)
#: C/gtkmm-tutorial-in.xml:1068(title)
#: C/gtkmm-tutorial-in.xml:1125(title)
#: C/gtkmm-tutorial-in.xml:1428(title)
#: C/gtkmm-tutorial-in.xml:1498(title)
#: C/gtkmm-tutorial-in.xml:1522(title)
#: C/gtkmm-tutorial-in.xml:1597(title)
#: C/gtkmm-tutorial-in.xml:1638(title)
#: C/gtkmm-tutorial-in.xml:1679(title)
#: C/gtkmm-tutorial-in.xml:1713(title)
#: C/gtkmm-tutorial-in.xml:1753(title)
#: C/gtkmm-tutorial-in.xml:2019(title)
#: C/gtkmm-tutorial-in.xml:2057(title)
#: C/gtkmm-tutorial-in.xml:2211(title)
#: C/gtkmm-tutorial-in.xml:2264(title)
#: C/gtkmm-tutorial-in.xml:2304(title)
#: C/gtkmm-tutorial-in.xml:3842(title)
#: C/gtkmm-tutorial-in.xml:3910(title)
#: C/gtkmm-tutorial-in.xml:3937(title)
#: C/gtkmm-tutorial-in.xml:3959(title)
#: C/gtkmm-tutorial-in.xml:3982(title)
#: C/gtkmm-tutorial-in.xml:4149(title)
#: C/gtkmm-tutorial-in.xml:4272(title)
#: C/gtkmm-tutorial-in.xml:4352(title)
#: C/gtkmm-tutorial-in.xml:4739(title)
#: C/gtkmm-tutorial-in.xml:5288(title)
#: C/gtkmm-tutorial-in.xml:6241(title)
#: C/gtkmm-tutorial-in.xml:6310(title)
#: C/gtkmm-tutorial-in.xml:6918(title)
#: C/gtkmm-tutorial-in.xml:6944(title)
#: C/gtkmm-tutorial-in.xml:7698(title)
#, fuzzy
msgid "Example"
msgstr "Primer"

#: C/gtkmm-tutorial-in.xml:692(para)
msgid "This example creates a button with a picture and a label."
msgstr ""

#: C/gtkmm-tutorial-in.xml:697(title)
#, fuzzy
msgid "buttons example"
msgstr "Primer Bakery"

#: C/gtkmm-tutorial-in.xml:709(para)
msgid "The <classname>Gtk::Button</classname> widget has the following signals, but most of the time you will just handle the <literal>clicked</literal> signal:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:717(literal)
#, fuzzy
msgid "pressed"
msgstr "pritisnjeno"

#: C/gtkmm-tutorial-in.xml:719(para)
#, fuzzy
msgid "Emitted when the button is pressed."
msgstr "Ko je pritisnjen gum_b za zaustavitev:"

#: C/gtkmm-tutorial-in.xml:725(literal)
#, fuzzy
msgid "released"
msgstr "izdano"

#: C/gtkmm-tutorial-in.xml:727(para)
#, fuzzy
msgid "Emitted when the button is released."
msgstr "Ko je pritisnjen gum_b za zaustavitev:"

#: C/gtkmm-tutorial-in.xml:733(literal)
#, fuzzy
msgid "clicked"
msgstr "Klik gumba"

#: C/gtkmm-tutorial-in.xml:735(para)
msgid "Emitted when the button is pressed and released."
msgstr ""

#: C/gtkmm-tutorial-in.xml:741(literal)
#, fuzzy
msgid "enter"
msgstr "vnosna tipka"

#: C/gtkmm-tutorial-in.xml:743(para)
msgid "Emitted when the mouse pointer moves over the button's window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:749(literal)
#, fuzzy
msgid "leave"
msgstr "Zapusti"

#: C/gtkmm-tutorial-in.xml:751(para)
msgid "Emitted when the mouse pointer leaves the button's window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:763(title)
#, fuzzy
msgid "ToggleButton"
msgstr "PreklopniGumb"

#: C/gtkmm-tutorial-in.xml:765(para)
msgid "<classname>ToggleButton</classname>s are like normal <classname>Button</classname>s, but when clicked they remain activated, or pressed, until clicked again."
msgstr ""

#: C/gtkmm-tutorial-in.xml:767(para)
msgid "To retrieve the state of the <classname>ToggleButton</classname>, you can use the <methodname>get_active()</methodname> method. This returns <literal>true</literal> if the button is \"down\". You can also set the toggle button's state, with <methodname>set_active()</methodname>. Note that, if you do this, and the state actually changes, it causes the \"clicked\" signal to be emitted. This is usually what you want."
msgstr ""

#: C/gtkmm-tutorial-in.xml:774(para)
msgid "You can use the <methodname>toggled()</methodname> method to toggle the button, rather than forcing it to be up or down: This switches the button's state, and causes the <literal>toggled</literal> signal to be emitted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:779(para)
msgid "<classname>Gtk::ToggleButton</classname> is most useful as a base class for the <classname>Gtk::CheckButton</classname> and <classname>Gtk::RadioButton</classname> classes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:790(title)
#: C/gtkmm-tutorial-in.xml:805(title)
msgid "CheckButton"
msgstr ""

#: C/gtkmm-tutorial-in.xml:792(para)
msgid "<classname>Gtk::CheckButton</classname> inherits from <classname>Gtk::ToggleButton</classname>. The only real difference between the two is <classname>Gtk::CheckButton</classname>'s appearance. You can check, set, and toggle a checkbox using the same member methods as for <classname>Gtk::ToggleButton</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:817(title)
#: C/gtkmm-tutorial-in.xml:914(title)
#, fuzzy
msgid "RadioButton"
msgstr "RadijskiGumb"

#: C/gtkmm-tutorial-in.xml:819(para)
msgid "Like checkboxes, radio buttons also inherit from <classname>Gtk::ToggleButton</classname>, but these work in groups, and only one RadioButton in a group can be selected at any one time."
msgstr ""

#: C/gtkmm-tutorial-in.xml:825(title)
#, fuzzy
msgid "Groups"
msgstr "Skupine"

#: C/gtkmm-tutorial-in.xml:826(para)
msgid "There are two ways to set up a group of radio buttons. The first way is to create the buttons, and set up their groups afterwards. Only the first two constructors are used. In the following example, we make a new window class called <classname>RadioButtons</classname>, and then put three radio buttons in it:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:834(programlisting)
#, no-wrap
msgid ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"\n"
"protected:\n"
"    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"  : m_rb1(\"button1\"),\n"
"    m_rb2(\"button2\"),\n"
"    m_rb3(\"button3\")\n"
"{\n"
"    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
"    m_rb2.set_group(group);\n"
"    m_rb3.set_group(group);\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:852(para)
msgid "We told <application>gtkmm</application> to put all three <classname>RadioButton</classname>s in the same group by obtaining the group with <methodname>get_group()</methodname> and using <methodname>set_group()</methodname> to tell the other <classname>RadioButton</classname>s to share that group."
msgstr ""

#: C/gtkmm-tutorial-in.xml:861(programlisting)
#, no-wrap
msgid "m_rb2.set_group(m_rb1.get_group()); //doesn't work"
msgstr ""

#: C/gtkmm-tutorial-in.xml:859(para)
msgid "Note that you can't just do <placeholder-1/> because the group is modified by <methodname>set_group()</methodname> and therefore non-const."
msgstr ""

#: C/gtkmm-tutorial-in.xml:867(para)
msgid "The second way to set up radio buttons is to make a group first, and then add radio buttons to it. Here's an example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:871(programlisting)
#, no-wrap
msgid ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"{\n"
"    Gtk::RadioButton::Group group;\n"
"    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
"      new Gtk::RadioButton(group,\"button1\"));\n"
"    Gtk::RadioButton *m_rb2 = manage(\n"
"      new Gtk::RadioButton(group,\"button2\"));\n"
"      Gtk::RadioButton *m_rb3 = manage(\n"
"        new Gtk::RadioButton(group,\"button3\"));\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:888(para)
msgid "We made a new group by simply declaring a variable, <literal>group</literal>, of type <classname>Gtk::RadioButton::Group</classname>. Then we made three radio buttons, using a constructor to make each of them part of <literal>group</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:896(title)
#: C/gtkmm-tutorial-in.xml:1378(title)
#: C/gtkmm-tutorial-in.xml:4610(title)
#, fuzzy
msgid "Methods"
msgstr "_Načini vnosa"

#: C/gtkmm-tutorial-in.xml:897(para)
msgid "<classname>RadioButtons</classname> are \"off\" when created; this means that when you first make a group of them, they will all be off. Don't forget to turn one of them on using <methodname>set_active()</methodname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:908(para)
msgid "The following example demonstrates the use of <classname>RadioButton</classname>s:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:930(title)
#: C/gtkmm-tutorial-in.xml:1079(title)
#, fuzzy
msgid "Range Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:932(para)
msgid "<classname>Gtk::Scale</classname> and <classname>Gtk::Scrollbar</classname> both inherit from <classname>Gtk::Range</classname> and share much functionality. They contain a \"trough\" and a \"slider\" (sometimes called a \"thumbwheel\" in other GUI environments). Dragging the slider with the pointer moves it within the trough, while clicking in the trough advances the slider towards the location of the click, either completely, or by a designated amount, depending on which mouse button is used. This should be familiar scrollbar behaviour."
msgstr ""

#: C/gtkmm-tutorial-in.xml:943(para)
msgid "As will be explained in the <link linkend=\"chapter-adjustment\">Adjustment</link> section, all Range widgets are associated with a <classname>Adjustment</classname> object. To change the lower, upper, and current values used by the widget you need to use the methods of its <classname>Adjustment</classname>, which you can get with the <methodname>get_adjustment()</methodname> method. The <classname>Range</classname> widgets' default constructors create an <classname>Adjustment</classname> automatically, or you can specify an existing <classname>Adjustment</classname>, maybe to share it with another widget. See the <link linkend=\"chapter-adjustment\">Adjustments</link> section for further details."
msgstr ""

#: C/gtkmm-tutorial-in.xml:960(title)
#, fuzzy
msgid "Scrollbar Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:962(para)
msgid "These are standard scrollbars. They should be used only to scroll another widget, such as, a <classname>Gtk::Entry</classname>, or a <classname>Gtk::Viewport</classname>, though it's usually easier to use the <classname>Gtk::ScrolledWindow</classname> widget in most cases."
msgstr ""

#: C/gtkmm-tutorial-in.xml:969(para)
msgid "There are horizontal and vertical scrollbar classes - <classname>Gtk::HScrollbar</classname> and <classname>Gtk::VScrollbar</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:980(title)
#, fuzzy
msgid "Scale Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:982(para)
msgid "<classname>Gtk::Scale</classname> widgets (or \"sliders\") allow the user to visually select and manipulate a value within a specific range. You might use one, for instance, to adjust the magnification level on a zoomed preview of a picture, or to control the brightness of a colour, or to specify the number of minutes of inactivity before a screensaver takes over the screen."
msgstr ""

#: C/gtkmm-tutorial-in.xml:991(para)
msgid "As with <classname>Scrollbar</classname>s, there are separate widget types for horizontal and vertical widgets - <classname>Gtk::HScale</classname> and <classname>Gtk::VScale</classname>. The default constructors create an <classname>Adjustment</classname> with all of its values set to <literal>0.0</literal>. This isn't useful so you will need to set some <classname>Adjustment</classname> details to get meaningful behaviour."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1001(title)
#, fuzzy
msgid "Useful methods"
msgstr "_Načini vnosa"

#: C/gtkmm-tutorial-in.xml:1003(para)
msgid "<classname>Scale</classname> widgets can display their current value as a number next to the trough. By default they show the value, but you can change this with the <methodname>set_draw_value()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1009(para)
msgid "The value displayed by a scale widget is rounded to one decimal point by default, as is the <literal>value</literal> field in its <classname>Gtk::Adjustment</classname>. You can change this with the <methodname>set_digits()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1016(para)
msgid "Also, the value can be drawn in different positions relative to the trough, specified by the <methodname>set_value_pos()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1027(title)
#, fuzzy
msgid "Update Policies"
msgstr "Pravila datotek"

#: C/gtkmm-tutorial-in.xml:1039(para)
msgid "<literal>Gtk::UPDATE_CONTINUOUS</literal> - This is the default. The <literal>value_changed</literal> signal is emitted continuously, i.e. whenever the slider is moved by even the tiniest amount."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1047(para)
msgid "<literal>Gtk::UPDATE_DISCONTINUOUS</literal> - The <literal>value_changed</literal> signal is only emitted once the slider has stopped moving and the user has released the mouse button."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1055(para)
msgid "<literal>Gtk::UPDATE_DELAYED</literal> - The <literal>value_changed</literal> signal is emitted when the user releases the mouse button, or if the slider stops moving for a short period of time."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1029(para)
msgid "The <emphasis>update policy</emphasis> of a <classname>Range</classname> widget defines at what points during user interaction it will change the <literal>value</literal> field of its <classname>Gtk::Adjustment</classname> and emit the <literal>value_changed</literal> signal. The update policies, set with the <methodname>set_update_policy()</methodname> method, are: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1070(para)
msgid "This example displays a window with three range widgets all connected to the same adjustment, along with a couple of controls for adjusting some of the parameters mentioned above and in the section on adjustments, so you can see how they affect the way these widgets work for the user."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1092(title)
#, fuzzy
msgid "Miscellaneous Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:1095(title)
#: C/gtkmm-tutorial-in.xml:1133(title)
#, fuzzy
msgid "Label"
msgstr "Oznaka"

#: C/gtkmm-tutorial-in.xml:1097(para)
msgid "Labels are the main method of placing non-editable text in windows, for instance to place a title next to a <classname>Entry</classname> widget. You can specify the text in the constructor, or later with the <methodname>set_text()</methodname> or set_markup() methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1104(para)
msgid ""
"The width of the label will be adjusted automatically. You can produce multi-line labels by putting line breaks (\"\\n"
"\") in the label string."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1108(para)
msgid "The label text can be justified using the <methodname>set_justify()</methodname> method. The widget is also capable of word-wrapping, which can be activated with <methodname>set_line_wrap()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1114(para)
msgid "Gtk::Label support some simple formatting, for instance allowing you to make some text bold, colored, or larger. You can do this by providing a string to <methodname>set_markup()</methodname>, using the <ulink url=\"http://library.gnome.org/devel/pango/unstable/PangoMarkupFormat.html\">Pango Markup syntax</ulink>. For instance, <code> &lt;b&gt;bold text/&lt;b&gt; and &lt;s&gt;strikethrough text/&lt;s&gt; </code> ."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1126(para)
msgid "Below is a short example to illustrate these functions. This example makes use of the Frame widget to better demonstrate the label styles. (The Frame widget is explained in the <link linkend=\"sec-frame\">Frame</link> section.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1146(title)
#: C/gtkmm-tutorial-in.xml:1188(title)
#, fuzzy
msgid "Entry"
msgstr "Vnos"

#: C/gtkmm-tutorial-in.xml:1149(title)
#, fuzzy
msgid "Simple Use"
msgstr "Uporabi šifriranje:"

#: C/gtkmm-tutorial-in.xml:1151(para)
msgid "Entry widgets allow the user to enter text. You can change the contents with the <methodname>set_text()</methodname> method, and read the current contents with the <methodname>get_text()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1156(para)
msgid "Occasionally you might want to make an <classname>Entry</classname> widget read-only. This can be done by passing <literal>false</literal> to the <methodname>set_editable()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1162(para)
msgid "For the input of passwords, passphrases and other information you don't want echoed on the screen, calling <methodname>set_visibility()</methodname> with <literal>false</literal> will cause the text to be hidden."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1168(para)
msgid "You might want to be notified whenever the user types in a text entry widget. <classname>Gtk::Entry</classname> provides two signals, <literal>activate</literal> and <literal>changed</literal>, for just this purpose. <literal>activate</literal> is emitted when the user presses the enter key in a text-entry widget; <literal>changed</literal> is emitted when the text in the widget changes. You can use these, for instance, to validate or filter the text the user types."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1180(title)
#, fuzzy
msgid "Simple Entry Example"
msgstr "Primer XML Bakery."

#: C/gtkmm-tutorial-in.xml:1181(para)
msgid "This example uses <classname>Gtk::Entry</classname>. It also has two <classname>CheckButton</classname>s, with which you can toggle the editable and visible flags."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1201(title)
#: C/gtkmm-tutorial-in.xml:1235(title)
#, fuzzy
msgid "Entry Completion"
msgstr "Dopolnjevanje vnosa"

#: C/gtkmm-tutorial-in.xml:1202(para)
msgid "A <classname>Entry</classname> widget can offer a drop-down list of pre-existing choices based on the first few characters typed by the user. For instance, a search dialog could suggest text from previous searches."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1207(para)
msgid "To enable this functionality, you must create a <classname>EntryCompletion</classname> object, and provide it to the <classname>Entry</classname> widget via the <methodname>set_completion()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1212(para)
msgid "The <classname>EntryCompletion</classname> may use a <classname>TreeModel</classname> containing possible entries, specified with <methodname>set_model()</methodname>. You should then call <methodname>set_text_column()</methodname> to specify which of your model columns should be used to match possible text entries."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1218(para)
msgid "Alternatively, if a complete list of possible entries would be too large or too inconvenient to generate, a callback slot may instead be specified with <methodname>set_match_func()</methodname>. That callback function. This is also useful if you wish to match on a part of the string other than the start."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1226(title)
#, fuzzy
msgid "Entry Completion Example"
msgstr "Primer XML Bakery."

#: C/gtkmm-tutorial-in.xml:1227(para)
msgid "This example creates a <classname>Gtk::EntryCompletion</classname> and associates it with a <classname>Gtk::Entry</classname> widget. The completion uses a <classname>Gtk::TreeModel</classname> of possible entries, and some additional actions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1247(title)
#, fuzzy
msgid "Entry Icons"
msgstr "Le ikone"

#: C/gtkmm-tutorial-in.xml:1248(para)
msgid "An <classname>Entry</classname> widget can show an icon at the start or end of the text area. The icon can be specifed by methods such as <methodname>set_icon_from_pixbuf()</methodname> or <methodname>set_icon_from_stock()</methodname>. An application can respond to the user pressing the icon by handling the <methodname>signal_icon_press</methodname> signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1255(title)
#, fuzzy
msgid "Entry Icon Example"
msgstr "Gnome vnos ikone"

#: C/gtkmm-tutorial-in.xml:1256(para)
msgid "This example shows a <classname>Gtk::Entry</classname> widget with a stock search icon, and prints text to the terminal when the icon is pressed."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1262(title)
#, fuzzy
msgid "Entry with Icon"
msgstr "Gnome vnos ikone"

#: C/gtkmm-tutorial-in.xml:1274(title)
#, fuzzy
msgid "Entry Progress"
msgstr "kazalnik napredka"

#: C/gtkmm-tutorial-in.xml:1275(para)
msgid "An <classname>Entry</classname> widget can show a progress bar inside the text area, under the entered text. The progress bar will be shown if the <methodname>set_progress_fraction()</methodname> or <methodname>set_progress_pulse_step()</methodname> methods are called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1280(title)
#, fuzzy
msgid "Entry Progress Example"
msgstr "Primer XML Bakery."

#: C/gtkmm-tutorial-in.xml:1281(para)
msgid "This example shows a <classname>Gtk::Entry</classname> widget with a progress bar."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1287(title)
#, fuzzy
msgid "Entry with Progress Bar"
msgstr "Besedilo, ki bo prikazano v prikazovalniku napredka"

#: C/gtkmm-tutorial-in.xml:1301(title)
#: C/gtkmm-tutorial-in.xml:1435(title)
#, fuzzy
msgid "SpinButton"
msgstr "VrtljivGumb"

#: C/gtkmm-tutorial-in.xml:1303(para)
msgid "A <classname>SpinButton</classname> allows the user to select a value from a range of numeric values. It has an Entry widget with up and down arrow buttons at the side. Clicking the buttons causes the value to 'spin' up and down across the range of possible values. The <classname>Entry</classname> widget may also be used to enter a value directly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1311(para)
msgid "The value can have an adjustable number of decimal places, and the step size is configurable. <classname>SpinButton</classname>s have an 'auto-repeat' feature as well: holding down one of the arrows can optionally cause the value to change more quickly the longer the arrow is held down."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1326(para)
msgid "<literal>value</literal>: value for the Spin Button"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1332(para)
#, fuzzy
msgid "<literal>lower</literal>: lower range value"
msgstr "Celoštevilska vrednost '%s' izven obsega"

#: C/gtkmm-tutorial-in.xml:1338(para)
#, fuzzy
msgid "<literal>upper</literal>: upper range value"
msgstr "Celoštevilska vrednost '%s' izven obsega"

#: C/gtkmm-tutorial-in.xml:1343(para)
msgid "<literal>step_increment</literal>: value to increment/decrement when pressing mouse button 1 on a button"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1350(para)
msgid "<literal>page_increment</literal>: value to increment/decrement when pressing mouse button 2 on a button"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1357(para)
#, fuzzy
msgid "<literal>page_size</literal>: unused"
msgstr "Velikost drsne strani ponudnikov"

#: C/gtkmm-tutorial-in.xml:1318(para)
msgid "<classname>SpinButton</classname>s use an <link linkend=\"chapter-adjustment\">Adjustment</link> object to hold information about the range of values. These Adjustment attributes are used by the Spin Button like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1365(para)
msgid "Additionally, mouse button 3 can be used to jump directly to the <literal>upper</literal> or <literal>lower</literal> values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1370(para)
msgid "The <classname>SpinButton</classname> can create a default <classname>Adjustment</classname>, which you can access via the <methodname>get_adjustment()</methodname> method, or you can specify an existing <classname>Adjustment</classname> in the constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1380(para)
msgid "The number of decimal places can be altered using the <methodname>set_digits()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1385(para)
msgid "You can set the spinbutton's value using the <methodname>set_value()</methodname> method, and retrieve it with <methodname>get_value()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1390(para)
msgid "The <methodname>spin()</methodname> method 'spins' the <classname>SpinButton</classname>, as if one of its arrows had been clicked. You need to specify a <classname>Gtk::SpinType</classname> to specify the direction or new position."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1397(para)
msgid "To prevent the user from typing non-numeric characters into the entry box, pass <literal>true</literal> to the <methodname>set_numeric()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1402(para)
msgid "To make the <classname>SpinButton</classname> 'wrap' between its upper and lower bounds, use the <methodname>set_wrap()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1407(para)
msgid "To force it to snap to the nearest <literal>step_increment</literal>, use <methodname>set_snap_to_ticks()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1412(para)
msgid "You can modify the update policy using the <methodname>set_update_policy()</methodname> method, specifying either <literal>Gtk::UPDATE_ALWAYS</literal> or <literal>Gtk::UPDATE_IF_VALID</literal>. <literal>Gtk::UPDATE_ALWAYS</literal> causes the <classname>SpinButton</classname> to ignore errors encountered while converting the text in the entry box to a numeric value. This setting also therefore allows the <classname>SpinButton</classname> to accept non-numeric values. You can force an immediate update using the <methodname>update()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1430(para)
msgid "Here's an example of a <classname>SpinButton</classname> in action:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1448(title)
#: C/gtkmm-tutorial-in.xml:1501(title)
#, fuzzy
msgid "ProgressBar"
msgstr "Slog vrstice napredka"

#: C/gtkmm-tutorial-in.xml:1450(para)
msgid "Progress bars are used to show the status of an ongoing operation. For instance, a <classname>ProgressBar</classname> can show how much of a task has been completed."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1456(para)
msgid "To change the value shown, use the <methodname>set_fraction()</methodname> method, passing a double between 0 and 1 to provide the new percentage."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1461(para)
msgid "where <literal>percentage</literal> is a number, from 0 to 1, indicating what fraction of the bar should be filled."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1466(para)
msgid "A <classname>ProgressBar</classname>is horizontal and left-to-right by default, but you can change it to a vertical progress bar by using the <methodname>set_orientation()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1475(title)
#, fuzzy
msgid "Activity Mode"
msgstr "Aktivni način"

#: C/gtkmm-tutorial-in.xml:1476(para)
msgid "Besides indicating the amount of progress that has occured, the progress bar can also be used to indicate that there is some activity; this is done by placing the progress bar in <emphasis>activity mode</emphasis>. In this mode, the progress bar displays a small rectangle which moves back and forth. Activity mode is useful in situations where the progress of an operation cannot be calculated as a value range (e.g., receiving a file of unknown length)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1486(para)
msgid "To do this, you need to call the <methodname>pulse()</methodname> method at regular intervals. You can also choose the step size, with the <methodname>set_pulse_step()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1492(para)
msgid "When in continuous mode, the progress bar can also display a configurable text string within its trough, using the <methodname>set_text()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1515(title)
#: C/gtkmm-tutorial-in.xml:1525(title)
msgid "InfoBar"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1517(para)
msgid "An <classname>InfoBar</classname> may show small items of information or to ask brief questions. Unlike a <classname>Dialog</classname>, it appears at the top of the current window instead of opening a new window. Its API is very similar to the <link linkend=\"chapter-dialogs\">Gtk::Dialog</link> API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1538(title)
#, fuzzy
msgid "Tooltips"
msgstr "Orodni nasveti"

#: C/gtkmm-tutorial-in.xml:1540(para)
msgid "Tooltips are the little information windows that pop up when you leave your pointer over a widget for a few seconds. Use <methodname>set_tooltip_text()</methodname> to set a text string as a tooltip on any <classname>Widget</classname>. <classname>Gtk::ToolItem</classname>s are not <classname>Widget</classname>s, but have the same method for convenience. <classname>Gtk::Tooltip</classname> is used for more advanced tooltip usage, such as showing an image as well as text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1550(ulink)
#, fuzzy
msgid "Widget Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:1551(ulink)
#, fuzzy
msgid "Tooltip Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:1558(title)
#, fuzzy
msgid "Container Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:1560(para)
msgid "All container widgets derive from <classname>Gtk::Container</classname>, not always directly. Some container widgets, such as <classname>Gtk::Table</classname> can hold many child widgets, so these typically have more complex interfaces. Others, such as <classname>Gtk::Frame</classname> contain only one child widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1569(title)
#, fuzzy
msgid "Single-item Containers"
msgstr "potrditveno polje menija"

#: C/gtkmm-tutorial-in.xml:1571(para)
msgid "The single-item container widgets derive from <classname>Gtk::Bin</classname>, which provides the <methodname>add()</methodname> and <methodname>remove()</methodname> methods for the child widget. Note that <classname>Gtk::Button</classname> and <classname>Gtk::Window</classname> are technically single-item containers, but we have discussed them already elsewhere."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1579(para)
msgid "We also discuss the <classname>Gtk::Paned</classname> widget, which allows you to divide a window into two separate \"panes\". This widget actually contains two child widgets, but the number is fixed so it seems appropriate."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1586(title)
#: C/gtkmm-tutorial-in.xml:1600(title)
#, fuzzy
msgid "Frame"
msgstr "Okvir"

#: C/gtkmm-tutorial-in.xml:1588(para)
msgid "Frames can enclose one or a group of widgets within a box, optionally with a title. For instance, you might place a group of <classname>RadioButton</classname>s or <classname>CheckButton</classname>s in a <classname>Frame</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1614(title)
#: C/gtkmm-tutorial-in.xml:1641(title)
#, fuzzy
msgid "Paned"
msgstr "Pladenj"

#: C/gtkmm-tutorial-in.xml:1616(para)
msgid "Panes divide a widget into two halves, separated by a moveable divider. There are two such widgets: <classname>Gtk::HPaned</classname> adds a horizontal divider, and <classname>Gtk::VPaned</classname> adds a vertical one. Other than the names and the orientations, there's no difference between the two."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1623(para)
msgid "Unlike the other widgets in this chapter, pane widgets contain not one but two child widgets, one in each pane. Therefore, you should use <methodname>add1()</methodname> and <methodname>add2()</methodname> instead of the <methodname>add()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1630(para)
msgid "You can adjust the position of the divider using the <methodname>set_position()</methodname> method, and you will probably need to do so."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1654(title)
#: C/gtkmm-tutorial-in.xml:1686(title)
msgid "ScrolledWindow"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1656(para)
msgid "<classname>ScrolledWindow</classname> widgets create a scrollable area. You can insert any type of widget into a <classname>ScrolledWindow</classname> window, and it will be accessible regardless of its size by using the scrollbars. Note that <classname>ScrolledWindow</classname> is not a <classname>Gtk::Window</classname> despite the slightly misleading name."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1665(para)
msgid "Scrolled windows have <emphasis>scrollbar policies</emphasis> which determine whether the <classname>Scrollbar</classname>s will be displayed. The policies can be set with the <methodname>set_policy()</methodname> method. The policy may be one of <literal>Gtk::POLICY_AUTOMATIC</literal> or <literal>Gtk::POLICY_ALWAYS</literal>. <literal>Gtk::POLICY_AUTOMATIC</literal> will cause the scrolled window to display the scrollbar only if the contained widget is larger than the visible area. <literal>Gtk::POLICY_ALWAYS</literal> will cause the scrollbar to be displayed always."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1681(para)
msgid "Here is a simple example that packs 100 toggle buttons into a ScrolledWindow. Try resizing the window to see the scrollbars react."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1699(title)
#: C/gtkmm-tutorial-in.xml:1721(title)
msgid "AspectFrame"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1701(para)
msgid "The <classname>AspectFrame</classname> widget looks like a <classname>Frame</classname> widget, but it also enforces the <emphasis>aspect ratio</emphasis> (the ratio of the width to the height) of the child widget, adding extra space if necessary. For instance, this would allow you to display a photograph without allowing the user to distort it horizontally or vertically while resizing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1714(para)
msgid "The following program uses a <classname>Gtk::AspectFrame</classname> to present a drawing area whose aspect ratio will always be 2:1, no matter how the user resizes the top-level window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1734(title)
#: C/gtkmm-tutorial-in.xml:1760(title)
#, fuzzy
msgid "Alignment"
msgstr "Poravnava"

#: C/gtkmm-tutorial-in.xml:1736(para)
msgid "The <classname>Alignment</classname> widget allows you to place a widget at a position and size relative to the size of the <classname>Alignment</classname> widget itself. For instance, it might be used to center a widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1742(para)
msgid "You need to specify the <classname>Alignment</classname>'s characteristics to the constructor, or to the <methodname>set()</methodname> method. In particular, you won't notice much effect unless you specify a number other than 1.0 for the <literal>xscale</literal> and <literal>yscale</literal> parameters, because 1.0 simply means that the child widget will expand to fill all available space."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1754(para)
msgid "This example right-aligns a button in a window by using an <classname>Alignment</classname> widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1768(para)
msgid "See the <link linkend=\"sec-progressbar\">ProgressBar</link> section for another example that uses an <classname>Alignment</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1780(title)
#, fuzzy
msgid "Multiple-item widgets"
msgstr "Ni mogoče prilepiti gradnikov"

#: C/gtkmm-tutorial-in.xml:1782(para)
msgid "Multiple-item widgets inherit from <classname>Gtk::Container</classname>; just as with <classname>Gtk::Bin</classname>, you use the <methodname>add()</methodname> and <methodname>remove()</methodname> methods to add and remove contained widgets. Unlike <methodname>Gtk::Bin::remove()</methodname>, however, the <methodname>remove()</methodname> method for <classname>Gtk::Container</classname> takes an argument, specifiying which widget to remove."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1792(title)
#, fuzzy
msgid "Packing"
msgstr "Stiskanje"

#: C/gtkmm-tutorial-in.xml:1793(para)
msgid "You've probably noticed that <application>gtkmm</application> windows seem \"elastic\" - they can usually be stretched in many different ways. This is due to the <emphasis>widget packing</emphasis> system."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1798(para)
msgid "Many GUI toolkits require you to precisely place widgets in a window, using absolute positioning, often using a visual editor. This leads to several problems:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1805(para)
msgid "The widgets don't rearrange themselves when the window is resized. Some widgets are hidden when the window is made smaller, and lots of useless space appears when the window is made larger."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1809(para)
msgid "It's impossible to predict the amount of space necessary for text after it has been translated to other languages, or displayed in a different font. On Unix it is also impossible to anticipate the effects of every theme and window manager."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1813(para)
msgid "Changing the layout of a window \"on the fly\", to make some extra widgets appear, for instance, is complex. It requires tedious recalculation of every widget's position."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1819(para)
msgid "<application>gtkmm</application> uses the packing system to solve these problems. Rather than specifying the position and size of each widget in the window, you can arrange your widgets in rows, columns, and/or tables. <application>gtkmm</application> can size your window automatically, based on the sizes of the widgets it contains. And the sizes of the widgets are, in turn, determined by the amount of text they contain, or the minimum and maximum sizes that you specify, and/or how you have requested that the available space should be shared between sets of widgets. You can perfect your layout by specifying padding distance and centering values for each of your widgets. <application>gtkmm</application> then uses all this information to resize and reposition everything sensibly and smoothly when the user manipulates the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1828(para)
msgid "<application>gtkmm</application> arranges widgets hierarchically, using <emphasis>containers</emphasis>. A Container widget contains other widgets. Most <application>gtkmm</application> widgets are containers. Windows, Notebook tabs, and Buttons are all container widgets. There are two flavours of containers: single-child containers, which are all descendants of <classname>Gtk::Bin</classname>, and multiple-child containers, which are descendants of <classname>Gtk::Container</classname>. Most widgets in <application>gtkmm</application> are descendants of <classname>Gtk::Bin</classname>, including <classname>Gtk::Window</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1839(para)
msgid "Yes, that's correct: a Window can contain at most one widget. How, then, can we use a window for anything useful? By placing a multiple-child container in the window. The most useful container widgets are <classname>Gtk:VBox</classname>, <classname>Gtk::HBox</classname>, and <classname>Gtk::Table</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1851(para)
msgid "<classname>Gtk::VBox</classname> and <classname>Gtk::HBox</classname> arrange their child widgets vertically and horizontally, respectively. Use <methodname>pack_start()</methodname> and <methodname>pack_end()</methodname> to insert child widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1860(para)
msgid "<classname>Gtk::Table</classname> arranges its widgets in a grid. Use <methodname>attach()</methodname> to insert widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1868(para)
msgid "There are several other containers, which we will also discuss."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1872(para)
msgid "If you've never used a packing toolkit before, it can take some getting used to. You'll probably find, however, that you don't need to rely on visual form editors quite as much as you might with other toolkits."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1882(title)
#, fuzzy
msgid "An improved Hello World"
msgstr "Končaj svetovno lakoto"

#: C/gtkmm-tutorial-in.xml:1884(para)
msgid "Let's take a look at a slightly improved <literal>helloworld</literal>, showing what we've learnt."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1889(title)
#, fuzzy
msgid "Hello World 2"
msgstr "Pozdravljen svet!"

#: C/gtkmm-tutorial-in.xml:1897(para)
msgid "After building and running this program, try resizing the window to see the behaviour. Also, try playing with the options to <methodname>pack_start()</methodname> while reading the <link linkend=\"sec-boxes\">Boxes</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1907(title)
#, fuzzy
msgid "Boxes"
msgstr "[Okna]"

#: C/gtkmm-tutorial-in.xml:1909(para)
msgid "Most packing uses boxes as in the above example. These are invisible containers into which we can pack our widgets. When packing widgets into a horizontal box, the objects are inserted horizontally from left to right or right to left depending on whether <methodname>pack_start()</methodname> or <methodname>pack_end()</methodname> is used. In a vertical box, widgets are packed from top to bottom or vice versa. You may use any combination of boxes inside or beside other boxes to create the desired effect."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1920(title)
#: C/gtkmm-tutorial-in.xml:2112(title)
#, fuzzy
msgid "Adding widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:1921(title)
#, fuzzy
msgid "Per-child packing options"
msgstr "Možnosti, ki določajo vodoravno vedenje podrejenega predmeta"

#: C/gtkmm-tutorial-in.xml:1922(para)
msgid "The <methodname>pack_start()</methodname> and <methodname>pack_end()</methodname> methods place widgets inside these containers. The <methodname>pack_start()</methodname> method will start at the top and work its way down in a <classname>VBox</classname>, or pack left to right in an <classname>HBox</classname>. <methodname>pack_end()</methodname> will do the opposite, packing from bottom to top in a <classname>VBox</classname>, or right to left in an <classname>HBox</classname>. Using these methods allows us to right justify or left justify our widgets. We will use <methodname>pack_start()</methodname> in most of our examples."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1935(para)
msgid "There are several options governing how widgets are to be packed, and this can be confusing at first. If you have difficulties then it is sometimes a good idea to play with the <application>glade</application> GUI designer to see what is possible. You might even decide to use the <application>Gtk::Builder</application> API to load your GUI at runtime."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1943(para)
msgid "There are basically five different styles, as shown in this picture:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1949(title)
#, fuzzy
msgid "Box Packing 1"
msgstr "Stiskanje datotek"

#: C/gtkmm-tutorial-in.xml:1955(para)
msgid "Each line contains one horizontal box (<classname>HBox</classname>) with several buttons. Each of the buttons on a line is packed into the <classname>HBox</classname> with the same arguments to the <methodname>pack_start()</methodname> method)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1962(para)
msgid "This is the declaration of the <methodname>pack_start()</methodname> method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1965(programlisting)
#, no-wrap
msgid ""
"void pack_start(Gtk::Widget&amp; child,\n"
"                PackOptions options = PACK_EXPAND_WIDGET,\n"
"                guint padding = 0);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1969(para)
msgid "The first argument is the widget you're packing. In our example these are all <classname>Button</classname>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1976(para)
msgid "<literal>PACK_SHRINK</literal>: Space is contracted to the child widget size. The widget will take up just-enough space and never expand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1977(para)
msgid "<literal>PACK_EXPAND_PADDING</literal>: Extra space is filled with padding. The widgets will be spaced out evenly, but their sizes won't change - there will be empty space between the widgets instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1978(para)
msgid "<literal>PACK_EXPAND_WIDGET</literal>: Extra space is taken up by increasing the child widget size, without changing the amount of space between widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1973(para)
msgid "The <parameter>options</parameter> argument can take one of these three options: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1982(para)
msgid "The <parameter>padding</parameter> argument specifies the width of an extra border area to leave around the packed widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:1991(title)
msgid "Per-container packing options"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1994(programlisting)
#, no-wrap
msgid "Gtk::Box(bool homogeneous = false, int spacing = 0);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:1992(para)
msgid "Here's the constructor for the box widgets: <placeholder-1/> Passing <literal>true</literal> for <parameter>homogeneous</parameter> will cause all of the contained widgets to be the same size. <parameter>spacing</parameter> is a (minimum) number of pixels to leave between each widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2001(para)
msgid "What's the difference between spacing (set when the box is created) and padding (set when elements are packed)? Spacing is added between objects, and padding is added on either side of a widget. The following figure should make it clearer:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2009(title)
#, fuzzy
msgid "Box Packing 2"
msgstr "Stiskanje datotek"

#: C/gtkmm-tutorial-in.xml:2020(para)
msgid "Here is the source code for the example that produced the screenshots above. When you run this example, provide a number between 1 and 3 as a command-line option, to see different packing options in use."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2029(title)
msgid "ButtonBoxes"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2031(para)
msgid "Button boxes are a convenient way to quickly arrange a group of buttons. They come in both horizontal (<classname>Gtk::HButtonBox</classname>) and vertical (<classname>Gtk::VButtonBox</classname>) flavours. They are exactly alike, except in name and orientation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2038(para)
msgid "<classname>ButtonBox</classname>es help to make applications appear consistent because they use standard settings, such as inter-button spacing and packing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2043(para)
msgid "Buttons are added to a <classname>ButtonBox</classname> with the <methodname>add()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2048(para)
msgid "Button boxes support several layout styles. The style can be retrieved and changed using <methodname>get_layout()</methodname> and <methodname>set_layout()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2060(title)
msgid "ButtonBox"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2073(title)
#: C/gtkmm-tutorial-in.xml:2219(title)
#, fuzzy
msgid "Table"
msgstr "Preglednica"

#: C/gtkmm-tutorial-in.xml:2075(para)
msgid "Tables allows us to place widgets in a grid."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2079(title)
#, fuzzy
msgid "Constructor"
msgstr "izgradnja različic"

#: C/gtkmm-tutorial-in.xml:2080(para)
msgid "The grid's dimensions need to be specified in the constructor:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2083(programlisting)
#, no-wrap
msgid "Gtk::Table(int rows = 1, int columns = 1, bool homogeneous = false);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2085(para)
msgid "The first argument is the number of rows to make in the table, while the second, obviously, is the number of columns. If <parameter>homogeneous</parameter> is <literal>true</literal>, the table cells will all be the same size (the size of the largest widget in the table)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2092(para)
msgid "The rows and columns are indexed starting at 0. If you specify <parameter>rows</parameter> = 2 and <parameter>columns</parameter> = 2, the layout would look something like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2098(programlisting)
#, fuzzy, no-wrap
msgid ""
"\n"
" 0          1          2\n"
"0+----------+----------+\n"
" |          |          |\n"
"1+----------+----------+\n"
" |          |          |\n"
"2+----------+----------+\n"
msgstr ""
"1 (privzeto)\n"
"2\n"
"3\n"
"4"

#: C/gtkmm-tutorial-in.xml:2107(para)
msgid "Note that the coordinate system starts in the upper left hand corner."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2113(para)
msgid "To place a widget into a box, use the following method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2116(programlisting)
#, no-wrap
msgid ""
"void Gtk::Table::attach(Gtk::Widget&amp; child,\n"
"                        guint left_attach, guint right_attach,\n"
"                        guint top_attach, guint bottom_attach,\n"
"                        guint xoptions = Gtk::FILL | Gtk::EXPAND,\n"
"                        guint yoptions = Gtk::FILL | Gtk::EXPAND,\n"
"                        guint xpadding = 0, guint ypadding = 0);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2122(para)
msgid "The first argument is the widget you wish to place in the table."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2126(para)
msgid "The <parameter>left_attach</parameter> and <parameter>right_attach</parameter> arguments specify where to place the widget, and how many boxes to use. For example, if you want a button in the lower-right cell of a 2 x 2 table, and want it to occupy that cell <emphasis>only</emphasis>, then <parameter>left_attach</parameter> would be 1, <parameter>right_attach</parameter> 2, <parameter>top_attach</parameter> 1, and <parameter>bottom_attach</parameter> 2. If, on the other hand, you wanted a widget to take up the entire top row of our 2 x 2 table, you'd set <parameter>left_attach</parameter> = 0, <parameter>right_attach</parameter> = 2, <parameter>top_attach</parameter> = 0, and <parameter>bottom_attach</parameter> = 1."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2142(para)
msgid "<parameter>xoptions</parameter> and <parameter>yoptions</parameter> are used to specify packing options and may be bitwise ORed together to allow multiple options. These options are:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2152(literal)
#, fuzzy
msgid "Gtk::FILL"
msgstr "Barva polnila:"

#: C/gtkmm-tutorial-in.xml:2154(para)
msgid "If the table box is larger than the widget, and <literal>Gtk::FILL</literal> is specified, the widget will expand to use all the room available."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2162(literal)
#, fuzzy
msgid "Gtk::SHRINK"
msgstr "Pomanjšaj velikost slike"

#: C/gtkmm-tutorial-in.xml:2164(para)
msgid "If the table widget is allocated less space than it requested (because the user resized the window), then the widgets will normally just disappear off the bottom of the window. If <literal>Gtk::SHRINK</literal> is specified, the widgets will shrink with the table."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2175(literal)
#, fuzzy
msgid "Gtk::EXPAND"
msgstr "Razširi vse"

#: C/gtkmm-tutorial-in.xml:2177(para)
msgid "This will cause the table to expand to use up anyremaining space in the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2185(para)
msgid "The padding arguments work just as they do for <methodname>pack_start()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2191(title)
#, fuzzy
msgid "Other methods"
msgstr "_Načini vnosa"

#: C/gtkmm-tutorial-in.xml:2193(para)
msgid "<methodname>set_row_spacing()</methodname> and <methodname>set_col_spacing()</methodname> set the spacing between the rows at the specified row or column. Note that for columns, the space goes to the right of the column, and for rows, the space goes below the row."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2200(para)
msgid "You can also set a consistent spacing for all rows and/or columns with <methodname>set_row_spacings()</methodname> and <methodname>set_col_spacings()</methodname>. Note that with these calls, the last row and last column do not get any spacing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2212(para)
msgid "In the following example, we make a window with three buttons in a 2 x 2 table. The first two buttons will be placed in the upper row. A third button is placed in the lower row, spanning both columns."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2232(title)
#: C/gtkmm-tutorial-in.xml:2267(title)
#, fuzzy
msgid "Notebook"
msgstr "Beležnica"

#: C/gtkmm-tutorial-in.xml:2234(para)
msgid "A <classname>Notebook</classname> has a set of stacked <literal>pages</literal>, each of which contains widgets. Labelled <literal>tabs</literal> allow the user to select the pages. <classname>Notebook</classname>s allow several sets of widgets to be placed in a small space, by only showing one page at a time. For instance, they are often used in preferences dialogs."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2243(para)
msgid "Use the <methodname>append_page()</methodname>, <methodname>prepend_page()</methodname> and <methodname>insert_page()</methodname> methods to add tabbed pages to the <literal>Notebook</literal>, supplying the child widget and the name for the tab."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2250(para)
msgid "To discover the currently visible page, use the <methodname>get_current_page()</methodname> method. This returns the page number, and then calling <methodname>get_nth_page()</methodname> with that number will give you a pointer to the actual child widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2257(para)
msgid "To programmatically change the selected page, use the <methodname>set_current_page()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2280(title)
#: C/gtkmm-tutorial-in.xml:2307(title)
#, fuzzy
msgid "Assistant"
msgstr "Pomočnik"

#: C/gtkmm-tutorial-in.xml:2282(para)
msgid "An <classname>Assistant</classname> splits a complex operation into steps. Each step is a page, containing a header, a child widget and an action area. The Assistant's action area has navigation buttons which update automatically depending on the type of the page, set with <methodname>set_page_type()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2286(para)
msgid "Use the <methodname>append_page()</methodname>, <methodname>prepend_page</methodname> and <methodname>insert_page()</methodname> methods to add pages to the <classname>Assistant</classname>, supplying the child widget for each page."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2290(para)
msgid "To determine the currently-visible page, use the <methodname>get_current_page()</methodname> method, and pass the result to <methodname>get_nth_page()</methodname>, which returns a pointer to the actual widget. To programmatically change the current page, use the <methodname>set_current_page()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2294(para)
msgid "To set the title of a page, use the <methodname>set_page_title()</methodname> method. The header and side images of a page can be set with the <methodname>set_page_header_image()</methodname> and <methodname>set_page_side_image()</methodname> methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2298(para)
msgid "To add widgets to the action area, use the <methodname>add_action_widget()</methodname> method. They will be packed alongside the default buttons. Use the <methodname>remove_action_widget()</methodname> method to remove widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2325(title)
#, fuzzy
msgid "The TreeView widget"
msgstr "Ime gradnika"

#: C/gtkmm-tutorial-in.xml:2326(para)
msgid "The <classname>Gtk::TreeView</classname> widget can contain lists or trees of data, in columns."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2332(title)
#, fuzzy
msgid "The Model"
msgstr "Model"

#: C/gtkmm-tutorial-in.xml:2333(para)
msgid "Each <classname>Gtk::TreeView</classname> has an associated <classname>Gtk::TreeModel</classname>, which contains the data displayed by the <classname>TreeView</classname>. Each <classname>Gtk::TreeModel</classname> can be used by more than one <classname>Gtk::TreeView</classname>. For instance, this allows the same underlying data to be displayed and edited in 2 different ways at the same time. Or the 2 Views might display different columns from the same Model data, in the same way that 2 SQL queries (or \"views\") might show different fields from the same database table."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2343(para)
msgid "Although you can theoretically implement your own Model, you will normally use either the <classname>ListStore</classname> or <classname>TreeStore</classname> model classes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2352(title)
#, fuzzy
msgid "ListStore, for rows"
msgstr "Vrstice na trak slike"

#: C/gtkmm-tutorial-in.xml:2353(para)
msgid "The <classname>ListStore</classname> contains simple rows of data, and each row has no children."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2359(title)
#: C/gtkmm-tutorial-in.xml:2903(title)
#, fuzzy
msgid "TreeView - ListStore"
msgstr "Način TreeView"

#: C/gtkmm-tutorial-in.xml:2370(title)
#, fuzzy
msgid "TreeStore, for a hierarchy"
msgstr "Izvoz _hierarhije značk"

#: C/gtkmm-tutorial-in.xml:2371(para)
msgid "The <classname>TreeStore</classname> contains rows of data, and each row may have child rows."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2377(title)
#: C/gtkmm-tutorial-in.xml:2922(title)
#, fuzzy
msgid "TreeView - TreeStore"
msgstr "Način TreeView"

#: C/gtkmm-tutorial-in.xml:2388(title)
#, fuzzy
msgid "Model Columns"
msgstr "Izbrani stolpci"

#: C/gtkmm-tutorial-in.xml:2389(para)
msgid "The <classname>TreeModelColumnRecord</classname> class is used to keep track of the columns and their data types. You add <classname>TreeModelColumn</classname> instances to the <classname>ColumnRecord</classname> and then use those <classname>TreeModelColumns</classname> when getting and setting the data in model rows. You will probably find it convenient to derive a new <classname>TreeModelColumnRecord</classname> which has your <classname>TreeModelColumn</classname> instances as member data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2400(programlisting)
#, no-wrap
msgid ""
"class ModelColumns : public Gtk::TreeModelColumnRecord\n"
"{\n"
"public:\n"
"\n"
"  ModelColumns()\n"
"    { add(m_col_text); add(m_col_number); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_number;\n"
"};\n"
"\n"
"ModelColumns m_Columns;"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2413(para)
msgid "You specify the <classname>ColumnRecord</classname> when creating the Model, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2417(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2419(para)
msgid "Note that the instance (such as m_Columns here) should usually not be static, because it often needs to be instantiated after glibmm has been instantiated."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2424(title)
#, fuzzy
msgid "Adding Rows"
msgstr "Izbrane vrstice"

#: C/gtkmm-tutorial-in.xml:2425(para)
msgid "Add rows to the model with the <methodname>append()</methodname>, <methodname>prepend()</methodname>, or <methodname>insert()</methodname> methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2429(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2430(para)
msgid "You can dereference the iterator to get the Row:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2432(programlisting)
#, fuzzy, no-wrap
msgid "Gtk::TreeModel::Row row = *iter;"
msgstr "TreeModel stolpec, ki vsebuje vrednosti širine preko vrstic"

#: C/gtkmm-tutorial-in.xml:2433(title)
#, fuzzy
msgid "Adding child rows"
msgstr "Vrstice na trak slike"

#: C/gtkmm-tutorial-in.xml:2434(para)
msgid "<classname>Gtk::TreeStore</classname> models can have child items. Add them with the <methodname>append()</methodname>, <methodname>prepend()</methodname>, or <methodname>insert()</methodname> methods, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2439(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter_child =\n"
"    m_refListStore-&gt;append(row.children());"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2446(title)
#, fuzzy
msgid "Setting values"
msgstr "Vrednosti CIE"

#: C/gtkmm-tutorial-in.xml:2447(para)
msgid "You can use the <methodname>operator[]</methodname> override to set the data for a particular column in the row, specifying the <classname>TreeModelColumn</classname> used to create the model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2452(programlisting)
#, no-wrap
msgid "row[m_Columns.m_col_text] = \"sometext\";"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2456(title)
#, fuzzy
msgid "Getting values"
msgstr "Vrednosti CIE"

#: C/gtkmm-tutorial-in.xml:2457(para)
msgid "You can use the <methodname>operator[]</methodname> override to get the data in a particular column in a row, specifiying the <classname>TreeModelColumn</classname> used to create the model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2462(programlisting)
#, no-wrap
msgid ""
"Glib::ustring strText = row[m_Columns.m_col_text];\n"
"int number = row[m_Columns.m_col_number];"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2464(para)
msgid "The compiler will complain if you use an inappropriate type. For instance, this would generate a compiler error:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2468(programlisting)
#, no-wrap
msgid ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2473(title)
#, fuzzy
msgid "\"Hidden\" Columns"
msgstr "Skriti stolpci:"

#: C/gtkmm-tutorial-in.xml:2474(para)
msgid "You might want to associate extra data with each row. If so, just add it as a Model column, but don't add it to the View."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2483(title)
#: C/gtkmm-tutorial-in.xml:3277(title)
#, fuzzy
msgid "The View"
msgstr "Pogled"

#: C/gtkmm-tutorial-in.xml:2484(para)
msgid "The View is the actual widget (<classname>Gtk::TreeView</classname>) that displays the model (<classname>Gtk::TreeModel</classname>) data and allows the user to interact with it. The View can show all of the model's columns, or just some, and it can show them in various ways."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2494(title)
#, fuzzy
msgid "Using a Model"
msgstr "<b>Jezikovni model</b>"

#: C/gtkmm-tutorial-in.xml:2495(para)
msgid "You can specify a <classname>Gtk::TreeModel</classname> when constructing the <classname>Gtk::TreeView</classname>, or you can use the <methodname>set_model()</methodname> method, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2500(programlisting)
#, fuzzy, no-wrap
msgid "m_TreeView.set_model(m_refListStore);"
msgstr "Določitev korenskega vozlišča modela"

#: C/gtkmm-tutorial-in.xml:2504(title)
#, fuzzy
msgid "Adding View Columns"
msgstr "Stolpci pogleda skladb"

#: C/gtkmm-tutorial-in.xml:2505(para)
msgid "You can use the <methodname>append_column()</methodname> method to tell the View that it should display certain Model columns, in a certain order, with a certain column title."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2510(programlisting)
#, no-wrap
msgid "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2511(para)
msgid "When using this simple <methodname>append_column()</methodname> override, the <classname>TreeView</classname> will display the model data with an appropriate <classname>CellRenderer</classname>. For instance, strings and numbers are shown in a simple <classname>Gtk::Entry</classname> widget, and booleans are shown in a <classname>Gtk::CheckButton</classname>. This is usually what you need. For other column types you must either connect a callback that converts your type into a string representation, with <methodname>TreeViewColumn::set_cell_data_func()</methodname>, or derive a custom <classname>CellRenderer</classname>. Note that (unsigned) short is not supported by default - You could use (unsigned) int or (unsigned) long as the column type instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2527(title)
msgid "More than one Model Column per View Column"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2528(para)
msgid "To render more than one model column in a view column, you need to create the <classname>TreeView::Column</classname> widget manually, and use <methodname>pack_start()</methodname> to add the model columns to it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2534(para)
msgid "Then use <methodname>append_column()</methodname> to add the view Column to the View. Notice that <methodname>Gtk::View::append_column()</methodname> is overridden to accept either a prebuilt <classname>Gtk::View::Column</classname> widget, or just the <classname>TreeModelColumn</classname> from which it generates an appropriate <classname>Gtk::View::Column</classname> widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2541(para)
msgid "Here is some example code from <filename>demos/gtk-demo/example_stockbrowser.cc</filename>, which has a pixbuf icon and a text name in the same column:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2546(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeView::Column* pColumn =\n"
"    Gtk::manage( new Gtk::TreeView::Column(\"Symbol\") );\n"
"\n"
"// m_columns.icon and m_columns.symbol are columns in the model.\n"
"// pColumn is the column in the TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, false); //false = don't expand.\n"
"pColumn-&gt;pack_start(m_columns.symbol);\n"
"\n"
"m_TreeView.append_column(*pColumn);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2558(title)
#, fuzzy
msgid "Specifying CellRenderer details"
msgstr "Ogled podrobnosti predmeta"

#: C/gtkmm-tutorial-in.xml:2559(para)
msgid "The default <classname>CellRenderers</classname> and their default behaviour will normally suffice, but you might occasionally need finer control. For instance, this example code from <filename>demos/gtk-demo/example_treestore.cc</filename>, manually constructs a <classname>Gtk::CellRenderer</classname> widget and instructs it to render the data from various model columns through various aspects of its appearance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2567(programlisting)
#, no-wrap
msgid ""
"Gtk::CellRendererToggle* pRenderer =\n"
"    Gtk::manage( new Gtk::CellRendererToggle() );\n"
"int cols_count = m_TreeView.append_column(\"Alex\", *pRenderer);\n"
"Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_active(),\n"
"      m_columns.alex);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(),\n"
"      m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(),\n"
"      m_columns.world);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2580(para)
msgid "You can also connect to <classname>CellRenderer</classname> signals to detect user actions. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2584(programlisting)
#, no-wrap
msgid ""
"Gtk::CellRendererToggle* pRenderer =\n"
"    Gtk::manage( new Gtk::CellRendererToggle() );\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2593(title)
#: C/gtkmm-tutorial-in.xml:2932(title)
#, fuzzy
msgid "Editable Cells"
msgstr "Uredljivi stolpec"

#: C/gtkmm-tutorial-in.xml:2596(title)
msgid "Automatically-stored editable cells."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2597(para)
msgid "Cells in a <classname>TreeView</classname> can be edited in-place by the user. To allow this, use the <classname>Gtk::TreeView</classname><methodname>insert_column_editable()</methodname> and <methodname>append_column_editable()</methodname> methods instead of <methodname>insert_column()</methodname> and <methodname>append_column()</methodname>. When these cells are edited the new values will be stored immediately in the Model. Note that these methods are templates which can only be instantiated for simple column types such as <classname>Glib::ustring</classname>, int, and long."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2611(title)
msgid "Implementing custom logic for editable cells."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2612(para)
msgid "However, you might not want the new values to be stored immediately. For instance, maybe you want to restrict the input to certain characters or ranges of values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2617(para)
msgid "To achieve this, you should use the normal <classname>Gtk::TreeView</classname><methodname>insert_column()</methodname> and <methodname>append_column()</methodname> methods, then use <methodname>get_column_cell_renderer()</methodname> to get the <classname>Gtk::CellRenderer</classname> used by that column."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2623(para)
msgid "You should then cast that <classname>Gtk::CellRenderer*</classname> to the specific <classname>CellRenderer</classname> that you expect, so you can use specific API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2627(para)
msgid "For instance, for a CellRendererText, you would set the cell's <emphasis>editable</emphasis> property to true, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2630(programlisting)
#, no-wrap
msgid "cell.property_editable() = true;"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2631(para)
msgid "For a CellRendererToggle, you would set the <emphasis>activatable</emphasis> property instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2635(para)
msgid "You can then connect to the appropriate \"edited\" signal. For instance, connect to <methodname>Gtk::CellRendererText::signal_edited()</methodname>, or <methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. If the column contains more than one <classname>CellRenderer</classname> then you will need to use <methodname>Gtk::TreeView::get_column()</methodname> and then call <methodname>get_cell_renderers()</methodname> on that view Column."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2643(para)
msgid "In your signal handler, you should examine the new value and then store it in the Model if that is appropriate for your application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2655(title)
msgid "Iterating over Model Rows"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2656(para)
msgid "<classname>Gtk::TreeModel</classname> provides a C++ Standard Library-style container of its children, via the <methodname>children()</methodname> method. You can use the familiar <methodname>begin()</methodname> and <methodname>end()</methodname> methods iterator incrementing, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2662(programlisting)
#, no-wrap
msgid ""
"typedef Gtk::TreeModel::Children type_children; //minimise code length.\n"
"type_children children = refModel-&gt;children();\n"
"for(type_children::iterator iter = children.begin();\n"
"    iter != children.end(); ++iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"  //Do something with the row - see above for set/get.\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2672(title)
#, fuzzy
msgid "Row children"
msgstr "Vrstica ima podrejene predmete"

#: C/gtkmm-tutorial-in.xml:2677(programlisting)
#, fuzzy, no-wrap
msgid "Gtk::TreeModel::Children children = row.children();"
msgstr "TreeModel stolpec, ki vsebuje vrednosti širine preko vrstic"

#: C/gtkmm-tutorial-in.xml:2673(para)
msgid "When using a <classname>Gtk::TreeStore</classname>, the rows can have child rows, which can have their own children in turn. Use <methodname>Gtk::TreeModel::Row::children()</methodname> to get the container of child <classname>Row</classname>s: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2684(title)
#, fuzzy
msgid "The Selection"
msgstr "_Izbor"

#: C/gtkmm-tutorial-in.xml:2685(para)
msgid "To find out what rows the user has selected, get the <classname>Gtk::TreeView::Selection</classname> object from the <classname>TreeView</classname>, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2690(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"    m_TreeView.get_selection();"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2694(title)
#, fuzzy
msgid "Single or multiple selection"
msgstr "Razvrsti trenutni dokument ali izbiro"

#: C/gtkmm-tutorial-in.xml:2698(programlisting)
#, no-wrap
msgid "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2695(para)
msgid "By default, only single rows can be selected, but you can allow multiple selection by setting the mode, like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2703(title)
#, fuzzy
msgid "The selected rows"
msgstr "Izbrane vrstice"

#: C/gtkmm-tutorial-in.xml:2704(para)
msgid "For single-selection, you can just call <methodname>get_selected()</methodname>, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2708(programlisting)
#, no-wrap
msgid ""
"TreeModel::iterator iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) //If anything is selected\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2715(para)
msgid "For multiple-selection, you need to define a callback, and give it to <methodname>selected_foreach()</methodname>, <methodname>selected_foreach_path()</methodname>, or <methodname>selected_foreach_iter()</methodname>, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2721(programlisting)
#, no-wrap
msgid ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::iterator&amp; iter)\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2734(title)
#, fuzzy
msgid "The \"changed\" signal"
msgstr "Signalna dejanja"

#: C/gtkmm-tutorial-in.xml:2735(para)
msgid "To respond to the user clicking on a row or range of rows, connect to the signal like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2739(programlisting)
#, no-wrap
msgid ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_StockBrowser::on_selection_changed)\n"
");"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2745(title)
#, fuzzy
msgid "Preventing row selection"
msgstr "Zapomni si izbiro"

#: C/gtkmm-tutorial-in.xml:2746(para)
msgid "Maybe the user should not be able to select every item in your list or tree. For instance, in the gtk-demo, you can select a demo to see the source code, but it doesn't make any sense to select a demo category."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2751(para)
msgid "To control which rows can be selected, use the <methodname>set_select_function()</methodname> method, providing a <classname>sigc::slot</classname> callback. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2756(programlisting)
#, no-wrap
msgid ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2758(para)
#, fuzzy
msgid "and then"
msgstr "in nato po"

#: C/gtkmm-tutorial-in.xml:2761(programlisting)
#, no-wrap
msgid ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2771(title)
#, fuzzy
msgid "Changing the selection"
msgstr "_Počisti izbor"

#: C/gtkmm-tutorial-in.xml:2772(para)
msgid "To change the selection, specify a <classname>Gtk::TreeModel::iterator</classname> or <classname>Gtk::TreeModel::Row</classname>, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2777(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2780(para)
#, fuzzy
msgid "or"
msgstr "ali"

#: C/gtkmm-tutorial-in.xml:2783(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2792(title)
#, fuzzy
msgid "Sorting"
msgstr "Razvrščanje"

#: C/gtkmm-tutorial-in.xml:2793(para)
msgid "The standard tree models (<classname>TreeStore</classname> and <classname>ListStore</classname> derive from <classname>TreeSortable</classname>, so they offer sorting functionality. For instance, call <methodname>set_sort_column()</methodname>, to sort the model by the specified column. Or supply a callback function to <methodname>set_sort_func()</methodname> to implement a more complicated sorting algorithm."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2797(ulink)
#, fuzzy
msgid "TreeSortable Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:2800(title)
msgid "Sorting by clicking on columns"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2801(para)
msgid "So that a user can click on a <classname>TreeView</classname>'s column header to sort the <classname>TreeView</classname>'s contents, call <methodname>Gtk::TreeViewModel::set_sort_column()</methodname>, supplying the model column on which model should be sorted when the header is clicked. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2804(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeView::Column* pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2810(title)
msgid "Independently sorted views of the same model"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2811(para)
msgid "The <classname>TreeView</classname> already allows you to show the same <classname>TreeModel</classname> in two <classname>TreeView</classname> widgets. If you need one of these TreeViews to sort the model differently than the other then you should use a <classname>TreeModelSort</classname> instead of just, for instance, <methodname>Gtk::TreeViewModel::set_sort_column()</methodname>. <classname>TreeModelSort</classname> is a model that contains another model, presenting a sorted version of that model. For instance, you might add a sorted version of a model to a <classname>TreeView</classname> like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2814(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TreeModelSort&gt; sorted_model =\n"
"    Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2819(para)
msgid "Note, however, that the TreeView will provide iterators to the sorted model. You must convert them to iterators to the underlying child model in order to perform actions on that model. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2821(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"      m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    Gtk::TreeModel::iterator sorted_iter =\n"
"        m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      Gtk::TreeModel::iterator iter =\n"
"          m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2838(ulink)
#, fuzzy
msgid "TreeModelSort Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:2844(title)
#: C/gtkmm-tutorial-in.xml:2951(title)
#: C/gtkmm-tutorial-in.xml:3583(title)
#: C/gtkmm-tutorial-in.xml:4581(title)
#: C/gtkmm-tutorial-in.xml:4743(title)
#, fuzzy
msgid "Drag and Drop"
msgstr "Povleci in spusti"

#: C/gtkmm-tutorial-in.xml:2845(para)
msgid "<classname>Gtk::TreeView</classname> already implments simple drag-and-drop when used with the <classname>Gtk::ListStore</classname> or <classname>Gtk::TreeStore</classname> models. If necessary, it also allows you to implement more complex behaviour when items are dragged and dropped, using the normal <link linkend=\"chapter-draganddrop\">Drag and Drop</link> API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2854(title)
#, fuzzy
msgid "Reorderable rows"
msgstr "Izbrane vrstice"

#: C/gtkmm-tutorial-in.xml:2855(para)
msgid "If you call <methodname>Gtk::TreeView::set_reorderable()</methodname> then your TreeView's items can be moved within the treeview itself. This is demonstrated in the <classname>TreeStore</classname> example."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2860(para)
msgid "However, this does not allow you any control of which items can be dragged, and where they can be dropped. If you need that extra control then you might create a derived <literal>Gtk::TreeModel</literal> from <literal>Gtk::TreeStore</literal> or <literal>Gtk::ListStore</literal> and override the <literal>Gtk::TreeDragSource::row_draggable()</literal> and <literal>Gdk::TreeDragDest::row_drop_possible()</literal> virtual methods. You can examine the <literal>Gtk::TreeModel::Path</literal>s provided and allow or disallow dragging or dropping by return <literal>true</literal> or <literal>false</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2861(para)
msgid "This is demonstrated in the drag_and_drop example."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2867(title)
#: C/gtkmm-tutorial-in.xml:2973(title)
#, fuzzy
msgid "Popup Context Menu"
msgstr "odpri vsebinski meni"

#: C/gtkmm-tutorial-in.xml:2868(para)
msgid "Lots of people need to implement right-click context menus for <classname>TreeView</classname>'s so we will explain how to do that here to save you some time. Apart from one or two points, it's much the same as a normal context menu, as described in the <link linkend=\"sec-menus-popup\">menus chapter</link>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2877(title)
msgid "Handling <literal>button_press_event</literal>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2878(para)
msgid "To detect a click of the right mouse button, you need to handle the <literal>button_press_event</literal> signal, and check exactly which button was pressed. Because the <classname>TreeView</classname> normally handles this signal completely, you need to either override the default signal handler in a derived <classname>TreeView</classname> class, or use <methodname>connect_nofify()</methodname> instead of <methodname>connect()</methodname>. You probably also want to call the default handler before doing anything else, so that the right-click will cause the row to be selected first."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2888(para)
msgid "This is demonstrated in the Popup Custom Menu example."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2893(title)
#: C/gtkmm-tutorial-in.xml:3344(title)
#: C/gtkmm-tutorial-in.xml:3519(title)
#: C/gtkmm-tutorial-in.xml:4892(title)
#, fuzzy
msgid "Examples"
msgstr "Primeri"

#: C/gtkmm-tutorial-in.xml:2895(title)
msgid "ListStore"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2896(para)
msgid "This example has a <classname>Gtk::TreeView</classname> widget, with a <classname>Gtk::ListStore</classname> model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2913(title)
msgid "TreeStore"
msgstr ""

#: C/gtkmm-tutorial-in.xml:2915(para)
msgid "This example is very similar to the <classname>ListStore</classname> example, but uses a <classname>Gtk::TreeStore</classname> model instead, and adds children to the rows."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2934(para)
msgid "This example is identical to the <classname>ListStore</classname> example, but it uses <methodname>TreeView::append_column_editable()</methodname> instead of <methodname>TreeView::append_column()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2941(title)
#, fuzzy
msgid "TreeView - Editable Cells"
msgstr "Prostor med celicami"

#: C/gtkmm-tutorial-in.xml:2953(para)
msgid "This example is much like the <classname>TreeStore</classname> example, but has 2 extra columns to indicate whether the row can be dragged, and whether it can receive drag-and-dropped rows. It uses a derived <classname>Gtk::TreeStore</classname> which overrides the virtual functions as described in the <link linkend=\"sec-treeview-draganddrop\">TreeView Drag and Drop</link> section.."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2963(title)
#, fuzzy
msgid "TreeView - Drag And Drop"
msgstr "večkratno povleci in spusti"

#: C/gtkmm-tutorial-in.xml:2975(para)
msgid "This example is much like the <classname>ListStore</classname> example, but derives a custom <classname>TreeView</classname> in order to override the <literal>button_press_event</literal>, and also to encapsulate the tree model code in our derived class. See the <link linkend=\"sec-treeview-contextmenu\">TreeView Popup Context Menu</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:2985(title)
#, fuzzy
msgid "TreeView - Popup Context Menu"
msgstr "Izjema iz pojavnega menija '%s'\n"

#: C/gtkmm-tutorial-in.xml:3002(title)
#, fuzzy
msgid "Combo Boxes"
msgstr "Ni več pojavnih menijev."

#: C/gtkmm-tutorial-in.xml:3004(para)
msgid "The <classname>ComboBox</classname> widgets offers a list (or tree) of choices in a dropdown menu. If appropriate, it can show extra information about each item, such as text, a picture, a checkbox, or a progress bar. The <classname>ComboBox</classname> widget usually restricts the user to the available choices, but it can optionally have an <classname>Entry</classname>, allowing the user to enter arbitrary text if the none of the available choices are suitable."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3007(para)
msgid "The list is provided via a <classname>TreeModel</classname>, and columns from this model are added to the ComboBox's view with the <methodname>ComboBox::pack_start()</methodname> method. This provides flexibility and compile-time type-safety, but the <classname>ComboBoxText</classname> class provides a simpler text-based specialization in case that flexibility is not required."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3013(title)
#, fuzzy
msgid "The model"
msgstr "Model"

#: C/gtkmm-tutorial-in.xml:3014(para)
msgid "The model for a ComboBox can be defined and filled exactly as for a <classname>TreeView</classname>. For instance, you might derive a ComboBox class with one integer and one text columns, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3016(programlisting)
#, no-wrap
msgid ""
"ModelColumns()\n"
"{ add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3025(para)
msgid "After appending rows to this model, you should provide the model to the <classname>ComboBox</classname> with the <methodname>set_model()</methodname> method. Then use the <methodname>pack_start()</methodname> or <methodname>pack_end()</methodname> methods to specify what methods will be displayed in the ComboBox. As with the TreeView you may either use the default cell renderer by passing the <classname>TreeModelColumn</classname> to the pack methods, or you may instantiate a specific <classname>CellRenderer</classname> and specify a particular mapping with either <methodname>add_attribute()</methodname> or <methodname>set_cell_data_func()</methodname>. Note that these methods are in the <classname>CellLayout</classname> base class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3029(title)
#, fuzzy
msgid "The chosen item"
msgstr "_Nov predmet"

#: C/gtkmm-tutorial-in.xml:3030(para)
msgid "To discover what item, if any, the user has chosen from the ComboBox, call <methodname>ComboBox::get_active()</methodname>. This returns a <classname>TreeModel::iterator</classname> that you can dereference to a <classname>Row</classname> in order to read the values in your columns. For instance, you might read an integer ID value from the model, even though you have chosen only to show the human-readable description in the Combo. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3032(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"\n"
"  //Get the data for the selected row, using our knowledge\n"
"  //of the tree model:\n"
"  int id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); //Your own function.\n"
"}\n"
"else\n"
"  set_nothing_chosen(); //Your own function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3047(title)
#, fuzzy
msgid "Responding to changes"
msgstr "Izbor sprememb za povrnitev:"

#: C/gtkmm-tutorial-in.xml:3048(para)
msgid "You might need to react to every change of selection in the ComboBox, for instance to update other widgets. To do so, you should handle the \"changed\" signal. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3051(programlisting)
#, no-wrap
msgid ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3055(title)
#: C/gtkmm-tutorial-in.xml:3102(title)
#, fuzzy
msgid "Full Example"
msgstr "Primer Bakery"

#: C/gtkmm-tutorial-in.xml:3058(title)
#: C/gtkmm-tutorial-in.xml:3071(title)
#, fuzzy
msgid "ComboBox"
msgstr "Model spustnega polja"

#: C/gtkmm-tutorial-in.xml:3068(title)
#: C/gtkmm-tutorial-in.xml:3115(title)
#, fuzzy
msgid "Simple Text Example"
msgstr "Primer XML Bakery."

#: C/gtkmm-tutorial-in.xml:3082(title)
#, fuzzy
msgid "ComboBox with an Entry"
msgstr "Polja povezana z <b>%s</b> vrsto vnosa"

#: C/gtkmm-tutorial-in.xml:3084(para)
msgid "A <classname>ComboBox</classname> may contain an <classname>Entry</classname> widget for entering of arbitrary text, by specifying true for the constructor's <literal>has_entry</literal> parameter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3087(title)
#, fuzzy
msgid "The text column"
msgstr "Stolpec stolpca besedila"

#: C/gtkmm-tutorial-in.xml:3089(programlisting)
#, no-wrap
msgid "m_combo.set_text_column(m_columns.m_col_name);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3088(para)
msgid "So that the Entry can interact with the drop-down list of choices, you must specify which of your model columns are the text column, with <methodname>set_text_column()</methodname>. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3091(para)
msgid "When you select a choice from the drop-down menu, the value from this column will be placed in the <classname>Entry</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3097(title)
#, fuzzy
msgid "The entry"
msgstr "vnos"

#: C/gtkmm-tutorial-in.xml:3098(para)
msgid "Because the user may enter arbitrary text, an active model row isn't enough to tell us what text the user has inputted. Therefore, you should retrieve the <classname>Entry</classname> widget with the <methodname>ComboBoxEntry::get_entry()</methodname> method and call <methodname>get_text()</methodname> on that."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3105(title)
msgid "ComboBoxEntry"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3118(title)
msgid "ComboBoxEntryText"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3137(title)
#: C/gtkmm-tutorial-in.xml:3349(title)
msgid "TextView"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3138(para)
msgid "The <classname>TextView</classname> widget can be used to display and edit large amounts of formatted text. Like the <classname>TreeView</classname>, it has a model/view design. In this case the <classname>TextBuffer</classname> is the model."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3146(title)
#, fuzzy
msgid "The Buffer"
msgstr "Medpomnilnik"

#: C/gtkmm-tutorial-in.xml:3147(para)
msgid "<classname>Gtk::TextBuffer</classname> is a model containing the data for the <classname>Gtk::TextView</classname>, like the <classname>Gtk::TreeModel</classname> used by <classname>Gtk::TreeView</classname>. This allows two or more <classname>Gtk::TextView</classname>s to share the same <classname>TextBuffer</classname>, and allows those TextBuffers to be displayed slightly differently. Or you could maintain several <classname>Gtk::TextBuffer</classname>s and choose to display each one at different times in the same <classname>Gtk::TextView</classname> widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3157(para)
msgid "The <classname>TextView</classname> creates its own default <classname>TextBuffer</classname>, which you can access via the <methodname>get_buffer()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3166(title)
msgid "Iterators"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3172(title)
#, fuzzy
msgid "Tags and Formatting"
msgstr "Kategorije in oznake"

#: C/gtkmm-tutorial-in.xml:3175(title)
#, fuzzy
msgid "Tags"
msgstr "Oznake"

#: C/gtkmm-tutorial-in.xml:3176(para)
msgid "To specify that some text in the buffer should have specific formatting, you must define a tag to hold that formatting information, and then apply that tag to the region of text. For instance, to define the tag and its properties:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3179(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch =\n"
"    Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3182(para)
msgid "You can specify a name for the <classname>Tag</classname> when using the <methodname>create()</methodname> method, but it is not necessary."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3187(para)
msgid "The <classname>Tag</classname> class has many other properties."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3196(title)
msgid "TagTable"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3198(para)
msgid "Each <classname>Gtk::TextBuffer</classname> uses a <classname>Gtk::TextBuffer::TagTable</classname>, which contains the <classname>Tag</classname>s for that buffer. 2 or more <classname>TextBuffer</classname>s may share the same <classname>TagTable</classname>. When you create <classname>Tag</classname>s you should add them to the <classname>TagTable</classname>. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3206(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable =\n"
"    Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,\n"
"//for use after creation of the buffer.\n"
"Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer =\n"
"    Gtk::TextBuffer::create(refTagTable);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3214(para)
msgid "You can also use <methodname>get_tag_table()</methodname> to get, and maybe modify, the <classname>TextBuffer</classname>'s default <classname>TagTable</classname> instead of creating one explicitly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3225(title)
#, fuzzy
msgid "Applying Tags"
msgstr "Izbriši oznake"

#: C/gtkmm-tutorial-in.xml:3226(para)
msgid "If you have created a <classname>Tag</classname> and added it to the <classname>TagTable</classname>, you may apply that tag to part of the <classname>TextBuffer</classname> so that some of the text is displayed with that formatting. You define the start and end of the range of text by specifying <classname>Gtk::TextBuffer::iterator</classname>s. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3233(programlisting)
#, no-wrap
msgid "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3234(para)
msgid "Or you could specify the tag when first inserting the text: refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3239(para)
msgid "You can apply more than one <classname>Tag</classname> to the same text, by using <methodname>apply_tag()</methodname> more than once, or by using <methodname>insert_with_tags()</methodname>. The <classname>Tag</classname>s might specify different values for the same properties, but you can resolve these conflicts by using <methodname>Tag::set_priority()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3251(title)
#, fuzzy
msgid "Marks"
msgstr "Pokaži oznake"

#: C/gtkmm-tutorial-in.xml:3252(para)
msgid "<classname>TextBuffer</classname> iterators are generally invalidated when the text changes, but you can use a <classname>Gtk::TextBuffer::Mark</classname> to remember a position in these situations. For instance,"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3257(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark =\n"
"    refBuffer-&gt;create_mark(iter);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3260(para)
msgid "You can then use the <methodname>get_iter()</methodname> method later to create an iterator for the <classname>Mark</classname>'s new position."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3265(para)
msgid "There are two built-in <classname>Mark</classname>s - <literal>insert</literal> and <literal>select_bound</literal>, which you can access with <classname>TextBuffer</classname>'s <methodname>get_insert()</methodname> and <methodname>get_selection_bound()</methodname> methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3278(para)
msgid "As mentioned above, each <classname>TextView</classname> has a <classname>TextBuffer</classname>, and one or more <classname>TextView</classname> can share the same <classname>TextBuffer</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3285(para)
msgid "Like the <classname>TreeView</classname>, you should probably put your <classname>TextView</classname> inside a <classname>ScrolledWindow</classname> to allow the user to see and move around the whole text area with scrollbars."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3295(title)
#, fuzzy
msgid "Default formatting"
msgstr "Oblikovanje sporočila"

#: C/gtkmm-tutorial-in.xml:3296(para)
msgid "<classname>TextView</classname> has various methods which allow you to change the presentation of the buffer for this particular view. Some of these may be overridden by the <classname>Gtk::TextTag</classname>s in the buffer, if they specify the same things. For instance, <methodname>set_left_margin()</methodname>, <methodname>set_right_margin()</methodname>, <methodname>set_indent()</methodname>, etc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3307(title)
#, fuzzy
msgid "Scrolling"
msgstr "Drsenje"

#: C/gtkmm-tutorial-in.xml:3308(para)
msgid "<classname>Gtk::TextView</classname> has various <methodname>scroll_to_*()</methodname> methods. These allow you to ensure that a particular part of the text buffer is visible. For instance, your application's Find feature might use <methodname>Gtk::TextView::scroll_to_iter()</methodname> to show the found text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3323(title)
#, fuzzy
msgid "Widgets and ChildAnchors"
msgstr "Opozorila in napake"

#: C/gtkmm-tutorial-in.xml:3324(para)
msgid "You can embed widgets, such as <classname>Gtk::Button</classname>s, in the text. Each such child widget needs a <classname>ChildAnchor</classname>. ChildAnchors are associated with <classname>iterators</classname>. For instance, to create a child anchor at a particular position, use <methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3331(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor =\n"
"    refBuffer-&gt;create_child_anchor(iter);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3334(para)
msgid "Then, to add a widget at that position, use <methodname>Gtk::TextView::add_child_at_anchor()</methodname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3338(programlisting)
#, no-wrap
msgid "m_TextView.add_child_at_anchor(m_Button, refAnchor);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3364(title)
#, fuzzy
msgid "Menus and Toolbars"
msgstr "Opozorila in napake"

#: C/gtkmm-tutorial-in.xml:3366(para)
msgid "There are specific APIs for Menus and toolbars, but you should usually deal with them together, using the <classname>UIManager</classname> to define <classname>Action</classname>s which you can then arrange in menu and toolbars. In this way you can handle activation of the action instead of responding to the menu and toolbar items separately. And you can enable or disable both the menu and toolbar item via the action."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3374(para)
msgid "This involves the use of the <classname>Gtk::ActionGroup</classname>, <classname>Gtk::Action</classname>, and <classname>UIManager</classname> classes, all of which should be instantiated via their <methodname>create()</methodname> methods, which return <classname>RefPtr</classname>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3383(title)
#, fuzzy
msgid "Actions"
msgstr "Dejanja"

#: C/gtkmm-tutorial-in.xml:3384(para)
msgid "First create the <classname>Action</classname>s and add them to an <classname>ActionGroup</classname>, with <methodname>ActionGroup::add()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3390(para)
msgid "The arguments to <methodname>Action::create()</methodname> specify the action's name and how it will appear in menus and toolbars. Use stock items where possible so that you don't need to specify the label, accelerator, icon, and tooltips, and so you can use pre-existing translations."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3396(para)
msgid "You can also specify a signal handler when calling <methodname>ActionGroup::add()</methodname>. This signal handler will be called when the action is activated via either a menu item or a toolbar button."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3401(para)
msgid "Note that you must specify actions for sub menus as well as menu items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3403(para)
#, fuzzy
msgid "For instance:"
msgstr "Večkratna pojavitev"

#: C/gtkmm-tutorial-in.xml:3405(programlisting)
#, no-wrap
msgid ""
"m_refActionGroup = Gtk::ActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"MenuFile\", \"_File\") );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"New\", Gtk::Stock::NEW),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"ExportData\", \"Export Data\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"Quit\", Gtk::Stock::QUIT),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3415(para)
msgid "Note that this is where we specify the names of the actions as they will be seen by users in menus and toolbars. Therefore, this is where you should make strings translatable, by putting them inside the _() macro. When we use the Gtk::Stock items, of course, translations are automatically available."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3420(title)
msgid "UIManager"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3421(para)
msgid "Next you should create a <classname>UIManager</classname> and add the <classname>ActionGroup</classname> to the <classname>UIManager</classname> with <methodname>insert_action_group()</methodname> At this point is also a good idea to tell the parent window to respond to the specified keyboard shortcuts, by using <methodname>add_accel_group()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3429(para)
#: C/gtkmm-tutorial-in.xml:4810(para)
#, fuzzy
msgid "For instance,"
msgstr "Večkratna pojavitev"

#: C/gtkmm-tutorial-in.xml:3431(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager =\n"
"    Gtk::UIManager::create();\n"
"m_refUIManager-&gt;insert_action_group(m_refActionGroup);\n"
"add_accel_group(m_refUIManager-&gt;get_accel_group());"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3435(para)
msgid "Then, you can define the actual visible layout of the menus and toolbars, and add the UI layout to the <classname>UIManager</classname>. This \"ui string\" uses an XML format, in which you should mention the names of the actions that you have already created. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3441(programlisting)
#, no-wrap
msgid ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;menubar name='MenuBar'&gt;\"\n"
"    \"    &lt;menu action='MenuFile'&gt;\"\n"
"    \"      &lt;menuitem action='New'/&gt;\"\n"
"    \"      &lt;menuitem action='Open'/&gt;\"\n"
"    \"      &lt;separator/&gt;\"\n"
"    \"      &lt;menuitem action='Quit'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"    &lt;menu action='MenuEdit'&gt;\"\n"
"    \"      &lt;menuitem action='Cut'/&gt;\"\n"
"    \"      &lt;menuitem action='Copy'/&gt;\"\n"
"    \"      &lt;menuitem action='Paste'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"  &lt;/menubar&gt;\"\n"
"    \"  &lt;toolbar  name='ToolBar'&gt;\"\n"
"    \"    &lt;toolitem action='Open'/&gt;\"\n"
"    \"    &lt;toolitem action='Quit'/&gt;\"\n"
"    \"  &lt;/toolbar&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3464(para)
msgid "Remember that these names are just the identifiers that we used when creating the actions. They are not the text that the user will see in the menus and toolbars. We provided those human-readable names when we created the actions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3465(para)
msgid "To instantiate a <classname>Gtk::MenuBar</classname> or <classname>Gtk::Toolbar</classname> which you can actually show, you should use the <methodname>UIManager::get_widget()</methodname> method, and then add the widget to a container. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3471(programlisting)
#, no-wrap
msgid ""
"Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget(\"/MenuBar\");\n"
"pBox-&gt;add(*pMenuBar, Gtk::PACK_SHRINK);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3477(title)
#, fuzzy
msgid "Popup Menus"
msgstr "Ur_edi menije"

#: C/gtkmm-tutorial-in.xml:3478(para)
msgid "<classname>Menus</classname> are normally just added to a window, but they can also be displayed temporarily as the result of a mouse button click. For instance, a context menu might be displayed when the user clicks their right mouse button."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3485(para)
msgid "The UI layout for a popup menu should use the <literal>popup</literal> node. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3487(programlisting)
#, no-wrap
msgid ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;popup name='PopupMenu'&gt;\"\n"
"    \"    &lt;menuitem action='ContextEdit'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextProcess'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextRemove'/&gt;\"\n"
"    \"  &lt;/popup&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3498(para)
msgid "To show the popup menu, use <classname>Gtk::Menu</classname>'s <methodname>popup()</methodname> method, providing the button identifier and the time of activation, as provided by the <literal>button_press_event</literal> signal, which you will need to handle anyway. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3504(programlisting)
#, no-wrap
msgid ""
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;\n"
"      (event-&gt;button == 3) )\n"
"  {\n"
"    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; //It has been handled.\n"
"  }\n"
"  else\n"
"    return false;\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3521(title)
#, fuzzy
msgid "Main Menu example"
msgstr "Glavni meni GNOME"

#: C/gtkmm-tutorial-in.xml:3524(title)
#, fuzzy
msgid "Main Menu"
msgstr "Glavni meni"

#: C/gtkmm-tutorial-in.xml:3534(title)
#, fuzzy
msgid "Popup Menu example"
msgstr "Pokaži pojavno okno"

#: C/gtkmm-tutorial-in.xml:3537(title)
#, fuzzy
msgid "Popup Menu"
msgstr "Pojavni meni"

#: C/gtkmm-tutorial-in.xml:3552(title)
#: C/gtkmm-tutorial-in.xml:3593(title)
msgid "ToolPalette"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3554(para)
msgid "A <classname>ToolPalette</classname> is similar to a <classname>Toolbar</classname> but can contain a grid of items, categorized into groups. The user may hide or expand each group. As in a toolbar, the items may be displayed as only icons, as only text, or as icons with text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3556(para)
msgid "The <classname>ToolPalette</classname>'s items might be dragged or simply activated. For instance, the user might drag objects to a canvas to create new items there. Or the user might click an item to activate a certain brush size in a drawing application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3557(para)
msgid "<classname>ToolItemGroup</classname>s should be added to the tool pallete via the base class's <function>Gtk::Container::add()</function> method, for instance like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3560(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::ToolItemGroup* group_brushes =\n"
"  Gtk::manage(new Gtk::ToolItemGroup(\"Brushes\"));\n"
"m_ToolPalette.add(*group_brushes);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3566(para)
msgid "<classname>Gtk::ToolItem</classname>s can then be added to the group. For instance, like so:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3570(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, \"Big\"));\n"
"button-&gt;set_tooltip_text(\"Big Brush);\n"
"group_brushes-&gt;insert(*button);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3576(para)
msgid "You might then handle the <classname>ToolButton</classname>'s <literal>clicked</literal> signal. Alternatively, you could allow the item to be dragged to another widget, by calling <methodname>Gtk::ToolPalette::add_drag_dest()</methodname> and then using <methodname>Gtk::ToolPalette::get_drag_item()</methodname> in the other widget's <literal>drag_data_received</literal> signal handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3578(ulink)
#, fuzzy
msgid "ToolPalette Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:3579(ulink)
#, fuzzy
msgid "ToolItemGroup Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:3580(ulink)
#, fuzzy
msgid "ToolItem Reference"
msgstr "_API referenca"

#: C/gtkmm-tutorial-in.xml:3584(para)
msgid "Call <methodname>add_drag_dest()</methodname> to allow items or groups to be dragged from the tool palette to a particular destination widget. You can then use <methodname>get_drag_item()</methodname> to discover which ToolItem or ToolItemGroup is being dragged. You can use <literal>dynamic_cast</literal> to discover whether is it an item or a group. For instance, you might use this in your <literal>drag_data_received</literal> signal handler, to add a dropped item, or to show a suitable icon while dragging."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3585(para)
msgid "See the <link linkend=\"chapter-draganddrop\">Drag and Drop</link> chapter for general advice about Drag and Drop with gtkmm."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3588(title)
#, fuzzy
msgid "ToolPalette Example"
msgstr "Primer Bakery"

#: C/gtkmm-tutorial-in.xml:3590(para)
msgid "This example adds a <classname>ToolPalette</classname> and a <classname>DrawingArea</classname> to a window and allows the user to drag icons from the tool palette to the drawing area. The tool palette contains several groups of items. The combo boxes allow the user to change the style and orientation of the tool palette."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3606(title)
#, fuzzy
msgid "Adjustments"
msgstr "Pokaži spremembe"

#: C/gtkmm-tutorial-in.xml:3608(para)
msgid "<application>gtkmm</application> has various widgets that can be visually adjusted using the mouse or the keyboard, such as the <classname>Range</classname> widgets (described in the <link linkend=\"chapter-range-widgets\">Range Widgets</link> section). There are also a few widgets that display some adjustable part of a larger area, such as the <classname>Viewport</classname> widget. These widgets have <classname>Gtk::Adjustment</classname> objects that express this common part of their API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3618(para)
msgid "So that applications can react to changes, for instance when a user moves a scrollbar, <classname>Gtk::Adjustment</classname> has a <literal>changed</literal> signal. You can then use the <methodname>get_changed()</methodname> method to discover the new value."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3626(title)
#, fuzzy
msgid "Creating an Adjustment"
msgstr "Stolpec prilagajanja"

#: C/gtkmm-tutorial-in.xml:3628(para)
msgid "The <classname>Gtk::Adjustment</classname> constructor is as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3632(programlisting)
#, no-wrap
msgid ""
"Gtk::Adjustment(float value,\n"
"                float lower,\n"
"                float upper,\n"
"                float step_increment = 1,\n"
"                float page_increment = 10,\n"
"                float page_size = 0);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3639(para)
msgid "The <parameter>value</parameter> argument is the initial value of the adjustment, usually corresponding to the topmost or leftmost position of an adjustable widget. The <parameter>lower</parameter> and <parameter>upper</parameter> arguments specifies the possible range of values which the adjustment can hold. The <parameter>step_increment</parameter> argument specifies the smaller of the two increments by which the user can change the value, while the <parameter>page_increment</parameter> is the larger one. The <parameter>page_size</parameter> argument usually corresponds somehow to the visible area of a panning widget. The <parameter>upper</parameter> argument is used to represent the bottom most or right most coordinate in a panning widget's child."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3658(title)
msgid "Using Adjustments the Easy Way"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3660(para)
msgid "The adjustable widgets can be roughly divided into those which use and require specific units for these values, and those which treat them as arbitrary numbers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3665(para)
msgid "The group which treats the values as arbitrary numbers includes the <classname>Range</classname> widgets (<classname>Scrollbars</classname> and <classname>Scales</classname>, the <classname>Progressbar</classname> widget, and the <classname>SpinButton</classname> widget). These widgets are typically \"adjusted\" directly by the user with the mouse or keyboard. They will treat the <parameter>lower</parameter> and <parameter>upper</parameter> values of an adjustment as a range within which the user can manipulate the adjustment's <parameter>value</parameter>. By default, they will only modify the <parameter>value</parameter> of an adjustment."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3677(para)
msgid "The other group includes the <classname>Viewport</classname> widget and the <classname>ScrolledWindow</classname> widget. All of these widgets use pixel values for their adjustments. These are also typically adjusted indirectly using scrollbars. While all widgets which use adjustments can either create their own adjustments or use ones you supply, you'll generally want to let this particular category of widgets create its own adjustments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3686(para)
msgid "If you share an adjustment object between a Scrollbar and a TextView widget, manipulating the scrollbar will automagically adjust the TextView widget. You can set it up like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3691(programlisting)
#, no-wrap
msgid ""
"// creates its own adjustments\n"
"Gtk::TextView textview;\n"
"// uses the newly-created adjustment for the scrollbar as well\n"
"Gtk::VScrollbar vscrollbar (*(textview.get_vadjustment()));"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3699(title)
#, fuzzy
msgid "Adjustment Internals"
msgstr "Stolpec prilagajanja"

#: C/gtkmm-tutorial-in.xml:3701(para)
msgid "OK, you say, that's nice, but what if I want to create my own handlers to respond when the user adjusts a <classname>Range</classname> widget or a <classname>SpinButton</classname>. To access the value of a <classname>Gtk::Adjustment</classname>, you can use the <methodname>get_value()</methodname> and <methodname>set_value()</methodname> methods:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3709(para)
msgid "As mentioned earlier, <classname>Gtk::Adjustment</classname> can emit signals. This is, of course, how updates happen automatically when you share an <classname>Adjustment</classname> object between a <classname>Scrollbar</classname> and another adjustable widget; all adjustable widgets connect signal handlers to their adjustment's <literal>value_changed</literal> signal, as can your program."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3718(para)
msgid "So, for example, if you have a <classname>Scale</classname> widget, and you want to change the rotation of a picture whenever its value changes, you would create a signal handler like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3723(programlisting)
#, no-wrap
msgid ""
"void cb_rotate_picture (Gtk::Widget *picture)\n"
"{\n"
"  picture-&gt;set_rotation (adj-&gt;value);\n"
"..."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3727(para)
msgid "and connect it to the scale widget's adjustment like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3730(programlisting)
#, no-wrap
msgid ""
"adj.value_changed.connect(sigc::bind&lt;Widget*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3733(para)
msgid "What if a widget reconfigures the <parameter>upper</parameter> or <parameter>lower</parameter> fields of its <classname>Adjustment</classname>, such as when a user adds more text to a text widget? In this case, it emits the <literal>changed</literal> signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3740(para)
msgid "<classname>Range</classname> widgets typically connect a handler to this signal, which changes their appearance to reflect the change - for example, the size of the slider in a scrollbar will grow or shrink in inverse proportion to the difference between the <parameter>lower</parameter> and <parameter>upper</parameter> values of its <classname>Adjustment</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3749(para)
msgid "You probably won't ever need to attach a handler to this signal, unless you're writing a new type of range widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3753(programlisting)
#, fuzzy, no-wrap
msgid "adjustment-&gt;changed();"
msgstr "Geslo je uspešno spremenjeno."

#: C/gtkmm-tutorial-in.xml:3760(title)
#, fuzzy
msgid "Widgets Without X-Windows"
msgstr "Windows zvočna datoteka"

#: C/gtkmm-tutorial-in.xml:3762(para)
msgid "Some Widgets do not have an associated X-Window, so they therefore do not receive X events. This means that the signals described in the <link linkend=\"sec-xeventsignals\">X event signals</link> section will not be emitted. If you want to capture events for these widgets you can use a special container called <classname>Gtk::EventBox</classname>, which is described in the <link linkend=\"sec-eventbox\">EventBox</link> section."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3771(para)
msgid "Here is a list of some of these Widgets:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3774(programlisting)
#, no-wrap
msgid ""
"Gtk::Alignment\n"
"Gtk::Arrow\n"
"Gtk::Bin\n"
"Gtk::Box\n"
"Gtk::Button\n"
"Gtk::CheckButton\n"
"Gtk::Fixed\n"
"Gtk::Image\n"
"Gtk::Item\n"
"Gtk::Label\n"
"Gtk::MenuItem\n"
"Gtk::Notebook\n"
"Gtk::Paned\n"
"Gtk::Pixmap\n"
"Gtk::RadioButton\n"
"Gtk::Range\n"
"Gtk::ScrolledWindow\n"
"Gtk::Separator\n"
"Gtk::Table\n"
"Gtk::Toolbar\n"
"Gtk::AspectFrame\n"
"Gtk::Frame\n"
"Gtk::VBox\n"
"Gtk::HBox\n"
"Gtk::VSeparator\n"
"Gtk::HSeparator"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3801(para)
msgid "These widgets are mainly used for decoration or layout, so you won't often need to capture events on them. They are intended to have no X-Window in order to improve performance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3807(title)
#: C/gtkmm-tutorial-in.xml:3851(title)
msgid "EventBox"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3809(para)
msgid "Some <application>gtkmm</application> widgets don't have associated X windows; they draw on their parents' windows. Because of this, they cannot receive events. Also, if they are incorrectly sized, they don't clip, so you can get messy overwriting etc. To receive events on one of these widgets, you can it inside an <classname>EventBox</classname> widget and then call <methodname>Gtk::Widget::set_events()</methodname> on the EventBox before showing it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3817(para)
msgid "Although the name <classname>EventBox</classname> emphasises the event-handling method, the widget can also be used for clipping (and more; see the example below)."
msgstr ""

#. <para>TODO: Why don't they have X Windows - explain clipping.
#. Also, how does this affect platform such as Windows and MacOS that don't use X.
#. </para>
#: C/gtkmm-tutorial-in.xml:3827(para)
msgid "The constructor for <classname>Gtk::EventBox</classname> is:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3831(programlisting)
#, fuzzy, no-wrap
msgid "Gtk::EventBox();"
msgstr "Gtk+ zastarelo"

#: C/gtkmm-tutorial-in.xml:3833(para)
msgid "A child widget can be added to the <classname>EventBox</classname> using:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3837(programlisting)
#, no-wrap
msgid "event_box.add(child_widget);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3843(para)
msgid "The following example demonstrates both uses of an <classname>EventBox</classname> - a label is created that is clipped to a small box, and set up so that a mouse-click on the label causes the program to exit. Resizing the window reveals varying amounts of the label."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3865(title)
#, fuzzy
msgid "Dialogs"
msgstr "Okna WinCE"

#: C/gtkmm-tutorial-in.xml:3867(para)
msgid "Dialogs are used as secondary windows, to provide specific information or to ask questions. <classname>Gtk::Dialog</classname> windows contain a few pre-packed widgets to ensure consistency, and a <methodname>run()</methodname> method which blocks until the user dismisses the dialog."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3874(para)
msgid "There are several derived <classname>Dialog</classname> classes which you might find useful. <classname>Gtk::MessageDialog</classname> is used for most simple notifications. But at other times you might need to derive your own dialog class to provide more complex functionality."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3881(para)
msgid "To pack widgets into a custom dialog, you should pack them into the <classname>Gtk::VBox</classname>, available via <methodname>get_vbox()</methodname>. To just add a <classname>Button</classname> to the bottom of the <classname>Dialog</classname>, you could use the <methodname>add_button()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3889(para)
msgid "The <methodname>run()</methodname> method returns an <literal>int</literal>. This may be a value from the <literal>Gtk::ResponseType</literal> if the user closed the button by clicking a standard button, or it could be the custom response value that you specified when using <methodname>add_button()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3898(title)
#: C/gtkmm-tutorial-in.xml:3913(title)
msgid "MessageDialog"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3899(para)
msgid "<classname>MessageDialog</classname> is a convenience class, used to create simple, standard message dialogs, with a message, an icon, and buttons for user response. You can specify the type of message and the text in the constructor, as well as specifying standard buttons via the <literal>Gtk::ButtonsType</literal> enum."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3924(title)
msgid "FileChooserDialog"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3925(para)
msgid "The <classname>FileChooserDialog</classname> is suitable for use with \"Open\" or \"Save\" menu items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3929(para)
msgid "Most of the useful member methods for this class are actually in the <classname>Gtk::FileChooser</classname> base class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3940(title)
#, fuzzy
msgid "FileChooser"
msgstr "IzbirnikDatotek"

#: C/gtkmm-tutorial-in.xml:3950(title)
#: C/gtkmm-tutorial-in.xml:3962(title)
msgid "ColorSelectionDialog"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3951(para)
msgid "The <classname>ColorSelectionDialog</classname> allows the user to choose a color."
msgstr ""

#: C/gtkmm-tutorial-in.xml:3973(title)
#: C/gtkmm-tutorial-in.xml:3985(title)
msgid "FontSelectionDialog"
msgstr ""

#: C/gtkmm-tutorial-in.xml:3974(para)
msgid "The <classname>FontSelectionDialog</classname> allows the user to choose a font."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4000(title)
#, fuzzy
msgid "The Drawing Area Widget"
msgstr "Gradnika ni mogoče najti: %s"

#: C/gtkmm-tutorial-in.xml:4001(para)
msgid "The <classname>DrawingArea</classname> widget is a blank window that gives you the freedom to create any graphic you desire. Along with that freedom comes the responsibility to handle expose events on the widget. When a widget is first shown, or when it is covered and then uncovered again it needs to redraw itself. Most widgets have code to do this, but the DrawingArea does not, allowing you to write your own expose event signal handler to determine how the contents of the widget will be drawn. This is most often done by overriding the virtual <methodname>on_expose_event()</methodname> member function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4013(para)
msgid "GTK+ uses the <ulink url=\"http://cairographics.org\">Cairo</ulink> drawing API. With gtkmm, you may use the <ulink url=\"http://www.cairographics.org/cairomm/\">cairomm</ulink> C++ API for cairo."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4018(para)
msgid "You can draw very sophisticated shapes using Cairo, but the methods to do so are quite basic. Cairo provides methods for drawing straight lines, curved lines, and arcs (including circles). These basic shapes can be combined to create more complex shapes and paths which can be filled with solid colors, gradients, patterns, and other things. In addition, Cairo can perform complex transformations, do compositing of images, and render antialiased text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4028(title)
#, fuzzy
msgid "Cairo and Pango"
msgstr "Opozorila in napake"

#: C/gtkmm-tutorial-in.xml:4029(para)
msgid "Although Cairo can render text, it's not meant to be a replacement for Pango. Pango is a better choice if you need to perform more advanced text rendering such as wrapping or ellipsizing text. Drawing text with Cairo should only be done if the text is part of a graphic."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4034(para)
msgid "In this section of the tutorial, we'll cover the basic Cairo drawing model, describe each of the basic drawing elements in some detail (with examples), and then present a simple application that uses Cairo to draw a custom clock widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4041(title)
#, fuzzy
msgid "The Cairo Drawing Model"
msgstr "Na besedah temelječ način"

#: C/gtkmm-tutorial-in.xml:4042(para)
msgid "The basic concept of drawing in Cairo involves defining 'invisible' paths and then stroking or filling them to make them visible."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4046(para)
msgid "To do any drawing in <application>gtkmm</application> with Cairo, you must first create a <classname>Cairo::Context</classname> object. This class holds all of the graphics state parameters that describe how drawing is to be done. This includes information such as line width, color, the surface to draw to, and many other things. This allows the actual drawing functions to take fewer arguments to simplify the interface. In <application>gtkmm</application>, a <classname>Cairo::Context</classname> is created by calling the <methodname>Gdk::Window::create_cairo_context()</methodname> function. Since Cairo context are reference-counted objects, this function returns a <classname>Cairo::RefPtr&lt;Cairo::Context&gt;</classname> object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4059(para)
msgid "The following example shows how to set up a Cairo context with a foreground color of red and a width of 2. Any drawing functions that use this context will use these settings."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4064(programlisting)
#, no-wrap
msgid ""
"Gtk::DrawingArea myArea;\n"
"Cairo::RefPtr&lt;Cairo::Context&gt; myContext = myArea.get_window()-&gt;create_cairo_context();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4068(para)
msgid "Each <classname>Cairo::Context</classname> is associated with a particular <classname>Gdk::Window</classname>, so the first line of the above example creates a <classname>Gtk::DrawingArea</classname> widget and the second line uses its associated <classname>Gdk::Window</classname> to create a <classname>Cairo::Context</classname> object. The final two lines change the graphics state of the context."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4077(para)
msgid "There are a number of graphics state variables that can be set for a Cairo context. The most common context attributes are color (using <methodname>set_source_rgb()</methodname> or <methodname>set_source_rgba()</methodname> for translucent colors), line width (using <methodname>set_line_width()</methodname>), line dash pattern (using <methodname>set_dash()</methodname>), line cap style (using <methodname>set_line_cap()</methodname>), and line join style (using <methodname>set_line_join()</methodname>), and font styles (using <methodname>set_font_size()</methodname>, <methodname>set_font_face()</methodname> and others). There are many other settings as well, such as transformation matrices, fill rules, whether to perform antialiasing, and others. For further information, see the <ulink url=\"http://www.cairographics.org/cairomm/\">cairomm</ulink> API documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4109(para)
msgid "It is good practice to put all modifications to the graphics state between <methodname>save()</methodname>/<methodname>restore()</methodname> function calls. For example, if you have a function that takes a <classname>Cairo::Context</classname> reference as an argument, you might implement it as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4115(programlisting)
#, no-wrap
msgid ""
"void doSomething(Cairo::RefPtr&lt;Cairo::Context&gt; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // change graphics state\n"
"    // peform drawing operations\n"
"    context-&gt;restore();\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4092(para)
msgid "The current state of a <classname>Cairo::Context</classname> can be saved to an internal stack of saved states and later be restored to the state it was in when you saved it. To do this, use the <methodname>save()</methodname> method and the <methodname>restore()</methodname> method. This can be useful if you need to temporarily change the line width and color (or any other graphics setting) in order to draw something and then return to the previous settings. In this situation, you could call <methodname>Cairo::Context::save()</methodname>, change the graphics settings, draw the lines, and then call <methodname>Cairo::Context::restore()</methodname> to restore the original graphics state. Multiple calls to <methodname>save()</methodname> and <methodname>restore()</methodname> can be nested; each call to <methodname>restore()</methodname> restores the state from the matching paired <methodname>save()</methodname>. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4126(title)
#, fuzzy
msgid "Drawing Straight Lines"
msgstr "Primerjaj celotne vrstice"

#: C/gtkmm-tutorial-in.xml:4135(para)
msgid "Since the Cairo graphics library was written with support for multiple output targets (the X window system, PNG images, OpenGL, etc), there is a distinction between user-space and device-space coordinates. The mapping between these two coordinate systems defaults to one-to-one so that integer values map roughly to pixels on the screen, but this setting can be adjusted if desired. Sometimes it may be useful to scale the coordinates so that the full width and height of a window both range from 0 to 1 (the 'unit square') or some other mapping that works for your application. this can be done with the <methodname>Cairo::Context::scale()</methodname> function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4127(para)
msgid "Now that we understand the basics of the Cairo graphics library, we're almost ready to start drawing. We'll start with the simplest of drawing elements: the straight line. But first you need to know a little bit about Cairo's coordinate system. The origin of the Cairo coordinate system is located in the upper-left corner of the window with positive x values to the right and positive y values going down. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4150(para)
msgid "In this example, we'll construct a small but fully functional <application>gtkmm</application> program and draw some lines into the window. The lines are drawn by creating a path and then stroking it. A path is created using the functions <methodname>Cairo::Context::move_to()</methodname> and <methodname>Cairo::Context::line_to()</methodname>. The function <methodname>move_to()</methodname> is similar to the act of lifting your pen off of the paper and placing it somewhere else -- no line is drawn between the point you were at and the point you moved to. To draw a line between two points, use the <methodname>line_to()</methodname> function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4162(para)
msgid "After you've finished creating your path, you still haven't drawn anything visible yet. To make the path visible, you must use the function <methodname>stroke()</methodname> which will stroke the current path with the line width and style specified in your <classname>Cairo::Context</classname> object. After stroking, the current path will be cleared so that you can start on your next path."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4171(para)
msgid "Many Cairo drawing functions have a <methodname>_preserve()</methodname> variant. Normally drawing functions such as <methodname>clip()</methodname>, <methodname>fill()</methodname>, or <methodname>stroke()</methodname> will clear the current path. If you use the <methodname>_preserve()</methodname> variant, the current path will be retained so that you can use the same path with the next drawing function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4181(title)
#: C/gtkmm-tutorial-in.xml:4278(title)
#, fuzzy
msgid "Drawing Area - Lines"
msgstr "Primerjaj celotne vrstice"

#: C/gtkmm-tutorial-in.xml:4189(para)
msgid "This program contains a single class, <classname>MyArea</classname>, which is a subclass of <classname>Gtk::DrawingArea</classname> and contains an <methodname>on_expose_event()</methodname> member function. This method is called whenever the image in the drawing area needs to be redrawn. This function is passed a pointer to a <classname>GdkEventExpose</classname> structure which defines the area that needs to be redrawn. We use these values to create a rectangle path in Cairo (using the <methodname>rectangle()</methodname> function) and then <methodname>clip()</methodname> to this path. The <methodname>clip()</methodname> function sets a clip region. The current clip region affects all drawing operations by effectively masking out any changes to the surface that are outside the current clip region. This allows us to limit our redrawing to only the area that needs to be redrawn. The actual drawing code sets the color we want to use for drawing by using <methodname>set_source_rgb()</methodname> which takes arguments defining the Red, Green, and Blue components of the desired color (valid values are between 0 and 1). After setting the color, we created a new path using the functions <methodname>move_to()</methodname> and <methodname>line_to()</methodname>, and then stroked this path with <methodname>stroke()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4213(title)
msgid "Drawing with relative coordinates"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4214(para)
msgid "In the example above we drew everything using absolute coordinates. You can also draw using relative coordinates. For a straight line, this is done with the function <methodname>Cairo::Context::rel_line_to()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4220(title)
#, fuzzy
msgid "Line styles"
msgstr "_Slog mesta:"

#: C/gtkmm-tutorial-in.xml:4221(para)
msgid "In addition to drawing basic straight lines, there are a number of things that you can customize about a line. You've already seen examples of setting a line's color and width, but there are others as well."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4227(para)
msgid "If you've drawn a series of lines that form a path, you may want them to join together in a certain way. Cairo offers three different ways to join lines together: Miter, Bevel, and Round. These are show below:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4234(title)
#, fuzzy
msgid "Different join types in Cairo"
msgstr "Prijavljenih je preveč različnih uporabnikov"

#: C/gtkmm-tutorial-in.xml:4239(para)
msgid "The line join style is set using the function <methodname>Cairo::Context::set_line_join()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4243(para)
msgid "Line ends can have different styles as well. The default style is for the line to start and stop exactly at the destination points of the line. This is called a Butt cap. The other options are Round (uses a round ending, with the center of the circle at the end point) or Square (uses a squared ending, with the center of the square at the end point). This setting is set using the function <methodname>Cairo::Context::set_line_cap()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4253(para)
msgid "There are other things you can customize as well, including creating dashed lines and other things. For more information , see the Cairo API documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4261(title)
#, fuzzy
msgid "Drawing Curved Lines"
msgstr "Primerjaj celotne vrstice"

#: C/gtkmm-tutorial-in.xml:4262(para)
msgid "In addition to drawing straight lines Cairo allows you to easily draw curved lines (technically a cubic Bézier spline) using the <methodname>Cairo::Context::curve_to()</methodname> and <methodname>Cairo::Context::rel_curve_to()</methodname> functions. These functions take coordinates for a destination point as well as coordinates for two 'control' points. This is best explained using an example, so let's dive in."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4273(para)
msgid "This simple application draws a curve with Cairo and displays the control points for each end of the curve."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4285(para)
msgid "The only difference between this example and the straight line example is in the <methodname>on_expose_event()</methodname> function, but there are a few new concepts and functions introduced here, so let's examine them briefly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4291(para)
msgid "Note that we clip to the area that needs re-exposing just as we did in the last example. After clipping, however, we make a call to <methodname>Cairo::Context::scale()</methodname>, passing in the width and height of the drawing area. This scales the user-space coordinate system such that the the width and height of the widget are both equal to 1.0 'units'. There's no particular reason to scale the coordinate system in this case, but sometimes it can make drawing operations easier."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4301(para)
msgid "The call to <methodname>Cairo::Context::curve_to()</methodname> should be fairly self-explanatory. The first pair of coordinates define the control point for the beginning of the curve. The second set of coordinates define the control point for the end of the curve, and the last set of coordinates define the destination point. To make the concept of control points a bit easier to visualize, a line has been draw from each control point to the end-point on the curve that it is associated with. Note that these control point lines are both translucent. This is achieved with a variant of <methodname>set_source_rgb()</methodname> called <methodname>set_source_rgba()</methodname>. This function takes a fourth argument specifying the alpha value of the color (valid values are between 0 and 1)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4319(title)
msgid "Drawing Arcs and Circles"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4320(para)
msgid "With Cairo, the same function is used to draw arcs, circles, or ellipses: <methodname>Cairo::Context::arc()</methodname>. This function takes five arguments. The first two are the coordinates of the center point of the arc, the third argument is the radius of the arc, and the final two arguments define the start and end angle of the arc. All angles are defined in radians, so drawing a circle is the same as drawing an arc from 0 to 2 * M_PI radians. An angle of 0 is in the direction of the positive X axis (in user-space). An angle of M_PI/2 radians (90 degrees) is in the direction of the positive Y axis (in user-space). Angles increase in the direction from the positive X axis toward the positive Y axis. So with the default transformation matrix, angles increase in a clockwise direction."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4341(programlisting)
#, no-wrap
msgid ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4334(para)
msgid "To draw an ellipse, you can scale the current transformation matrix by different amounts in the X and Y directions. For example, to draw an ellipse in the box given by <varname>x</varname>, <varname>y</varname>, <varname>width</varname>, <varname>height</varname>: <placeholder-1/> Note that this contradicts the <ulink url=\"http://www.cairographics.org/manual/cairo-Paths.html#cairo-arc\">advice given in the official Cairo documentation</ulink>, but it seems to work."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4353(para)
msgid "Here's an example of a simple program that draws an arc, a circle and an ellipse into a drawing area."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4358(title)
#, fuzzy
msgid "Drawing Area - Arcs"
msgstr "Območje urejanje vnosa"

#: C/gtkmm-tutorial-in.xml:4367(para)
msgid "There are a couple of things to note about this example code. Again, the only real difference between this example and the previous ones is the <methodname>on_expose_event()</methodname> function, so we'll limit our focus to that function. In addition, the first part of the function is nearly identical to the previous examples, so we'll skip that portion."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4375(para)
msgid "Note that in this case, we've expressed nearly everything in terms of the height and width of the window, including the width of the lines. Because of this, when you resize the window, everything scales with the window. Also note that there are three drawing sections in the function and each is wrapped with a <methodname>save()</methodname>/<methodname>restore()</methodname> pair so that we're back at a known state after each drawing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4384(para)
msgid "The section for drawing an arc introduces one new function, <methodname>close_path()</methodname>. This function will in effect draw a straight line from the current point back to the first point in the path. There is a significant difference between calling <methodname>close_path()</methodname> and manually drawing a line back to the starting point, however. If you use <methodname>close_path()</methodname>, the lines will be nicely joined together. If you use <methodname>line_to()</methodname> instead, the lines will end at the same point, but Cairo won't do any special joining."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4397(title)
#, fuzzy
msgid "Drawing counter-clockwise"
msgstr "Zavrti levo"

#: C/gtkmm-tutorial-in.xml:4398(para)
msgid "The function <methodname>Cairo::Context::arc_negative()</methodname> is exactly the same as <methodname>Cairo::Context::arc()</methodname> but the angles go the opposite direction."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4410(title)
#, fuzzy
msgid "Drawing Text"
msgstr "Besedilne datoteke"

#: C/gtkmm-tutorial-in.xml:4412(title)
#, fuzzy
msgid "Drawing Text with Pango"
msgstr "Prevajanje besedila z Google prevajalnikom"

#: C/gtkmm-tutorial-in.xml:4413(para)
msgid "Text is drawn via Pango Layouts. The easiest way to create a <classname>Pango::Layout</classname> is to use <methodname>create_pango_layout</methodname>. Once created, the layout can be manipulated in various ways, including changing the text, font, etc. Finally, the layout can be rendered using the <methodname>draw_layout</methodname> method of <classname>Gdk::Drawable</classname>, which takes a <classname>Gdk::GC</classname> object, an x-position, a y-position and the layout itself."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4435(title)
#, fuzzy
msgid "Drawing Images"
msgstr "Filmi"

#: C/gtkmm-tutorial-in.xml:4437(title)
#, fuzzy
msgid "Drawing Images with Gdk"
msgstr "Odpri izbrane slike s programom"

#: C/gtkmm-tutorial-in.xml:4438(para)
msgid "There are a couple of drawing methods for putting image data into a drawing area. <methodname>draw_pixmap()</methodname> can copy the contents of a <classname>Gdk::Drawable</classname> (the window of a drawing area is one) into the drawing area. There is also <methodname>draw_bitmap()</methodname> for drawing a two-color image into the drawing area, and <methodname>draw_image()</methodname> for drawing an image with more than two colors."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4447(para)
msgid "For all of these methods, the first argument is the <classname>Gdk::GC</classname>. The second argument is the object of the appropriate type to copy in: <classname>Gdk::Drawable</classname>, <classname>Gdk::Bitmap</classname>, <classname>Gdk::Image</classname>. The next two arguments are the x and y points in the image to begin copying from. Then come the x and y points in the drawing area to copy to. The final two arguments are the width and height of the area to copy."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4458(para)
msgid "There is also a method for drawing from a <classname>Gdk::Pixbuf</classname>. A <classname>Gdk::Pixbuf</classname> buffer is a useful wrapper around a collection of pixels, which can be read from files, and manipulated in various ways."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4465(para)
msgid "Probably the most common way of creating <classname>Gdk::Pixbuf</classname>s is to use <methodname>Gdk::Pixbuf::create_from_file()</methodname>, which can read an image file, such as a png file into a pixbuf ready for rendering."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4472(para)
msgid "The <classname>Gdk::Pixbuf</classname> can be rendered with <methodname>render_to_drawable</methodname>, which takes quite a few parameters. The <methodname>render_to_drawable</methodname> is a member of <classname>Gdk::Pixbuf</classname> rather than <classname>Gdk::Drawable</classname>, which is unlike the <methodname>draw_*</methodname> functions described earlier. As such, its first parameter is the drawable to render to. The second parameter is still the <classname>Gdk::GC</classname>. The next two parameters are the point in the pixbuf to start drawing from. This is followed by the point in the drawable to draw it at, and by the width and height to actually draw (which may not be the whole image, especially if you're only responding to an expose event for part of the window). Finally, there are the dithering parameters. If you use Gdk::RGB_DITHER_NONE as the dither type, then the dither offset parameters can both be 0."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4489(para)
msgid "Here is a small bit of code to tie it all together: (Note that usually you wouldn't load the image every time in the expose event handler! It's just shown here to keep it all together)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4494(programlisting)
#, no-wrap
msgid ""
"bool myarea::on_expose_event(GdkEventExpose* ev)\n"
"{\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"image-&gt;render_to_drawable(get_window(), get_style()-&gt;get_black_gc(),\n"
"0, 0, 100, 80, image-&gt;get_width(), image-&gt;get_height(), // draw the whole image (from 0,0 to the full width,height) at 100,80 in the window\n"
"Gdk::RGB_DITHER_NONE, 0, 0);\n"
"return true;\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4521(title)
msgid "Example Application: Creating a Clock with Cairo"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4522(para)
msgid "Now that we've covered the basics of drawing with Cairo, let's try to put it all together and create a simple application that actually does something. The following example uses Cairo to create a custom <classname>Clock</classname> widget. The clock has a second hand, a minute hand, and an hour hand, and updates itself every second."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4534(para)
msgid "As before, almost all of the interesting stuff is done in the expose event handler <methodname>on_expose_event()</methodname>. Before we dig into the expose event handler, notice that the constructor for the <classname>Clock</classname> widget connects a handler function <methodname>onSecondElapsed()</methodname> to a timer with a timeout period of 1000 milliseconds (1 second). This means that <methodname>onSecondElapsed()</methodname> will get called once per second. The sole responsibility of this function is to invalidate the window so that <application>gtkmm</application> will be forced to redraw it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4545(para)
msgid "Now let's take a look at the code that performs the actual drawing. The first section of <methodname>on_expose_event()</methodname> should be pretty familiar by now as it's mostly 'boilerplate' code for getting the <classname>Gdk::Window</classname>, creating a <classname>Cairo::Context</classname>, and clipping to the area that we want to re-draw. This example again scales the coordinate system to be a unit square so that it's easier to draw the clock as a percentage of window size so that it will automatically scale when the window size is adjusted. Furthermore, the coordinate system is scaled over and down so that the (0, 0) coordinate is in the very center of the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4558(para)
msgid "The function <methodname>Cairo::Context::paint()</methodname> is used here to set the background color of the window. This function takes no arguments and fills the current surface (or the clipped portion of the surface) with the source color currently active. After setting the background color of the window, we draw a circle for the clock outline, fill it with white, and then stroke the outline in black. Notice that both of these actions use the <methodname>_preserve</methodname> variant to preserve the current path, and then this same path is clipped to make sure than our next lines don't go outside the outline of the clock."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4570(para)
msgid "After drawing the outline, we go around the clock and draw ticks for every hour, with a larger tick at 12, 3, 6, and 9. Now we're finally ready to implement the time-keeping functionality of the clock, which simply involves getting the current values for hours, minutes and seconds, and drawing the hands at the correct angles."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4582(para)
msgid "<classname>Gtk::Widget</classname> has several methods and signals which are prefixed with \"drag_\". These are used for Drag and Drop."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4587(title)
#, fuzzy
msgid "Sources and Destinations"
msgstr "Opozorila in napake"

#: C/gtkmm-tutorial-in.xml:4588(para)
msgid "Things are dragged from <literal>sources</literal> to be dropped on <literal>destinations</literal>. Each source and destination has infomation about the data formats that it can send or receive, provided by <classname>Gtk::TargetEntry</classname> items. A drop destination will only accept a dragged item if they both share a compatible <classname>Gtk::TargetEntry</classname> item. Appropriate signals will then be emitted, telling the signal handlers which <classname>Gtk::TargetEntry</classname> was used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4601(para)
msgid "target: A name, such as \"STRING\""
msgstr ""

#: C/gtkmm-tutorial-in.xml:4602(para)
msgid "info: An identifier which will be sent to your signals to tell you which TargetEntry was used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4603(para)
msgid "flags: Used only for drag and drop, this specifies whether the data may be dragged to other widgets and applications, or only to the same ones."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4598(para)
msgid "<classname>Gtk::TargetEntry</classname> objects contain this information: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4611(para)
msgid "<classname>Widgets</classname> can be identified as sources or destinations using these <classname>Gtk::Widget</classname> methods:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4615(programlisting)
#, no-wrap
msgid ""
"void drag_source_set(const ArrayHandle_TargetEntry&amp; targets,\n"
"      GdkModifierType start_button_mask, GdkDragAction actions);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4620(para)
msgid "<literal>targets</literal> is a container of <classname>Gtk::TargetEntry</classname> (<classname>std::list&lt;Gtk::TargetEntry&gt;</classname> or <classname>std::vector&lt;Gtk::TargetEntry&gt;</classname>, for instance) elements."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4629(para)
msgid "<literal>start_button_mask</literal> is an ORed combination of values, which specify which modifier key or mouse button must be pressed to start the drag."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4636(para)
msgid "<literal>actions</literal> is an ORed combination of values, which specified which Drag and Drop operations will be possible from this source - for instance, copy, move, or link. The user can choose between the actions by using modifier keys, such as <keycap>Shift</keycap> to change from <literal>copy</literal> to <literal>move</literal>, and this will be shown by a different cursor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4647(programlisting)
#, no-wrap
msgid ""
"void drag_dest_set(const ArrayHandle_TargetEntry&amp; targets,\n"
"    GtkDestDefaults flags, GdkDragAction actions);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4652(para)
msgid "<literal>flags</literal> is an ORed combination of values which indicates how the widget will respond visually to Drag and Drop items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4658(para)
msgid "<literal>actions</literal> indicates the Drag and Drop actions which this destination can receive - see the description above."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4668(para)
msgid "When a drop destination has accepted a dragged item, certain signals will be emitted, depending on what action has been selected. For instance, the user might have held down the <keycap>Shift</keycap> key to specify a <literal>move</literal> rather than a <literal>copy</literal>. Remember that the user can only select the actions which you have specified in your calls to <methodname>drag_dest_set()</methodname> and <methodname>drag_source_set()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4679(title)
#: C/gtkmm-tutorial-in.xml:4802(title)
#, fuzzy
msgid "Copy"
msgstr "Kopiraj"

#: C/gtkmm-tutorial-in.xml:4683(para)
msgid "<literal>drag_begin</literal>: Provides DragContext."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4684(para)
msgid "<literal>drag_motion</literal>: Provides DragContext and coordinates. You can call the drag_status() method of the DragContext to indicate which target will be accepted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4685(para)
msgid "<literal>drag_get</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>GtkSelectionData</literal> structure, in which you should put the requested data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4686(para)
msgid "<literal>drag_drop</literal>: Provides DragContext and coordinates."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4687(para)
msgid "<literal>drag_end</literal>: Provides DragContext."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4680(para)
msgid "The source widget will emit these signals, in this order: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4694(para)
msgid "<literal>drag_data_received</literal>: Provides <literal>info</literal> about the dragged data format, and a <literal>GtkSelectionData</literal> structure which contains the dropped data. You should call the <methodname>drag_finish()</methodname> method of the <literal>DragContext</literal> to indicate whether the operation was successful."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4690(para)
msgid "The destination widget will emit this signal, after the source destination has emitted the <literal>drag_get</literal> signal: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4709(title)
#, fuzzy
msgid "Move"
msgstr "Premakni"

#: C/gtkmm-tutorial-in.xml:4712(para)
msgid "<literal>drag_delete</literal>: Gives the source the opportunity to delete the original data if that's appropriate."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4710(para)
msgid "During a <literal>move</literal>, the source widget will also emit this signal: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4726(title)
msgid "DragContext"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4727(para)
msgid "The drag and drop signals provide a DragContext, which contains some information about the drag and drop operation and can be used to influence the process. For instance, you can discover the source widget, or change the drag and drop icon, by using the <methodname>set_icon()</methodname> methods. More importantly, you should call the <methodname>drag_finish()</methodname> method from your <literal>drag_data_received</literal> signal handler to indicate whether the drop was successful."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4740(para)
msgid "Here is a very simple example, demonstrating a drag and drop <literal>Copy</literal> operation:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4751(para)
msgid "There is a more complex example in examples/dnd."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4760(title)
#, fuzzy
msgid "The Clipboard"
msgstr "Odložišče"

#: C/gtkmm-tutorial-in.xml:4761(para)
msgid "Simple text copy-paste functionality is provided for free by widgets such as Gtk::Entry and Gtk::TextView, but you might need special code to deal with your own data formats. For instance, a drawing program would need special code to allow copy and paste within a view, or between documents."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4763(para)
msgid "<classname>Gtk::Clipboard</classname> is a singleton. You can get the one and only instance with <methodname>Gtk::Clipboard::get()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4768(para)
msgid "So your application doesn't need to wait for clipboard operations, particularly between the time when the user chooses Copy and then later chooses Paste, most <classname>Gtk::Clipboard</classname> methods take <classname>sigc::slot</classname>s which specify callback methods. When <classname>Gtk::Clipboard</classname> is ready, it will call these methods, either providing the requested data, or asking for data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4780(title)
#, fuzzy
msgid "Targets"
msgstr "cilji"

#: C/gtkmm-tutorial-in.xml:4781(para)
msgid "Different applications contain different types of data, and they might make that data available in a variety of formats. <application>gtkmm</application> calls these data types <literal>target</literal>s."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4785(para)
msgid "For instance, gedit can supply and receive the <literal>\"UTF8_STRING\"</literal> target, so you can paste data into gedit from any application that supplies that target. Or two different image editing applications might supply and receive a variety of image formats as targets. As long as one application can receive one of the targets that the other supplies then you will be able to copy data from one to the other."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4789(para)
msgid "A target can be in a variety of binary formats. This chapter, and the examples, assume that the data is 8-bit text. This would allow us to use an XML format for the clipboard data. However this would probably not be appropriate for binary data such as images. <classname>Gtk::Clipboard</classname> provides overloads that allow you to specify the format in more detail if necessary."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4798(para)
msgid "The <link linkend=\"chapter-draganddrop\">Drag and Drop</link> API uses the same mechanism. You should probably use the same data targets and formats for both Clipboard and Drag and Drap operations."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4803(para)
msgid "When the user asks to copy some data, you should tell the <classname>Clipboard</classname> what targets are available, and provide the callback methods that it can use to get the data. At this point you should store a copy of the data, to be provided when the clipboard calls your callback method in repsonse to a paste."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4812(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();\n"
"\n"
"//Targets:\n"
"std::list&lt;Gtk::TargetEntry&gt; listTargets;\n"
"listTargets.push_back( Gtk::TargetEntry(\"example_custom_target\") );\n"
"listTargets.push_back( Gtk::TargetEntry(\"UTF8_STRING\") );\n"
"\n"
"refClipboard-&gt;set( listTargets,\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4823(para)
msgid "Your callback will then provide the store data when the user chooses to paste the data. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4825(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_get(\n"
"    Gtk::SelectionData&amp; selection_data, guint info)\n"
"{\n"
"  const Glib::ustring target = selection_data.get_target();\n"
"\n"
"  if(target == \"example_custom_target\")\n"
"    selection_data.set(\"example_custom_target\", m_ClipboardStore);\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4833(para)
msgid "The <literal>ideal</literal> example below can supply more than one clipboard target."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4837(para)
msgid "The clear callback allows you to free the memory used by your stored data when the clipboard replaces its data with something else."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4843(title)
#, fuzzy
msgid "Paste"
msgstr "Prilepi"

#: C/gtkmm-tutorial-in.xml:4844(para)
msgid "When the user asks to paste data from the <classname>Clipboard</classname>, you should request a specific format and provide a callback method which will be called with the actual data. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4849(programlisting)
#, no-wrap
msgid ""
"refClipboard-&gt;request_contents(\"example_custom_target\",\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4852(para)
msgid "Here is an example callback method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4854(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_received(\n"
"    const Gtk::SelectionData&amp; selection_data)\n"
"{\n"
"  Glib::ustring clipboard_data = selection_data.get_data_as_string();\n"
"  //Do something with the pasted data.\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4862(title)
#, fuzzy
msgid "Discovering the available targets"
msgstr "SELECT poizvedba: cilji"

#: C/gtkmm-tutorial-in.xml:4863(para)
msgid "To find out what targets are currently available on the <classname>Clipboard</classname> for pasting, call the <methodname>request_targets()</methodname> method, specifying a method to be called with the information. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4869(programlisting)
#, no-wrap
msgid ""
"refClipboard-&gt;request_targets( sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_clipboard_received_targets) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4872(para)
msgid "In your callback, compare the list of available targets with those that your application supports for pasting. You could enable or disable a Paste menu item, depending on whether pasting is currently possible. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4875(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_received_targets(\n"
"  const Glib::StringArrayHandle&amp; targets_array)\n"
"{\n"
"  // Get the list of available clipboard targets:\n"
"  std::list&lt;std::string&gt; targets = targets_array;\n"
"\n"
"  const bool bPasteIsPossible =\n"
"    std::find(targets.begin(), targets.end(),\n"
"      example_target_custom) != targets.end();\n"
"\n"
"  // Enable/Disable the Paste button appropriately:\n"
"  m_Button_Paste.set_sensitive(bPasteIsPossible);\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4894(title)
#: C/gtkmm-tutorial-in.xml:5291(title)
#, fuzzy
msgid "Simple"
msgstr "Enostavno"

#: C/gtkmm-tutorial-in.xml:4895(para)
msgid "This example allows copy and pasting of application-specific data, using the standard text target. Although this is simple, it's not ideal because it does not identify the <classname>Clipboard</classname> data as being of a particular type."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4903(title)
#, fuzzy
msgid "Clipboard - Simple"
msgstr "Enostavno iskanje"

#: C/gtkmm-tutorial-in.xml:4913(title)
msgid "Ideal"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4916(simpara)
msgid "Defines a custom clipboard target, though the format of that target is still text."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4917(simpara)
msgid "It supports pasting of 2 targets - both the custom one and a text one that creates an arbitrary text representation of the custom data."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4918(simpara)
msgid "It uses <methodname>request_targets()</methodname> and disables the Paste button if it can't use anything on the clipboard"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4914(para)
msgid "This is like the simple example, but it <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4923(title)
#, fuzzy
msgid "Clipboard - Ideal"
msgstr "Prilepi iz odložišča"

#: C/gtkmm-tutorial-in.xml:4939(title)
#, fuzzy
msgid "Printing"
msgstr "Tiskanje"

#: C/gtkmm-tutorial-in.xml:4942(para)
msgid "Printing support is available in <application>gtkmm</application> version 2.10 and later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4945(para)
msgid "At the application development level, <application>gtkmm</application>'s printing API provides dialogs that are consistent across applications and allows us of Cairo's common drawing API, with Pango-driven text rendering. In the implementation of this common API, platform-specific backends and printer-specific drivers are used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4951(title)
msgid "PrintOperation"
msgstr ""

#: C/gtkmm-tutorial-in.xml:4953(para)
msgid "The primary object is <classname>Gtk::PrintOperation</classname>, allocated for each print operation. To handle page drawing connect to its signals, or inherit from it and override the default virtual signal handlers. <classname>PrintOperation</classname> automatically handles all the settings affecting the print loop."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4970(para)
msgid "<literal>begin_print</literal>: You must handle this signal, because this is where you create and set up a <classname>Pango::Layout</classname> using the provided <classname>Gtk::PrintContext</classname>, and break up your printing output into pages."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4980(para)
msgid "<literal>paginate</literal>: Pagination is potentially slow so if you need to monitor it you can call the <methodname>PrintOperation::set_show_progress()</methodname> method and handle this signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4994(para)
msgid "<literal>request_page_setup</literal>: Provides a <classname>PrintContext</classname>, page number and <classname>Gtk::PageSetup</classname>. Handle this signal if you need to modify page setup on a per-page basis."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5003(para)
msgid "<literal>draw_page</literal>: You must handle this signal, which provides a <classname>PrintContext</classname> and a page number. The <classname>PrintContext</classname> should be used to create a <classname>Cairo::Context</classname> into which the provided page should be drawn. To render text, iterate over the <classname>Pango::Layout</classname> you created in the <literal>begin_print</literal> handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4989(para)
msgid "For each page that needs to be rendered, the following signals are emitted: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5018(para)
msgid "<literal>end_print</literal>: A handler for it is a safe place to free any resources related to a <classname>PrintOperation</classname>. If you have your custom class that inherits from <classname>PrintOperation</classname>, it is naturally simpler to do it in the destructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5028(para)
msgid "<literal>done</literal>: This signal is emitted when printing is finished, meaning when the print data is spooled. Note that the provided <literal>Gtk::PrintOperationResult</literal> may indicate that an error occurred. In any case you probably want to notify the user about the final status."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5038(para)
msgid "<literal>status_changed</literal>: Emitted whenever a print job's status changes, until it is finished. Call the <methodname>PrintOperation::set_track_print_status()</methodname> method to monitor the job status after spooling. To see the status, use <methodname>get_status()</methodname> or <methodname>get_status_string()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:4964(para)
msgid "The <methodname>PrintOperation::run()</methodname> method starts the print loop, during which various signals are emitted: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5060(title)
#, fuzzy
msgid "Page setup"
msgstr "Nastavitev strani"

#: C/gtkmm-tutorial-in.xml:5062(para)
msgid "The <classname>PrintOperation</classname> class has a method called <methodname>set_default_page_setup()</methodname> which selects the default paper size, orientation and margins. To show a page setup dialog from your application, use the <methodname>Gtk::run_page_setup_dialog()</methodname> method, which returns a <classname>Gtk::PageSetup</classname> object with the chosen settings. Use this object to update a <classname>PrintOperation</classname> and to access the selected <classname>Gtk::PaperSize</classname>, <literal>Gtk::PageOrientation</literal> and printer-specific margins."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5072(para)
msgid "You should save the chosen <classname>Gtk::PageSetup</classname> so you can use it again if the page setup dialog is shown again."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5076(programlisting)
#, no-wrap
msgid ""
"\n"
"//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...\n"
"Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5075(para)
#: C/gtkmm-tutorial-in.xml:5140(para)
#: C/gtkmm-tutorial-in.xml:8920(para)
#, fuzzy
msgid "For instance, <placeholder-1/>"
msgstr "Poišče naslednji zadetek niza."

#: C/gtkmm-tutorial-in.xml:5087(para)
msgid "The Cairo coordinate system, in the <literal>draw_page</literal> handler, is automatically rotated to the current page orientation. It is normally within the printer margins, but you can change that via the <methodname>PrintOperation::set_use_full_page()</methodname> method. The default measurement unit is device pixels. To select other units, use the <methodname>PrintOperation::set_unit()</methodname> method."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5099(title)
#, fuzzy
msgid "Rendering text"
msgstr "Enota izrisovanja besedila"

#: C/gtkmm-tutorial-in.xml:5101(para)
msgid "Text rendering is done using Pango. The <classname>Pango::Layout</classname> object for printing should be created by calling the <methodname>PrintContext::create_pango_layout()</methodname> method. The <classname>PrintContext</classname> object also provides the page metrics, via <methodname>get_width()</methodname> and <methodname>get_height()</methodname>. The number of pages can be set with <methodname>PrintOperation::set_n_pages()</methodname>. To actually render the Pango text in <literal>on_draw_page</literal>, get a <classname>Cairo::Context</classname> with <methodname>PrintContext::get_cairo_context()</methodname> and show the <classname>Pango::LayoutLine</classname>s that appear within the requested page number."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5116(para)
msgid "See <link linkend=\"sec-printing-example-simple\">an example</link> of exactly how this can be done."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5124(title)
#, fuzzy
msgid "Asynchronous operations"
msgstr "CVS opravila"

#: C/gtkmm-tutorial-in.xml:5126(para)
msgid "By default, <methodname>PrintOperation::run()</methodname> returns when a print operation is completed. If you need to run a non-blocking print operation, call <methodname>PrintOperation::set_allow_async()</methodname>. Note that <methodname>set_allow_async()</methodname> is not supported on all platforms, however the <literal>done</literal> signal will still be emitted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5133(para)
msgid "<methodname>run()</methodname> may return <literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>. To track status and handle the result or error you need to implement signal handlers for the <literal>done</literal> and <literal>status_changed</literal> signals:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5141(programlisting)
#, no-wrap
msgid ""
"\n"
"// in class ExampleWindow's method...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// run the op\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5151(programlisting)
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    //notify user\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    //Update PrintSettings with the ones used in this PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5150(para)
msgid "Second, check for an error and connect to the <literal>status_changed</literal> signal. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5166(programlisting)
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    //the print job is finished\n"
"  else\n"
"    //get the status with get_status() or get_status_string()\n"
"\n"
"  //update UI\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5165(para)
msgid "Finally, check the status. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5182(title)
#, fuzzy
msgid "Export to PDF"
msgstr "Izvozi v Facebook"

#: C/gtkmm-tutorial-in.xml:5186(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::PrintOperation&gt; op = Gtk::PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"Gtk::PrintOperationResult res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5183(para)
msgid "The 'Print to file' option is available in the print dialog, without the need for extra implementation. However, it is sometimes useful to generate a pdf file directly from code. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5198(title)
#, fuzzy
msgid "Extending the print dialog"
msgstr "Dialog tiskanja Gnome"

#: C/gtkmm-tutorial-in.xml:5205(para)
msgid "Set the title of the tab via <methodname>PrintOperation::set_custom_tab_label()</methodname>, create a new widget and return it from the <literal>create_custom_widget</literal> signal handler. You'll probably want this to be a container widget, packed with some others."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5215(para)
msgid "Get the data from the widgets in the <literal>custom_widget_apply</literal> signal handler."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5200(para)
msgid "You may add a custom tab to the print dialog: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5230(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  Gtk::HBox* hbox = new Gtk::HBox(false, 8);\n"
"  hbox-&gt;set_border_width(6);\n"
"\n"
"  Gtk::Label* label = Gtk::manage(new Gtk::Label(\"Enter some text: \"));\n"
"  hbox-&gt;pack_start(*label, false, false);\n"
"  label-&gt;show();\n"
"\n"
"  hbox-&gt;pack_start(m_Entry, false, false);\n"
"  m_Entry.show();\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  Glib::ustring user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5223(para)
msgid "Although the <literal>custom_widget_apply</literal> signal provides the widget you previously created, to simplify things you can keep the widgets you expect to contain some user input as class members. For example, let's say you have a <classname>Gtk::Entry</classname> called <literal>m_Entry</literal> as a member of your <classname>CustomPrintOperation</classname> class: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5257(para)
msgid "The example in examples/book/printing/advanced demonstrates this."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5264(title)
#, fuzzy
msgid "Preview"
msgstr "Predogled"

#: C/gtkmm-tutorial-in.xml:5270(programlisting)
#, no-wrap
msgid ""
"\n"
"// in a class that inherits from Gtk::Window...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5266(para)
msgid "The native GTK+ print dialog has a preview button, but you may also start a preview directly from an application: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5278(para)
msgid "On Unix, the default preview handler uses an external viewer program. On Windows, the native preview dialog will be shown. If necessary you may override this behaviour and provide a custom preview dialog. See the example located in /examples/book/printing/advanced."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5293(para)
msgid "The following example demonstrates how to print some input from a user interface. It shows how to implement <literal>on_begin_print</literal> and <literal>on_draw_page</literal>, as well as how to track print status and update the print settings."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5301(title)
#, fuzzy
msgid "Printing - Simple"
msgstr "Enostavno iskanje"

#: C/gtkmm-tutorial-in.xml:5316(title)
#, fuzzy
msgid "Recently Used Documents"
msgstr "Nedavno uporabljeni dokumenti"

#: C/gtkmm-tutorial-in.xml:5318(para)
#: C/gtkmm-tutorial-in.xml:5474(para)
msgid "Recent Files support is available in <application>gtkmm</application> version 2.10 and later"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5321(para)
msgid "<application>gtkmm</application> provides an easy way to manage recently used documents. The classes involved in implementing this functionality are <classname>RecentManager</classname>, <classname>RecentChooserDialog</classname>, <classname>RecentChooserMenu</classname>, <classname>RecentChooserWidget</classname>, and <classname>RecentFilter</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5330(para)
msgid "Each item in the list of recently used files is identified by its URI, and can have associated metadata. The metadata can be used to specify how the file should be displayed, a description of the file, its mime type, which application registered it, whether it's private to the registering application, and several other things."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5338(title)
msgid "RecentManager"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5339(para)
msgid "<classname>RecentManager</classname> acts as the central database of recently used files. You use this class to register new files, remove files from the list, or look up recently used files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5344(para)
msgid "You can create a new <classname>RecentManager</classname>, but you'll most likely just want to use the default one. You can get a reference to the default <classname>RecentManager</classname> with <methodname>get_default()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5351(title)
msgid "Adding Items to the List of Recent Files"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5352(para)
msgid "To add a new file to the list of recent documents, in the simplest case, you only need to provide the URI. For example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5356(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::RecentManager&gt; recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5358(para)
msgid "If you want to register a file with metadata, you can pass a <classname>RecentManager::Data</classname> parameter to <methodname>add_item()</methodname>. The metadata that can be set on a particular file item is as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5366(para)
msgid "<varname>app_exec</varname>: The command line to be used to launch this resource. This string may contain the \"f\" and \"u\" escape characters which will be expanded to the resource file path and URI respectively"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5372(para)
msgid "<varname>app_name</varname>: The name of the application that registered the resource"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5376(para)
msgid "<varname>description</varname>: A short description of the resource as a UTF-8 encoded string"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5380(para)
msgid "<varname>display_name</varname>: The name of the resource to be used for display as a UTF-8 encoded string"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5384(para)
msgid "<varname>groups</varname>: A list of groups associated with this item. Groups are essentially arbitrary strings associated with a particular resource. They can be thought of as 'categories' (such as \"email\", \"graphics\", etc) or tags for the resource."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5390(para)
msgid "<varname>is_private</varname>: Whether this resource should be visible only to applications that have registered it or not"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5394(para)
#, fuzzy
msgid "<varname>mime_type</varname>: The MIME type of the resource"
msgstr "%s zahteva nove mime vrste."

#: C/gtkmm-tutorial-in.xml:5397(para)
msgid "In addition to adding items to the list, you can also look up items from the list and modify or remove items."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5403(title)
msgid "Looking up Items in the List of Recent Files"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5404(para)
msgid "To look up recently used files, <classname>RecentManager</classname> provides several functions. To look up a specific item by its URI, you can use the <methodname>lookup_item()</methodname> function, which will return a <classname>RecentInfo</classname> class. If the specified URI did not exist in the list of recent files, the <classname>RecentInfo</classname> object will be invalid. <classname>RecentInfo</classname> provides an implementation for <methodname>operator bool()</methodname> which can be used to test for validity. For example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5415(programlisting)
#, no-wrap
msgid ""
"Gtk::RecentInfo info = recent_manager-&gt;lookup_item(uri);\n"
"if (info)\n"
"{\n"
"  // item was found\n"
"}"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5420(para)
msgid "A <classname>RecentInfo</classname> object is essentially an object containing all of the metadata about a single recently-used file. You can use this object to look up any of the properties listed above. FIXME - add cross-reference."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5426(para)
msgid "If you don't want to look for a specific URI, but instead want to get a list of all recently used items, <classname>RecentManager</classname> provides the <methodname>get_items()</methodname> function. The return value of this function can be assigned to any standard C++ container (e.g. <classname>std::vector</classname>, <classname>std::list</classname>, etc) and contains a list of all recently-used files up to a user-defined limit (FIXME: what's the default limit?). The following code demonstrates how you might get a list of recently-used files:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5437(programlisting)
#, no-wrap
msgid "std::vector&lt;Gtk::RecentInfo&gt; info_list = recent_manager-&gt;get_items();"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5438(para)
msgid "The limit on the number of items returned can be set by <methodname>set_limit()</methodname>, and queried with <methodname>get_limit()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5445(title)
#, fuzzy
msgid "Modifying the List of Recent Files"
msgstr "Nedavna največja starost datotek"

#: C/gtkmm-tutorial-in.xml:5446(para)
msgid "There may be times when you need to modify the list of recent files. For instance, if a file is moved or renamed, you may need to update the file's location in the recent files list so that it doesn't point to an incorrect location. You can update an item's location by using <methodname>move_item()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5453(para)
msgid "In addition to changing a file's URI, you can also remove items from the list, either one at a time or by clearint them all at once. The former is accomplished with <methodname>remove_item()</methodname>, the latter with <methodname>purge_items()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5460(para)
msgid "The functions <methodname>move_item()</methodname>, <methodname>remove_item()</methodname> and <methodname>purge_items()</methodname> have no effect on the actual files that are referred to by the URIs, they only modify the list of recent files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5472(title)
msgid "RecentChooser"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5477(para)
msgid "<classname>RecentChooser</classname> is an interface that can be implemented by widgets displaying the list of recently used files. <application>gtkmm</application> provides three built-in implementations for choosing recent files: <classname>RecentChooserWidget</classname>, <classname>RecentChooserDialog</classname>, and <classname>RecentChooserMenu</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5485(para)
msgid "<classname>RecentChooserWidget</classname> is a simple widget for displaying a list of recently used files. <classname>RecentChooserWidget</classname> is the basic building block for <classname>RecentChooserDialog</classname>, but you can embed it into your user interface if you want to."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5492(para)
msgid "The last class that implements the <classname>RecentChooser</classname> interface is <classname>RecentChooserMenu</classname>. This class allows you to list recently used files as a menu."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5498(title)
#, fuzzy
msgid "Simple RecentChooserWidget example"
msgstr "Primer XML Bakery."

#: C/gtkmm-tutorial-in.xml:5499(para)
msgid "Shown below is a simple example of how to use the <classname>RecentChooserDialog</classname> class in a program. This simple program has a menubar with a \"Recent Files Dialog\" menu item. When you select this menu item, a dialog pops up showing the list of recently used files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5507(para)
msgid "If this is the first time you're using a program that uses the Recent Files framework, the dialog may be empty at first. Otherwise it should show the list of recently used documents registered by other applications."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5514(para)
msgid "After selecting the <guimenuitem>Recent Files Dialog</guimenuitem> menu item, you should see something similar to the following window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5523(para)
msgid "The constructor for <classname>ExampleWindow</classname> creates the menu using <classname>UIManager</classname> (see <xref linkend=\"chapter-menus-and-toolbars\"/> for more information). It then adds the menu and the toolbar to the window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5531(title)
#, fuzzy
msgid "Filtering Recent Files"
msgstr "Odpri nedavne datoteke"

#: C/gtkmm-tutorial-in.xml:5532(para)
msgid "For any of the <classname>RecentChooser</classname> classes, if you don't wish to display all of the items in the list of recent files, you can filter the list to show only those that you want. You can filter the list with the help of the <classname>RecentFilter</classname> class. This class allows you to filter recent files by their name (<methodname>add_pattern()</methodname>), their mime type (<methodname>add_mime_type()</methodname>), the application that registered them (<methodname>add_application()</methodname>), or by a custom filter function (<methodname>add_custom()</methodname>). It also provides the ability to filter based on how long ago the file was modified and which groups it belongs to."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5545(para)
msgid "After you've created and set up the filter to match only the items you want, you can apply a filter to a chooser widget with the <methodname>RecentChooser::add_filter()</methodname> function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5555(title)
msgid "Plugs and Sockets"
msgstr "Vstavki in vtiči"

#: C/gtkmm-tutorial-in.xml:5557(title)
msgid "Overview"
msgstr "Pregled"

#: C/gtkmm-tutorial-in.xml:5558(para)
msgid "From time to time, it may be useful to be able to embed a widget from another application within your application. <application>gtkmm</application> allows you to do this with the <classname>Gtk::Socket</classname> and <classname>Gtk::Plug</classname> classes. It is not anticipated that very many applications will need this functionality, but in the rare case that you need to display a widget that is running in a completely different process, these classes can be very helpful."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5567(para)
msgid "The communication between a <classname>Socket</classname> and a <classname>Plug</classname> follows the XEmbed protocol. This protocol has also been implemented in other toolkits (e.g. Qt), which allows the same level of integration when embedding a Qt widget in GTK+ or vice versa."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5573(para)
msgid "The way that <classname>Sockets</classname> and <classname>Plugs</classname> work together is through their window ids. Both a <classname>Socket</classname> and a <classname>Plug</classname> have IDs that can be retrieved with their <methodname>get_id()</methodname> member functions. The use of these IDs will be explained below in <xref linkend=\"sec-connecting-plugs-sockets\"/>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5582(title)
msgid "Sockets"
msgstr "Vtiči"

#: C/gtkmm-tutorial-in.xml:5583(para)
msgid "A <classname>Socket</classname> is a special kind of container widget that provides the ability to embed widgets from one process into another process in a way that is transparent to the user."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5590(title)
msgid "Plugs"
msgstr "Vstavki"

#: C/gtkmm-tutorial-in.xml:5591(para)
msgid "A <classname>Plug</classname> is a special kind of Window that can be plugged into a <classname>Socket</classname>. Besides the normal properties and methods of <classname>Gtk::Window</classname>, a <classname>Plug</classname> provides a constructor that takes the ID of a <classname>Socket</classname>, which will automatically embed the <classname>Plug</classname> into the <classname>Socket</classname> that matches that ID."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5600(para)
msgid "Since a <classname>Plug</classname> is just a special type of <classname>Gtk::Window</classname> class, you can add containers or widgets to it like you would to any other window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5607(title)
msgid "Connecting Plugs and Sockets"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5608(para)
msgid "After a <classname>Socket</classname> or <classname>Plug</classname> object is realized, you can obtain its ID with its <methodname>get_id()</methodname> function. This ID can then be shared with other processes so that other processes know how to connect to eachother."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5619(para)
msgid "Create a <classname>Socket</classname> object in one process and pass the ID of that <classname>Socket</classname> to another process so that it can create a <classname>Plug</classname> object by specifying the given <classname>Socket</classname> ID in its constructor. There is no way to assign a <classname>Plug</classname> to a particular <classname>Socket</classname> after creation, so you must pass the <classname>Socket</classname> ID to the <classname>Plug</classname>'s constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5632(para)
msgid "Create a <classname>Plug</classname> independantly from any particular <classname>Socket</classname> and pass the ID of the <classname>Plug</classname> to other processes that need to use it. The ID of the <classname>Plug</classname> can be associated with a particular <classname>Socket</classname> object using the <methodname>Socket::add_id()</methodname> function. This is the approach used in the example below."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5615(para)
msgid "There are two basic strategies that can be used: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5647(title)
msgid "Plugs and Sockets Example"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5648(para)
msgid "The following is a simple example of using sockets and plugs. The method of communication between processes is deliberately kept very simple: The <classname>Plug</classname> writes its ID out to a text file named <filename>plug.id</filename> and the process with the socket reads the ID from this files. In a real program, you may want to use a more sophisticated method of inter-process communication."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5657(para)
msgid "This example creates two executable programs: <filename>socket</filename> and <filename>plug</filename>. The idea is that <filename>socket</filename> has an application window that will embed a widget from the <filename>plug</filename> program. The way this example is designed, <filename>plug</filename> must be running first before starting <filename>socket</filename>. To see the example in action, execute the following commands in order from within the example directory:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5666(para)
msgid "Start the <filename>plug</filename> program and send it to the background (or just use a different terminal)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5670(screen)
#, fuzzy, no-wrap
msgid "$ ./plug &amp;"
msgstr "Vstavki"

#: C/gtkmm-tutorial-in.xml:5671(para)
msgid "After which you should see something like the following:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5674(screen)
#, fuzzy, no-wrap
msgid "The window ID is: 69206019"
msgstr "Okno z opombo je mogoče urejati"

#: C/gtkmm-tutorial-in.xml:5675(para)
msgid "Then start the <filename>socket</filename> program:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5676(screen)
#, fuzzy, no-wrap
msgid "$ ./socket"
msgstr "Vnos vtiča"

#: C/gtkmm-tutorial-in.xml:5677(para)
msgid "After starting <filename>socket</filename>, you should see the following output in the terminal:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5681(screen)
#, no-wrap
msgid ""
"I've been embedded.\n"
"A plug was added"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5683(para)
msgid "The first line of output is from <filename>plug</filename>, after it has been notified that it has been embedded inside of a <classname>Socket</classname>. The second line was emitted by <filename>socket</filename> in response to its <methodname>plug_added</methodname> signal. If everything was done as described above, the <filename>socket</filename> window should look roughly like the following:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5695(para)
msgid "If for some reason the <classname>Socket</classname> couldn't attach the <classname>Plug</classname>, the window would look something like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5706(title)
#, fuzzy
msgid "Timeouts, I/O and Idle Functions"
msgstr "Podatki funkcij odklepanja in zaklepanja"

#: C/gtkmm-tutorial-in.xml:5709(title)
msgid "Timeouts"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5711(para)
msgid "You may be wondering how to make <application>gtkmm</application> do useful work while it's idling along (well, sleeping actually) in <methodname>Gtk::Main::run()</methodname>. Happily, you have several options. Using the following methods you can create a timeout method that will be called every few milliseconds."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5719(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot, unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5724(para)
msgid "The first argument is a <classname>slot</classname> you wish to have called when the timeout occurs. The second argument is the number of milliseconds between calls to that method. You receive a <classname>sigc::connection</classname> object that can be used to deactivate the connection using its <methodname>disconnect()</methodname> method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5734(programlisting)
#, fuzzy, no-wrap
msgid ""
"\n"
"my_connection.disconnect();\n"
msgstr "Povezave ni mogoče prekiniti {0}: {1}"

#: C/gtkmm-tutorial-in.xml:5746(programlisting)
#, no-wrap
msgid ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n"
"\" &lt;&lt; std::endl; return true; }\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5739(para)
msgid "Another way of destroying the connection is your signal handler. It has to be of the type <classname>sigc::slot&lt;bool&gt;</classname>. As you see from the definition your signal handler has to return a value of the type <literal>bool</literal>. A definition of a sample method might look like this: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5752(para)
msgid "You can stop the timeout method by returning <literal>false</literal> from your signal handler. Therefore, if you want your method to be called repeatedly, it should return <literal>true</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5758(para)
msgid "Here's an example of this technique:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5767(title)
#, fuzzy
msgid "Monitoring I/O"
msgstr "<b>Nadziranje datotek</b>"

#: C/gtkmm-tutorial-in.xml:5769(para)
msgid "A nifty feature of Glib (one of the libraries underlying <application>gtkmm</application>) is the ability to have it check for data on a file descriptor for you. This is especially useful for networking applications. The following method is used to do this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5777(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::connection Glib::SignalInput::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,\n"
"                                    int fd, Glib::IOCondition condition,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5784(para)
msgid "The first argument is a slot you wish to have called when then the specified event (see argument 3) occurs on the file descriptor you specify using argument two. Argument three may be one or more (using <literal>|</literal>) of:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5794(para)
msgid "Glib::IO_IN - Call your method when there is data ready for reading on your file descriptor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5802(para)
msgid "Glib::IO_OUT - Call your method when the file descriptor is ready for writing."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5810(para)
msgid "Glib::IO_PRI - Call your method when the file descriptor has urgent data to be read."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5817(para)
msgid "Glib::IO_ERR - Call your method when an error has occurred on the file descriptor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5824(para)
msgid "Glib::IO_HUP - Call your method when hung up (the connection has been broken usually for pipes and sockets)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5831(para)
msgid "The return value is a <classname>sigc::connection</classname> that may be used to stop monitoring this file descriptor using its <methodname>disconnect()</methodname> method. The <parameter>slot</parameter> signal handler should be declared as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5838(programlisting)
#, no-wrap
msgid ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5843(para)
msgid "where <parameter>condition</parameter> is as specified above. As usual the slot is created with <function>sigc::mem_fun()</function> (for a member method of an object.), or <function>sigc::ptr_fun()</function> (for a function)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5850(para)
msgid "A little example follows. To use the example just execute it from a terminal; it doesn't create a window. It will create a pipe named <literal>testfifo</literal> in the current directory. Then start another shell and execute <literal>echo \"Hello\" &gt; testfifo</literal>. The example will print each line you enter until you execute <literal>echo \"Q\" &gt; testfifo</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5864(title)
#, fuzzy
msgid "Idle Functions"
msgstr "XSLT - Funkcije"

#: C/gtkmm-tutorial-in.xml:5866(para)
msgid "If you want to specify a method that gets called when nothing else is happening, use the following:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5871(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot, int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5876(para)
msgid "This causes <application>gtkmm</application> to call the specified method whenever nothing else is happening. You can add a priority (lower numbers are higher priorities). There are two ways to remove the signal handler: calling <methodname>disconnect()</methodname> on the <classname>sigc::connection</classname> object, or returning <literal>false</literal> in the signal handler, which should be declared as follows:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5886(programlisting)
#, no-wrap
msgid ""
"\n"
"bool idleFunc();\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5891(para)
msgid "Since this is very similar to the methods above this explanation should be sufficient to understand what's going on. However, here's a little example:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5898(para)
msgid "This example points out the difference of idle and timeout methods a little. If you need methods that are called periodically, and speed is not very important, then you want timeout methods. If you want methods that are called as often as possible (like calculating a fractal in background), then use idle methods."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5906(para)
msgid "Try executing the example and increasing the system load. The upper progress bar will increase steadily; the lower one will slow down."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5916(title)
#, fuzzy
msgid "Memory management"
msgstr "Upravljanje omrežij"

#: C/gtkmm-tutorial-in.xml:5922(title)
#, fuzzy
msgid "Normal C++ memory management"
msgstr "Možnosti upravljanja seje:"

#: C/gtkmm-tutorial-in.xml:5924(para)
msgid "<application>gtkmm</application> allows the programmer to control the lifetime (that is, the construction and destruction) of any widget in the same manner as any other C++ object. This flexibility allows you to use <literal>new</literal> and <literal>delete</literal> to create and destroy objects dynamically or to use regular class members (that are destroyed automatically when the class is destroyed) or to use local instances (that are destroyed when the instance goes out of scope). This flexibility is not present in some C++ GUI toolkits, which restrict the programmer to only a subset of C++'s memory management features."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5936(para)
msgid "Here are some examples of normal C++ memory management:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5939(title)
#, fuzzy
msgid "Class Scope widgets"
msgstr "Področje razreda (statično)"

#: C/gtkmm-tutorial-in.xml:5941(para)
msgid "If a programmer does not need dynamic memory allocation, automatic widgets in class scope may be used. One advantage of automatic widgets in class scope is that memory management is grouped in one place. The programmer does not risk memory leaks from failing to <literal>delete</literal> a widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5948(para)
msgid "The primary disadvantages of using class scope widgets are revealing the class implementation rather than the class interface in the class header. Class scope widgets also require Automatic widgets in class scope suffer the same disadvantages as any other class scope automatic variable."
msgstr ""

#: C/gtkmm-tutorial-in.xml:5956(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"class Foo\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // will be destroyed when the Foo object is destroyed\n"
"};\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5969(title)
#, fuzzy
msgid "Function scope widgets"
msgstr "Področje razreda (statično)"

#: C/gtkmm-tutorial-in.xml:5977(programlisting)
#, no-wrap
msgid ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  kit.run();\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5971(para)
msgid "If a programmer does not need a class scope widget, a function scope widget may also be used. The advantages to function scope over class scope are the increased data hiding and reduced dependencies. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5989(title)
msgid "Dynamic allocation with new and delete"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5991(para)
msgid "Although, in most cases, the programmer will prefer to allow containers to automatically destroy their children using <function>manage()</function> (see below), the programmer is not required to use <function>manage()</function>. The traditional <literal>new</literal> and <literal>delete</literal> operators may also be used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6001(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Button* pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// do something useful with pButton\n"
"\n"
"delete pButton;\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:5999(para)
msgid "<placeholder-1/> Here, the programmer deletes pButton to prevent a memory leak."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6016(title)
#, fuzzy
msgid "Managed Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:6018(para)
msgid "Alternatively, you can let a widget's container control when the widget is destroyed. In most cases, you want a widget to last only as long as the container it is in. To delegate the management of a widget's lifetime to its container, first create it with <function>manage()</function> and pack it into its container with <methodname>add()</methodname>. Now, the widget will be destroyed whenever its container is destroyed."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6028(title)
msgid "Dynamic allocation with manage() and add()"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6030(para)
msgid "<application>gtkmm</application> provides the <function>manage()</function> function and <methodname>add()</methodname> methods to create and destroy widgets. Every widget except a top-level window must be added or packed into a container in order to be displayed. The <function>manage()</function> function marks a packed widget so that when the widget is added to a container, the container becomes responsible for deleting the widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6040(programlisting)
#, no-wrap
msgid ""
"\n"
"MyWidget::MyWidget()\n"
"{\n"
"  Gtk::Button* pButton = manage(new Gtk::Button(\"Test\"));\n"
"  add(*pButton); //add aButton to MyWidget\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6039(para)
msgid "<placeholder-1/> Now, when objects of type <classname>MyWidget</classname> are destroyed, the button will also be deleted. It is no longer necessary to delete pButton to free the button's memory; its deletion has been delegated to the <classname>MyWidget</classname> object."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6054(para)
msgid "<application>gtkmm</application> also provides the <methodname>set_manage()</methodname> method for all widgets. This can be used to generate the same result as <function>manage()</function>, but is more tedious:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6060(para)
msgid "foo.add( (w=new Gtk::Label(\"Hello\"), w-&gt;set_manage(), &amp;w) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6064(para)
#, fuzzy
msgid "is the same as"
msgstr "Enako kot odvod"

#: C/gtkmm-tutorial-in.xml:6068(para)
msgid "foo.add( manage(new Gtk::Label(\"Hello\")) );"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6072(para)
msgid "Of course, a top level container will not be added to another container. The programmer is responsible for destroying the top level container using one of the traditional C++ techniques. For instance, your top-level Window might just be an instance in your <function>main()</function> function.."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6084(title)
#, fuzzy
msgid "Shared resources"
msgstr "_Spletni viri"

#: C/gtkmm-tutorial-in.xml:6086(para)
msgid "Some objects, such as <classname>Gdk::Pixmap</classname>s and <classname>Pango::Font</classname>s, are obtained from a shared store. Therefore you cannot instantiate your own instances. These classes typically inherit from <classname>Glib::Object</classname>. Rather than requiring you to reference and unreference these objects, <application>gtkmm</application> uses the <classname>RefPtr&lt;&gt;</classname> smartpointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6098(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Bitmap&gt; bitmap = Gdk::Bitmap::create(window, data, width, height);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6095(para)
msgid "Objects such as <classname>Gdk::Bitmap</classname> can only be instantiated with a <methodname>create()</methodname> function. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6107(programlisting)
#, no-wrap
msgid ""
"\n"
"if(bitmap)\n"
"{\n"
"  int depth = bitmap-&gt;get_depth().\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6103(para)
msgid "You have no way of getting a bare <classname>Gdk::Bitmap</classname>. In the example, <varname>bitmap</varname> is a smart pointer, so you can do this, much like a normal pointer: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6115(para)
msgid "When <varname>bitmap</varname> goes out of scope an <methodname>unref()</methodname> will happen in the background and you don't need to worry about it anymore. There's no <literal>new</literal> so there's no <literal>delete</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6123(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Bitmap&gt; bitmap2 = bitmap.\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6121(para)
msgid "If you copy a <classname>RefPtr</classname>, for instance <placeholder-1/> , or if you pass it as a method argument or a return type, then <classname>RefPtr</classname> will do any necessary referencing to ensure that the instance will not be destroyed until the last <classname>RefPtr</classname> has gone out of scope."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6131(para)
msgid "See the <link linkend=\"chapter-refptr\">appendix</link> for detailed information about RefPtr."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6136(para)
msgid "Bjarne Stroustrup, \"The C++ Programming Language\" - section 14.4.2"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6139(para)
msgid "Nicolai M. Josuttis, \"The C++ Standard Library\" - section 4.2"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6132(para)
msgid "If you wish to learn more about smartpointers, you might look in these books: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6150(title)
#, fuzzy
msgid "Glade and Gtk::Builder"
msgstr "Mono, Gtk# in Jump n Bump so zakon!"

#: C/gtkmm-tutorial-in.xml:6151(para)
msgid "Although you can use C++ code to instantiate and arrange widgets, this can soon become tedious and repetitive. And it requires a recompilation to show changes. The <application>Glade</application> application allows you to layout widgets on screen and then save an XML description of the arrangement. Your application can then use the <application>Gtk::Builder</application> API to load that XML file at runtime and obtain a pointer to specifically named widget instances."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6164(simpara)
#, fuzzy
msgid "Less C++ code is required."
msgstr "Zahtevana razširitev '{0}' je onemogočena."

#: C/gtkmm-tutorial-in.xml:6165(simpara)
msgid "UI changes can be seen more quickly, so UIs are able to improve."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6166(simpara)
msgid "Designers without programming skills can create and edit UIs."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6161(para)
msgid "This has the following advantages: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6170(para)
msgid "You still need C++ code to deal with User Interface changes triggered by user actions, but using <application>Gtk::Builder</application> for the widget layout allows you to focus on implementing that functionality."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6177(title)
#, fuzzy
msgid "Loading the .glade file"
msgstr "Napaka pri nalaganju datoteke '%s'"

#: C/gtkmm-tutorial-in.xml:6182(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6178(para)
msgid "<classname>Gtk::Builder</classname> must be used via a <classname>Glib::RefPtr</classname>. Like all such classes, you need to use a <methodname>create()</methodname> method to instantiate it. For instance, <placeholder-1/> This will instantiate the windows defined in the .glade file, though they will not be shown immediately unless you have specified that via the <guilabel>Properties</guilabel> window in <application>Glade</application>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6191(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6190(para)
msgid "To instantiate just one window, or just one of the child widgets, you can specify the name of a widget as the second parameter. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6199(title)
#, fuzzy
msgid "Accessing widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:6207(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Dialog* pDialog = 0;\n"
"builder-&gt;get_widget(\"DialogBasic\", pDialog);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6201(para)
msgid "To access a widget, for instance to <methodname>show()</methodname> a dialog, use the <methodname>get_widget()</methodname> method, providing the widget's name. This name should be specified in the <application>Glade</application> Properties window. If the widget could not be found, or is of the wrong type, then the pointer will be set to 0. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6213(para)
msgid "<application>Gtk::Builder</application> checks for a null pointer, and checks that the widget is of the expected type, and will show warnings on the command line about these."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6219(para)
msgid "Remember that you are not instantiating a widget with <methodname>get_widget()</methodname>, you are just obtaining a pointer to one that already exists. You will always receive a pointer to the same instance when you call <methodname>get_widget()</methodname> on the same <classname>Gtk::Builder</classname>, with the same widget name. The widgets are instantiated during <methodname>Gtk::Builder::create_from_file()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6228(para)
msgid "<methodname>get_widget()</methodname> returns child widgets that are <function>manage()</function>ed (see the <link linkend=\"chapter-memory\">Memory Management</link> chapter), so they will be deleted when their parent container is deleted. So, if you get only a child widget from <application>Gtk::Builder</application>, instead of a whole window, then you must either put it in a <classname>Container</classname> or delete it. <classname>Windows</classname> (such as <classname>Dialogs</classname>) cannot be managed because they have no parent container, so you must delete them at some point."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6242(para)
msgid "This simple example shows how to load a <application>Glade</application> file at runtime and access the widgets with <application>Gtk::Builder</application>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6255(title)
#, fuzzy
msgid "Using derived widgets"
msgstr "Prepreči med uporabo:"

#: C/gtkmm-tutorial-in.xml:6256(para)
msgid "You can use <application>Glade</application> to layout your own custom widgets derived from <application>gtkmm</application> widget classes. This keeps your code organized and encapsulated. Of course you won't see the exact appearance and properties of your derived widget in <application>Glade</application>, but you can specify its location and child widgets and the properties of its <application>gtkmm</application> base class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6265(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog* pDialog = 0;\n"
"builder-&gt;get_widget_derived(\"DialogBasic\", pDialog);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6264(para)
msgid "Use <methodname>Gtk::Builder::get_widget_derived()</methodname> like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6271(para)
msgid "Your derived class must have a constructor that takes a pointer to the underlying C type, and the <classname>Gtk::Builder</classname> instance. All relevant classes of <application>gtkmm</application> typedef their underlying C type as <classname>BaseObjectType</classname> (<classname>Gtk::Dialog</classname> typedefs <classname>BaseObjectType</classname> as <type>GtkDialog</type>, for instance)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6281(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6278(para)
msgid "You must call the base class's constructor in the initialization list, providing the C pointer. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6293(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(0)\n"
"{\n"
"  //Get the Glade-instantiated Button, and connect a signal handler:\n"
"  m_builder-&gt;get_widget(\"quit_button\", m_pButton);\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6289(para)
msgid "You could then encapsulate the manipulation of the child widgets in the constructor of the derived class, maybe using <methodname>get_widget()</methodname> or <methodname>get_widget_derived()</methodname> again. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6311(para)
msgid "This example shows how to load a <application>Glade</application> file at runtime and access the widgets via a derived class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6324(title)
#, fuzzy
msgid "Internationalization and Localization"
msgstr "Mednarodno in jezikovno prilagajanje"

#: C/gtkmm-tutorial-in.xml:6326(para)
msgid "<application>gtkmm</application> applications can easily support multiple languages, including non-European languages such as Chinese and right-to-left languages such as Arabic. An appropriately-written and translated <application>gtkmm</application> application will use the appropriate language at runtime based on the user's environment."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6332(para)
msgid "You might not anticipate the need to support additional languages, but you can never rule it out. And it's easier to develop the application properly in the first place rather than retrofitting later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6338(para)
msgid "The process of writing source code that allows for translation is called <literal>internationalization</literal>, often abbreviated to <literal>i18n</literal>. The <literal>Localization</literal> process, sometimes abbreviated as <literal>l10n</literal>, provides translated text for other languages, based on that source code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6346(para)
msgid "The main activity in the internationalization process is finding strings seen by users and marking them for translation. You do not need to do it all at once - if you set up the necessary project infrastructure correctly then your application will work normally regardless of how many strings you've covered."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6354(para)
msgid "String literals should be typed in the source code in English, but surrounded by a macro. The <application>gettext</application> (or intltool) utility can then extract the marked strings for tramslation, and substitute the translated text at runtime."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6362(title)
#, fuzzy
msgid "Preparing your project"
msgstr "Ime vašega projekta."

#: C/gtkmm-tutorial-in.xml:6365(para)
msgid "In the instructions below we will assume that you will not be using <application>gettext</application> directly, but <application>intltool</application>, which was written specifically for <literal>GNOME</literal>. <application>intltool</application> uses <function>gettext()</function>, which extracts strings from source code, but <application>intltool</application> can also combine strings from other files, for example from desktop menu details, and GUI resource files such as <application>Glade</application> files, into standard <application>gettext</application><filename>.pot/.po</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6376(para)
msgid "We also assume that you are using autotools (e.g. <application>automake</application> and <application>autoconf</application>) to build your project, and that you are using <ulink url=\"http://svn.gnome.org/viewcvs/gnome-common/trunk/autogen.sh?view=markup\"><literal>./autogen.sh</literal> from <application>gnome-common</application></ulink>, which, among other things, takes care of some <application>intltool</application> initialization."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6389(para)
msgid "Create a sub-directory named <literal>po</literal> in your project's root directory. This directory will eventually contain all of your translations. Within it, create a file named <literal>LINGUAS</literal> and a file named <literal>POTFILES.in</literal>. It is common practice to also create a <literal>ChangeLog</literal> file in the <literal>po</literal> directory so that translators can keep track of translation changes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6399(para)
msgid "<literal>LINGUAS</literal> contains an alphabetically sorted list of codes identifying the languages for which your program is translated (comment lines starting with a <literal>#</literal> are ignored). Each language code listed in the <literal>LINGUAS</literal> file must have a corresponding <literal>.po</literal> file. So, if your program has German and Japanese translations, your <literal>LINGUAS</literal> file would look like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6408(programlisting)
#, no-wrap
msgid ""
"# keep this file sorted alphabetically, one language code per line\n"
"de\n"
"ja"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6411(para)
msgid "(In addition, you'd have the files <literal>ja.po</literal> and <literal>de.po</literal> in your <literal>po</literal> directory which contain the German and Japanese translations, respectively.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6418(para)
msgid "<literal>POTFILES.in</literal> is a list of paths to all files which contain strings marked up for translation, starting from the project root directory. So for example, if your project sources were located in a subdirectory named <literal>src</literal>, and you had two files that contained strings that should be translated, your <literal>POTFILES.in</literal> file might look like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6427(programlisting)
#, no-wrap
msgid ""
"src/main.cc\n"
"src/other.cc"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6430(para)
msgid "If you are using <application>gettext</application> directly, you can only mark strings for translation if they are in source code file. However, if you use <application>intltool</application>, you can mark strings for translation in a variety of other file formats, including <application>Glade</application> UI files, xml, <ulink url=\"http://standards.freedesktop.org/desktop-entry-spec/latest/\">.desktop files</ulink> and several more. So, if you have designed some of the application UI in <application>Glade</application> then also add your <filename>.glade</filename> files to the list in <literal>POTFILES.in</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6443(para)
msgid "Now that there is a place to put your translations, you need to initialize <application>intltool</application> and <application>gettext</application>. Add the following code to your <literal>configure.ac</literal>, substituting 'programname' with the name of your program:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6450(programlisting)
#, no-wrap
msgid ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=programname\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [The domain to use with gettext])\n"
"AM_GLIB_GNU_GETTEXT\n"
"\n"
"PROGRAMNAME_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(PROGRAMNAME_LOCALEDIR)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6461(para)
msgid "This <varname>PROGRAMNAME_LOCALEDIR</varname> variable will be used later in the <literal>Makefile.am</literal> file, to define a macro that will be used when you initialize <application>gettext</application> in your source code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6472(para)
msgid "Add <literal>po</literal> to the <literal>SUBDIRS</literal> variable. Without this, your translations won't get built and installed when you build the program"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6479(programlisting)
#, no-wrap
msgid ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6477(para)
msgid "Define <literal>INTLTOOL_FILES</literal> as: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6485(para)
msgid "Add <literal>INTLTOOL_FILES</literal> to the <literal>EXTRA_DIST</literal> list of files. This ensures that when you do a <command>make dist</command>, these commands will be included in the source tarball."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6495(programlisting)
#, no-wrap
msgid ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6493(para)
msgid "Update your <literal>DISTCLEANFILES</literal>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6468(para)
msgid "In the top-level Makefile.am: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6504(para)
msgid "In your <literal>src/Makefile.am</literal>, update your <literal>AM_CPPFLAGS</literal> to add the following preprocessor macro definition:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6509(programlisting)
#, no-wrap
msgid "AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\\"${PROGRAMNAME_LOCALEDIR}\\\""
msgstr ""

#: C/gtkmm-tutorial-in.xml:6510(para)
msgid "This macro will be used when you initialize <literal>gettext</literal> in your source code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6517(title)
#, fuzzy
msgid "Marking strings for translation"
msgstr "Vsebinski opis za _prevod:"

#: C/gtkmm-tutorial-in.xml:6519(para)
msgid "String literals should be typed in the source code in English, but they should be surrounded by a call to the <function>gettext()</function> function. These strings will be extracted for translation and the translations may be used at runtime instead of the original English strings."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6527(para)
msgid "The <application>GNU gettext</application> package allows you to mark strings in source code, extract those strings for translation, and use the translated strings in your application."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6539(programlisting)
#, no-wrap
msgid "display_message(\"Getting ready for i18n.\");"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6541(programlisting)
#, no-wrap
msgid "display_message(_(\"Getting ready for i18n.\"));"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6533(para)
msgid "However, <application>Glib</application> defines <function>gettext()</function> support macros which are shorter wrappers in an easy-to-use form. To use these macros, include <literal>&lt;glibmm/i18n.h&gt;</literal>, and then, for example, substitute: <placeholder-1/> with: <placeholder-2/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6552(programlisting)
#, no-wrap
msgid "xgettext -a -o my-strings --omit-header *.cc *.h"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6544(para)
msgid "For reference, it is possible to generate a file which contains all strings which appear in your code, even if they are not marked for translation, together with file name and line number references. To generate such a file named <literal>my-strings</literal>, execute the following command, within the source code directory: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6559(programlisting)
#, no-wrap
msgid ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6555(para)
msgid "Finally, to let you program use the translation for the current locale, add this code to the beginning of your <filename>main.cc</filename> file, to initialize gettext. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6565(title)
#, fuzzy
msgid "How gettext works"
msgstr "Predloga prevoda gettext"

#: C/gtkmm-tutorial-in.xml:6567(para)
msgid "<application>intltool</application> / <application>xgettext</application> script extracts the strings and puts them in a <filename>mypackage.pot</filename> file. The translators of your application create their translations by first copying this <filename>.pot</filename> file to a <filename>localename.po</filename> file. A locale identifies a language and an encoding for that language, including date and numerical formats. Later, when the text in your source code has changed, the <literal>msmerge</literal> script is used to update the <filename>localename.po</filename> files from the regenerated <filename>.pot</filename> file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6581(para)
msgid "At install time, the <filename>.po</filename> files are converted to a binary format (with the extension <filename>.mo</filename>) and placed in a system-wide directory for locale files, for example <filename>/usr/share/locale/</filename>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6588(para)
msgid "When the application runs, the <application>gettext</application> library checks the system-wide directory to see if there is a <filename>.mo</filename> file for the user's locale environment (you can set the locale with, for instance, \"export LANG=de_DE.UTF-8\" from a bash console). Later, when the program reaches a <literal>gettext</literal> call, it looks for a translation of a particular string. If none is found, the original string is used."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6600(title)
#, fuzzy
msgid "Testing and adding translations"
msgstr "--ask-cdrom Vprašaj za dodajanje CD-ja in zapusti program\n"

#: C/gtkmm-tutorial-in.xml:6607(programlisting)
#, fuzzy, no-wrap
msgid "intltool-update --pot"
msgstr "Posodobi iz datoteke &POT ..."

#: C/gtkmm-tutorial-in.xml:6602(para)
msgid "To convince yourself that you've done well, you may wish to add a translation for a new locale. In order to do that, go to the <filename>po</filename> subdirectory of your project and execute the following command: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6610(para)
msgid "That will create a file named <filename>programname.pot</filename>. Now copy that file to <filename>languagecode.po</filename>, such as <filename>de.po</filename> or <filename>hu.po</filename>. Also add that language code to <literal>LINGUAS</literal>. The <filename>.po</filename> file contains a header and a list of English strings, with space for the translated strings to be entered. Make sure you set the encoding of the <filename>.po</filename> file (specified in the header, but also as content) to <literal>UTF-8</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6623(para)
msgid "It's possible that certain strings will be marked as <literal>fuzzy</literal> in the <filename>.po</filename> file. These translations will not substitute the original string. To make them appear, simply remove the <literal>fuzzy</literal> tag."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6633(title)
msgid "Resources"
msgstr "Viri"

#: C/gtkmm-tutorial-in.xml:6642(ulink)
#, fuzzy
msgid "Internationalizing GNOME applications"
msgstr "Ekstra GNOME programi"

#: C/gtkmm-tutorial-in.xml:6649(ulink)
#, fuzzy
msgid "Intltool README"
msgstr "PreberiMe / Pogosta vprašanja ..."

#: C/gtkmm-tutorial-in.xml:6655(ulink)
msgid "How to use GNOME CVS as a Translator"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6661(ulink)
#, fuzzy
msgid "gettext manual"
msgstr "Priročnik programa Anjuta"

#: C/gtkmm-tutorial-in.xml:6667(literal)
#, fuzzy
msgid "gtkmm_hello"
msgstr "Hello Python"

#: C/gtkmm-tutorial-in.xml:6667(ulink)
#: C/gtkmm-tutorial-in.xml:6673(ulink)
#, fuzzy
msgid "<placeholder-1/> example package"
msgstr "Paket, ki vsebuje program"

#: C/gtkmm-tutorial-in.xml:6673(literal)
#, fuzzy
msgid "gnomemm_hello"
msgstr "Hello Python"

#: C/gtkmm-tutorial-in.xml:6635(para)
msgid "More information about what lies behind the internationalization and localization process is presented and demonstrated in: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6683(title)
#, fuzzy
msgid "Expecting UTF8"
msgstr "Neveljavni UTF8"

#: C/gtkmm-tutorial-in.xml:6684(para)
msgid "A properly internationalized application will not make assumptions about the number of bytes in a character. That means that you shouldn't use pointer arithmetic to step through the characters in a string, and it means you shouldn't use <classname>std::string</classname> or standard C functions such as <function>strlen()</function> because they make the same assumption."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6691(para)
msgid "However, you probably already avoid bare char* arrays and pointer arithmetic by using <classname>std::string</classname>, so you just need to start using <classname>Glib::ustring</classname> instead. See the <link linkend=\"sec-basics-ustring\">Basics</link> chapter about <classname>Glib::ustring</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6699(title)
msgid "Glib::ustring and std::iostreams"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6716(programlisting)
#, no-wrap
msgid ""
"std::ostringstream output;\n"
"output.imbue(std::locale(\"\")); // use the user's locale for this stream\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"
msgstr ""

#. <para>TODO: This section is not clear - it needs to spell things out more clearly and obviously.</para>
#: C/gtkmm-tutorial-in.xml:6701(para)
msgid "Unfortunately, the integration with the standard iostreams is not completely foolproof. <application>gtkmm</application> converts <classname>Glib::ustring</classname>s to a locale-specific encoding (which usually is not UTF-8) if you output them to an <classname>ostream</classname> with <function>operator&lt;&lt;</function>. Likewise, retrieving <classname>Glib::ustrings</classname> from <classname>istream</classname> with <function>operator&gt;&gt;</function> causes a conversion in the opposite direction. But this scheme breaks down if you go through a <classname>std::string</classname>, e.g. by inputting text from a stream to a <classname>std::string</classname> and then implicitly converting it to a <classname>Glib::ustring</classname>. If the string contained non-ASCII characters and the current locale is not UTF-8 encoded, the result is a corrupted <classname>Glib::ustring</classname>. You can work around this with a manual conversion. For instance, to retrieve the <classname>std::string</classname> from a <classname>ostringstream</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6726(title)
msgid "Pitfalls"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6728(para)
msgid "There are a few common mistakes that you would discover eventually yourself. But this section might help you to avoid them."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6731(title)
msgid "Same strings, different semantics"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6733(para)
msgid "Sometimes two english strings are identical but have different meanings in different contexts, so they would probably not be identical when translated. Since the English strings are used as look-up keys, this causes problems."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6737(para)
msgid "In these cases, you should add extra characters to the strings. For instance, use <literal>\"jumps[noun]\"</literal> and <literal>\"jumps[verb]\"</literal> instead of just <literal>\"jumps\"</literal>) and strip them again outside the <function>gettext</function> call. If you add extra characters you should also add a comment for the translators before the <function>gettext</function> call. Such comments will be shown in the <filename>.po</filename> files. For instance:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6747(programlisting)
#, no-wrap
msgid ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6753(title)
#, fuzzy
msgid "Composition of strings"
msgstr "Osnovni niz"

#: C/gtkmm-tutorial-in.xml:6755(para)
msgid "C programmers use <function>sprintf()</function> to compose and concatenate strings. C++ favours streams, but unfortunately, this approach makes translation difficult, because each fragment of text is translated separately, without allowing the translators to rearrange them according to the grammar of the language."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6762(para)
msgid "For instance, this code would be problematic:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6764(programlisting)
#, no-wrap
msgid ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6769(para)
msgid "So you should either avoid this situation or revert to the C-style <function>sprintf()</function>. One possible solution is the <ulink url=\"http://www.cs.auc.dk/~olau/compose/\">compose library</ulink> which supports syntax such as:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6776(programlisting)
#, no-wrap
msgid "label.set_text(compose(_(\"Really delete %1 now?\"), filename));"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6780(title)
msgid "Assuming the displayed size of strings"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6782(para)
msgid "You never know how much space a string will take on screen when translated. It might very possibly be twice the size of the original English string. Luckily, most <application>gtkmm</application> widgets will expand at runtime to the required size."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6786(title)
#, fuzzy
msgid "Unusual words"
msgstr "Besede dokumenta"

#: C/gtkmm-tutorial-in.xml:6788(para)
msgid "You should avoid cryptic abbreviations, slang, or jargon. They are usually difficult to translate, and are often difficult for even native speakers to understand. For instance, prefer \"application\" to \"app\""
msgstr ""

#: C/gtkmm-tutorial-in.xml:6794(title)
msgid "Using non-ASCII characters in strings"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6796(para)
msgid "Currently, <application>gettext</application> does not support non-ASCII characters (i.e. any characters with a code above 127) in source code. For instance, you cannot use the copyright sign (©)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6802(para)
msgid "To work around this, you could write a comment in the source code just before the string, telling the translators to use the special character if it is available in their languages. For english, you could then make an American English <filename>en_US.po</filename> translation which used that special charactger."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6810(title)
#, fuzzy
msgid "Getting help with translations"
msgstr "Pomoč s programom"

#: C/gtkmm-tutorial-in.xml:6812(para)
msgid "If your program is free software, there is a whole <literal>GNOME</literal> subproject devoted to helping you make translations, the <ulink url=\"http://developer.gnome.org/projects/gtp/\"><literal>GNOME</literal> Translation Project</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6817(para)
msgid "The way it works is that you contact the gnome-i18n mailing list to find out how the translators can access your <filename>po/</filename> subdirectory, and to add your project to the big <ulink url=\"http://developer.gnome.org/projects/gtp/status/\">status tables</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6824(para)
msgid "Then you make sure you update the file <filename>POTFILES.in</filename> in the <filename>po/</filename> subdirectory (<command>intltool-update -M</command> can help with this) so that the translators always access updated <filename>myprogram.pot</filename> files, and simply freeze the strings at least a couple of days before you make a new release, announcing it on gnome-i18n. Depending on the number of strings your program contains and how popular it is, the translations will then start to tick in as <filename>languagename.po</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6836(para)
msgid "Note that most language teams only consist of 1-3 persons, so if your program contains a lot of strings, it might last a while before anyone has the time to look at it. Also, most translators do not want to waste their time (translating is a very time-consuming task) so if they do not assess your project as being really serious (in the sense that it is polished and being maintained) they may decide to spend their time on some other project."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6848(title)
#: C/gtkmm-tutorial-in.xml:6937(title)
#, fuzzy
msgid "Custom Widgets"
msgstr "< poišči gradnike >"

#: C/gtkmm-tutorial-in.xml:6850(para)
msgid "<application>gtkmm</application> makes it very easy to derive new widgets by inheriting from an existing widget class, either by deriving from a container and adding child widgets, or by deriving from a single-item widget, and changing its behaviour. But you might occasionally find that no suitable starting point already exists. In this case, you can implement a widget from scratch."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6852(title)
#, fuzzy
msgid "Custom Containers"
msgstr "_Vmesnik po meri"

#: C/gtkmm-tutorial-in.xml:6855(para)
msgid "<methodname>on_size_request()</methodname>: Calculate the minimum height and width needed by the container."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6856(para)
msgid "<methodname>on_size_allocate()</methodname>: Position the child widgets, given the height and width that the container has actually been given."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6857(para)
msgid "<methodname>forall_vfunc()</methodname>: Call the same callback for each of the children."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6858(para)
#, fuzzy
msgid "<methodname>on_add()</methodname>:"
msgstr "Zapri pogovorno okno ob dodajanju"

#: C/gtkmm-tutorial-in.xml:6859(para)
#, fuzzy
msgid "<methodname>on_remove()</methodname>:"
msgstr "Odstrani stolpec na %s"

#: C/gtkmm-tutorial-in.xml:6860(para)
msgid "<methodname>child_type_vfunc()</methodname>: Return what type of child can be added."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6853(para)
msgid "When deriving from <classname>Gtk::Container</classname>, you should override the following virtual methods: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:6864(para)
msgid "The <methodname>on_size_request()</methodname> and <methodname>on_size_allocate()</methodname> virtual methods control the layout of the child widgets. For instance, if your container has 2 child widgets, with one below the other, your <methodname>on_size_request()</methodname> might report the maximum of their widths and the sum of their heights. If you want padding between the child widgets then you would add that to the width and height too. Your widget's container will use this result to ensure that your widget gets enough space, and not less. By examining each widget's parent, and its parent, this logic will eventually decide the size of the top-level window."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6876(para)
msgid "<methodname>on_size_allocate()</methodname>, however, receives the actual height and width that the parent container has decided to give to your widget. This might be more than the minimum, for instance if the top-level window has been expanded. You might choose to ignore the extra space and leave a blank area, or you might choose to expand your child widgets to fill the space, or you might choose to expand the padding between your widgets. Its your container, so you decide. Don't forget to call <methodname>set_allocation()</methodname> inside your <methodname>on_size_allocate()</methodname> implementation to actually use the allocated space that has been offered by the parent container."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6887(para)
msgid "Unless your container is a top-level window that derives from <classname>Gtk::Window</classname>, you should also call <methodname>Gtk::Container::set_flags(Gtk::NO_WINDOW)</methodname> in your constructor. Otherwise, your container will appear in its own window, regardless of what container you put it in. And unless your container draws directly onto the underlying <classname>Gdk::Window</classname>, you should probably call <methodname>set_redraw_on_allocate(false)</methodname> to improve performance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6897(para)
msgid "By overriding <methodname>forall_vfunc()</methodname> you can allow applications to operate on all of the container's child widgets. For instance, <methodname>show_all_children()</methodname> uses this to find all the child widgets and show them."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6902(para)
msgid "Although your container might have its own method to set the child widgets, you should still provide an implementation for the virtual <methodname>on_add()</methodname> and <methodname>on_remove()</methodname> methods from the base class, so that the add() and remove() methods will do something appropriate if they are called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6908(para)
msgid "Your implementation of the <methodname>child_type_vfunc()</methodname> method should report the type of widget that may be added to your container, if it is not yet full. This is usually <methodname>Gtk::Widget::get_type()</methodname> to indicate that the container may contain any class derived from <classname>Gtk::Widget</classname>. If the container may not contain any more widgets, then this method should return <literal>G_TYPE_NONE</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6920(para)
msgid "This example implements a container with two child widgets, one above the other. Of course, in this case it would be far simpler just to use a <classname>Gtk::VBox</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6925(title)
#, fuzzy
msgid "Custom Container"
msgstr "zabojnik html"

#: C/gtkmm-tutorial-in.xml:6938(para)
msgid "By deriving directly from <classname>Gtk::Widget</classname> you can do all the drawing for your widget directly, instead of just arranging child widgets. For instance, a <classname>Gtk::Label</classname> draws the text of the label, but does not do this by using other widgets."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6946(para)
msgid "This example implements a widget which draws a Penrose triangle."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6949(title)
#, fuzzy
msgid "Custom Widget"
msgstr "Gradnik po meri"

#: C/gtkmm-tutorial-in.xml:6965(title)
#, fuzzy
msgid "Recommended Techniques"
msgstr "Priporočeni izvajalci"

#: C/gtkmm-tutorial-in.xml:6967(para)
msgid "This section is simply a gathering of wisdom, general style guidelines and hints for creating <application>gtkmm</application> applications."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6971(para)
msgid "Use GNU <application>autoconf</application> and <application>automake</application>! They are your friends :) <application>Automake</application> examines C files, determines how they depend on each other, and generates a <filename>Makefile</filename> so the files can be compiled in the correct order. <application>Autoconf</application> permits automatic configuration of software installation, handling a large number of system quirks to increase portability.."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6981(para)
msgid "Subclass Widgets to better organize your code. You should probably subclass your main <classname>Window</classname> at least. Then you can make your child Widgets and signal handlers members of that class."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6986(para)
msgid "Create your own signals instead of passing pointers around. Objects can communicate with each other via signals and signal handlers. This is much simpler than objects holding pointers to each other and calling each other's methods. <application>gtkmm</application>'s classes uses special versions of <classname>sigc::signal</classname>, but you should use normal <classname>sigc::signal</classname>s, as described in the <application>libsigc++</application> documentation."
msgstr ""

#: C/gtkmm-tutorial-in.xml:6995(title)
#, fuzzy
msgid "Application Lifetime"
msgstr "Izbran program"

#: C/gtkmm-tutorial-in.xml:6996(para)
msgid "Most applications will have only one <classname>Window</classname>, or only one main window. These applications can use the <methodname>Gtk::Main::run(Gtk::Window&amp;)</methodname> overload. It shows the window and returns when the window has been hidden. This might happen when the user closes the window, or when your code decides to <methodname>hide()</methodname> the window. You can prevent the user from closing the window (for instance, if there are unsaved changes) by overriding <methodname>Gtk::Window::on_delete_event()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7004(para)
msgid "Most of our examples use this technique."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7008(title)
#, fuzzy
msgid "Using a <application>gtkmm</application> widget"
msgstr "Vzorčni program GNOME tehnologij"

#: C/gtkmm-tutorial-in.xml:7010(para)
msgid "Our examples all tend to have the same structure. They follow these steps for using a <classname>Widget</classname>:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7019(para)
msgid "Declare a variable of the type of <classname>Widget</classname> you wish to use, generally as member variable of a derived container class. You could also declare a pointer to the widget type, and then create it with <literal>new</literal> in your code. Even when using the widget via a pointer, it's still probably best to make that pointer a member variable of a container class so that you can access it later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7030(para)
msgid "Set the attributes of the widget. If the widget has no default constructor, then you will need to initialize the widget in the initalizer list of your container class's constructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7036(para)
msgid "Connect any signals you wish to use to the appropriate handlers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7042(para)
msgid "Pack the widget into a container using the appropriate call, e.g. <methodname>Gtk::Container::add()</methodname> or <methodname>pack_start()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7050(para)
msgid "Call <methodname>show()</methodname> to display the widget."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7059(para)
msgid "<methodname>Gtk::Widget::show()</methodname> lets <application>gtkmm</application> know that we have finished setting the attributes of the widget, and that it is ready to be displayed. You can use <methodname>Gtk::Widget::hide()</methodname> to make it disappear again. The order in which you show the widgets is not important, but we do suggest that you show the top-level window last; this way, the whole window will appear with its contents already drawn. Otherwise, the user will first see a blank window, into which the widgets will be gradually drawn."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7073(title)
msgid "Contributing"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7075(para)
msgid "This document, like so much other great software out there, was created for free by volunteers. If you are at all knowledgeable about any aspect of <application>gtkmm</application> that does not already have documentation, please consider contributing to this document."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7081(para)
msgid "Ideally, we would like you to <ulink url=\"http://www.gtkmm.org/bugs.shtml\">provide a patch</ulink> to the <filename>docs/tutorial/C/gtkmm-tutorial-in.xml</filename> file. This file is currently in the <literal>gtkmm-documentation</literal> module in GNOME git."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7087(para)
msgid "If you do decide to contribute, please post your contribution to the <application>gtkmm</application> mailing list at <ulink url=\"mailto:gtkmm-list@gnome.org\">&lt;gtkmm-list@gnome.org&gt;</ulink>. Also, be aware that the entirety of this document is free, and any addition you provide must also be free. That is, people must be able to use any portion of your examples in their programs, and copies of this document (including your contribution) may be distributed freely."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7099(title)
msgid "The RefPtr smartpointer"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7100(para)
msgid "<classname>Glib::RefPtr</classname> is a smartpointer. Specifically, it is a reference-counting smartpointer. You might be familiar with <literal>std::auto_ptr&lt;&gt;</literal>, which is also a smartpointer, but <literal>Glib::RefPtr&lt;&gt;</literal> is much simpler, and more useful. We expect a future version of the C++ Standard Library to contain a reference-counting shared smartpointer, and a future version of <application>gtkmm</application> might possibly use that instead."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7110(para)
msgid "A smartpointer acts much like a normal pointer. Here are a few examples."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7113(title)
#, fuzzy
msgid "Copying"
msgstr "Kopiranje"

#: C/gtkmm-tutorial-in.xml:7114(para)
msgid "You can copy <classname>RefPtr</classname>s, just like normal pointers. But unlike normal pointers, you don't need to worry about deleting the underlying instance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7120(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,\n"
"data, width, height);\n"
"Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap2 = refBitmap;\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7126(para)
msgid "Of course this means that you can store <classname>RefPtrs</classname> in standard containers, such as <classname>std::vector</classname> or <classname>std::list</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7131(programlisting)
#, no-wrap
msgid ""
"\n"
"std::list&lt; Glib::RefPtr&lt;Gdk::Pixmap&gt; &gt; listPixmaps;\n"
"Glib::RefPtr&lt;Gdk::Pixmap&gt; refPixmap = Gdk::Pixmap::create(window,\n"
"width, height, depth);\n"
"listPixmaps.push_back(refPixmap);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7140(title)
msgid "Dereferencing"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7141(para)
msgid "You can dereference a smartpointer with the -&gt; operator, to call the methods of the underlying instance, just like a normal pointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7145(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,\n"
"data, width, height);\n"
"int depth = refBitmap-&gt;get_depth();\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7151(para)
msgid "But unlike most smartpointers, you can't use the * operator to access the underlying instance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7155(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Bitmap&gt; refBitmap = Gdk::Bitmap::create(window,\n"
"data, width, height);\n"
"Gdk::Bitmap* underlying = *refBitmap; //Syntax error - will not compile.\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7163(title)
msgid "Casting"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7164(para)
msgid "You can cast <classname>RefPtrs</classname> to base types, just like normal pointers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7169(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7174(para)
msgid "This means that any method which takes a <type>const Glib::RefPtr&lt;BaseType&gt;</type> argument can also take a <type>const Glib::RefPtr&lt;DerivedType&gt;</type>. The cast is implicit, just as it would be for a normal pointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7178(para)
msgid "You can also cast to a derived type, but the syntax is a little different than with a normal pointer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7182(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7192(title)
#, fuzzy
msgid "Checking for null"
msgstr "Preverjanje za posodobitve ..."

#: C/gtkmm-tutorial-in.xml:7193(para)
msgid "Just like normal pointers, you can check whether a <classname>RefPtr</classname> points to anything."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7198(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();\n"
"if(refModel)\n"
"{\n"
"  int cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7207(para)
msgid "But unlike normal pointers, <classname>RefPtr</classname>s are automatically initialized to null so you don't need to remember to do that yourself."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7214(title)
msgid "Constness"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7215(para)
msgid "The use of the <literal>const</literal> keyword in C++ is not always clear. You might not realise that <type>const Something*</type> declares a pointer to a <type>const Something</type>, The pointer can be changed, but not the <type>Something</type> that it points to."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7221(para)
msgid "Therefore, the <classname>RefPtr</classname> equivalent of <type>Something*</type> for a method parameter is <type>const Glib::RefPtr&lt;Something&gt;&amp;</type>, and the equivalent of <type>const Something*</type> is <type>const Glib::RefPtr&lt;const Something&gt;&amp;</type>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7228(para)
msgid "The <literal>const ... &amp;</literal> around both is just for efficiency, like using <classname>const std::string&amp;</classname> instead of <classname>std::string</classname> for a method parameter to avoid unnecessary copying."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7243(title)
#, fuzzy
msgid "Connecting signal handlers"
msgstr "Upravljalnik posodobitev tipkovnice"

#: C/gtkmm-tutorial-in.xml:7244(para)
msgid "<application>gtkmm</application> widget classes have signal accessor methods, such as <methodname>Gtk::Button::signal_clicked()</methodname>, which allow you to connect your signal handler. Thanks to the flexibility of <application>libsigc++</application>, the callback library used by <application>gtkmm</application>, the signal handler can be almost any kind of function, but you will probably want to use a class method. Among <application>GTK+</application> C coders, these signal handlers are often named callbacks."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7254(para)
msgid "Here's an example of a signal handler being connected to a signal:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7259(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7275(para)
msgid "There's rather a lot to think about in this (non-functional) code. First let's identify the parties involved:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7283(para)
msgid "The signal handler is <methodname>on_button_clicked()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7289(para)
msgid "We're hooking it up to the <classname>Gtk::Button</classname> object called <varname>button</varname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7296(para)
msgid "When the Button emits its <literal>clicked</literal> signal, <methodname>on_button_clicked()</methodname> will be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7304(para)
msgid "Now let's look at the connection again:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7309(programlisting)
#, no-wrap
msgid ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7316(para)
msgid "Note that we don't pass a pointer to <methodname>on_button_clicked()</methodname> directly to the signal's <methodname>connect()</methodname> method. Instead, we call <function>sigc::ptr_fun()</function>, and pass the result to <methodname>connect()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7323(para)
msgid "<function>sigc::ptr_fun()</function> generates a <classname>sigc::slot</classname>. A slot is an object which looks and feels like a function, but is actually an object. These are also known as function objects, or functors. <function>sigc::ptr_fun()</function> generates a slot for a standalone function or static method. <function>sigc::mem_fun()</function> generates a slot for a member method of a particular instance."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7332(para)
msgid "Here's a slightly larger example of slots in action:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7337(programlisting)
#, no-wrap
msgid ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7356(para)
msgid "The first call to <methodname>connect()</methodname> is just like the one we saw last time; nothing new here."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7359(para)
msgid "The next is more interesting. <function>sigc::mem_fun()</function> is called with two arguments. The first argument is <parameter>some_object</parameter>, which is the object that our new slot will be pointing at. The second argument is a pointer to one of its methods. This particular version of <function>sigc::mem_fun()</function> creates a slot which will, when \"called\", call the pointed-to method of the specified object, in this case <methodname>some_object.on_button_clicked()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7369(para)
msgid "Another thing to note about this example is that we made the call to <methodname>connect()</methodname> twice for the same signal object. This is perfectly fine - when the button is clicked, both signal handlers will be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7376(para)
msgid "We just told you that the button's <literal>clicked</literal> signal is expecting to call a method with no arguments. All signals have requirements like this - you can't hook a function with two arguments to a signal expecting none (unless you use an adapter, such as <function>sigc::bind()</function>, of course). Therefore, it's important to know what type of signal handler you'll be expected to connect to a given signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7388(title)
#, fuzzy
msgid "Writing signal handlers"
msgstr "Upravljalnik posodobitev tipkovnice"

#: C/gtkmm-tutorial-in.xml:7390(para)
msgid "To find out what type of signal handler you can connect to a signal, you can look it up in the reference documentation or the header file. Here's an example of a signal declaration you might see in the <application>gtkmm</application> headers:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7397(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy1&lt;bool, Gtk::DirectionType&gt; signal_focus()\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7402(para)
msgid "Other than the signal's name (<literal>focus</literal>), two things are important to note here: the number following the word <classname>SignalProxy</classname> at the beginning (1, in this case), and the types in the list (<type>bool</type> and <type>Gtk::DirectionType</type>). The number indicates how many arguments the signal handler should have; the first type, <type>bool</type>, is the type that the signal handler should return; and the next type, <type>Gtk::DirectionType</type>, is the type of this signal's first, and only, argument. By looking at the reference documentation, you can see the names of the arguments too."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7414(para)
msgid "The same principles apply for signals which have more arguments. Here's one with three (taken from <filename>&lt;gtkmm/editable.h&gt;</filename>):"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7420(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy3&lt;void, const Glib::ustring&amp;, int, int*&gt; signal_insert_text()\n"
"\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7426(para)
msgid "It follows the same form. The number 3 at the end of the type's name indicates that our signal handler will need three arguments. The first type in the type list is <type>void</type>, so that should be our signal handler's return type. The following three types are the argument types, in order. Our signal handler's prototype could look like this:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7435(programlisting)
#, no-wrap
msgid ""
"\n"
"void on_insert_text(const Glib::ustring&amp; text, int length, int* position);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7442(title)
#, fuzzy
msgid "Disconnecting signal handlers"
msgstr "Upravljalnik posodobitev tipkovnice"

#: C/gtkmm-tutorial-in.xml:7444(para)
msgid "Let's take another look at a Signal's <literal>connect</literal> method:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7449(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7454(para)
msgid "Notice that the return value is of type <classname>sigc::signal&lt;void,int&gt;::iterator</classname>. This can be implicitely converted into a <classname>sigc::connection</classname> which in turn can be used to control the connection. By keeping a connection object you can disconnect its associated signal handler using the method <methodname>sigc::connection::disconnect()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7465(title)
#, fuzzy
msgid "Overriding default signal handlers"
msgstr "Ni mogoče najti privzetega imena signala"

#: C/gtkmm-tutorial-in.xml:7467(para)
msgid "So far we've told you to perform actions in response to button-presses and the like by handling signals. That's certainly a good way to do things, but it's not the only way."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7474(para)
msgid "Instead of laboriously connecting signal handlers to signals, you can simply make a new class which inherits from a widget - say, a Button - and then override the default signal handler, such as Button::on_clicked(). This can be a lot simpler than hooking up signal handlers for everything."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7481(para)
msgid "Subclassing isn't always the best way to accomplish things. It is only useful when you want the widget to handle its own signal by itself. If you want some other class to handle the signal then you'll need to connect a separate handler. This is even more true if you want several objects to handle the same signal, or if you want one signal handler to respond to the same signal from different objects."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7486(para)
msgid "<application>gtkmm</application> classes are designed with overriding in mind; they contain virtual member methods specifically intended to be overridden."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7491(para)
msgid "Let's look at an example of overriding:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7496(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"    virtual void on_clicked();\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"    // call the base class's version of the method:\n"
"    Gtk::Button::on_clicked();\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7515(para)
msgid "Here we define a new class called <classname>OverriddenButton</classname>, which inherits from <classname>Gtk::Button</classname>. The only thing we change is the <methodname>on_clicked()</methodname> method, which is called whenever <classname>Gtk::Button</classname> emits the <literal>clicked</literal> signal. This method prints \"Hello World\" to <literal>stdout</literal>, and then calls the original, overridden method, to let <classname>Gtk::Button</classname> do what it would have done had we not overridden."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7526(para)
msgid "You don't always need to call the parent's method; there are times when you might not want to. Note that we called the parent method <emphasis>after</emphasis> writing \"Hello World\", but we could have called it before. In this simple example, it hardly matters much, but there are times when it will. With signals, it's not quite so easy to change details like this, and you can do something here which you can't do at all with connected signal handlers: you can call the parent method in the <emphasis>middle</emphasis> of your custom code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7540(title)
#, fuzzy
msgid "Binding extra arguments"
msgstr "Podrobnosti _argumentov funkcije"

#: C/gtkmm-tutorial-in.xml:7548(programlisting)
#, no-wrap
msgid ""
"\n"
"m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\") );\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7555(programlisting)
#, no-wrap
msgid ""
"\n"
"virtual void on_button_clicked(Glib::ustring data);\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7541(para)
msgid "If you use one signal handler to catch the same signal from several widgets, you might like that signal handler to receive some extra information. For instance, you might want to know which button was clicked. You can do this with <function>sigc::bind()</function>. Here's some code from the <link linkend=\"sec-helloworld2\">helloworld2</link> example, which you will encounter later. <placeholder-1/> This says that we want the signal to send an extra <classname>Glib::ustring</classname> argument to the signal handler, and that the value of that argument should be \"button 1\". Of course we will need to add that extra argument to the declaration of our signal handler: <placeholder-2/> Of course, a normal \"clicked\" signal handler would have no arguments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7560(para)
msgid "<function>sigc::bind()</function> is not commonly used, but you might find it helpful sometimes. If you are familiar with <application>GTK+</application> programming then you have probably noticed that this is similar to the extra <literal>gpointer data</literal> arguments which all GTK+ callbacks have. This is generally overused in <application>GTK+</application> to pass information that should be stored as member data in a derived widget, but widget derivation is very difficult in C. We have far less need of this hack in <application>gtkmm</application>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7572(title)
#, fuzzy
msgid "X Event signals"
msgstr "Signali jedra"

#: C/gtkmm-tutorial-in.xml:7573(para)
msgid "The <classname>Widget</classname> class has some special signals which correspond to the underlying X-Windows events. These are suffixed by <literal>_event</literal>; for instance, <methodname>Widget::signal_button_pressed_event()</methodname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7579(para)
msgid "You might occasionally find it useful to handle X events when there's something you can't accomplish with normal signals. <classname>Gtk::Button</classname>, for example, does not send mouse-pointer coordinates with its <literal>clicked</literal> signal, but you could handle <literal>button_pressed_event</literal> if you needed this information. X events are also often used to handle key-presses."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7588(para)
msgid "These signals behave slightly differently. The value returned from the signal handler indicates whether it has fully \"handled\" the event. If the value is <literal>false</literal> then <application>gtkmm</application> will pass the event on to the next signal handler. If the value is <literal>true</literal> then no other signal handlers will need to be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7593(para)
msgid "Handling an X event doesn't affect the Widget's other signals. If you handle <literal>button_pressed_event</literal> for <classname>Gtk::Button</classname>, you'll still be able to get the <literal>clicked</literal> signal. They are emitted at (nearly) the same time."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7600(para)
msgid "Note also that not all widgets receive all X events by default. To receive additional X events, you can use <methodname>Gtk::Widget::set_events()</methodname> before showing the widget, or <methodname>Gtk::Widget::add_events()</methodname> after showing the widget. However, some widgets must first be placed inside an <classname>EventBox</classname> widget. See the <link linkend=\"chapter-widgets-without-xwindows\">Widgets Without X-Windows</link> chapter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7609(programlisting)
#, no-wrap
msgid ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7607(para)
msgid "Here's a simple example: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7615(para)
msgid "When the mouse is over the button and a mouse button is pressed, <methodname>on_button_press()</methodname> will be called."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7620(para)
msgid "<type>GdkEventButton</type> is a structure containing the event's parameters, such as the coordinates of the mouse pointer at the time the button was pressed. There are several different types of <type>GdkEvent</type> structures for the various events."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7628(title)
#, fuzzy
msgid "Signal Handler sequence"
msgstr "Dodaj upravljalnik signalov %s"

#: C/gtkmm-tutorial-in.xml:7630(programlisting)
#, no-wrap
msgid ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7629(para)
msgid "By default, your signal handlers are called after any previously-connected signal handlers. However, this can be a problem with the X Event signals. For instance, the existing signal handlers, or the default signal handler, might return true to stop other signal handlers from being called. To specify that your signal handler should be called before the other signal handlers, so that will always be called, you can specify <literal>false</literal> for the optional <literal>after</literal> parameter. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7644(title)
#, fuzzy
msgid "Creating your own signals"
msgstr "Konfigurator - Nastavljanje po želji"

#: C/gtkmm-tutorial-in.xml:7645(para)
msgid "Now that you've seen signals and signal handlers in <application>gtkmm</application>, you might like to use the same technique to allow interaction between your own classes. That's actually very simple by using the <application>libsigc++</application> library directly."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7651(para)
msgid "This isn't purely a <application>gtkmm</application> or GUI issue. <application>gtkmm</application> uses <application>libsigc++</application> to implement its proxy wrappers for the <application>GTK+</application> signal system, but for new, non-GTK+ signals, you can create pure C++ signals, using the <classname>sigc::signal&lt;&gt;</classname> template."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7662(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void, bool, int&gt; signal_something;\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7658(para)
msgid "For instance, to create a signal that sends 2 parameters, a <type>bool</type> and an <type>int</type>, just declare a <classname>sigc::signal</classname>, like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7670(programlisting)
#, no-wrap
msgid ""
"\n"
"class Server\n"
"{\n"
"public:\n"
"  //signal accessor:\n"
"  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;\n"
"  type_signal_something signal_something();\n"
"\n"
"protected:\n"
"  type_signal_something m_signal_something;\n"
"};\n"
"\n"
"Server::type_signal_something Server::signal_something()\n"
"{\n"
"  return m_signal_something;\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7666(para)
msgid "You could just declare that signal as a public member variable, but some people find that distasteful and prefer to make it available via an accessor method, like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7692(programlisting)
#, no-wrap
msgid ""
"\n"
"server.signal_something().connect(\n"
"  sigc::mem_fun(client, &amp;Client::on_server_something) );\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7689(para)
msgid "You can then connect to the signal using the same syntax used when connecting to <application>gtkmm</application> signals. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7700(para)
msgid "This is a full working example that defines and uses custom signal."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7714(title)
msgid "Comparison with other signalling systems"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7715(para)
msgid "(An aside: <application>GTK+</application> calls this scheme \"signalling\"; the sharp-eyed reader with GUI toolkit experience will note that this same design is often seen under the name of \"broadcaster-listener\" (e.g., in Metrowerks' PowerPlant framework for the Macintosh). It works in much the same way: one sets up <literal>broadcasters</literal>, and then connects <literal>listeners</literal> to them; the broadcaster keeps a list of the objects listening to it, and when someone gives the broadcaster a message, it calls all of its objects in its list with the message. In <application>gtkmm</application>, signal objects play the role of broadcasters, and slots play the role of listeners - sort of. More on this later.)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7729(para)
msgid "<application>gtkmm</application> signal handlers are strongly-typed, whereas <application>GTK+</application> C code allows you to connect a callback with the wrong number and type of arguments, leading to a segfault at runtime. And, unlike <application>Qt</application>, <application>gtkmm</application> achieves this without modifying the C++ language."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7735(para)
msgid "Re. Overriding signal handlers: You can do this in the straight-C world of GTK+ too; that's what GTK's object system is for. But in GTK+, you have to go through some complicated procedures to get object-oriented features like inheritance and overloading. In C++, it's simple, since those features are supported in the language itself; you can let the compiler do the dirty work."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7743(para)
msgid "This is one of the places where the beauty of C++ really comes out. One wouldn't think of subclassing a GTK+ widget simply to override its action method; it's just too much trouble. In GTK+, you almost always use signals to get things done, unless you're writing a new widget. But because overriding methods is so easy in C++, it's entirely practical - and sensible - to subclass a button for that purpose."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7754(title)
#, fuzzy
msgid "<application>gtkmm</application> and Win32"
msgstr "Privzeti meni in brskalnik programov"

#: C/gtkmm-tutorial-in.xml:7755(para)
msgid "One of the major advantages of <application>gtkmm</application> is that it is crossplatform. <application>gtkmm</application> programs written on other platforms such as GNU/Linux can generally be transferred to Windows (and vice versa) with few modifications to the source."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7760(para)
msgid "<application>gtkmm</application> currently works with the <ulink url=\"http://mingw.org/\">MingW/GCC3.4 compiler</ulink> and Microsoft Visual C++ 2005 or later (including the freely available express editions) on the Windows platform. There is an <ulink url=\"ftp://ftp.gnome.org/pub/GNOME/binaries/win32/gtkmm\"> installer</ulink> available for gtkmm on Microsoft Windows. Refer to <ulink url=\"http://live.gnome.org/gtkmm/MSWindows/\"> http://live.gnome.org/gtkmm/MSWindows</ulink> for instructions how to use it."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7772(title)
msgid "Building <application>gtkmm</application> on Win32"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7773(para)
msgid "Please see <ulink url=\"http://live.gnome.org/gtkmm/MSWindows/BuildingGtkmm\">http://live.gnome.org/gtkmm/MSWindows/BuildingGtkmm</ulink> for instructions on how to build gtkmm on Windws."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7780(title)
msgid "Working with gtkmm's Source Code"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7781(para)
msgid "If you are interested in helping out with the development of <application>gtkmm</application>, or fixing a bug in <application>gtkmm</application>, you'll probably need to build the development version of <application>gtkmm</application>. However, you should not to install a development version over your stable version. Instead, you should install it alongside your existing <application>gtkmm</application> installation, in a separate path."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7788(para)
msgid "The easiest way to do this is using <ulink url=\"http://library.gnome.org/devel/jhbuild/unstable/\">jhbuild</ulink>. <application>jhbuild</application> is a program that makes building GNOME software much easier by calculating dependencies and building things in the correct order. This section will give a brief explanation of how to set up jhbuild to build and install <application>gtkmm</application> from the source repository (git). For up-to-date information on <application>jhbuild</application>, please refer to the <ulink url=\"http://library.gnome.org/devel/jhbuild/unstable/\">jhbuild manual</ulink>. If you need assistance using <application>jhbuild</application>, you should ask for help on the <ulink url=\"http://mail.gnome.org/mailman/listinfo/gnome-love\">gnome-love mailing list</ulink>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7803(para)
msgid "Note that to build <application>gtkmm</application> from git, you'll often need to build all of its dependencies from git as well. <application>jhbuild</application> makes this easier than it would normally be, but it will take quite a while to build and install them all. You will probably encounter build problems, though these will usually be corrected quickly if you report them."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7811(title)
#, fuzzy
msgid "Setting up jhbuild"
msgstr "Nastavljanje naprave '%s' ni uspelo."

#: C/gtkmm-tutorial-in.xml:7812(para)
msgid "To set up <application>jhbuild</application>, follow the basic installation instructions from the <ulink url=\"http://library.gnome.org/devel/jhbuild/unstable/\">jhbuild manual</ulink>. After you've have installd <application>jhbuild</application>, you should copy the sample <application>jhbuild</application> configuration file into your home directory by executing the following command from the <application>jhbuild</application> directory: <command>$ cp sample.jhbuildrc ~/.jhbuildrc</command>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7827(programlisting)
#, fuzzy, no-wrap
msgid "moduleset = 'gnome-2.30'"
msgstr "Zadnjih 30 minut"

#: C/gtkmm-tutorial-in.xml:7822(para)
msgid "The <application>gtkmm</application> module is defined in the GNOME moduleset (i.e. <filename>gnome-2.xx.modules</filename>, so edit your <filename>.jhbuildrc</filename> file and set your moduleset setting to the latest version of GNOME like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7833(programlisting)
#, fuzzy, no-wrap
msgid "modules = [ 'gtkmm', ]"
msgstr "Vsi moduli"

#: C/gtkmm-tutorial-in.xml:7829(para)
msgid "After setting the correct moduleset, you need to tell <application>jhbuild</application> which module or modules to build. To build <application>gtkmm</application> and all of its dependencies, set <varname>modules</varname> like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7835(para)
msgid "You can build all GNOME C++ modules by setting the <varname>modules</varname> variable to the meta-package named <literal>meta-gnome-c++</literal> or build all of the core GNOME modules with <literal>meta-gnome-desktop</literal>. The <varname>modules</varname> variable specifies which modules that will be built when you don't explicitly specify anything on the command line. You can always build a different moduleset later by specifying it on the commandline (e.g. <command>jhbuild build gtkmm</command>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7846(title)
#, fuzzy
msgid "Setting a prefix"
msgstr "Omrežna maska / Predpona"

#: C/gtkmm-tutorial-in.xml:7847(para)
msgid "By default, <application>jhbuild</application>'s configuration is configured to install all software built with <application>jhbuild</application> under the <filename>/opt/gnome2</filename> prefix. You can choose a different prefix, but it is recommended that you keep this prefix different from other software that you've installed (don't set it to <filename>/usr</filename>!) If you've followed the jhbuild instructions then this prefix belongs to your user, so you don't need to run jhbuild as <literal>root</literal>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7861(title)
msgid "Installing and Using the git version of <application>gtkmm</application>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7862(para)
msgid ""
"Once you've configured <application>jhbuild</application> as described above, building <application>gtkmm</application> should be relatively straightforward. The first time you run <application>jhbuild</application>, you should run the following sequence of commands to ensure that <application>jhbuild</application> has the required tools and verify that it is set up correctly: <screen>$ jhbuild bootstrap\n"
"$ jhbuild sanitycheck</screen>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7873(title)
msgid "Installing <application>gtkmm</application> with <application>jhbuild</application>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7874(para)
msgid "If everything worked correctly, you should be able to build <application>gtkmm</application> and all of its dependencies from git by executing <command>jhbuild build</command> (or, if you didn't specify <application>gtkmm</application> in the <varname>modules</varname> variable, with the command <command>jhbuild build gtkmm</command>)."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7881(para)
msgid "This command will build and install a series of modules and will probably take quite a long time the first time through. After the first time, however, it should go quite a bit faster since it only needs to rebuild files than changed since the last build. Alternatively, after you've built and installed <application>gtkmm</application> the first time, you can rebuild <application>gtkmm</application> by itself (without rebuilding all of its dependencies) with the command <command>jhbuild buildone gtkmm</command>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7892(title)
msgid "Using the git version of <application>gtkmm</application>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7893(para)
msgid "After you've installed the git version of <application>gtkmm</application>, you're ready to start using and experimenting with it. In order to use the new version of <application>gtkmm</application> you've just installed, you need to set some environment variables so that your <filename>configure</filename> script knows where to find the new libraries. Fortunately, <application>jhbuild</application> offers an easy solution to this problem. Executing the command <command>jhbuild shell</command> will start a new shell with all of the correct environment variables set. Now if you re-configure and build your project just as you usually do, it should link against the newly installed libraries. To return to your previous environment, simply exit the <application>jhbuild</application> shell."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7907(para)
msgid "Once you've built your software, you'll need to run your program within the jhbuild environment as well. To do this, you can again use the <command>jhbuild shell</command> command to start a new shell with the <application>jhbuild</application> environment set up. Alternatively, you can execute a one-off command in the <application>jhbuild</application> environment using the following command: <command>jhbuild run command-name</command>. In this case, the command will be run with the correct environment variables set, but will return to your previous environment after the program exits."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7924(title)
msgid "Wrapping C Libraries with gmmproc"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7925(para)
msgid "<application>gtkmm</application> uses the <command>gmmproc</command> tool to generate most of its source code, using .defs files that define the APIs of <classname>GObject</classname>-based libraries. So it's quite easy to create additional gtkmm-style wrappers of other glib/GObject-based libraries."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7930(para)
msgid "This involves a variety of tools, some of them crufty, but it does at least work, and has been used successfully by several projects."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7935(title)
#, fuzzy
msgid "The build structure"
msgstr "Struktura organizacije"

#: C/gtkmm-tutorial-in.xml:7936(para)
msgid "Generation of the source code for a gtkmm-style wrapper API requires use of tools such as <command>gmmproc</command> and <filename>generate_wrap_init.pl</filename>. In theory you could write your own build files to use these appropriately, but a much better option is to make use of the build infrastructure provided by the mm-common module. To get started, it helps a lot to pick an existing binding module as an example to look at."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7943(para)
msgid "For instance, let's pretend that we are wrapping a C library called libexample. It provides a <classname>GObject</classname>-based API with types named, for instance, <classname>ExampleThing</classname> and <classname>ExampleStuff</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7949(title)
#, fuzzy
msgid "Copying the skeleton project"
msgstr "Gradnja celotnega projekta"

#: C/gtkmm-tutorial-in.xml:7954(programlisting)
#, no-wrap
msgid ""
"\n"
"  $ git clone git://git.gnome.org/mm-common\n"
"  $ cp -a mm-common/skeletonmm libsomethingmm\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7951(para)
msgid "Typically our wrapper library would be called libsomethingmm. We can start by copying the <ulink url=\"http://git.gnome.org/cgit/mm-common/tree/skeletonmm\">skeleton source tree</ulink> from the mm-common module. <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7964(para)
msgid "<filename>libsomethingmm</filename>: The top-level directory."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7966(para)
msgid "<filename>libsomething</filename>: Contains the main include file and the pkg-config .pc file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7968(para)
msgid "<filename>src</filename>: Contains .hg and .ccg source files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7969(para)
msgid "<filename>libsomethingmm</filename>: Contains generated and hand-written .h and .cc files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7971(para)
msgid "<filename>private</filename>: Contains generated <filename>*_p.h</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7959(para)
msgid "This provides a directory structure for the source .hg and .ccg files and the generated .h and .cc files, with <filename>filelist.am</filename> Automake include files that can specify the various files in use, in terms of generic Automake variables. The directory structure usually looks like this, after we have renamed the directories appropriately: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7983(programlisting)
#, no-wrap
msgid ""
"\n"
"$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\\n"
"    d=\"${f%/*}\"; b=\"${f##*/}\"; mv \"$f\" \"$d/${b//skeleton/libsomething}\"; \\\n"
"  done\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:7981(para)
msgid "As well as renaming the directories, we should rename some of the source files. For instance: <placeholder-1/> A number of the skeleton files must still be filled in with project-specific content later."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7990(para)
msgid "Note that files ending in <filename>.in</filename> will be used to generate files with the same name but without the <filename>.in</filename> suffix, by replacing some variables with actual values during the configure stage."
msgstr ""

#: C/gtkmm-tutorial-in.xml:7996(title)
#, fuzzy
msgid "Modifying build files"
msgstr "Podrobnosti _ciljnih datotek"

#: C/gtkmm-tutorial-in.xml:7998(para)
msgid "Now we edit the files to adapt them to to our needs. You might prefer to use a multiple-file search-replace utility for this, such as <command>regexxer</command>. Note that nearly all of the files provided with the skeleton source tree contain placeholder text. Thus, the substitutions should be performed globally, and not be limited to the Automake and Autoconf files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8002(para)
msgid "All mentions of <varname>skeleton</varname> should be replaced by the correct name of the C library you are wrapping, such as \"something\" or \"libsomething\". In the same manner, all instances of <varname>SKELETON</varname> should be replaced by \"SOMETHING\" or \"LIBSOMETHING\", and all occurrences of <varname>Skeleton</varname> changed to \"Something\"."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8006(para)
msgid "Likewise, replace all instances of <varname>Joe Hacker</varname> by the name of the intended copyright holder, which is probably you. Do the same for the <varname>joe@example.com</varname> email address."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8011(title)
#, fuzzy
msgid "configure.ac"
msgstr "Generator toka"

#: C/gtkmm-tutorial-in.xml:8014(para)
msgid "The <function>AC_CONFIG_SRCDIR()</function> line must mention a file in our source tree. We can edit this later if we don't yet know the names of any of the files that we will create."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8017(para)
msgid "It is common for binding modules to track the version number of the library they are wrapping. So, for instance, if the C library is at version 1.23.4, then the initial version of the binding module would be 1.23.0. However, avoid starting with an even minor version number as that usually indicates a stable release."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8022(para)
msgid "The <function>AC_CONFIG_HEADERS()</function> line is used to generate two or more configuration header files. The first header file in the list contains all configuration macros which are set during the configure run. The remaining headers in the list contain only a subset of configuration macros and their corresponding <filename>configh.h.in</filename> file will not be autogenerated. The reason for this separation is that the namespaced configuration headers are installed with your library and define publically visible macros."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8030(para)
msgid "The <function>AC_SUBST([SOMETHINGMM_MODULES], ['...'])</function> line may need to be modified to check for the correct dependencies."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8032(para)
msgid "The <function>AC_CONFIG_FILES()</function> block must mention the correct directory names, as described above."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8012(para)
msgid "In <filename>configure.ac</filename>, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8039(title)
#, fuzzy
msgid "Makefile.am files"
msgstr "Podrobnosti _ciljnih datotek"

#: C/gtkmm-tutorial-in.xml:8042(para)
msgid "In <filename>skeleton/src/Makefile.am</filename> we must mention the correct values for the generic variables that are used elsewhere in the build system:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8047(varname)
#, fuzzy
msgid "binding_name"
msgstr "Ime pravila:"

#: C/gtkmm-tutorial-in.xml:8048(para)
msgid "The name of the library, such as libsomethingmm."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8052(varname)
#, fuzzy
msgid "wrap_init_flags"
msgstr "Zastavice Fortran prevajalnika:"

#: C/gtkmm-tutorial-in.xml:8053(para)
msgid "Additional command-line flags passed to the <filename>generate_wrap_init.pl</filename> script, such as the C++ namespace and the parent directory prefix of include files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8060(para)
msgid "In <filename>skeleton/skeletonmm/Makefile.am</filename> we must mention the correct values for the generic variables that are used elsewhere in the build system:"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8065(varname)
msgid "lib_LTLIBRARIES"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8066(para)
msgid "This variable must mention the correct library name, and this library name must be used to form the <varname>_SOURCES</varname>, <varname>_LDFLAGS</varname>, and <varname>_LIBADD</varname> variable names. It is permissible to use variables substituted by <filename>configure</filename> like <varname>@SOMETHINGMM_API_VERSION@</varname> as part of the variable names."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8075(varname)
#, fuzzy
msgid "AM_CPPFLAGS"
msgstr "AM radio"

#: C/gtkmm-tutorial-in.xml:8076(para)
#, fuzzy
msgid "The command line options passed to the C preprocessor."
msgstr "Argumentu ukazne vrstice razvrstitve je bila podana neveljavna možnost."

#: C/gtkmm-tutorial-in.xml:8080(varname)
#, fuzzy
msgid "AM_CXXFLAGS"
msgstr "AM radio"

#: C/gtkmm-tutorial-in.xml:8081(para)
#, fuzzy
msgid "The command line options passed to the C++ compiler."
msgstr "Argumentu ukazne vrstice razvrstitve je bila podana neveljavna možnost."

#: C/gtkmm-tutorial-in.xml:8040(para)
msgid "Next we must adapt the various <filename>Makefile.am</filename> files: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8091(title)
msgid "Creating .hg and .ccg files"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8092(para)
msgid "We should now create our first <filename>.hg</filename> and <filename>.ccg</filename> files, to wrap one of the objects in the C library. One pair of example source files already exists: <filename>skeleton.ccg</filename> and <filename>skeleton.hg</filename>. Create copies of these files as necessary."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8096(para)
msgid "We must mention all of our <filename>.hg</filename> and <filename>.ccg</filename> files in the <filename>skeleton/src/filelist.am</filename> file, typically in the <varname>files_hg</varname> variable."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8100(para)
msgid "Any additional non-generated <filename>.h</filename> and <filename>.cc</filename> source files may be placed in <filename>skeleton/skeletonmm/</filename> and listed in <filename>skeleton/skeletonmm/filelist.am</filename>, typically in the <varname>files_extra_h</varname> and <varname>files_extra_cc</varname> variables."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8106(para)
msgid "In the <link linkend=\"sec-wrapping-hg-files\">.hg and .ccg files</link> section you can learn about the syntax used in these files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8113(title)
#, fuzzy
msgid "Generating the .defs files."
msgstr "Podrobnosti _ciljnih datotek"

#: C/gtkmm-tutorial-in.xml:8117(para)
msgid "objects (GObjects, widgets, interfaces, boxed-types and plain structs)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8118(para)
#, fuzzy
msgid "functions"
msgstr "Funkcije"

#: C/gtkmm-tutorial-in.xml:8119(para)
msgid "enums"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8120(para)
#, fuzzy
msgid "signals"
msgstr "Signali"

#: C/gtkmm-tutorial-in.xml:8121(para)
#, fuzzy
msgid "properties"
msgstr "lastnosti"

#: C/gtkmm-tutorial-in.xml:8122(para)
msgid "vfuncs"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8114(para)
msgid "The <filename>.defs</filename> file are text files, in a lisp format, that describe the API of a C library, including its <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8131(filename)
#, fuzzy
msgid "gtk.defs"
msgstr "Gtk+ zastarelo"

#: C/gtkmm-tutorial-in.xml:8132(para)
#, fuzzy
msgid "Includes the other files."
msgstr "<b>Drugi predogledi</b>"

#: C/gtkmm-tutorial-in.xml:8135(filename)
#, fuzzy
msgid "gtk_methods.defs"
msgstr "<b>Dovoljene metode overitve</b>"

#: C/gtkmm-tutorial-in.xml:8136(para)
#, fuzzy
msgid "Objects and functions."
msgstr "Listi in predmeti ..."

#: C/gtkmm-tutorial-in.xml:8139(filename)
#, fuzzy
msgid "gtk_enums.defs"
msgstr "Izvorni GTK+ projekt"

#: C/gtkmm-tutorial-in.xml:8140(para)
msgid "Enumerations."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8143(filename)
#, fuzzy
msgid "gtk_signals.defs"
msgstr "Pokaži signale jedra"

#: C/gtkmm-tutorial-in.xml:8144(para)
#, fuzzy
msgid "Signals and properties."
msgstr "Lastnosti in atributi"

#: C/gtkmm-tutorial-in.xml:8147(filename)
#, fuzzy
msgid "gtk_vfuncs.defs"
msgstr "Izvorni GTK+ projekt"

#: C/gtkmm-tutorial-in.xml:8148(para)
msgid "vfuncs (function pointer member fields in structs), written by hand."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8125(para)
msgid "At the moment, we have separate tools for generating different parts of these <filename>.defs</filename>, so we split them up into separate files. For instance, in the <filename>gtk/src</filename> directory of the <application>gtkmm</application> sources, you will find these files: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8154(title)
#, fuzzy
msgid "Generating the methods .defs"
msgstr "<b>Dovoljene metode overitve</b>"

#: C/gtkmm-tutorial-in.xml:8158(programlisting)
#, no-wrap
msgid ""
"\n"
"$ ./h2def.py /usr/include/gtk-2.0/gtk/*.h &gt; gtk_methods.defs\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8155(para)
msgid "This <filename>.defs</filename> file describes objects and their functions. It is generated by the <command>h2def.py</command> script which you can find in pygobject's <filename>codegen</filename> directory. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8165(title)
#, fuzzy
msgid "Generating the enums .defs"
msgstr "Ustvarjam seznam sporočil"

#: C/gtkmm-tutorial-in.xml:8169(programlisting)
#, no-wrap
msgid ""
"\n"
"$ ./enum.pl /usr/include/gtk-2.0/gtk/*.h &gt; gtk_enums.defs\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8166(para)
msgid "This <filename>.defs</filename> file describes enum types and their possible values. It is generated by the <filename>enum.pl</filename> script which you can find in glibmm's <filename>tools</filename> directory. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8176(title)
msgid "Generating the signals and properties .defs"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8181(programlisting)
#, no-wrap
msgid ""
"\n"
"$ cd tools/extra_defs_gen\n"
"$ ./generate_extra_defs &gt; gtk_signals.defs\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8177(para)
msgid "This <filename>.defs</filename> file describes signals and properties. It is generated by the special <filename>extra_defs</filename> utility that is in every wrapping project, such as <filename>gtkmm/tools/extra_defs_gen/</filename>. For instance <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8186(para)
msgid "You must edit the source code of your own <filename>generate_extra_defs</filename> tool in order to generate the <filename>.defs</filename> for the GObject C types that you wish to wrap. In the skeleton source tree, the source file is named <filename>codegen/extradefs/generate_extra_defs_skeleton.cc</filename>. If not done so already, the file should be renamed, with the basename of your new binding substituted for the <varname>skeleton</varname> placeholder. The <filename>codegen/Makefile.am</filename> file should also mention the new source filename."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8195(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;libsomething.h&gt;\n"
"\n"
"int main(int, char**)\n"
"{\n"
"  something_init();\n"
"\n"
"  std::cout &lt;&lt; get_defs(EXAMPLE_TYPE_SOMETHING)\n"
"            &lt;&lt; get_defs(EXAMPLE_TYPE_THING);\n"
"  return 0;\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8193(para)
msgid "Then edit the <filename>.cc</filename> file to specify the correct types. For instance, your <function>main()</function> function might look like this: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8211(title)
#, fuzzy
msgid "Writing the vfuncs .defs"
msgstr "Zapisovanje cue predloge"

#: C/gtkmm-tutorial-in.xml:8221(title)
#, fuzzy
msgid "The .hg and .ccg files"
msgstr "Uporabi popravke datotek in map."

#: C/gtkmm-tutorial-in.xml:8222(para)
msgid "The .hg and .ccg source files are very much like .h anc .cc C++ source files, but they contain extra macros, such as <function>_CLASS_GOBJECT()</function> and <function>_WRAP_METHOD()</function>, from which <command>gmmproc</command> generates appropriate C++ source code, usually at the same position in the header. Any additional C++ source code will be copied verbatim into the corresponding .h or .cc file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8235(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/bin.h&gt;\n"
"#include &lt;gtkmm/stockid.h&gt;\n"
"_DEFS(gtkmm,gtk)\n"
"_PINCLUDE(gtkmm/private/bin_p.h)\n"
"\n"
"namespace Gtk\n"
"{\n"
"\n"
"class Button : public Bin\n"
"{\n"
"  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
"public:\n"
"\n"
"  _CTOR_DEFAULT\n"
"  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
"  explicit Button(const StockID&amp; stock_id);\n"
"\n"
"  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
"};\n"
"\n"
"} // namespace Gtk\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8230(para)
msgid "A .hg file will typically include some headers and then declare a class, using some macros to add API or behaviour to this class. For instance, gtkmm's <filename>button.hg</filename> looks roughly like this: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8270(function)
msgid "_DEFS()"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8271(para)
msgid "Specifies the destination directry for generated sources, and the name of the main .defs file that <command>gmmproc</command> should parse."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8274(function)
msgid "_PINCLUDE()"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8275(para)
msgid "Tells <command>gmmproc</command> to include a header from the generated private/button_p.h file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8278(function)
#, fuzzy
msgid "_CLASS_GTKOBJECT()"
msgstr "Osnovni razred:"

#: C/gtkmm-tutorial-in.xml:8279(para)
msgid "Tells <command>gmmproc</command> to add some typedefs, constructors, and standard methods to this class, as appropriate when wrapping a GtkObject-derived type."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8282(term)
msgid "<function>_WRAP_METHOD()</function>, <function>_WRAP_SIGNAL()</function>, and <function>_WRAP_PROPERTY()</function>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8285(para)
msgid "Add methods to wrap parts of the C API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8267(para)
msgid "The macros in this example do the following: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8292(programlisting)
#, no-wrap
msgid ""
"\n"
"$ cd gtk/src\n"
"$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8289(para)
msgid "The .h and .cc files will be generated from the .hg and .ccg files by processing them with <command>gmmproc</command> like so, though this happens automatically when using the above build structure: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8297(para)
msgid "Notice that we provided <command>gmmproc</command> with the path to the .m4 convert files, the path to the .defs file, the name of a .hg file, the source directory, and the destination directory."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8300(para)
msgid "You should avoid including the C header from your C++ header, to avoid polluting the global namespace, and to avoid exporting unnecessary public API. But you will need to include the necessary C headers from your .ccg file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8305(para)
msgid "The macros are explained in more detail in the following sections."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8308(title)
#, fuzzy
msgid "m4 Conversions"
msgstr "Pretvorba podatkov"

#: C/gtkmm-tutorial-in.xml:8315(programlisting)
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8309(para)
msgid "The macros that you use in the .hg and .ccg files often need to know how to convert a C++ type to a C type, or vice-versa. gmmproc takes this information from an .m4 file in your <literal>tools/m4/</literal> directory. This allows it to call a C function in the implementation of your C++ method, passing the appropriate parameters to that C functon. For instance, this tells gmmproc how to convert a GtkTreeView pointer to a Gtk::TreeView pointer: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8320(para)
msgid "<literal>$3</literal> will be replaced by the parameter name when this conversion is used by gmmproc."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8327(programlisting)
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)\n"
"_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)\n"
"_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8324(para)
msgid "Some extra macros make this easier and consistent. Look in gtkmm's .m4 files for examples. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8337(title)
#, fuzzy
msgid "Class macros"
msgstr "Anjuta makroji"

#: C/gtkmm-tutorial-in.xml:8338(para)
msgid "The class macro declares the class itself and its relationship with the underlying C type. It generates some internal constructors, the member <varname>gobject_</varname>, typedefs, the <function>gobj()</function> accessors, type registration, and the <function>Glib::wrap()</function> method, among other things."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8343(para)
msgid "Other macros, such as <function>_WRAP_METHOD()</function> and <function>_SIGNAL()</function> may only be used after a call to a <function>_CLASS_*</function> macro."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8348(title)
#, fuzzy
msgid "_CLASS_GOBJECT"
msgstr "Razred GObject\t"

#: C/gtkmm-tutorial-in.xml:8349(para)
#: C/gtkmm-tutorial-in.xml:8439(para)
msgid "This macro declares a wrapper for a type that is derived from <classname>GObject</classname>, but which is not derived from <classname>GtkObject</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8352(function)
msgid "_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8354(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8353(para)
msgid "For instance, from <filename>accelgroup.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8361(title)
#, fuzzy
msgid "_CLASS_GTKOBJECT"
msgstr "Osnovni razred:"

#: C/gtkmm-tutorial-in.xml:8362(para)
msgid "This macro declares a wrapper for a type that is derived from <classname>GtkObject</classname>, such as a widget or dialog."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8364(function)
msgid "_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C base class )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8366(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8365(para)
#: C/gtkmm-tutorial-in.xml:8653(para)
#: C/gtkmm-tutorial-in.xml:8684(para)
msgid "For instance, from <filename>button.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8373(title)
#, fuzzy
msgid "_CLASS_BOXEDTYPE"
msgstr "Osnovni razred:"

#: C/gtkmm-tutorial-in.xml:8374(para)
msgid "This macro declares a wrapper for a non-<classname>GObject</classname> struct, registered with <function>g_boxed_type_register_static()</function>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8377(function)
msgid "_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free function )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8379(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE(Color, GdkColor, NONE, gdk_color_copy, gdk_color_free)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8378(para)
msgid "For instance, for <classname>Gdk::Color</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8386(title)
#, fuzzy
msgid "_CLASS_BOXEDTYPE_STATIC"
msgstr "Področje razreda (statično)"

#: C/gtkmm-tutorial-in.xml:8387(para)
msgid "This macro declares a wrapper for a simple assignable struct such as <classname>GdkRectangle</classname>. It is similar to <function>_CLASS_BOXEDTYPE</function>, but the C struct is not allocated dynamically."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8391(function)
#, fuzzy
msgid "_CLASS_BOXEDTYPE_STATIC( C++ class, C class )"
msgstr "Področje razreda (statično)"

#: C/gtkmm-tutorial-in.xml:8393(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8392(para)
msgid "For instance, for <classname>Gdk::Rectangle</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8400(title)
#, fuzzy
msgid "_CLASS_OPAQUE_COPYABLE"
msgstr "Nasledstvo osnovnega razreda:"

#: C/gtkmm-tutorial-in.xml:8401(para)
msgid "This macro declares a wrapper for an opaque struct that has copy and free functions. The new, copy and free functions will be used to instantiate the default constructor, copy constructor and destructor."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8404(function)
msgid "_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, free function )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8406(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_COPYABLE(Region, GdkRegion, gdk_region_new, gdk_region_copy, gdk_region_destroy)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8405(para)
msgid "For instance, for <classname>Gdk::Region</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8413(title)
#, fuzzy
msgid "_CLASS_OPAQUE_REFCOUNTED"
msgstr "Nasledstvo osnovnega razreda:"

#: C/gtkmm-tutorial-in.xml:8414(para)
msgid "This macro declares a wrapper for a reference-counted opaque struct. The C++ wrapper cannot be directly instantiated and can only be used with <classname>Glib::RefPtr</classname>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8417(function)
msgid "_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, ref function, unref function )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8419(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8418(para)
msgid "For instance, for <classname>Pango::Coverage</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8426(title)
#, fuzzy
msgid "_CLASS_GENERIC"
msgstr "Izvorni C++ razred"

#: C/gtkmm-tutorial-in.xml:8427(para)
msgid "This macro can be used to wrap structs which don't fit into any specialized category."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8429(function)
#, fuzzy
msgid "_CLASS_GENERIC( C++ class, C class )"
msgstr "Izvorni C++ razred"

#: C/gtkmm-tutorial-in.xml:8431(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GENERIC(AttrIter, PangoAttrIterator)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8430(para)
msgid "For instance, for <classname>Pango::AttrIter</classname>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8438(title)
#, fuzzy
msgid "_CLASS_INTERFACE"
msgstr "Implementira, razredno implementira določen vmesnik"

#: C/gtkmm-tutorial-in.xml:8443(function)
msgid "_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, Base C++ class (optional), Base C class (optional) )"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8446(programlisting)
#, no-wrap
msgid ""
"\n"
"  _CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8444(para)
msgid "For instance, from <filename>celleditable.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8453(programlisting)
#, no-wrap
msgid ""
"\n"
"  _CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8450(para)
msgid "Two extra parameters are optional, for the case that the interface derives from another interface, which should be the case when the GInterface has another GInterface as a prerequisitite. For instance, from <filename>loadableicon.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8463(title)
#, fuzzy
msgid "Constructor macros"
msgstr "Anjuta makroji"

#: C/gtkmm-tutorial-in.xml:8464(para)
msgid "The <function>_CTOR_DEFAULT()</function> and <function>_WRAP_CTOR()</function> macros add constructors, wrapping the specified <function>*_new()</function> C functions. These macros assume that the C object has properties with the same names as the function parameters, as is usually the case, so that it can supply the parameters directly to a <function>g_object_new()</function> call. These constructors never actually call the <function>*_new()</function> C functions, because gtkmm must actually instantiate derived GTypes, and the <function>*_new()</function> C functions are meant only as convenience functions for C programmers."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8479(programlisting)
#, no-wrap
msgid ""
"\n"
"class ActionGroup : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(ActionGroup, GtkActionGroup, GTK_ACTION_GROUP, Glib::Object, GObject)\n"
"\n"
"protected:\n"
"  _WRAP_CTOR(ActionGroup(const Glib::ustring&amp; name = Glib::ustring()), gtk_action_group_new)\n"
"\n"
"public:\n"
"  _WRAP_CREATE(const Glib::ustring&amp; name = Glib::ustring())\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8474(para)
msgid "When using <function>_CLASS_GOBJECT()</function>, the constructors should be protected (rather than public) and each constructor should have a corresponding <function>_WRAP_CREATE()</function> in the public section. This prevents the class from being instantiated without using a <classname>RefPtr</classname>. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8493(title)
#, fuzzy
msgid "_CTOR_DEFAULT"
msgstr "Privzeto stiskanje"

#: C/gtkmm-tutorial-in.xml:8494(para)
msgid "This macro creates a default constructor with no arguments."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8499(title)
#, fuzzy
msgid "_WRAP_CTOR"
msgstr "Opravila preloma vrstic"

#: C/gtkmm-tutorial-in.xml:8500(para)
msgid "This macro creates a constructor with arguments, equivalent to a <function>*_new()</function> C function. It won't actually call the <function>*_new()</function> function, but will simply create an equivalent constructor with the same argument types. It takes a C++ constructor signature, and a C function name."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8509(title)
#, fuzzy
msgid "Hand-coding constructors"
msgstr "_Kodiranje znakov:"

#: C/gtkmm-tutorial-in.xml:8518(programlisting)
#, no-wrap
msgid ""
"\n"
"Button::Button(const Glib::ustring&amp; label, bool mnemonic)\n"
":\n"
"  _CONSTRUCT(\"label\", label.c_str(), \"use_underline\", gboolean(mnemonic))\n"
"{}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8510(para)
msgid "When a constructor must be partly hand written because, for instance, the <function>*_new()</function> C function's parameters do not correspond directly to object properties, or because the <function>*_new()</function> C function does more than call <function>g_object_new()</function>, the <function>_CONSTRUCT()</function> macro may be used in the .ccg file to save some work. The <function>_CONSTRUCT</function> macro takes a series of property names and values. For instance, from <filename>button.ccg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8530(title)
#, fuzzy
msgid "Method macros"
msgstr "Anjuta makroji"

#: C/gtkmm-tutorial-in.xml:8533(title)
#, fuzzy
msgid "_WRAP_METHOD"
msgstr "Način razdeljevanja"

#: C/gtkmm-tutorial-in.xml:8534(para)
msgid "This macro generates the C++ method to wrap a C function."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8535(function)
msgid "_WRAP_METHOD( C++ method signature, C function name)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8537(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8536(para)
msgid "For instance, from <filename>entry.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8541(para)
msgid "The C function (e.g. <function>gtk_entry_set_text</function>) is described more fully in the .defs file, and the <filename>convert*.m4</filename> files contain the necessary conversion from the C++ parameter type to the C parameter type. This macro also generates doxygen documentation comments based on the <filename>*_docs.xml</filename> and <filename>*_docs_override.xml</filename> files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8550(term)
msgid "refreturn"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8552(para)
msgid "Do an extra reference() on the return value, in case the C function does not provide a reference."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8557(term)
msgid "errthrow"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8559(para)
msgid "Use the last GError* parameter of the C function to throw an exception."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8564(term)
#, fuzzy
msgid "deprecated"
msgstr "Zastarelo"

#: C/gtkmm-tutorial-in.xml:8566(para)
msgid "Puts the generated code in #ifdef blocks. Text about the deprecation can be specified as an optional parameter."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8572(term)
msgid "constversion"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8574(para)
msgid "Just call the non-const version of the same function, instead of generating almost duplicate code."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8547(para)
#: C/gtkmm-tutorial-in.xml:8661(para)
msgid "There are some optional extra arguments: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8582(para)
msgid "Objects used via <classname>RefPtr</classname>: Pass the <classname>RefPtr</classname> as a const reference. For instance, <code>const Glib::RefPtr&lt;Gtk::Action&gt;&amp; action</code>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8586(para)
msgid "Const Objects used via <classname>RefPtr</classname>: If the object should not be changed by the function, then make sure that the object is const, even if the <classname>RefPtr</classname> is already const. For instance, <code>const Glib::RefPtr&lt;const Gtk::Action&gt;&amp; action</code>."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8591(para)
msgid "Wrapping <classname>GList*</classname> and <classname>GSList*</classname> parameters: First, you need to discover what objects are contained in the list's data field for each item, usually by reading the documentation for the C function. The list can then be wrapped by an appropriate intermediate type, such as <classname>Glib::ListHandle</classname> or <classname>Glib::SListHandle</classname>. These are templates, so you can specify the item type. For instance, <code>Glib::ListHandle&lt; Glib::RefPtr&lt;Action&gt; &gt;</code>. Existing typedefs exist for some common list types. You may need to define a Traits type to specify how the C and C++ types should be converted."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8610(programlisting)
#, no-wrap
msgid "#m4 _CONVERSION(`GSList*', `Glib::SListHandle&lt;Widget*&gt;', `$2($3, Glib::OWNERSHIP_NONE)')"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8602(para)
msgid "Wrapping <classname>GList*</classname> and <classname>GSList*</classname> return types: You must discover whether the caller should free the list and whether it should release the items in the list, again by reading the documentation of the C function. With this information you can choose the ownership (none, shallow or deep) for the m4 conversion rule, which you should probably put directly into the .hg file because the ownership depends on the function rather than the type. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8580(para)
msgid "Though it's usually obvious what C++ types should be used in the C++ method, here are some hints: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8616(title)
msgid "_WRAP_METHOD_DOCS_ONLY"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8617(para)
msgid "This macro is like <function>_WRAP_METHOD()</function>, but it generates only the documentation for a C++ method that wraps a C function. Use this when you must hand-code the method, but you want to use the documentation that would be generated if the method was generated."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8621(function)
msgid "_WRAP_METHOD_DOCS_ONLY(C function name)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8623(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8622(para)
msgid "For instance, from <filename>container.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8630(title)
#, fuzzy
msgid "_IGNORE()"
msgstr "Prezri"

#: C/gtkmm-tutorial-in.xml:8631(para)
msgid "<command>gmmproc</command> will warn you on stdout about functions that you have forgotten to wrap, helping to ensure that you are wrapping the complete API. Buf if you don't want to wrap some functions or if you chose to hand-code some methods then you can use the _IGNORE() macro the make <command>gmmproc</command> stop complaining."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8636(function)
msgid "_IGNORE(C function name 1, C function name2, etc)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8638(programlisting)
#, no-wrap
msgid ""
"\n"
"_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing,\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8637(para)
msgid "For instance, from <filename>buttonbox.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8645(title)
#, fuzzy
msgid "_WRAP_SIGNAL"
msgstr "Signalna dejanja"

#: C/gtkmm-tutorial-in.xml:8646(para)
msgid "This macro generates the C++ libsigc++-style signal to wrap a C GObject signal. It actually generates a public accessor method, such as <function>signal_clicked()</function>, which returns a proxy object. <command>gmmproc</command> uses the .defs file to discover the C parameter types and the .m4 convert files to discover appropriate type conversions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8652(function)
msgid "_WRAP_SIGNAL( C++ signal handler signature, C signal name)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8654(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_SIGNAL(void clicked(),\"clicked\")\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8658(para)
msgid "Signals usually have function pointers in the GTK struct, with a corresponding enum value. and a <function>g_signal_new()</function> in the .c file."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8664(term)
#, fuzzy
msgid "no_default_handler"
msgstr "ni privzetega profila"

#: C/gtkmm-tutorial-in.xml:8666(para)
msgid "Do not generate an <function>on_something()</function> virtual method to allow easy overriding of the default signal handler. Use this when adding a signal with a default signal handler would break the ABI by increasing the size of the class's virtual function table."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8678(title)
#, fuzzy
msgid "_WRAP_PROPERTY"
msgstr "Orodna vrstica lastnosti"

#: C/gtkmm-tutorial-in.xml:8679(para)
msgid "This macro generates the C++ method to wrap a C GObject property. You must specify the property name and the wanted C++ type for the property. <command>gmmproc</command> uses the .defs file to discover the C type and the .m4 convert files to discover appropriate type conversions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8683(function)
#, fuzzy
msgid "_WRAP_PROPERTY(C property name, C++ type)"
msgstr "<b>Vrsta:</b> %s <b>Ime odstopne točke:</b> %s"

#: C/gtkmm-tutorial-in.xml:8685(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_PROPERTY(\"label\", Glib::ustring)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8694(title)
#, fuzzy
msgid "Other macros"
msgstr "Anjuta makroji"

#: C/gtkmm-tutorial-in.xml:8696(title)
#, fuzzy
msgid "_WRAP_ENUM"
msgstr "Opravila preloma vrstic"

#: C/gtkmm-tutorial-in.xml:8697(para)
msgid "This macro generates a C++ enum to wrap a C enum. You must specify the desired C++ name and the name of the underlying C enum."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8700(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(WindowType, GdkWindowType)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8699(para)
msgid "For instance, from <filename>widget.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8704(para)
msgid "If the enum is not a <classname>GType</classname>, you must pass a third parameter NO_GTYPE. This is the case when there is no <function>*_get_type()</function> function for the C enum, but be careful that you don't just need to include an extra header for that function. You should also file a bug against the C API, because all enums should be registered as GTypes."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8709(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8708(para)
#, fuzzy
msgid "For example: <placeholder-1/>"
msgstr "Držalo logičnega držala"

#: C/gtkmm-tutorial-in.xml:8716(title)
#, fuzzy
msgid "_WRAP_GERROR"
msgstr "Opravila preloma vrstic"

#: C/gtkmm-tutorial-in.xml:8717(para)
msgid "This macro generates a C++ exception class, derived from Glib::Error, with a Code enum and a code() method. You must specify the desired C++ name, the name of the corresponding C enum, and the prefix for the C enum values."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8720(para)
msgid "This exception can then be thrown by methods which are generated from _WRAP_METHOD() with the errthrow option."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8722(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8721(para)
msgid "For instance, from <filename>pixbuf.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8729(title)
#, fuzzy
msgid "_MEMBER_GET / _MEMBER_SET"
msgstr "| volume [X] . . . . . . . . . .  nastavi/izpiši glasnost"

#: C/gtkmm-tutorial-in.xml:8730(para)
msgid "Use these macro if you're wrapping a simple struct or boxed type that provides direct access to its data members, to create getters and setters for the data members."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8734(function)
#, fuzzy
msgid "_MEMBER_GET(C++ name, C name, C++ type, C type)"
msgstr "<b>Vrsta:</b> %s <b>Ime odstopne točke:</b> %s"

#: C/gtkmm-tutorial-in.xml:8735(function)
#, fuzzy
msgid "_MEMBER_SET(C++ name, C name, C++ type, C type)"
msgstr "<b>Vrsta:</b> %s <b>Ime odstopne točke:</b> %s"

#: C/gtkmm-tutorial-in.xml:8738(programlisting)
#, fuzzy, no-wrap
msgid "_MEMBER_GET(x, x, int, int)"
msgstr "Pričakoval celo število, dobil %s"

#: C/gtkmm-tutorial-in.xml:8736(para)
msgid "For example, in <filename>rectangle.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8742(title)
#, fuzzy
msgid "_MEMBER_GET_PTR / _MEMBER_SET_PTR"
msgstr "| volume [X] . . . . . . . . . .  nastavi/izpiši glasnost"

#: C/gtkmm-tutorial-in.xml:8743(para)
msgid "Use these macros to automatically provide getters and setters for a data member that is a pointer type. For the getter function, it will create two methods, one const and one non-const."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8748(function)
msgid "_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8749(function)
msgid "_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8751(programlisting)
#, no-wrap
msgid ""
"\n"
"_MEMBER_GET_PTR(vbox, vbox, VBox*, GtkWidget*)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8750(para)
msgid "For example, in <filename>dialog.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8757(title)
#, fuzzy
msgid "_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT"
msgstr "| volume [X] . . . . . . . . . .  nastavi/izpiši glasnost"

#: C/gtkmm-tutorial-in.xml:8758(para)
msgid "Use this macro to provide getters and setters for a data member that is a <classname>GObject</classname> type that must be referenced before being returned."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8763(function)
msgid "_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8764(function)
msgid "_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8766(programlisting)
#, no-wrap
msgid ""
"\n"
"_MEMBER_GET_GOBJECT(offscreen_pixmap, offscreen_pixmap, Gdk::Pixmap, GdkPixmap*)\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8765(para)
msgid "For example, in <filename>progress.hg</filename>: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8773(title)
#, fuzzy
msgid "Basic Types"
msgstr "Vrste prejemanja"

#: C/gtkmm-tutorial-in.xml:8774(para)
msgid "Some of the basic types that are used in C APIs have better alternatives in C++. For example, there's no need for a <type>gboolean</type> type since C++ has <type>bool</type>. The following list shows some commonly-used types in C APIs and what you might convert them to in a C++ wrapper library."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8779(title)
#, fuzzy
msgid "Basic Type equivalents"
msgstr "Prepreči sporočila vrste:"

#: C/gtkmm-tutorial-in.xml:8781(segtitle)
#, fuzzy
msgid "C type"
msgstr "Vrsta: "

#: C/gtkmm-tutorial-in.xml:8782(segtitle)
#, fuzzy
msgid "C++ type"
msgstr "Vrsta: "

#: C/gtkmm-tutorial-in.xml:8783(type)
msgid "gboolean"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8783(type)
#, fuzzy
msgid "bool"
msgstr "Pričakoval booleanovo vrednost, dobil %s"

#: C/gtkmm-tutorial-in.xml:8784(type)
msgid "gint"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8784(type)
#, fuzzy
msgid "int"
msgstr "Pričakoval celo število, dobil %s"

#: C/gtkmm-tutorial-in.xml:8785(type)
msgid "guint"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8786(type)
msgid "gdouble"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8786(type)
#, fuzzy
msgid "double"
msgstr "dvojno"

#: C/gtkmm-tutorial-in.xml:8787(type)
msgid "gunichar"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8788(type)
msgid "gchar*"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8788(classname)
#, fuzzy
msgid "std::string"
msgstr "Parametri niti"

#: C/gtkmm-tutorial-in.xml:8788(seg)
#, fuzzy
msgid "<placeholder-1/> (or <placeholder-2/> for filenames)"
msgstr "Za namestitev ali nadgradnjo"

#: C/gtkmm-tutorial-in.xml:8795(title)
#, fuzzy
msgid "Hand-coded source files"
msgstr "Ni mogoče dodati izvornih datotek"

#: C/gtkmm-tutorial-in.xml:8796(para)
msgid "You might want to include additional source files that will not be generated by <command>gmmproc</command> from <filename>.hg</filename> and <filename>.ccg</filename> files. You can simply place these in your <filename>libsomething/libsomethingmm</filename> directory and mention them in the <filename>Makefile.am</filename> in the <varname>files_extra_h</varname> and <varname>files_extra_cc</varname> variables."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8806(title)
#, fuzzy
msgid "Initialization"
msgstr "%d: Inicializacija protokola\n"

#: C/gtkmm-tutorial-in.xml:8815(programlisting)
#, no-wrap
msgid ""
"\n"
"void init()\n"
"{\n"
"  Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.\n"
"  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8807(para)
msgid "Your library must be initialized before it can be used, to register the new types that it makes available. Also, the C library that you are wrapping might have its own initialization function that you should call. You can do this in an <function>init()</function> function that you can place in hand-coded <filename>init.h</filename> and <filename>init.cc</filename> files. This function should initialize your dependencies (such as the C function, and <application>gtkmm</application>) and call your generated <function>wrap_init()</function> function. For instance: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8823(para)
msgid "The implementation of the <function>wrap_init()</function> method in <filename>wrap_init.cc</filename> is generated by <filename>generate_wrap_init.pl</filename>, but the declaration in <filename>wrap_init.h</filename> is hand-coded, so you will need to adjust <filename>wrap_init.h</filename> so that the <function>init()</function> function appears in the correct C++ namespace."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8832(title)
#, fuzzy
msgid "Problems in the C API."
msgstr "Prebrskaj API strani"

#: C/gtkmm-tutorial-in.xml:8833(para)
msgid "You are likely to encounter some problems in the library that you are wrapping, particularly if it is a new project. Here are some common problems, with solutions."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8835(title)
#, fuzzy
msgid "Unable to predeclare structs"
msgstr "Ni mogoče izbrisati datoteke"

#: C/gtkmm-tutorial-in.xml:8837(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _ExampleWidget ExampleWidget;\n"
"\n"
"struct _ExampleWidget\n"
"{\n"
"  ...\n"
"};\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8836(para)
msgid "By convention, structs are declared in glib/GTK+-style headers like so: <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8846(para)
msgid "The extra typedef allows the struct to be used in a header without including its full defintion, simply by predeclaring it, by repeating that typedef. This means that you don't have to include the C library's header in your C++ header, thus keeping it out of your public API. <command>gmmproc</command> assumes that this technique was used, so you will see compiler errors if that is not the case."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8849(programlisting)
#, no-wrap
msgid ""
"\n"
"example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'\n"
"../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here\n"
"make[4]: *** [example-widget.lo] Error 1\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8855(programlisting)
#, no-wrap
msgid ""
"\n"
"example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol\n"
"../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8847(para)
msgid "This compiler error might look like this: <placeholder-1/> or this: <placeholder-2/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8860(para)
msgid "This is easy to correct in the C library, so do send a patch to the relevant maintainer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8864(title)
#, fuzzy
msgid "Lack of properties"
msgstr "Lastnosti prekinitvene točke"

#: C/gtkmm-tutorial-in.xml:8871(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        return g_object_new (EXAMPLE_TYPE_WIDGET, \"something\", something, \"thing\", thing, NULL);\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8865(para)
msgid "By convention, glib/GTK+-style objects have <function>*_new()</function> functions, such as <function>example_widget_new()</function> that do nothing more than call <function>g_object_new()</function> and return the result. The input parameters are supplied to <function>g_object_new()</function> along with the names of the properties for which they are values. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8878(para)
msgid "This allows language bindings to implement their own equivalents (such as C++ constructors), without using the <function>*_new()</function> function. This is often necessary so that they can actually instantiate a derived GType, to add their own hooks for signal handlers and vfuncs."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8882(para)
msgid "At the least, the <function>_new()</function> function should not use any private API (functions that are only in a .c file). Even when there are no functions, we can sometimes reimplement 2 or 3 lines of code in a <function>_new()</function> function as long as those lines of code use API that is available to us."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8890(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        ExampleWidget* widget;\n"
"        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);\n"
"        example_widget_construct(widget, \"something\", something, \"thing\", thing);\n"
"}\n"
"\n"
"void example_widget_construct(ExampleWidget* widget, int something, const char* thing)\n"
"{\n"
"        //Do stuff that uses private API:\n"
"        widget-&gt;priv-&gt;thing = thing;\n"
"        do_something(something);\n"
"}\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8887(para)
msgid "Another workaround is to add a <function>*_construct()</function> function that the C++ constructor can call after instantiating its own type. For instance, <placeholder-1/>"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8906(para)
msgid "Adding properties, and ensuring that they interact properly with each other, is relatively difficult to correct in the C library, but it is possible, so do file a bug and try to send a patch to the relevant maintainer."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8914(title)
#, fuzzy
msgid "Documentation"
msgstr "Dokumentacija"

#: C/gtkmm-tutorial-in.xml:8915(para)
msgid "In general, gtkmm-style projects use Doxygen, which reads specially formatted C++ comments and generates HTML documentation. You may write these doxygen comments directly in the header files."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8918(title)
#, fuzzy
msgid "Reusing C documentation"
msgstr "Man dokumentacija"

#: C/gtkmm-tutorial-in.xml:8919(para)
msgid "You might wish to reuse documentation that exists for the C library that you are wrapping. GTK-style C libraries typically use gtk-doc and therefore have source code comments formatted for gtk-doc and some extra documentation in .tmpl files. The docextract_to_xml.py script, from pygobject's codegen directory, can read these files and generate an .xml file that <command>gmmproc</command> can use to generate doxygen comments. <command>gmmproc</command> will even try to transform the documentation to make it more appropriate for a C++ API."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8922(programlisting)
#, no-wrap
msgid "./docextract_to_xml.py -s /gnome/head/cvs/gtk+/gtk/ -s /gnome/head/cvs/gtk+/docs/reference/gtk/tmpl/ &gt; gtk_docs.xml\n"
msgstr ""

#: C/gtkmm-tutorial-in.xml:8925(para)
msgid "Because this automatic transformation is not always appropriate, you might want to provide hand-written text for a particular method. You can do this by copying the XML node for the function from your <filename>something_docs.xml</filename> file to the <filename>something_docs_override.xml</filename> file and changing the contents."
msgstr ""

#: C/gtkmm-tutorial-in.xml:8934(title)
#, fuzzy
msgid "Documentation build structure"
msgstr "GladeWidgetActionClass struktura kazalnika"

#: C/gtkmm-tutorial-in.xml:8935(para)
msgid "If you copied the skeleton source tree in mm-common and substituted the placeholder text, then you will already have suitable <filename>Makefile.am</filename> and <filename>Doxyfile.in</filename> files. With the mm-common build setup, the list of Doxygen input files is not defined in the Doxygen configuration file, but passed along from <command>make</command> to the standard input of <command>doxygen</command>. The input file list is defined by the <varname>doc_input</varname> variable in the <filename>Makefile.am</filename> file."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: C/gtkmm-tutorial-in.xml:0(None)
#, fuzzy
msgid "translator-credits"
msgstr "Matej Urbančič"

#~ msgid "Alan"
#~ msgstr "Alan"
#~ msgid "Ott"
#~ msgstr "Ott"

