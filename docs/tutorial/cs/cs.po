# Czech translation for gtkmm-documentation.
# Copyright (C) 2015 gtkmm-documentation's COPYRIGHT HOLDER
# This file is distributed under the same license as the gtkmm-documentation package.
# Marek Černocký <marek@manet.cz>, 2015, 2016, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: gtkmm-documentation master\n"
"POT-Creation-Date: 2014-04-03 21:30+0000\n"
"PO-Revision-Date: 2017-10-17 20:58+0200\n"
"Last-Translator: Marek Černocký <marek@manet.cz>\n"
"Language-Team: čeština <gnome-cs-list@gnome.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: cs\n"
"Plural-Forms: nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;\n"
"X-Generator: Gtranslator 2.91.7\n"

#: C/gtkmm-tutorial-in.xml:34(title)
msgid "Programming with <application>gtkmm</application> 3"
msgstr "Programování s <application>gtkmm</application> 3"

#: C/gtkmm-tutorial-in.xml:38(firstname)
msgid "Murray"
msgstr "Murray"

#: C/gtkmm-tutorial-in.xml:39(surname)
msgid "Cumming"
msgstr "Cumming"

#: C/gtkmm-tutorial-in.xml:42(firstname)
msgid "Bernhard"
msgstr "Bernhard"

#: C/gtkmm-tutorial-in.xml:43(surname)
msgid "Rieder"
msgstr "Rieder"

#: C/gtkmm-tutorial-in.xml:44(contrib)
msgid "Chapter on \"Timeouts\"."
msgstr "Kapitola „Časovače“"

#: C/gtkmm-tutorial-in.xml:47(firstname)
msgid "Jonathon"
msgstr "Jonathon"

#: C/gtkmm-tutorial-in.xml:48(surname)
msgid "Jongsma"
msgstr "Jongsma"

#: C/gtkmm-tutorial-in.xml:49(contrib)
msgid "Chapter on \"Drawing with Cairo\"."
msgstr "Kapitola „Kreslení s Cairo“"

#: C/gtkmm-tutorial-in.xml:50(contrib)
msgid "Chapter on \"Working with gtkmm's Source Code\"."
msgstr "Kapitola „Práce se zdrojovými kódy gtkmm“"

#: C/gtkmm-tutorial-in.xml:51(contrib)
msgid "Chapter on \"Recent Files\"."
msgstr "Kapitola „Nedávné soubory“"

#: C/gtkmm-tutorial-in.xml:54(firstname)
msgid "Ole"
msgstr "Ole"

#: C/gtkmm-tutorial-in.xml:55(surname)
msgid "Laursen"
msgstr "Laursen"

#: C/gtkmm-tutorial-in.xml:56(contrib) C/gtkmm-tutorial-in.xml:62(contrib)
msgid "Parts of chapter on \"Internationalization\"."
msgstr "Části kapitoly „Internacionalizace“"

#: C/gtkmm-tutorial-in.xml:59(firstname)
msgid "Marko"
msgstr "Marko"

#: C/gtkmm-tutorial-in.xml:60(surname)
msgid "Anastasov"
msgstr "Anastasov"

#: C/gtkmm-tutorial-in.xml:61(contrib)
msgid "Chapter on \"Printing\"."
msgstr "Kapitola „Tisk“"

#: C/gtkmm-tutorial-in.xml:65(firstname)
msgid "Daniel"
msgstr "Daniel"

#: C/gtkmm-tutorial-in.xml:66(surname)
msgid "Elstner"
msgstr "Elstner"

#: C/gtkmm-tutorial-in.xml:67(contrib)
msgid ""
"Section \"Build Structure\" of chapter on \"Wrapping C Libraries with gmmproc"
"\"."
msgstr ""
"Oddíl „Struktura sestavení“ v kapitole „Obalování knihoven C pomocí gmmproc“"

#: C/gtkmm-tutorial-in.xml:71(firstname)
msgid "Chris"
msgstr "Chris"

#: C/gtkmm-tutorial-in.xml:72(surname)
msgid "Vine"
msgstr "Vine"

#: C/gtkmm-tutorial-in.xml:73(contrib)
msgid "Chapter on \"Multi-threaded programs\"."
msgstr "Kapitola „Vícevláknové programování“"

#: C/gtkmm-tutorial-in.xml:76(firstname)
msgid "David"
msgstr "David"

#: C/gtkmm-tutorial-in.xml:77(surname)
msgid "King"
msgstr "King"

#: C/gtkmm-tutorial-in.xml:78(contrib)
msgid "Section on Gtk::Grid."
msgstr "Oddíl v Gtk::Grid."

#: C/gtkmm-tutorial-in.xml:81(firstname)
msgid "Pedro"
msgstr "Pedro"

#: C/gtkmm-tutorial-in.xml:82(surname)
msgid "Ferreira"
msgstr "Ferreira"

#: C/gtkmm-tutorial-in.xml:83(contrib)
msgid "Chapter on Keyboard Events."
msgstr "Kapitola v Události klávesnice."

#: C/gtkmm-tutorial-in.xml:86(firstname)
msgid "Kjell"
msgstr "Kjell"

#: C/gtkmm-tutorial-in.xml:87(surname)
msgid "Ahlstedt"
msgstr "Ahlstedt"

#: C/gtkmm-tutorial-in.xml:88(contrib)
msgid "Parts of the update from gtkmm 2 to gtkmm 3."
msgstr "Části v aktualizaci z gtkmm2 na gtkmm 3."

#. This text is copied from the introduction.
#: C/gtkmm-tutorial-in.xml:95(para)
msgid ""
"This book explains key concepts of the <application>gtkmm</application> C++ "
"API for creating user interfaces. It also introduces the main user interface "
"elements (\"widgets\")."
msgstr ""
"Tato kniha vysvětluje klíčové koncepty <application>gtkmm</application>, což "
"je API C++ pro vytváření uživatelského rozhraní. Seznamuje také v hlavními "
"prvky uživatelského rozhraní, tzv. widgety."

#: C/gtkmm-tutorial-in.xml:101(year)
msgid "2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010"
msgstr "2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010"

#: C/gtkmm-tutorial-in.xml:102(holder)
msgid "Murray Cumming"
msgstr "Murray Cumming"

#: C/gtkmm-tutorial-in.xml:106(para)
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.2 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, no Front-Cover Texts, and no Back-Cover Texts. You may obtain a "
"copy of the GNU Free Documentation License from the Free Software Foundation "
"by visiting their Web site or by writing to: Free Software Foundation, Inc., "
"59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."
msgstr ""
"Je povoleno kopírovat, šířit a/nebo upravovat tento dokument za podmínek GNU "
"Free Documentation License (GFDL) ve verzi 1.2 nebo v jakékoli novější verzi "
"vydané nadací Free Software Foundation; bez neměnných oddílů, bez textů "
"předních desek a bez textů zadních desek. Znění licence GNU Free "
"Documentation License můžete získat od organizace Free Software Foundation "
"na jejích webových stránkách, nebo si o ni napište na adresu: Free Software "
"Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA."

#: C/gtkmm-tutorial-in.xml:118(title)
msgid "Introduction"
msgstr "Úvod"

#: C/gtkmm-tutorial-in.xml:121(title)
msgid "This book"
msgstr "O této knize"

#: C/gtkmm-tutorial-in.xml:123(para)
msgid ""
"This book explains key concepts of the <application>gtkmm</application> C++ "
"API for creating user interfaces. It also introduces the main user interface "
"elements (\"widgets\"). Although it mentions classes, constructors, and "
"methods, it does not go into great detail. Therefore, for full API "
"information you should follow the links into the reference documentation."
msgstr ""
"Tato kniha vysvětluje klíčové koncepty <application>gtkmm</application>, což "
"je API C++ pro vytváření uživatelského rozhraní. Seznamuje také v hlavními "
"prvky uživatelského rozhraní, tzv. widgety. I když jsou zmíněny třídy, "
"konstruktory a metody, nezachází do přílišných podrobností. Je to proto, že "
"úplné informace o API byste měli hledat v odkazované referenční dokumentaci."

#: C/gtkmm-tutorial-in.xml:125(para)
msgid ""
"This book assumes a good understanding of C++, and how to create C++ "
"programs."
msgstr ""
"Pro čtení této knihy se předpokládá dobrá znalost jazyka C++, včetně "
"znalosti jak v C++ vytvořit program."

#: C/gtkmm-tutorial-in.xml:127(para)
msgid ""
"We would very much like to hear of any problems you have learning "
"<application>gtkmm</application> with this document, and would appreciate "
"input regarding improvements. Please see the <link linkend=\"chapter-"
"contributing\">Contributing</link> section for further information."
msgstr ""
"Rádi bychom se dozvěděli, když budete mít problém se studiem "
"<application>gtkmm</application> podle tohoto dokumentu a odměnou za to vám "
"bude jeho vylepšení. Na více informací se prosím podívejte do kapitoly <link "
"linkend=\"chapter-contributing\">Přispívání</link>."

#: C/gtkmm-tutorial-in.xml:134(title)
msgid "gtkmm"
msgstr "gtkmm"

#: C/gtkmm-tutorial-in.xml:135(para)
msgid ""
"<application>gtkmm</application> is a C++ wrapper for <ulink url=\"http://"
"www.gtk.org/\">GTK+</ulink>, a library used to create graphical user "
"interfaces. It is licensed using the LGPL license, so you can develop open "
"software, free software, or even commercial non-free software using "
"<application>gtkmm</application> without purchasing licenses."
msgstr ""
"<application>gtkmm</application> je obalení knihovny <ulink url=\"http://www."
"gtk.org/\">GTK+</ulink> pro jazyk C++. Tato knihovna slouží k vytváření "
"grafického uživatelského rozhraní. <application>gtkmm</application> je "
"licencováno pod LGPL, takže s jeho pomocí můžete vyvíjet otevřený software, "
"svobodný software nebo i komerční nesvobodný software aniž byste museli "
"platit za licence."

#: C/gtkmm-tutorial-in.xml:143(para)
msgid ""
"<application>gtkmm</application> was originally named gtk-- because GTK+ "
"already has a + in the name. However, as -- is not easily indexed by search "
"engines the package generally went by the name <application>gtkmm</"
"application>, and that's what we stuck with."
msgstr ""
"<application>gtkmm</application> se původně jmenovalo gtk--, protoge + už GTK"
"+ ve svém názvu má. Protože ale s -- je problém ve vyhledávačích, býval "
"balíček většinou pojmenován <application>gtkmm</application>, a u toho "
"nakonec zůstalo."

#: C/gtkmm-tutorial-in.xml:146(title)
msgid "Why use <application>gtkmm</application> instead of GTK+?"
msgstr "Proč používat <application>gtkmm</application> místo GTK+?"

#: C/gtkmm-tutorial-in.xml:147(para)
msgid ""
"<application>gtkmm</application> allows you to write code using normal C++ "
"techniques such as encapsulation, derivation, and polymorphism. As a C++ "
"programmer you probably already realise that this leads to clearer and "
"better organized code."
msgstr ""
"<application>gtkmm</application> umožňuje psát kód pomocí běžných technik C+"
"+, jako je zapouzdření, dědičnost a polymorfizmus. Jako programátor v C++ "
"jste již nejspíše zjistili, že to vede k jasnějšímu a přehlednějšímu "
"programovému kódu."

#: C/gtkmm-tutorial-in.xml:148(para)
msgid ""
"<application>gtkmm</application> is more type-safe, so the compiler can "
"detect errors that would only be detected at run time when using C. This use "
"of specific types also makes the API clearer because you can see what types "
"should be used just by looking at a method's declaration."
msgstr ""
"<application>gtkmm</application> je také typově bezpečnější, takže "
"kompilátor může odhalit chyby, které by při použití C šli odhalit jen za "
"běhu. Používání konkrétnějších typů také zpřehledňuje celé API, protože "
"můžete zjistit, které typy by měly být použity, jednoduše pohledem do "
"deklarace metody."

#: C/gtkmm-tutorial-in.xml:149(para)
msgid ""
"Inheritance can be used to derive new widgets. The derivation of new widgets "
"in GTK+ C code is so complicated and error prone that almost no C coders do "
"it. As a C++ developer you know that derivation is an essential Object "
"Orientated technique."
msgstr ""
"K odvozování nových widgetů můžete použít dědičnost. Odvozování nových "
"widgetů v kódu GTK+ v jazyce C je komplikované a náchylné na chyby, které "
"většina programátorů jiných jazyků při použití C dělá. Jako programátor v C+"
"+ víte, že odvozování s pomocí dědičnosti je základní technikou objektového "
"programování."

#: C/gtkmm-tutorial-in.xml:150(para)
msgid ""
"Member instances can be used, simplifying memory management. All GTK+ C "
"widgets are dealt with by use of pointers. As a C++ coder you know that "
"pointers should be avoided where possible."
msgstr ""
"Pro zjednodušení správy paměti můžete používat členské instance. Všechny "
"widgety GTK+ v C s nimi zachází pomocí ukazatelů. Jako programátor v C++ "
"víte, že ukazatelům byste se měli vyhnout, kdekoliv je to možné."

#: C/gtkmm-tutorial-in.xml:151(para)
msgid ""
"<application>gtkmm</application> involves less code compared to GTK+, which "
"uses prefixed function names and lots of cast macros."
msgstr ""
"<application>gtkmm</application> vyžaduje méně kódu ve srovnání s GTK+, "
"které používá názvy funkcí s prefixy a spoustu přetypovacích maker."

#: C/gtkmm-tutorial-in.xml:155(title)
msgid "<application>gtkmm</application> compared to Qt"
msgstr "<application>gtkmm</application> ve srovnání s Qt"

#: C/gtkmm-tutorial-in.xml:156(para)
msgid ""
"Trolltech's Qt is the closest competition to <application>gtkmm</"
"application>, so it deserves discussion."
msgstr ""
"Nejbližší konkurencí <application>gtkmm</application> je Qt od Trolltechu, "
"takže se na něj pojďme podívat blíže."

#: C/gtkmm-tutorial-in.xml:158(para)
msgid ""
"<application>gtkmm</application> developers tend to prefer "
"<application>gtkmm</application> to Qt because <application>gtkmm</"
"application> does things in a more C++ way. Qt originates from a time when C+"
"+ and the standard library were not standardised or well supported by "
"compilers. It therefore duplicates a lot of stuff that is now in the "
"standard library, such as containers and type information. Most "
"significantly, Trolltech modified the C++ language to provide signals, so "
"that Qt classes cannot be used easily with non-Qt classes. "
"<application>gtkmm</application> was able to use standard C++ to provide "
"signals without changing the C++ language. See the <ulink url=\"https://wiki."
"gnome.org/Projects/gtkmm/FAQ\">FAQ</ulink> for more detailed differences."
msgstr ""
"Vývojáři <application>gtkmm</application> mají tendenci protěžovat "
"<application>gtkmm</application> před Qt, protože <application>gtkmm</"
"application> dělá věci více přirozeně jazyku C++. Qt pochází z dob, kdy C++ "
"a standardní knihovny nebyly plně standardizované, nebo dobře podporované "
"kompilátory. Proto duplikuje plno věcí, které dnes již najdete ve "
"standardních knihovnách, jak třeba kontejnery a typové informace. "
"Nejdůležitější je, že Trolltech upravil jazyk C++, aby poskytovat signály, "
"takže třídy Qt nejde jednoduše používat s jinými třídami než z Qt. "
"<application>gtkmm</application> je schopné používat standardní C++ k "
"poskytování signálů, bez změn v jazyce C++. Další rozdíly najdete popsané na "
"stránce s <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/FAQ\">častými "
"dotazy a odpověďmi</ulink>."

#: C/gtkmm-tutorial-in.xml:163(title)
msgid "<application>gtkmm</application> is a wrapper"
msgstr "<application>gtkmm</application> jen obaluje GTK+"

#: C/gtkmm-tutorial-in.xml:164(para)
msgid ""
"<application>gtkmm</application> is not a native C++ toolkit, but a C++ "
"wrapper of a C toolkit. This separation of interface and implementation has "
"advantages. The <application>gtkmm</application> developers spend most of "
"their time talking about how <application>gtkmm</application> can present "
"the clearest API, without awkward compromises due to obscure technical "
"details. We contribute a little to the underlying GTK+ code base, but so do "
"the C coders, and the Perl coders and the Python coders, etc. Therefore GTK+ "
"benefits from a broader user base than language-specific toolkits - there "
"are more implementers, more developers, more testers, and more users."
msgstr ""
"<application>gtkmm</application> není nativní vývojářská sada C++, ale "
"obalení C++ okolo vývojářské sady C. Toto oddělení rozhraní a implementace "
"má jisté výhody. Vývojáři <application>gtkmm</application> tráví většinu "
"času rozpravami o tom, jak by <application>gtkmm</application> mělo podávat "
"nejčistší API, bez obtížných kompromisů kvůli obskurním technickým detailům. "
"Trochu přispíváme i do podkladového kódu GTK+, přestože kvůli tomu musíme "
"programovat v C, v Perlu, V Pythonu atd. GTK+ tak těží z širší základny "
"uživatelů, než vývojářské sady pro jediný konkrétní jazyk – má více "
"implementátorů, více vývojářů, více testerů a více uživatelů."

#: C/gtkmm-tutorial-in.xml:172(title)
msgid "Installation"
msgstr "Instalace"

#: C/gtkmm-tutorial-in.xml:174(title)
msgid "Dependencies"
msgstr "Závislosti"

#: C/gtkmm-tutorial-in.xml:175(para)
msgid ""
"Before attempting to install <application>gtkmm</application> 3.0, you might "
"first need to install these other packages."
msgstr ""
"Než se pokusíte nainstalovat <application>gtkmm</application> 3.0, budete "
"možná muset nejprve nainstalovat tyto další balíčky."

#: C/gtkmm-tutorial-in.xml:180(application)
msgid "libsigc++ 2.0"
msgstr "libsigc++ 2.0"

#: C/gtkmm-tutorial-in.xml:181(application)
msgid "GTK+ 3.0"
msgstr "GTK+ 3.0"

#: C/gtkmm-tutorial-in.xml:182(application)
msgid "glibmm"
msgstr "glibmm"

#: C/gtkmm-tutorial-in.xml:183(application)
msgid "cairomm"
msgstr "cairomm"

#: C/gtkmm-tutorial-in.xml:184(application)
msgid "pangomm"
msgstr "pangomm"

#: C/gtkmm-tutorial-in.xml:185(application)
msgid "atkmm"
msgstr "atkmm"

#: C/gtkmm-tutorial-in.xml:187(para)
msgid ""
"These dependencies have their own dependencies, including the following "
"applications and libraries:"
msgstr ""
"Tyto závislosti mají zase své vlastní závislosti, včetně následujících "
"aplikací a knihoven:"

#: C/gtkmm-tutorial-in.xml:192(application)
msgid "pkg-config"
msgstr "pkg-config"

#: C/gtkmm-tutorial-in.xml:193(application)
msgid "glib"
msgstr "glib"

#: C/gtkmm-tutorial-in.xml:194(application)
msgid "ATK"
msgstr "ATK"

#: C/gtkmm-tutorial-in.xml:195(application)
msgid "Pango"
msgstr "Pango"

#: C/gtkmm-tutorial-in.xml:196(application)
msgid "cairo"
msgstr "cairo"

#: C/gtkmm-tutorial-in.xml:197(application)
msgid "gdk-pixbuf"
msgstr "gdk-pixbuf"

#: C/gtkmm-tutorial-in.xml:202(title)
msgid "Unix and Linux"
msgstr "Unix a Linux"

#: C/gtkmm-tutorial-in.xml:205(title)
msgid "Prebuilt Packages"
msgstr "Předem sestavené balíčky"

#: C/gtkmm-tutorial-in.xml:207(para)
msgid ""
"Recent versions of <application>gtkmm</application> are packaged by nearly "
"every major Linux distribution these days. So, if you use Linux, you can "
"probably get started with <application>gtkmm</application> by installing the "
"package from the official repository for your distribution. Distributions "
"that include <application>gtkmm</application> in their repositories include "
"Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse, and many others."
msgstr ""
"V současnosti jsou nejnovější verze <application>gtkmm</application> "
"zabaleny v téměř všech hlavních linuxových distribucích. Takže pokud "
"používáte Linux, začnete nejspíše s <application>gtkmm</application> "
"instalací balíčku z oficiálního repozitáře své distribuce. Mezi distribuce, "
"které <application>gtkmm</application> obsahují ve svých repozitářích, patří "
"Debian, Ubuntu, Red Hat, Fedora, Mandriva, Suse a mnohé další."

#: C/gtkmm-tutorial-in.xml:215(para)
msgid ""
"The names of the <application>gtkmm</application> packages vary from "
"distribution to distribution (e.g. <application>libgtkmm-3.0-dev</"
"application> on Debian and Ubuntu or <application>gtkmm30-devel</"
"application> on Red Hat Fedora), so check with your distribution's package "
"management program for the correct package name and install it like you "
"would any other package."
msgstr ""
"Název balíčků <application>gtkmm</application> se liší distribuci od "
"distribuce (např. <application>libgtkmm-3.0-dev</application> v Debianu a "
"Ubuntu nebo <application>gtkmm30-devel</application> ve Fedoře), takže si "
"správný název balíčku budete muset najít ve správě balíčků své distribuce a "
"pak jej nainstalovat, jak jste běžně zvyklí u jiných balíčků."

#: C/gtkmm-tutorial-in.xml:223(para)
msgid ""
"The package names will not change when new API/ABI-compatible versions of "
"<application>gtkmm</application> are released. Otherwise they would not be "
"API/ABI-compatible. So don't be surprised, for instance, to find "
"<application>gtkmm</application> 3.8 supplied by Debian's "
"<application>libgtkmm-3.0-dev</application> package."
msgstr ""
"Název balíčku se nemění, když je vydána nová verze <application>gtkmm</"
"application> s kompatibilním API/ABI. Jinak by neměla kompatibilní API/ABI. "
"Takže nebuďte překvapeni, když například v Debianu najdete "
"<application>gtkmm</application> 3.8 poskytované v balíčku "
"<application>libgtkmm-3.0-dev</application>."

#: C/gtkmm-tutorial-in.xml:233(title)
msgid "Installing From Source"
msgstr "Instalace ze zdrojových kódů"

#: C/gtkmm-tutorial-in.xml:235(para)
msgid ""
"If your distribution does not provide a pre-built <application>gtkmm</"
"application> package, or if you want to install a different version than the "
"one provided by your distribution, you can also install <application>gtkmm</"
"application> from source. The source code for <application>gtkmm</"
"application> can be downloaded from <ulink url=\"http://www.gtkmm.org/\"/>."
msgstr ""
"V případě, že vaše distribuce neposkytuje sestavený balíček "
"<application>gtkmm</application>, nebo když chcete instalovat jinou verzi, "
"než je ta poskytovaná ve vaší distribuci, můžete <application>gtkmm</"
"application> nainstalovat také ze zdrojových kódů. Zdrojové kódy pro "
"<application>gtkmm</application> můžete stáhnout z <ulink url=\"http://www."
"gtkmm.org/\"/>."

#: C/gtkmm-tutorial-in.xml:241(para)
msgid ""
"After you've installed all of the dependencies, download the "
"<application>gtkmm</application> source code, unpack it, and change to the "
"newly created directory. <application>gtkmm</application> can be built and "
"installed with the following sequence of commands:"
msgstr ""
"Po té, co nainstalujete všechny závislosti, si stáhněte zdrojové kódy "
"<application>gtkmm</application>, rozbalte je a přepněte se do nově "
"vytvořené složky. <application>gtkmm</application> můžete sestavit a "
"nainstalovat následující posloupností přikazů:"

#: C/gtkmm-tutorial-in.xml:246(screen)
#, no-wrap
msgid ""
"\n"
"# ./configure\n"
"# make\n"
"# make install\n"
msgstr ""
"\n"
"# ./configure\n"
"# make\n"
"# make install\n"

#: C/gtkmm-tutorial-in.xml:252(para)
msgid ""
"Remember that on a Unix or Linux operating system, you will probably need to "
"be <literal>root</literal> to install software. The <command>su</command> or "
"<command>sudo</command> command will allow you to enter the <literal>root</"
"literal> password and have <literal>root</literal> status temporarily."
msgstr ""
"Nezapomeňte, že v operačních systémech Unix a Linux budete k instalaci "
"nejspíše potřebovat oprávnění uživatele <literal>root</literal>. Příkaz "
"<command>su</command> nebo <command>sudo</command> vám umožní zadat heslo "
"uživatele <literal>root</literal> a získat dočasně jeho status."

#: C/gtkmm-tutorial-in.xml:259(para)
msgid ""
"The <filename>configure</filename> script will check to make sure all of the "
"required dependencies are already installed. If you are missing any "
"dependencies, it will exit and display an error."
msgstr ""
"Skript <filename>configure</filename> zkontroluje, jestli jsou již "
"nainstalované všechny závislosti. Pokud bude některá chybět, zobrazí chybu a "
"skončí."

#: C/gtkmm-tutorial-in.xml:264(para)
msgid ""
"By default, <application>gtkmm</application> will be installed under the "
"<filename>/usr/local</filename> directory. On some systems you may need to "
"install to a different location. For instance, on Red Hat Linux systems you "
"might use the <literal>--prefix</literal> option with configure, like so: "
"<screen>\n"
"# ./configure --prefix=/usr\n"
"</screen>"
msgstr ""
"Standardně se <application>gtkmm</application> nainstaluje do složky "
"<filename>/usr/local</filename>. Na některých systémech můžete potřebovat "
"provést instalaci do jiného místa. Například v systému RHEL můžete použít "
"volbu <literal>--prefix</literal> konfiguračního skriptu takto: <screen>\n"
"# ./configure --prefix=/usr\n"
"</screen>"

#: C/gtkmm-tutorial-in.xml:275(para)
msgid ""
"You should be very careful when installing to standard system prefixes such "
"as <filename>/usr</filename>. Linux distributions install software packages "
"to <filename>/usr</filename>, so installing a source package to this prefix "
"could corrupt or conflict with software installed using your distribution's "
"package-management system. Ideally, you should use a separate prefix for all "
"software you install from source."
msgstr ""
"Měli byste být opatrní, když instalujete do standardních systémových složek, "
"jako je <filename>/usr</filename>. Linuxové distribuce instalují do "
"<filename>/usr</filename> softwarové balíčky, takže instalace ze zdrojových "
"kódů do této cesty by mohla poškodit software nainstalovaný správou balíčků "
"vaší distribuce, nebo s ním být v konfliktu. Nejlépe, když použijete "
"oddělenou složku pro všechen software instalovaný ze zdrojových kódů."

#: C/gtkmm-tutorial-in.xml:284(para)
msgid ""
"If you want to help develop <application>gtkmm</application> or experiment "
"with new features, you can also install <application>gtkmm</application> "
"from git. Most users will never need to do this, but if you're interested in "
"helping with <application>gtkmm</application> development, see the <link "
"linkend=\"chapter-working-with-source\">Working with gtkmm's Source Code</"
"link> appendix."
msgstr ""
"Pokud chcete pomoci s vývojem <application>gtkmm</application> nebo "
"experimentovat s novými funkcemi, můžete nainstalovat <application>gtkmm</"
"application> také ze systému správy verzí Git. Většina uživatelů to nikdy "
"nebude potřebovat, ale jestli máte zájem pomoci s vývojem "
"<application>gtkmm</application>, podívejte se do dodatku <link linkend="
"\"chapter-working-with-source\">Práce se zdrojovými kódy gtkmm</link>."

#: C/gtkmm-tutorial-in.xml:295(title)
msgid "Microsoft Windows"
msgstr "Microsoft Windows"

#: C/gtkmm-tutorial-in.xml:296(para)
msgid ""
"GTK+ and <application>gtkmm</application> were designed to work well with "
"Microsoft Windows, and the developers encourage its use on the win32 "
"platform. However, Windows has no standard installation system for "
"development libraries. Please see the <ulink url=\"https://wiki.gnome.org/"
"Projects/gtkmm/MSWindows\">Windows Installation</ulink> page for Windows-"
"specific installation instructions and notes."
msgstr ""
"GTK+ a <application>gtkmm</application> byly navrženy s tím, aby dobře "
"fungovaly i s Microsoft Windows a vývojáři pobízejí k jeho použití na "
"platformě win32. Windows ale nemají standardizovaný instalační systém pro "
"vývojářské knihovny. Proto se prosím podívejte na stránku <ulink url="
"\"https://wiki.gnome.org/Projects/gtkmm/MSWindows\">Windows Installation</"
"ulink> na instalační instrukce a poznámky týkající se výhradně Windows."

#: C/gtkmm-tutorial-in.xml:303(title)
msgid "Basics"
msgstr "Základy"

#: C/gtkmm-tutorial-in.xml:305(para)
msgid ""
"This chapter will introduce some of the most important aspects of "
"<application>gtkmm</application> coding. These will be demonstrated with "
"simple working example code. However, this is just a taster, so you need to "
"look at the other chapters for more substantial information."
msgstr ""
"Tato kapitola vám představí některé z nejdůležitějších aspektů programování "
"s <application>gtkmm</application>. Budou předvedeny na jednoduchém funkčním "
"ukázkovém kódu. Nicméně se jedná jen o takovou ochutnávku, na podstatné věci "
"se budete muset podívat do dalších kapitol."

#: C/gtkmm-tutorial-in.xml:308(para)
msgid ""
"Your existing knowledge of C++ will help you with <application>gtkmm</"
"application> as it would with any library. Unless we state otherwise, you "
"can expect <application>gtkmm</application> classes to behave like any other "
"C++ class, and you can expect to use your existing C++ techniques with "
"<application>gtkmm</application> classes."
msgstr ""
"Vaše stávající znalosti C++ vám budou s <application>gtkmm</application> ku "
"prospěchu, stejně jako u jakékoliv jiné knihovny. Pokud neuvedeme jinak, "
"očekávejte od tříd <application>gtkmm</application> chování jako u jakékoliv "
"jiné třídy C++ a můžete očekávat, že třídy <application>gtkmm</application> "
"používají běžné techniky C++."

#: C/gtkmm-tutorial-in.xml:313(title) C/gtkmm-tutorial-in.xml:3341(title)
msgid "Simple Example"
msgstr "Jednoduchý příklad"

#: C/gtkmm-tutorial-in.xml:315(para)
msgid ""
"To begin our introduction to <application>gtkmm</application>, we'll start "
"with the simplest program possible. This program will create an empty 200 x "
"200 pixel window."
msgstr ""
"Abychom vás uvedli do <application>gtkmm</application>, začneme s "
"nejjednodušším možným programem. Tento program vytvoří okno o rozměrech "
"200 × 200 pixelů."

#: C/gtkmm-tutorial-in.xml:320(ulink) C/gtkmm-tutorial-in.xml:502(ulink)
#: C/gtkmm-tutorial-in.xml:769(ulink) C/gtkmm-tutorial-in.xml:877(ulink)
#: C/gtkmm-tutorial-in.xml:986(ulink) C/gtkmm-tutorial-in.xml:1108(ulink)
#: C/gtkmm-tutorial-in.xml:1164(ulink) C/gtkmm-tutorial-in.xml:1234(ulink)
#: C/gtkmm-tutorial-in.xml:1281(ulink) C/gtkmm-tutorial-in.xml:1308(ulink)
#: C/gtkmm-tutorial-in.xml:1333(ulink) C/gtkmm-tutorial-in.xml:1469(ulink)
#: C/gtkmm-tutorial-in.xml:1530(ulink) C/gtkmm-tutorial-in.xml:1554(ulink)
#: C/gtkmm-tutorial-in.xml:1585(ulink) C/gtkmm-tutorial-in.xml:1642(ulink)
#: C/gtkmm-tutorial-in.xml:1682(ulink) C/gtkmm-tutorial-in.xml:1727(ulink)
#: C/gtkmm-tutorial-in.xml:1762(ulink) C/gtkmm-tutorial-in.xml:1801(ulink)
#: C/gtkmm-tutorial-in.xml:1930(ulink) C/gtkmm-tutorial-in.xml:2091(ulink)
#: C/gtkmm-tutorial-in.xml:2132(ulink) C/gtkmm-tutorial-in.xml:2174(ulink)
#: C/gtkmm-tutorial-in.xml:2235(ulink) C/gtkmm-tutorial-in.xml:2275(ulink)
#: C/gtkmm-tutorial-in.xml:2867(ulink) C/gtkmm-tutorial-in.xml:2886(ulink)
#: C/gtkmm-tutorial-in.xml:2905(ulink) C/gtkmm-tutorial-in.xml:2927(ulink)
#: C/gtkmm-tutorial-in.xml:2949(ulink) C/gtkmm-tutorial-in.xml:3022(ulink)
#: C/gtkmm-tutorial-in.xml:3035(ulink) C/gtkmm-tutorial-in.xml:3106(ulink)
#: C/gtkmm-tutorial-in.xml:3119(ulink) C/gtkmm-tutorial-in.xml:3350(ulink)
#: C/gtkmm-tutorial-in.xml:3523(ulink) C/gtkmm-tutorial-in.xml:3536(ulink)
#: C/gtkmm-tutorial-in.xml:3592(ulink) C/gtkmm-tutorial-in.xml:3847(ulink)
#: C/gtkmm-tutorial-in.xml:3909(ulink) C/gtkmm-tutorial-in.xml:3936(ulink)
#: C/gtkmm-tutorial-in.xml:3959(ulink) C/gtkmm-tutorial-in.xml:3983(ulink)
#: C/gtkmm-tutorial-in.xml:4015(ulink) C/gtkmm-tutorial-in.xml:4216(ulink)
#: C/gtkmm-tutorial-in.xml:4306(ulink) C/gtkmm-tutorial-in.xml:4334(ulink)
#: C/gtkmm-tutorial-in.xml:4410(ulink) C/gtkmm-tutorial-in.xml:4482(ulink)
#: C/gtkmm-tutorial-in.xml:4545(ulink) C/gtkmm-tutorial-in.xml:4571(ulink)
#: C/gtkmm-tutorial-in.xml:4786(ulink) C/gtkmm-tutorial-in.xml:4952(ulink)
#: C/gtkmm-tutorial-in.xml:4972(ulink) C/gtkmm-tutorial-in.xml:5346(ulink)
#: C/gtkmm-tutorial-in.xml:5567(ulink) C/gtkmm-tutorial-in.xml:5701(ulink)
#: C/gtkmm-tutorial-in.xml:5825(ulink) C/gtkmm-tutorial-in.xml:5893(ulink)
#: C/gtkmm-tutorial-in.xml:5955(ulink) C/gtkmm-tutorial-in.xml:6052(ulink)
#: C/gtkmm-tutorial-in.xml:6090(ulink) C/gtkmm-tutorial-in.xml:6417(ulink)
#: C/gtkmm-tutorial-in.xml:6485(ulink) C/gtkmm-tutorial-in.xml:7129(ulink)
#: C/gtkmm-tutorial-in.xml:7186(ulink) C/gtkmm-tutorial-in.xml:7442(ulink)
#: C/gtkmm-tutorial-in.xml:8327(ulink)
msgid "Source Code"
msgstr "Zdrojový kód"

# Poznámky:
# Přidat poznámku
#: C/gtkmm-tutorial-in.xml:322(para)
msgid "We will now explain each line of the example"
msgstr "Nyní si vysvětlíme jednotlivé řádky příkladu."

#: C/gtkmm-tutorial-in.xml:323(programlisting)
#, no-wrap
msgid "#include &lt;gtkmm.h&gt;"
msgstr "#include &lt;gtkmm.h&gt;"

#: C/gtkmm-tutorial-in.xml:324(para)
msgid ""
"All <application>gtkmm</application> programs must include certain "
"<application>gtkmm</application> headers; <literal>gtkmm.h</literal> "
"includes the entire <application>gtkmm</application> kit. This is usually "
"not a good idea, because it includes a megabyte or so of headers, but for "
"simple programs, it suffices."
msgstr ""
"Všechny programy používající <application>gtkmm</application> musí mít "
"vložené určité hlavičkové soubory <application>gtkmm</application>. "
"<literal>gtkmm.h</literal> vloží celou sadu <application>gtkmm</"
"application>. To obvykle není dobrý nápad, protože to vloží megabajty "
"hlaviček, ale pro tento jednoduchý program nás to nemusí trápit."

#: C/gtkmm-tutorial-in.xml:334(programlisting)
#, no-wrap
msgid "Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.examples.base\");"
msgstr "Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.examples.base\");"

#: C/gtkmm-tutorial-in.xml:331(para)
msgid ""
"The next statement: <placeholder-1/> creates a <classname>Gtk::Application</"
"classname> object, stored in a <classname>RefPtr</classname> smartpointer. "
"This is needed in all <application>gtkmm</application> applications. The "
"<methodname>create()</methodname> method for this object initializes "
"<application>gtkmm</application>, and checks the arguments passed to your "
"application on the command line, looking for standard options such as "
"<literal>--display</literal>. It takes these from the argument list, leaving "
"anything it does not recognize for your application to parse or ignore. This "
"ensures that all <application>gtkmm</application> applications accept the "
"same set of standard arguments."
msgstr ""
"Následující výraz: <placeholder-1/> vytvoří objekt <classname>Gtk::"
"Application</classname> a uchová jej v chytrém ukazateli <classname>RefPtr</"
"classname>. Tohle je zapotřebí ve všech aplikacích založených na "
"<application>gtkmm</application>. Metoda <methodname>create()</methodname> "
"tohoto objektu inicializuje <methodname>create()</methodname> a zkontroluje "
"argumenty předané aplikaci z příkazového řádku, přičemž se dívá po "
"standardních přepínačích, jako je <literal>--display</literal>. Přebírá je "
"ze seznamu argumentů, a co nerozpozná, to ponechá pro další zpracování, nebo "
"případně ignorování, ve vaší aplikaci. Tím se zajistí, že všechny aplikace "
"<application>gtkmm</application> přijímají stejnou množinu standardních "
"argumentů."

#: C/gtkmm-tutorial-in.xml:344(para)
msgid ""
"The next two lines of code create a window and set its default (initial) "
"size:"
msgstr ""
"Následujícídva řádky kódu vytvoří okno a nastaví jeho výchozí (počáteční) "
"velikost:"

#: C/gtkmm-tutorial-in.xml:347(programlisting)
#, no-wrap
msgid ""
"Gtk::Window window;\n"
"window.set_default_size(200, 200);"
msgstr ""
"Gtk::Window window;\n"
"window.set_default_size(200, 200);"

#: C/gtkmm-tutorial-in.xml:349(para)
msgid ""
"The last line shows the window and enters the <application>gtkmm</"
"application> main processing loop, which will finish when the window is "
"closed. Your <function>main()</function> function will then return with an "
"appropriate success or error code."
msgstr ""
"Poslední řádek okno zobrazí a vstoupí do hlavní prováděcí smyčky "
"<application>gtkmm</application>, která skončí, když je okno zavřeno. Vaše "
"funkce <function>main()</function> pak vrátí příslušný úspěšný nebo chybový "
"kód."

#: C/gtkmm-tutorial-in.xml:354(programlisting)
#, no-wrap
msgid "return app-&gt;run(window);"
msgstr "return app-&gt;run(window);"

#: C/gtkmm-tutorial-in.xml:359(programlisting)
#, no-wrap
msgid "g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`"
msgstr "g++ simple.cc -o simple `pkg-config gtkmm-3.0 --cflags --libs`"

#: C/gtkmm-tutorial-in.xml:356(para)
msgid ""
"After putting the source code in <literal>simple.cc</literal> you can "
"compile the above program with <application>gcc</application> using: "
"<placeholder-1/> Note that you must surround the <literal>pkg-config</"
"literal> invocation with backquotes. Backquotes cause the shell to execute "
"the command inside them, and to use the command's output as part of the "
"command line. Note also that <literal>simple.cc</literal> must come before "
"the <literal>pkg-config</literal> invocation on the command line."
msgstr ""
"Po zadání zdrojového kódu do <literal>simple.cc</literal> můžete zkompilovat "
"výše uvedený program pomocí <application>gcc</application>: <placeholder-1/> "
"Pamatujte, že musíte volání <literal>pkg-config</literal> uzavřít do "
"zpětných uvozovek. Ty způsobí, že shell provede příkaz v nich uzavřený a "
"výstup tohoto příkazu použije jako součást příkazového řádku. Také "
"pamatujte, že <literal>simple.cc</literal> musí být před zavoláním "
"<literal>pkg-config</literal> v příkazovém řádku."

#: C/gtkmm-tutorial-in.xml:369(title)
msgid "Headers and Linking"
msgstr "Hlavičkové soubory a linkování"

#: C/gtkmm-tutorial-in.xml:370(para)
msgid ""
"Although we have shown the compilation command for the simple example, you "
"really should use the automake and autoconf tools, as described in "
"\"Autoconf, Automake, Libtool\", by G. V. Vaughan et al. The examples used "
"in this book are included in the <application>gtkmm-documentation</"
"application> package, with appropriate build files, so we won't show the "
"build commands in future. You'll just need to find the appropriate directory "
"and type <literal>make</literal>."
msgstr ""
"Ačkoliv jsme si ukázali na jednoduchém příkladu příkaz pro kompilaci, měli "
"byste ve skutečnosti používat nástroje automake a autoconf, jak je to "
"popsáno v „Autoconf, Automake, Libtool“ od G. V. Vaughana a kol. Příklady "
"uváděné v této knize jsou zahrnuté v balíčku <application>gtkmm-"
"documentation</application> včetně příslušných souborů pro sestavení, takže "
"příkazy pro sestavení již nadále nebudeme uvádět. Stačí vám jen najít "
"příslušnou složku s příkladem a napsat <literal>make</literal>."

#: C/gtkmm-tutorial-in.xml:373(para)
msgid ""
"To simplify compilation, we use <literal>pkg-config</literal>, which is "
"present in all (properly installed) <application>gtkmm</application> "
"installations. This program 'knows' what compiler switches are needed to "
"compile programs that use <application>gtkmm</application>. The <literal>--"
"cflags</literal> option causes <literal>pkg-config</literal> to output a "
"list of include directories for the compiler to look in; the <literal>--"
"libs</literal> option requests the list of libraries for the compiler to "
"link with and the directories to find them in. Try running it from your "
"shell-prompt to see the results on your system."
msgstr ""
"Pro zjednodušení kompilace používáme <literal>pkg-config</literal>, který "
"najdete ve všech (správně nainstalovaných) instalacích <application>gtkmm</"
"application>. Tento program „zná“ přepínače, které jsou zapotřebí ke "
"kompilaci programu, který používá <application>gtkmm</application>. Přepínač "
"<literal>--cflags</literal> způsobí, že <literal>pkg-config</literal> vypíše "
"seznam složek, ve kterých kompilátor hledá hlavičkové soubory, a přepínač "
"<literal>--libs</literal> zažádá o seznam knihoven, které má kompilátor "
"přilinkovat, a o složky, ve kterých je má hledat. Zkuste si to spustit ručně "
"v shellu, abyste viděli výsledky pro váš systém."

#: C/gtkmm-tutorial-in.xml:386(programlisting)
#, no-wrap
msgid "PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.8.0])"
msgstr "PKG_CHECK_MODULES([MYAPP], [gtkmm-3.0 &gt;= 3.8.0])"

#: C/gtkmm-tutorial-in.xml:383(para)
msgid ""
"However, this is even simpler when using the <function>PKG_CHECK_MODULES()</"
"function> macro in a standard configure.ac file with autoconf and automake. "
"For instance: <placeholder-1/> This checks for the presence of gtkmm and "
"defines MYAPP_LIBS and MYAPP_CFLAGS for use in your Makefile.am files."
msgstr ""
"Jde to ale i jednodušeji, když použijete makro "
"<function>PKG_CHECK_MODULES()</function> ve standardním souboru configure.ac "
"v spolupráci s autoconf a automake. Například: <placeholder-1/> Tím se "
"zkontroluje přítomnost gtkmm a definují MYAPP_LIBS a MYAPP_CFLAGS pro "
"použití se soubory Makefile.am."

#: C/gtkmm-tutorial-in.xml:389(para)
msgid ""
"gtkmm-3.0 is the name of the current stable API. There was an older API "
"called gtkmm-2-4 which installs in parallel when it is available. There were "
"several versions of gtkmm-2.4, such as gtkmm 2.10 and there are several "
"versions of the gtkmm-3.0 API. Note that the API name does not change for "
"every version because that would be an incompatible API and ABI break. "
"Theoretically, there might be a future gtkmm-4.0 API which would install in "
"parallel with gtkmm-3.0 without affecting existing applications."
msgstr ""
"gtkmm-3.0 je název aktuálního stabilního API. Existuje i starší API nazývané "
"gtkmm-2.4, které, pokud je dostupné, se instaluje souběžně. Existovalo "
"postupně několik verzí gtkmm-2.4, jako třeba gtkmm 2.10 a existuje i několik "
"verzí API gtkmm-3.0. Je třeba si uvědomit, že název API se nemění s každou "
"verzí, protože by došlo k narušení kompatibility API a ABI. Teoreticky může "
"v budoucnu vzniknout API gtkmm-4.0, které by se instalovalo souběžně s "
"gtkmm-3.0 bez vlivu na stávající aplikace."

#: C/gtkmm-tutorial-in.xml:392(para)
msgid ""
"Note that if you mention extra modules in addition to gtkmm-3.0, they should "
"be separated by spaces, not commas."
msgstr ""
"Pokud budeme uvádět dodatečné moduly navíc ke gtkmm-3.0, měly by být "
"oddělené mezerami, ne čárkami."

#: C/gtkmm-tutorial-in.xml:394(para)
msgid ""
"Openismus has more <ulink url=\"http://www.openismus.com/documents/linux/"
"automake/automake.shtml\">basic help with automake and autoconf</ulink>."
msgstr ""
"Na webu Openismus je další <ulink url=\"http://www.openismus.com/documents/"
"linux/automake/automake.shtml\">základní nápověda k automake a autoconf</"
"ulink>."

#: C/gtkmm-tutorial-in.xml:401(title) C/gtkmm-tutorial-in.xml:6113(title)
msgid "Widgets"
msgstr "Widgety"

#: C/gtkmm-tutorial-in.xml:402(para)
msgid ""
"<application>gtkmm</application> applications consist of windows containing "
"widgets, such as buttons and text boxes. In some other systems, widgets are "
"called \"controls\". For each widget in your application's windows, there is "
"a C++ object in your application's code. So you just need to call a method "
"of the widget's class to affect the visible widget."
msgstr ""
"Aplikace vytvoření pomocí <application>gtkmm</application> jsou tvořené okny "
"obsahujícími widgety, jako jsou tlačítka nebo textová pole. V některých "
"jiných systémech se widgety nazývají „ovládací prvky“. Ke každému widgetu v "
"oknech aplikace existuje objekt C++ ve vašem aplikačním kódu. Pro dosažení "
"vizuálních projevů widgetu vám stačí volat metody třídy widgetu."

#: C/gtkmm-tutorial-in.xml:404(programlisting)
#, no-wrap
msgid ""
"m_box.pack_start(m_Button1);\n"
"m_box.pack_start(m_Button2);"
msgstr ""
"m_box.pack_start(m_Button1);\n"
"m_box.pack_start(m_Button2);"

#: C/gtkmm-tutorial-in.xml:407(programlisting)
#, no-wrap
msgid "m_frame.add(m_box);"
msgstr "m_frame.add(m_box);"

#: C/gtkmm-tutorial-in.xml:403(para)
msgid ""
"Widgets are arranged inside container widgets such as frames and notebooks, "
"in a hierarchy of widgets within widgets. Some of these container widgets, "
"such as <classname>Gtk::Grid</classname>, are not visible - they exist only "
"to arrange other widgets. Here is some example code that adds 2 "
"<classname>Gtk::Button</classname> widgets to a <classname>Gtk::Box</"
"classname> container widget: <placeholder-1/> and here is how to add the "
"<classname>Gtk::Box</classname>, containing those buttons, to a "
"<classname>Gtk::Frame</classname>, which has a visible frame and title: "
"<placeholder-2/>"
msgstr ""
"Widgety se uspořádávají do kontejnerových widgetů, jako jsou rámy a sešity, "
"v hierarchii widgetů ve widgetech. Některé z těchto kontejnerových widgetů, "
"jako třeba <classname>Gtk::Grid</classname>, nejsou viditelné – existují jen "
"pro potřeby uspořádání ostatních widgetů. Zde je příklad kódu, který přidává "
"dva widgety <classname>Gtk::Button</classname> do kontejnerového widgetu "
"<classname>Gtk::Box</classname>: <placeholder-1/> a zde je, jak přidat "
"<classname>Gtk::Box</classname> obsahující tato dvě tlačítka do "
"<classname>Gtk::Frame</classname>, který má viditelný rámeček a název: "
"<placeholder-2/>"

#: C/gtkmm-tutorial-in.xml:409(para)
msgid ""
"Most of the chapters in this book deal with specific widgets. See the <link "
"linkend=\"chapter-container-widgets\">Container Widgets</link> section for "
"more details about adding widgets to container widgets."
msgstr ""
"Většina kapitol v této knize se zabývá konkrétními widgety. Více informací o "
"přidávání widgetů do kontejnerového widgetu najdete v kapitole <link linkend="
"\"chapter-container-widgets\">Kontejnerové widgety</link>."

#: C/gtkmm-tutorial-in.xml:413(para)
msgid ""
"Although you can specify the layout and appearance of windows and widgets "
"with C++ code, you will probably find it more convenient to design your user "
"interfaces with <literal>Glade</literal> and load them at runtime with "
"<literal>Gtk::Builder</literal>. See the <link linkend=\"chapter-builder"
"\">Glade and Gtk::Builder</link> chapter."
msgstr ""
"Ačkoliv můžete rozvržení a vzhled okna a widgetů určit přímo v kódu C++, asi "
"shledáte pohodlnějším navrhovat uživatelská rozhraní pomocí aplikace "
"<literal>Glade</literal> a pak je načítat za běhu pomocí <literal>Gtk::"
"Builder</literal>. Viz kapitola <link linkend=\"chapter-builder\">Glade a "
"Gtk::Builder</link>."

#: C/gtkmm-tutorial-in.xml:416(para)
msgid ""
"Although <application>gtkmm</application> widget instances have lifetimes "
"and scopes just like those of other C++ classes, <application>gtkmm</"
"application> has an optional time-saving feature that you will see in some "
"of the examples. <function>Gtk::manage()</function> allows you to say that a "
"child widget is owned by the container into which you place it. This allows "
"you to <function>new</function> the widget, add it to the container and "
"forget about deleting it. You can learn more about <application>gtkmm</"
"application> memory management techniques in the <link linkend=\"chapter-"
"memory\">Memory Management chapter</link>."
msgstr ""
"Ačkoliv instance widgetů <application>gtkmm</application> mají životnost a "
"rozsah působnosti stejné, jako jiné třídy C++, má <application>gtkmm</"
"application> volitelnou vlastnost, která šetří čas a uvidíte ji v některých "
"příkladech. <function>Gtk::manage()</function> vám umožňuje říci, že "
"synovský widget je vlastněný kontejnerem, ve kterém je umístěný. Díky tomu "
"můžete pomocí <function>new</function> vytvořit widget, přidat jej do "
"kontejneru a už se nestarat o jeho smazání. Více se o technikách správy "
"paměti v <application>gtkmm</application> se můžete dozvědět v kapitole "
"<link linkend=\"chapter-memory\">Správa paměti</link>."

#: C/gtkmm-tutorial-in.xml:422(title) C/gtkmm-tutorial-in.xml:773(title)
#: C/gtkmm-tutorial-in.xml:4699(title) C/gtkmm-tutorial-in.xml:5001(title)
#: C/gtkmm-tutorial-in.xml:7722(title)
msgid "Signals"
msgstr "Signály"

#: C/gtkmm-tutorial-in.xml:424(para)
msgid ""
"<application>gtkmm</application>, like most GUI toolkits, is <emphasis>event-"
"driven</emphasis>. When an event occurs, such as the press of a mouse "
"button, the appropriate signal will be <emphasis>emitted</emphasis> by the "
"Widget that was pressed. Each Widget has a different set of signals that it "
"can emit. To make a button click result in an action, we set up a "
"<emphasis>signal handler</emphasis> to catch the button's \"clicked\" signal."
msgstr ""
"<application>gtkmm</application> je, obdobně jako jiné vývojářské sady GUI, "
"<emphasis>řízené událostmi</emphasis>. Když se vyskytne událost, jako je "
"zmáčknutí tlačítka myši, je widgetem, který byl zmáčknut, <emphasis>vyslán</"
"emphasis> příslušný signál. Různé widgety mají různé sady signálů, které "
"mohou vyslat. Aby se kliknutí tlačítkem projevilo nějakou činností, je třeba "
"nastavit <emphasis>obsluhu signálu</emphasis> (signal handler), která signál "
"„clicked“ od tlačítka zachytí."

#: C/gtkmm-tutorial-in.xml:432(programlisting)
#, no-wrap
msgid ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"
msgstr ""
"m_button1.signal_clicked().connect( sigc::mem_fun(*this,\n"
"  &amp;HelloWorld::on_button_clicked) );"

#: C/gtkmm-tutorial-in.xml:431(para)
msgid ""
"<application>gtkmm</application> uses the libsigc++ library to implement "
"signals. Here is an example line of code that connects a Gtk::Button's "
"\"clicked\" signal with a signal handler called \"on_button_clicked\": "
"<placeholder-1/>"
msgstr ""
"<application>gtkmm</application> používá k implementaci signálů knihovnu "
"libsigc++. Zde je příklad jednořádkového kódu, který napojí signál „clicked“ "
"tlačítka Gtk::Button na obsluhu signálu nazvanou „on_button_clicked“: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:436(para)
msgid ""
"For more detailed information about signals, see the <link linkend=\"chapter-"
"signals\">appendix</link>."
msgstr ""
"Více informací o signálech najdete v <link linkend=\"chapter-signals"
"\">dodatku</link>."

#: C/gtkmm-tutorial-in.xml:437(para)
msgid ""
"For information about implementing your own signals rather than just "
"connecting to the existing <application>gtkmm</application> signals, see the "
"<link linkend=\"chapter-custom-signals\">appendix</link>."
msgstr ""
"Pokud byste raději implementovali své vlastní signály, místo napojení těch "
"stávajících v <application>gtkmm</application>, podívejte se do tohoto <link "
"linkend=\"chapter-custom-signals\">dodatku</link>."

#: C/gtkmm-tutorial-in.xml:443(title) C/gtkmm-tutorial-in.xml:9842(classname)
msgid "Glib::ustring"
msgstr "Glib::ustring"

#: C/gtkmm-tutorial-in.xml:444(para)
msgid ""
"You might be surprised to learn that <application>gtkmm</application> "
"doesn't use <classname>std::string</classname> in its interfaces. Instead it "
"uses <classname>Glib::ustring</classname>, which is so similar and "
"unobtrusive that you could actually pretend that each <classname>Glib::"
"ustring</classname> is a <classname>std::string</classname> and ignore the "
"rest of this section. But read on if you want to use languages other than "
"English in your application."
msgstr ""
"Možná budete překvapeni, že <application>gtkmm</application> nepoužívá ve "
"svých rozhraních <classname>std::string</classname>. Místo toho používá "
"<classname>Glib::ustring</classname>, který je ale  natolik podobný a "
"nenápadný, že klidně můžete předstírat, že <classname>Glib::ustring</"
"classname> je <classname>std::string</classname> a zbytek kapitoly "
"ignorovat. Přečtěte si ji ale, pokud chcete ve svých aplikacích používat "
"jiné jazyky, než jen angličtinu."

#: C/gtkmm-tutorial-in.xml:445(para)
msgid ""
"std::string uses 8 bit per character, but 8 bits aren't enough to encode "
"languages such as Arabic, Chinese, and Japanese. Although the encodings for "
"these languages have now been specified by the Unicode Consortium, the C and "
"C++ languages do not yet provide any standardised Unicode support. GTK+ and "
"GNOME chose to implement Unicode using UTF-8, and that's what is wrapped by "
"Glib::ustring. It provides almost exactly the same interface as std::string, "
"along with automatic conversions to and from std::string."
msgstr ""
"std::string používá 8 bitů na znak, ale to není dostačující pro kódování "
"jazyků, jako je arabština, čínština nebo japonština. Ačkoliv kódování pro "
"tyto jazyky je nyní standardizováno organizací Unicode Consortium, "
"programovací jazyky C a C++ neposkytují pro Unikód standardizovanou podporu. "
"GTK+ a GNOME se vydalo cestou implementace Unikódu pomocí UTF-8 a to je "
"přesně to, co obaluje Glib::ustring. Z větší části poskytuje přesně to "
"stejné rozhraní, jako std:string, včetně automatického převodu na a z std::"
"string."

#: C/gtkmm-tutorial-in.xml:446(para)
msgid ""
"One of the benefits of UTF-8 is that you don't need to use it unless you "
"want to, so you don't need to retrofit all of your code at once. "
"<classname>std::string</classname> will still work for 7-bit ASCII strings. "
"But when you try to localize your application for languages like Chinese, "
"for instance, you will start to see strange errors, and possible crashes. "
"Then all you need to do is start using <classname>Glib::ustring</classname> "
"instead."
msgstr ""
"Jednou z východ UTF-8 je, že jej nemusíte používat, když jej nechcete, a "
"nemusíte tak opravovat veškerý kód naráz. <classname>std::string</classname> "
"bude stále fungovat pro řetězce se 7bitovým ASCII. Když se ale rozhodnete "
"lokalizovat své aplikace do jazyků, jako je čeština nebo čínština, začnou se "
"objevovat zvláštní chyby a případně i zhroucení. Potom vše, co musíte "
"udělat, je začít používat místo něj <classname>Glib::ustring</classname>."

#: C/gtkmm-tutorial-in.xml:447(para)
msgid ""
"Note that UTF-8 isn't compatible with 8-bit encodings like ISO-8859-1. For "
"instance, German umlauts are not in the ASCII range and need more than 1 "
"byte in the UTF-8 encoding. If your code contains 8-bit string literals, you "
"have to convert them to UTF-8 (e.g. the Bavarian greeting \"Grüß Gott\" "
"would be \"Gr\\xC3\\xBC\\xC3\\x9F Gott\")."
msgstr ""
"Mějte ale na paměti, že UTF-8 není kompatibilní s 8bitovými kódováními, jako "
"je ISO-8859-2. Například ypsilon s čárkou není v ASCII a potřebuje proto v "
"UTF-8 k zakódování víc než jeden bajt. Pokud váš kód obsahuje 8bitové "
"řetězcové literály, musíte je převést do UTF-8 (např. český pozdrav „Dobrý "
"den“ by byl „Dobr\\xC3\\xBD den“)."

#: C/gtkmm-tutorial-in.xml:448(para)
msgid ""
"You should avoid C-style pointer arithmetic, and functions such as strlen(). "
"In UTF-8, each character might need anywhere from 1 to 6 bytes, so it's not "
"possible to assume that the next byte is another character. <classname>Glib::"
"ustring</classname> worries about the details of this for you so you can use "
"methods such as Glib::ustring::substr() while still thinking in terms of "
"characters instead of bytes."
msgstr ""
"Měli byste se vyvarovat ukazatelové aritmetiky ve stylu C a funkcí jako je "
"strlen(). V UTF-8 mohou znaky zabírat od 1 do 6 bajtů, takže se nedá "
"automaticky předpokládat, že následující bajt je jiný znak. <classname>Glib::"
"ustring</classname> se o tyto věci postará, takže můžete používat metody "
"jako je Glib::ustring::substr() a přitom stále uvažovat v intencích znaků, "
"ale ne bajtů."

#: C/gtkmm-tutorial-in.xml:450(para)
msgid ""
"Unlike the Windows UCS-2 Unicode solution, this does not require any special "
"compiler options to process string literals, and it does not result in "
"Unicode executables and libraries which are incompatible with ASCII ones."
msgstr ""
"Na rozdíl od řešení Unikódu v podobě UCS-2 ve Windows, nejsou zapotřebí "
"žádné speciální volby kompilátoru pro zpracování řetězcových literálů a "
"nevznikají tak spustitelné programy a knihovny s podporou Unikódu, které by "
"byly nekompatibilní s ASCII."

#: C/gtkmm-tutorial-in.xml:452(ulink) C/gtkmm-tutorial-in.xml:753(ulink)
#: C/gtkmm-tutorial-in.xml:851(ulink) C/gtkmm-tutorial-in.xml:866(ulink)
#: C/gtkmm-tutorial-in.xml:969(ulink) C/gtkmm-tutorial-in.xml:1023(ulink)
#: C/gtkmm-tutorial-in.xml:1040(ulink) C/gtkmm-tutorial-in.xml:1085(ulink)
#: C/gtkmm-tutorial-in.xml:1146(ulink) C/gtkmm-tutorial-in.xml:1218(ulink)
#: C/gtkmm-tutorial-in.xml:1264(ulink) C/gtkmm-tutorial-in.xml:1452(ulink)
#: C/gtkmm-tutorial-in.xml:1495(ulink) C/gtkmm-tutorial-in.xml:1543(ulink)
#: C/gtkmm-tutorial-in.xml:1631(ulink) C/gtkmm-tutorial-in.xml:1671(ulink)
#: C/gtkmm-tutorial-in.xml:1712(ulink) C/gtkmm-tutorial-in.xml:1745(ulink)
#: C/gtkmm-tutorial-in.xml:1785(ulink) C/gtkmm-tutorial-in.xml:2021(ulink)
#: C/gtkmm-tutorial-in.xml:2120(ulink) C/gtkmm-tutorial-in.xml:2157(ulink)
#: C/gtkmm-tutorial-in.xml:2224(ulink) C/gtkmm-tutorial-in.xml:2264(ulink)
#: C/gtkmm-tutorial-in.xml:2311(ulink) C/gtkmm-tutorial-in.xml:2327(ulink)
#: C/gtkmm-tutorial-in.xml:2345(ulink) C/gtkmm-tutorial-in.xml:2453(ulink)
#: C/gtkmm-tutorial-in.xml:2968(ulink) C/gtkmm-tutorial-in.xml:3158(ulink)
#: C/gtkmm-tutorial-in.xml:3186(ulink) C/gtkmm-tutorial-in.xml:3215(ulink)
#: C/gtkmm-tutorial-in.xml:3267(ulink) C/gtkmm-tutorial-in.xml:3287(ulink)
#: C/gtkmm-tutorial-in.xml:3335(ulink) C/gtkmm-tutorial-in.xml:3829(ulink)
#: C/gtkmm-tutorial-in.xml:3886(ulink) C/gtkmm-tutorial-in.xml:3897(ulink)
#: C/gtkmm-tutorial-in.xml:3924(ulink) C/gtkmm-tutorial-in.xml:3947(ulink)
#: C/gtkmm-tutorial-in.xml:3971(ulink) C/gtkmm-tutorial-in.xml:4003(ulink)
#: C/gtkmm-tutorial-in.xml:4819(ulink) C/gtkmm-tutorial-in.xml:5091(ulink)
#: C/gtkmm-tutorial-in.xml:5123(ulink) C/gtkmm-tutorial-in.xml:7594(ulink)
msgid "Reference"
msgstr "Odkaz"

#: C/gtkmm-tutorial-in.xml:454(para)
msgid ""
"See the <link linkend=\"chapter-internationalization\">Internationalization</"
"link> section for information about providing the UTF-8 string literals."
msgstr ""
"Více informací o poskytování řetězcových literálů v UTF-8 viz kapitola <link "
"linkend=\"chapter-internationalization\">Internacionalizace</link>."

#: C/gtkmm-tutorial-in.xml:459(title)
msgid "Intermediate types"
msgstr "Mezilehlé typy"

#: C/gtkmm-tutorial-in.xml:460(para)
msgid ""
"Some API related to gtkmm uses intermediate data containers, such as "
"<classname>Glib::StringArrayHandle</classname>, instead of a specific "
"Standard C++ container such as <classname>std::vector</classname> or "
"<classname>std::list</classname>, though <application>gtkmm</application> "
"itself now uses just <classname>std::vector</classname> since "
"<application>gtkmm</application> 3.0."
msgstr ""
"Některá API vztahující se ke gtkmm používají místo specifických standardních "
"kontejnerů jazyka C++, jako je <classname>std::vector</classname> nebo "
"<classname>std::list</classname>, mezilehlé datové kontejnery, jako je "
"<classname>Glib::StringArrayHandle</classname>, ačkoliv samotné "
"<application>gtkmm</application> nyní od verze 3.0 používá jen "
"<classname>std::vector</classname>."

#: C/gtkmm-tutorial-in.xml:463(para)
msgid ""
"<classname>Glib::StringArrayHandle</classname> or <classname>Glib::"
"ArrayHandle&lt;Glib::ustring&gt;</classname>: Use <classname>std::vector&lt;"
"Glib::ustring&gt;</classname>, <classname>std::list&lt;Glib::ustring&gt;</"
"classname>, <type>const char*[]</type>, etc."
msgstr ""
"<classname>Glib::StringArrayHandle</classname> nebo <classname>Glib::"
"ArrayHandle&lt;Glib::ustring&gt;</classname>: Použijte <classname>std::"
"vector&lt;Glib::ustring&gt;</classname>, <classname>std::list&lt;Glib::"
"ustring&gt;</classname>, <type>const char*[]</type>, atd."

#: C/gtkmm-tutorial-in.xml:464(para)
msgid ""
"<classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>: Use "
"<classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
"list&lt;Gtk::Widget*&gt;</classname>, etc."
msgstr ""
"<classname>Glib::ListHandle&lt;Gtk::Widget*&gt;</classname>: Použijte "
"<classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
"list&lt;Gtk::Widget*&gt;</classname>, atd."

#: C/gtkmm-tutorial-in.xml:465(para)
msgid ""
"<classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>: Use "
"<classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
"list&lt;Gtk::Widget*&gt;</classname>, etc."
msgstr ""
"<classname>Glib::SListHandle&lt;Gtk::Widget*&gt;</classname>: Použijte "
"<classname>std::vector&lt;Gtk::Widget*&gt;</classname>, <classname>std::"
"list&lt;Gtk::Widget*&gt;</classname>, atd."

#: C/gtkmm-tutorial-in.xml:461(para)
msgid ""
"You should not declare these types yourself. You should instead use whatever "
"Standard C++ container you prefer. glibmm will do the conversion for you. "
"Here are some of these intermediate types: <placeholder-1/>"
msgstr ""
"Tyto typy byste si neměli deklarovat sami. Místo toho byste měli použít "
"kterýkoliv standardní kontejner jazyka C++, který vám vyhovuje. glibmm za "
"vás provede převod. Zde jsou některé z mezilehlých typů: <placeholder-1/> "

#: C/gtkmm-tutorial-in.xml:473(title)
msgid "Mixing C and C++ APIs"
msgstr "Míchání API z C a C++"

#: C/gtkmm-tutorial-in.xml:474(para)
msgid ""
"You can use C APIs which do not yet have convenient C++ interfaces. It is "
"generally not a problem to use C APIs from C++, and <application>gtkmm</"
"application> helps by providing access to the underlying C object, and "
"providing an easy way to create a C++ wrapper object from a C object, "
"provided that the C API is also based on the GObject system."
msgstr ""
"Můžete používat API v C, která zatím nemají vhodné rozhraní v C++. Obecně "
"není problém s používáním API v C z C++ a <application>gtkmm</application> v "
"tom pomáhá poskytováním přístupu k podkladovým objektům C a poskytováním "
"jednoduchého způsobu, jak vytvořit objekt v C++ obalující objekt v C za "
"předpokladu, že API v C je také založené na systému GObject."

#: C/gtkmm-tutorial-in.xml:476(para)
msgid ""
"To use a <application>gtkmm</application> instance with a C function that "
"requires a C GObject instance, use the <function>gobj()</function> function "
"to obtain a pointer to the underlying GObject instance. For instance"
msgstr ""
"Pro použití instance <application>gtkmm</application> s funkcí C, které "
"požaduje instanci GObject v C, použijte funkci <function>gobj()</function>, "
"přes kterou získáte ukazatel na podkladovou instanci GObject. Například"

#: C/gtkmm-tutorial-in.xml:479(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Button* button = new Gtk::Button(\"example\");\n"
"gtk_button_do_something_new(button-&gt;gobj());\n"
msgstr ""
"\n"
"Gtk::Button* button = new Gtk::Button(\"example\");\n"
"gtk_button_do_something_new(button-&gt;gobj());\n"

#: C/gtkmm-tutorial-in.xml:485(para)
msgid ""
"To obtain a <application>gtkmm</application> instance from a C GObject "
"instance, use the Glib::wrap() function. For instance"
msgstr ""
"Když chcete získat instanci <application>gtkmm</application> z instance "
"GObject v C, použijte <methodname>Glib::wrap()</methodname>. Například"

#: C/gtkmm-tutorial-in.xml:487(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"
msgstr ""
"\n"
"GtkButton* cbutton = get_a_button();\n"
"Gtk::Button* button = Glib::wrap(cbutton);\n"

#: C/gtkmm-tutorial-in.xml:495(title)
msgid "Hello World in <application>gtkmm</application>"
msgstr "„Ahoj Světe“ v <application>gtkmm</application>"

#: C/gtkmm-tutorial-in.xml:497(para)
msgid ""
"We've now learned enough to look at a real example. In accordance with an "
"ancient tradition of computer science, we now introduce Hello World, a la "
"<application>gtkmm</application>:"
msgstr ""
"Nyní už toho víme dost na to, abychom se mohli podívat na nějaký funkční "
"příklad. A jak už je v programování tradicí, začneme aplikací „Ahoj Světe“ a "
"lá <application>gtkmm</application>:"

#: C/gtkmm-tutorial-in.xml:504(para)
msgid ""
"Try to compile and run it before going on. You should see something like "
"this:"
msgstr ""
"Než budeme pokračovat, zkuste si ji přeložit a spustit. Měli byste vidět "
"něco takového:"

#: C/gtkmm-tutorial-in.xml:509(title)
msgid "Hello World"
msgstr "Hello World"

#: C/gtkmm-tutorial-in.xml:515(para)
msgid ""
"Pretty thrilling, eh? Let's examine the code. First, the "
"<classname>HelloWorld</classname> class:"
msgstr ""
"Pěkný výsledek, ne? Pojďme si kód vysvětlit. Nejprve třída "
"<classname>HelloWorld</classname>:"

#: C/gtkmm-tutorial-in.xml:520(programlisting)
#, no-wrap
msgid ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"\n"
"public:\n"
"  HelloWorld();\n"
"  virtual ~HelloWorld();\n"
"\n"
"protected:\n"
"  //Signal handlers:\n"
"  virtual void on_button_clicked();\n"
"\n"
"  //Member widgets:\n"
"  Gtk::Button m_button;\n"
"};"
msgstr ""
"class HelloWorld : public Gtk::Window\n"
"{\n"
"\n"
"public:\n"
"  HelloWorld();\n"
"  virtual ~HelloWorld();\n"
"\n"
"protected:\n"
"  // Obsluha signálu:\n"
"  virtual void on_button_clicked();\n"
"\n"
"  // Členské widgety:\n"
"  Gtk::Button m_button;\n"
"};"

#: C/gtkmm-tutorial-in.xml:535(para)
msgid ""
"This class implements the \"Hello World\" window. It's derived from "
"<classname>Gtk::Window</classname>, and has a single <classname>Gtk::Button</"
"classname> as a member. We've chosen to use the constructor to do all of the "
"initialisation work for the window, including setting up the signals. Here "
"it is, with the comments omitted:"
msgstr ""
"Tato třída implementuje okno „Hello World“. Je odvozená z <classname>Gtk::"
"Window</classname> a má jako člena jeden widget <classname>Gtk::Button</"
"classname>. Rozhodli jsme se využít konstruktor k provedené veškerých "
"instalačních prácí s oknem, včetně nastavení signálů. Zde je s vynechanými "
"komentáři:"

#: C/gtkmm-tutorial-in.xml:544(programlisting)
#, no-wrap
msgid ""
"HelloWorld::HelloWorld()\n"
":\n"
"  m_button (\"Hello World\")\n"
"{\n"
"  set_border_width(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  add(m_button);.\n"
"  m_button.show();\n"
"}"
msgstr ""
"HelloWorld::HelloWorld()\n"
":\n"
"  m_button (\"Hello World\")\n"
"{\n"
"  set_border_width(10);\n"
"  m_button.signal_clicked().connect(sigc::mem_fun(*this,\n"
"    &amp;HelloWorld::on_button_clicked));\n"
"  add(m_button);.\n"
"  m_button.show();\n"
"}"

#: C/gtkmm-tutorial-in.xml:555(para)
msgid ""
"Notice that we've used an initialiser statement to give the "
"<literal>m_button</literal> object the label \"Hello World\"."
msgstr ""
"Všimněte si, že používáme inicializační výraz k předání popisku „Hello "
"World“ objektu <literal>m_button</literal>."

#: C/gtkmm-tutorial-in.xml:560(para)
msgid ""
"Next we call the Window's <methodname>set_border_width()</methodname> "
"method. This sets the amount of space between the sides of the window and "
"the widget it contains."
msgstr ""
"Následně voláme metodu <methodname>set_border_width()</methodname> objektu "
"Window. Tím se nastaví množství volného místa mezi okraji okna a widgetem, "
"který je v okně obsažen."

#: C/gtkmm-tutorial-in.xml:566(para)
msgid ""
"We then hook up a signal handler to <literal>m_button</literal>'s "
"<literal>clicked</literal> signal. This prints our friendly greeting to "
"<literal>stdout</literal>."
msgstr ""
"Potom zaháčkujeme obsluhu signálu na signál <literal>clicked</literal> "
"widgetu <literal>m_button</literal>. V ní vypisujeme přátelské uvítání do "
"<literal>stdout</literal>."

#: C/gtkmm-tutorial-in.xml:571(para)
msgid ""
"Next, we use the Window's <methodname>add()</methodname> method to put "
"<literal>m_button</literal> in the Window. (<methodname>add()</methodname> "
"comes from <classname>Gtk::Container</classname>, which is described in the "
"chapter on container widgets.) The <methodname>add()</methodname> method "
"places the Widget in the Window, but it doesn't display the widget. "
"<application>gtkmm</application> widgets are always invisible when you "
"create them - to display them, you must call their <methodname>show()</"
"methodname> method, which is what we do in the next line."
msgstr ""
"Následně použijeme metodu <methodname>add()</methodname> k vložení "
"<literal>m_button</literal> do okna. (<methodname>add()</methodname> pochází "
"z třídy <classname>Gtk::Container</classname>, která je popsaná v kapitole o "
"kontejnerových třídách.) Metoda <methodname>add()</methodname> umístí widget "
"do okna, ale nezobrazí jej. Widgety jsou v <application>gtkmm</application> "
"po svém vytvoření vždy neviditelné – abyste je zobrazili, musíte zavolat "
"jejich metodu <methodname>show()</methodname>, což je přesně to, co děláme "
"na dalším řádku."

#: C/gtkmm-tutorial-in.xml:581(para)
msgid ""
"Now let's look at our program's <function>main()</function> function. Here "
"it is, without comments:"
msgstr ""
"Nyní se pojďme podívat na funkci <function>main()</function> našeho "
"programu. Zde je i s komentáři:"

#: C/gtkmm-tutorial-in.xml:586(programlisting)
#, no-wrap
msgid ""
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.example\");\n"
"\n"
"  HelloWorld helloworld;\n"
"  return app-&gt;run(helloworld);\n"
"}"
msgstr ""
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app = Gtk::Application::create(argc, argv, \"org.gtkmm.example\");\n"
"\n"
"  HelloWorld helloworld;\n"
"  return app-&gt;run(helloworld);\n"
"}"

#: C/gtkmm-tutorial-in.xml:594(para)
msgid ""
"First we instantiate an object stored in a <classname>RefPtr</classname> "
"smartpointer called <literal>app</literal>. This is of type <classname>Gtk::"
"Application</classname>. Every <application>gtkmm</application> program must "
"have one of these. We pass our command-line arguments to its create() "
"method. It takes the arguments it wants, and leaves you the rest, as we "
"described earlier."
msgstr ""
"Nejprve vytvoříme instanci objektu uchovávaného v chytrém ukazateli "
"<classname>RefPtr</classname> nazývaném <literal>app</literal>. Je typu "
"<classname>Gtk::Application</classname>. Každý program používající "
"<application>gtkmm</application> musí jeden takový mít. Jeho metodě "
"<function>create()</function> předáme argumenty příkazové řádky. Argumenty, "
"které potřebuje, si zpracuje a zpracování ostatních, jak jsme již psali, "
"ponechá na vás."

#: C/gtkmm-tutorial-in.xml:601(para)
msgid ""
"Next we make an object of our <classname>HelloWorld</classname> class, whose "
"constructor takes no arguments, but it isn't visible yet. When we call "
"<methodname>Gtk::Application::run()</methodname>, giving it the helloworld "
"Window, it shows the Window and starts the <application>gtkmm</"
"application><emphasis>event loop</emphasis>. During the event loop "
"<application>gtkmm</application> idles, waiting for actions from the user, "
"and responding appropriately. When the user closes the Window, run() will "
"return, causing the final line of our main() function be to executed. The "
"application will then finish."
msgstr ""
"Následně vytvoříme objekt naší třídy <classname>HelloWorld</classname>, "
"jejíž konstruktor nemá žádný argument, ale zatím není viditelná. Pak "
"zavoláme <methodname>Gtk::Application::run()</methodname>, čímž aplikace "
"dostane okno, to se zobrazí a spustí se <emphasis>smyčka událostí</emphasis> "
"<application>gtkmm</application>. Ve smyčce událostí je <application>gtkmm</"
"application> nečinné a jen vyčkává na nějakou činnost ze strany uživatele, "
"na níž příslušně zareaguje. Když uživatel zavře okno, dojde k návratu z "
"metody <methodname>run()</methodname> a tím se provede zbývající řádek ve "
"funkci <function>main()</function>. Po té aplikace skončí."

#: C/gtkmm-tutorial-in.xml:610(title)
msgid "Changes in <application>gtkmm</application> 3"
msgstr "Změny v <application>gtkmm</application> 3"

#: C/gtkmm-tutorial-in.xml:612(para)
msgid ""
"<application>gtkmm</application>-3.0 is a new version of the "
"<application>gtkmm</application> API that installs in parallel with the "
"older <application>gtkmm</application>-2.4 API. The last version of the "
"<application>gtkmm</application>-2.4 API was <application>gtkmm</"
"application> 2.24. <application>gtkmm</application> 3 has no major "
"fundamental differences to <application>gtkmm</application> 2 but does make "
"several small changes that were not possible while maintaining binary "
"compatibility. If you never used the <application>gtkmm</application>-2.4 "
"API then you can safely ignore this chapter."
msgstr ""
"<application>gtkmm</application>-3.0 je nová verze API <application>gtkmm</"
"application>, která se instaluje souběžně se starším API <application>gtkmm</"
"application>-2.4. Poslední verzí API <application>gtkmm</application>-2.4 "
"byla <application>gtkmm</application> 2.24. <application>gtkmm</application> "
"3 nemá žádné hlavní podstatné rozdíly vůči <application>gtkmm</application> "
"2, ale událo se v ní několik menších změn, které nejsou možné s dodržením "
"binární kompatibility. Pokud jste doposud nikdy nepoužívali API "
"<application>gtkmm</application>-2.4, můžete jej v této kapitole v klidu "
"ignorovat."

#: C/gtkmm-tutorial-in.xml:614(para)
msgid ""
"<application>gtkmm</application> 3's library is called "
"<literal>libgtkmm-3.0</literal> rather than <literal>libgtkmm-2.4</literal> "
"and installs its headers in a similarly-versioned directory, so your pkg-"
"config check should ask for <literal>gtkmm-3.0</literal> rather than "
"<literal>gtkmm-2.4</literal>."
msgstr ""
"Knihovna tvořící <application>gtkmm</application> 3.0 se nazývá "
"<literal>libgtkmm-3.0</literal> místo <literal>libgtkmm-2.4</literal> a "
"instaluje své hlavičkové soubory do obdobně verzované složky, takže se pkg-"
"config může doptat na <literal>gtkmm-3.0</literal> i <literal>gtkmm-2.4</"
"literal>."

#: C/gtkmm-tutorial-in.xml:617(para)
msgid "<application>gtkmm</application> 3 added some new classes:"
msgstr "<application>gtkmm</application> 3 přidává některé nové třídy:"

#: C/gtkmm-tutorial-in.xml:620(simpara)
msgid ""
"<classname>Gtk::AppChooser</classname>, <classname>Gtk::AppChooserButton</"
"classname>, <classname>Gtk::AppChooserDialog</classname> allow the user to "
"select an installed application to open a particular type of content."
msgstr ""
"<classname>Gtk::AppChooser</classname>, <classname>Gtk::AppChooserButton</"
"classname> a <classname>Gtk::AppChooserDialog</classname> umožňují uživateli "
"vybrat nainstalovanou aplikaci pro otevření konkrétního typu obsahu."

#: C/gtkmm-tutorial-in.xml:621(simpara)
msgid ""
"<classname>Gtk::Grid</classname> is a new container widget that will "
"eventually replace <classname>Gtk::Box</classname> and <classname>Gtk::"
"Table</classname>. It arranges its children according to properties of those "
"children rather than its own layout details."
msgstr ""
"<classname>Gtk::Grid</classname> je nový kontejnerový widget, který může "
"případně nahradit <classname>Gtk::Box</classname> a <classname>Gtk::Table</"
"classname>. Své potomky uspořádává přednostně podle jejich vlastností, místo "
"nějakého svého daného rozvržení."

#: C/gtkmm-tutorial-in.xml:622(simpara)
msgid ""
"<classname>Gtk::Switch</classname> displays On/Off states more explictly "
"than <classname>Gtk::CheckBox</classname>. It may be useful, for instance, "
"when allowing users to activate hardware."
msgstr ""
"<classname>Gtk::Switch</classname> zobrazuje stavy zapnuto/vypnuto jasnějším "
"způsobem, než <classname>Gtk::CheckBox</classname>. Může se například hodit, "
"když umožňujete uživateli aktivovat hardware."

#: C/gtkmm-tutorial-in.xml:625(para)
msgid ""
"<application>gtkmm</application> 3 also made several small changes to the "
"API, which you will probably encounter when porting code that used "
"<application>gtkmm</application>-2.4. Here is a short list:"
msgstr ""
"<application>gtkmm</application> 3 má také několik menších změn v API, na "
"které pravděpodobně narazíte při portování kódu, který používá "
"<application>gtkmm</application> 2.4. Zde je jejich krátký seznam:"

#: C/gtkmm-tutorial-in.xml:630(simpara)
msgid ""
"<classname>Gtk::CellLayout</classname>, used by <classname>Gtk::IconView</"
"classname>, <classname>Gtk::TreeView::Column</classname> and <classname>Gtk::"
"ComboBox</classname>, now has a <classname>Gtk::CellArea</classname> which "
"can be used to specify more details of how the <classname>CellRenderer</"
"classname>s are arranged and aligned."
msgstr ""
"<classname>Gtk::CellLayout</classname> používaná třídami <classname>Gtk::"
"IconView</classname>, <classname>Gtk::TreeView::Column</classname> a "
"<classname>Gtk::ComboBox</classname> má nyní <classname>Gtk::CellArea</"
"classname>, kterou lze použít k přesnějšímu určení, jak jsou objekty "
"<classname>CellRenderer</classname> uspořádané a zarovnané."

#: C/gtkmm-tutorial-in.xml:632(simpara)
msgid ""
"Gtk::ComboBox now derives from CellLayout, allowing easier layout and "
"alignment of its <classname>Gtk::CellRenderer</classname>s."
msgstr ""
"Gtk::ComboBox nyní odvozuje z CellLayout, díky čemuž je rozvržení a "
"zarovnání jeho instancí <classname>Gtk::CellRenderer</classname> snazší."

#: C/gtkmm-tutorial-in.xml:634(simpara)
msgid ""
"<classname>Gtk::Adjustment</classname> and <classname>IconSet</classname> "
"and <classname>Gdk::Cursor</classname> are now used via <classname>Glib::"
"RefPtr</classname>."
msgstr ""
"<classname>Gtk::Adjustment</classname>, <classname>IconSet</classname> a "
"<classname>Gdk::Cursor</classname> se teď používají přes <classname>Glib::"
"RefPtr</classname>."

#: C/gtkmm-tutorial-in.xml:636(simpara)
msgid ""
"<classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>, "
"<classname>Gtk::IconView</classname>, <classname>Gtk::Paned</classname>, "
"<classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</"
"classname>, <classname>Gtk::Scrollbar</classname> and <classname>Gtk::"
"Separator</classname> now derive from <classname>Gtk::Orientable</"
"classname>, allowing their orientation (vertical or horizontal) to be "
"specified without requiring the use of a derived class such as "
"<classname>Gtk::HBox</classname>."
msgstr ""
"<classname>Gtk::Box</classname>, <classname>Gtk::ButtonBox</classname>, "
"<classname>Gtk::IconView</classname>, <classname>Gtk::Paned</classname>, "
"<classname>Gtk::ProgressBar</classname>, <classname>Gtk::ScaleButton</"
"classname>, <classname>Gtk::Scrollbar</classname> a <classname>Gtk::"
"Separator</classname> jsou nyní odovozené z <classname>Gtk::Orientable</"
"classname>, což umožňuje jejich otočení (svislé nebo vodorovné) určit bez "
"požadavku na použití odvozené třídy, jako je <classname>Gtk::HBox</"
"classname>."

#: C/gtkmm-tutorial-in.xml:639(simpara)
msgid ""
"<classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, "
"<classname>Gtk::TreeView</classname> and other widgets derive from "
"Scrollable instead of having their own methods such as "
"<methodname>get_vadjustment()</methodname> and instead of having their own "
"set_scroll_adjustments signal."
msgstr ""
"<classname>Gtk::IconView</classname>, <classname>Gtk::TextView</classname>, "
"<classname>Gtk::TreeView</classname> a další widgety odvozují ze Scrollable, "
"místo aby si definovali své vlastní metody, jako je "
"<methodname>get_vadjustment()</methodname>, a místo aby měli svůj vlastní "
"signál set_scroll_adjustments."

#: C/gtkmm-tutorial-in.xml:641(simpara)
msgid ""
"<classname>Gtk::Style</classname> and <classname>Gtk::Rc</classname> were "
"removed, replaced by <classname>Gtk::StyleContext</classname>, and "
"<classname>Gtk::StyleProvider</classname>s, such as <classname>Gtk::"
"CssProvider</classname>."
msgstr ""
"<classname>Gtk::Style</classname> a <classname>Gtk::Rc</classname> byla "
"odstraněny a nahrazují je třída <classname>Gtk::StyleContext</classname> a "
"třídy <classname>Gtk::StyleProvider</classname>, jako je <classname>Gtk::"
"CssProvider</classname>."

#: C/gtkmm-tutorial-in.xml:643(simpara)
msgid ""
"Widget::on_expose_event() was replaced by Widget::on_draw(), which assumes "
"that cairomm is used for drawing, via the provided <classname>Cairo::"
"Context</classname> and does not require you to call <methodname>Cairo::"
"Context::clip()</methodname>."
msgstr ""
"Metoda Widget::on_expose_event() byla nahrazena pomocí Widget::on_draw(), "
"která předpokládá, že pro kreslení je použita knihovna cairomm přes "
"poskytovaný <classname>Cairo::Context</classname> a nevyžaduje volání "
"<methodname>Cairo::Context::clip()</methodname>."

#: C/gtkmm-tutorial-in.xml:645(simpara)
msgid ""
"<classname>Gdk::RGBA</classname> replaces <classname>Color</classname>, "
"adding an alpha component for opacity. <classname>Colormap</classname> was "
"removed, along with its awkward use to allocate colors."
msgstr ""
"<classname>Gdk::RGBA</classname> nahrazuje <classname>Color</classname>, "
"přičemž přidává komponentu alfa pro průhlednost. <classname>Colormap</"
"classname> byla odstraněna, spolu s jejím nevhodným alokováním barev."

#: C/gtkmm-tutorial-in.xml:647(simpara)
msgid ""
"<classname>Gdk::Pixmap</classname> and <classname>Gdk::Bitmap</classname> "
"were removed in favour of <classname>Gdk::Pixbuf</classname>."
msgstr ""
"<classname>Gdk::Pixmap</classname> a <classname>Gdk::Bitmap</classname> byly "
"odstraněny ve prospěch <classname>Gdk::Pixbuf</classname>."

#: C/gtkmm-tutorial-in.xml:649(simpara)
msgid ""
"<classname>Gdk::Drawable</classname> was removed, with its methods moving "
"into <classname>Gdk::Window</classname>."
msgstr ""
"Třída <classname>Gdk::Drawable</classname> byla odstraněn a jeho metody "
"přesunuty do <classname>Gdk::Window</classname>."

#: C/gtkmm-tutorial-in.xml:651(simpara)
msgid ""
"We now use std::vector in several methods instead of the intermediate "
"*Handle types to make the API clearer."
msgstr ""
"Nyní v několika metodách používáme std::vector místo mezilehlého typu "
"*Handle, aby bylo API čistší."

#: C/gtkmm-tutorial-in.xml:656(para)
msgid ""
"All deprecated API was removed in <application>gtkmm</application> 3.0, "
"though there will be new deprecations in future versions."
msgstr ""
"Všechna zavržená API byla v <application>gtkmm</application> 3.0 odstraněna, "
"ale v budoucnu se samozřejmě mohou objevit nově zavržená."

#: C/gtkmm-tutorial-in.xml:658(para)
msgid ""
"As a first step to porting your source code to <application>gtkmm</"
"application>-3.0 you should probably ensure that your application builds "
"with the deprecated <application>gtkmm</application>-2.4 API disabled, by "
"defining macro such as GTKMM_DISABLE_DEPRECATED. There are some autotools "
"macros that can help with this by defining them optionally at build time. "
"See the <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"PortingToGtkmm3\">gtkmm 3 porting wiki page</ulink> for more details."
msgstr ""
"Jako první krok při portování zdrojového kódu do <application>gtkmm</"
"application>-3.0 byste asi měli zajistit, abys se vaše aplikace sestavila se "
"zakázaným zavrženým API <application>gtkmm</application>-2.4 pomocí definice "
"makra GTKMM_DISABLE_DEPRECATED. Existují některá makra v autotools, která "
"vám to mohou usnadnit tím, že je volitelně definujete v době sestavení. Více "
"podrobností viz <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"PortingToGtkmm3\">wikistránka o portování na gtkmm 3</ulink>."

#: C/gtkmm-tutorial-in.xml:663(title)
msgid "Buttons"
msgstr "Tlačítka"

#: C/gtkmm-tutorial-in.xml:665(para)
msgid "<application>gtkmm</application> provides four basic types of buttons:"
msgstr ""
"<application>gtkmm</application> poskytuje čtyři základní typy tlačítek:"

#: C/gtkmm-tutorial-in.xml:672(term)
msgid "Push-Buttons"
msgstr "Mačkací tlačítko (Button)"

#: C/gtkmm-tutorial-in.xml:674(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button."
"html\"><classname>Gtk::Button</classname></ulink>. Standard buttons, usually "
"marked with a label or picture. Pushing one triggers an action. See the "
"<link linkend=\"sec-pushbuttons\">Button</link> section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/classGtk_1_1Button."
"html\"><classname>Gtk::Button</classname></ulink>. Standardní tlačítko, "
"obvykle doplnění popiskem nebo obrázkem. Zmáčknutí spustí akci. Viz kapitola "
"<link linkend=\"sec-pushbuttons\">Button</link>."

#: C/gtkmm-tutorial-in.xml:681(term)
msgid "Toggle buttons"
msgstr "Přepínací tlačítka (ToggleButton)"

#: C/gtkmm-tutorial-in.xml:683(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ToggleButton.html\"><classname>Gtk::ToggleButton</classname></"
"ulink>. Unlike a normal Button, which springs back up, a ToggleButton stays "
"down until you press it again. It might be useful as an on/off switch. See "
"the <link linkend=\"sec-toggle-buttons\">ToggleButton</link> section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1ToggleButton.html\"><classname>Gtk::ToggleButton</classname></"
"ulink>. Na rozdíl od normálního tlačítka, které se automaticky vrátí do "
"normálního stavu, přepínací tlačítko zůstane zmáčknuté, dokud jej znovu "
"nezmáčknete. Tím pádem se dá použít jak přepínač stavů zapnuto/vypnuto. Viz "
"kapitola <link linkend=\"sec-toggle-buttons\">ToggleButton</link>."

#: C/gtkmm-tutorial-in.xml:691(term)
msgid "Checkboxes"
msgstr "Zaškrtávací políčka (CheckButton)"

#: C/gtkmm-tutorial-in.xml:693(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1CheckButton.html\"><classname>Gtk::CheckButton</classname></"
"ulink>. These act like ToggleButtons, but show their state in small squares, "
"with their label at the side. They should be used in most situations which "
"require an on/off setting. See the <link linkend=\"sec-checkboxes"
"\">CheckButton</link> section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1CheckButton.html\"><classname>Gtk::CheckButton</classname></"
"ulink>. Funguje podobně jako přepínací tlačítko, ale svůj stav zobrazuje v "
"podobě malého čtverečku s popiskem vedle sebe. Mělo by se používat ve "
"většině situací, které požadují nastavení zapnuto/vypnuto. Viz kapitola "
"<link linkend=\"sec-checkboxes\">CheckButton</link>."

#: C/gtkmm-tutorial-in.xml:703(term)
msgid "Radio buttons"
msgstr "Skupinové přepínače (RadioButton)"

#: C/gtkmm-tutorial-in.xml:705(para)
msgid ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1RadioButton.html\"><classname>Gtk::RadioButton</classname></"
"ulink>. Named after the station selectors on old car radios, these buttons "
"are used in groups for options which are mutually exclusive. Pressing one "
"causes all the others in its group to turn off. They are similar to "
"CheckBoxes (a small widget with a label at the side), but usually look "
"different. See the <link linkend=\"sec-radio-buttons\">RadioButton</link> "
"section."
msgstr ""
"<ulink url=\"http://developer.gnome.org/gtkmm/unstable/"
"classGtk_1_1RadioButton.html\"><classname>Gtk::RadioButton</classname></"
"ulink>. Anglický název „rádiové tlačítko“ vznikl podle tlačítek na starých "
"autorádiích, kde tlačítka voliče spojená do skupiny a když jste některé "
"zmáčkli, jiné zmáčknuté vyskočilo, takže vždy mohl být zmáčknuté jen jedno. "
"Stejně tak u skupinového přepínače, když zvolení jednoho tlačítka způsobí "
"vypnutí ostatních. Jsou podobná zaškrtávacím políčkům (malý widget s "
"popiskem vedle sebe), ale mají jinou vizuální podobu. Viz kapitola <link "
"linkend=\"sec-radio-buttons\">RadioButton</link>."

#: C/gtkmm-tutorial-in.xml:719(para)
msgid ""
"Note that, due to GTK+'s theming system, the appearance of these widgets "
"will vary. In the case of checkboxes and radio buttons, they may vary "
"considerably."
msgstr ""
"Pamatujte, že díky systému motivů v GTK+ se vzhled těchto widgetů může "
"měnit. V případě zaškrtávacích políček a přepínačů dokonce značně."

#: C/gtkmm-tutorial-in.xml:726(title)
msgid "Button"
msgstr "Tlačítko (Button)"

#: C/gtkmm-tutorial-in.xml:728(title)
msgid "Constructors"
msgstr "Konstruktory"

#: C/gtkmm-tutorial-in.xml:730(para)
msgid ""
"There are two ways to create a Button. You can specify a label string in the "
"<classname>Gtk::Button</classname> constructor, or set it later with "
"<methodname>set_label()</methodname>."
msgstr ""
"Existují dva postupy, jak vytvořit tlačítko. Můžete určit textový popisek v "
"konstruktoru <classname>Gtk::Button</classname> nebo jej nastavit později "
"pomocí <methodname>set_label()</methodname>."

#: C/gtkmm-tutorial-in.xml:736(para)
msgid ""
"To define an accelerator key for keyboard navigation, place an underscore "
"before one of the label's characters and specify <literal>true</literal> for "
"the optional <literal>mnemonic</literal> parameter. For instance:"
msgstr ""
"K definici horké klávesy pro ovládání z klávesnice umístěte před jeden ze "
"znaků popisku podtržítko a volitelný parametr <literal>mnemonic</literal> "
"nastavte na <literal>true</literal>. Například:"

#: C/gtkmm-tutorial-in.xml:738(programlisting)
#, no-wrap
msgid "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"
msgstr "Gtk::Button* pButton = new Gtk::Button(\"_Something\", true);"

#: C/gtkmm-tutorial-in.xml:740(para)
msgid ""
"Stock items have been recommended for use in buttons. From "
"<application>gtkmm</application>-3.10 they are deprecated. They should not "
"be used in newly-written code. However, the documentation of <ulink url="
"\"http://developer.gnome.org/gtkmm/unstable/namespaceGtk_1_1Stock.html"
"\">namespace Gtk::Stock</ulink> shows recommended labels and named icons to "
"show in buttons."
msgstr ""
"Pro tlačítka byly doporučované standardní ikony. Od <application>gtkmm</"
"application>-3.10 jsou zavržené a v nově psaném kódu byste je neměli "
"používat. Místo toho dokumentace ke <ulink url=\"http://developer.gnome.org/"
"gtkmm/unstable/namespaceGtk_1_1Stock.html\">jmennému prostoru Gtk::Stock</"
"ulink> ukazuje doporučené popisky a pojmenované ikony pro zobrazení na "
"tlačítkách."

#: C/gtkmm-tutorial-in.xml:747(para)
msgid ""
"<classname>Gtk::Button</classname> is also a container so you could put any "
"other widget, such as a <classname>Gtk::Image</classname> into it."
msgstr ""
"<classname>Gtk::Button</classname> je také kontejner, takže do něj můžete "
"vložit jiný widget, jako třeba <classname>Gtk::Image</classname>."

#: C/gtkmm-tutorial-in.xml:756(title) C/gtkmm-tutorial-in.xml:868(title)
#: C/gtkmm-tutorial-in.xml:973(title) C/gtkmm-tutorial-in.xml:1091(title)
#: C/gtkmm-tutorial-in.xml:1148(title) C/gtkmm-tutorial-in.xml:1456(title)
#: C/gtkmm-tutorial-in.xml:1521(title) C/gtkmm-tutorial-in.xml:1545(title)
#: C/gtkmm-tutorial-in.xml:1576(title) C/gtkmm-tutorial-in.xml:1633(title)
#: C/gtkmm-tutorial-in.xml:1673(title) C/gtkmm-tutorial-in.xml:1714(title)
#: C/gtkmm-tutorial-in.xml:1748(title) C/gtkmm-tutorial-in.xml:1788(title)
#: C/gtkmm-tutorial-in.xml:2087(title) C/gtkmm-tutorial-in.xml:2123(title)
#: C/gtkmm-tutorial-in.xml:2159(title) C/gtkmm-tutorial-in.xml:2226(title)
#: C/gtkmm-tutorial-in.xml:2266(title) C/gtkmm-tutorial-in.xml:3832(title)
#: C/gtkmm-tutorial-in.xml:3900(title) C/gtkmm-tutorial-in.xml:3927(title)
#: C/gtkmm-tutorial-in.xml:3950(title) C/gtkmm-tutorial-in.xml:3974(title)
#: C/gtkmm-tutorial-in.xml:4006(title) C/gtkmm-tutorial-in.xml:4178(title)
#: C/gtkmm-tutorial-in.xml:4322(title) C/gtkmm-tutorial-in.xml:4397(title)
#: C/gtkmm-tutorial-in.xml:4469(title) C/gtkmm-tutorial-in.xml:4534(title)
#: C/gtkmm-tutorial-in.xml:4776(title) C/gtkmm-tutorial-in.xml:5327(title)
#: C/gtkmm-tutorial-in.xml:5807(title) C/gtkmm-tutorial-in.xml:5856(title)
#: C/gtkmm-tutorial-in.xml:6411(title) C/gtkmm-tutorial-in.xml:6480(title)
#: C/gtkmm-tutorial-in.xml:7116(title) C/gtkmm-tutorial-in.xml:7175(title)
#: C/gtkmm-tutorial-in.xml:7418(title) C/gtkmm-tutorial-in.xml:8321(title)
msgid "Example"
msgstr "Příklad"

#: C/gtkmm-tutorial-in.xml:758(para)
msgid "This example creates a button with a picture and a label."
msgstr "Tento příklad vytvoří tlačítko s obrázkem a popiskem."

#: C/gtkmm-tutorial-in.xml:763(title)
msgid "buttons example"
msgstr "Příklad tlačítka"

#: C/gtkmm-tutorial-in.xml:775(para)
msgid ""
"The <classname>Gtk::Button</classname> widget has the following signals, but "
"most of the time you will just handle the <literal>clicked</literal> signal:"
msgstr ""
"Widget <classname>Gtk::Button</classname> má následující signály, ale "
"povětšinou budete obsluhovat stejně jen signál <literal>clicked</literal>:"

#: C/gtkmm-tutorial-in.xml:783(literal)
msgid "pressed"
msgstr "pressed"

#: C/gtkmm-tutorial-in.xml:785(para)
msgid "Emitted when the button is pressed."
msgstr "Vyšle se, když je tlačítko zmáčknuto."

#: C/gtkmm-tutorial-in.xml:791(literal)
msgid "released"
msgstr "released"

#: C/gtkmm-tutorial-in.xml:793(para)
msgid "Emitted when the button is released."
msgstr "Vyšle se, když je tlačítko uvolněno."

#: C/gtkmm-tutorial-in.xml:799(literal)
msgid "clicked"
msgstr "clicked"

#: C/gtkmm-tutorial-in.xml:801(para)
msgid "Emitted when the button is pressed and released."
msgstr "Vyšle se, když je tlačítko zmáčknuto a uvolněno."

#: C/gtkmm-tutorial-in.xml:807(literal)
msgid "enter"
msgstr "enter"

#: C/gtkmm-tutorial-in.xml:809(para)
msgid "Emitted when the mouse pointer moves over the button's window."
msgstr "Vyšle se, když ukazatel myši najede nad okno vlastnící tlačítko."

#: C/gtkmm-tutorial-in.xml:815(literal)
msgid "leave"
msgstr "leave"

#: C/gtkmm-tutorial-in.xml:817(para)
msgid "Emitted when the mouse pointer leaves the button's window."
msgstr "Vyšle se, když ukazatel myši opustí okno vlastnící tlačítko."

#: C/gtkmm-tutorial-in.xml:829(title)
msgid "ToggleButton"
msgstr "Přepínací tlačítko (ToggleButton)"

#: C/gtkmm-tutorial-in.xml:831(para)
msgid ""
"<classname>ToggleButton</classname>s are like normal <classname>Button</"
"classname>s, but when clicked they remain activated, or pressed, until "
"clicked again."
msgstr ""
"<classname>ToggleButton</classname> se podobá na normální <classname>Button</"
"classname>, ale když je zmáčknuto, tak zůstane zmáčknuté, dokud na něj znovu "
"nekliknete."

#: C/gtkmm-tutorial-in.xml:833(para)
msgid ""
"To retrieve the state of the <classname>ToggleButton</classname>, you can "
"use the <methodname>get_active()</methodname> method. This returns "
"<literal>true</literal> if the button is \"down\". You can also set the "
"toggle button's state, with <methodname>set_active()</methodname>. Note "
"that, if you do this, and the state actually changes, it causes the \"clicked"
"\" signal to be emitted. This is usually what you want."
msgstr ""
"Pro získání stavu widgetu <classname>ToggleButton</classname> můžete použít "
"metodu <methodname>get_active()</methodname>. Ta vrací <literal>true</"
"literal>, když je tlačítko „dole“. Můžete také stav tlačítka nastavit pomocí "
"<methodname>set_active()</methodname>. Všimněte si, že když to uděláte a "
"aktuální stav se tím změní, způsobí to vyslání signálu „clicked“, což je "
"přesně to, co obvykle chcete."

#: C/gtkmm-tutorial-in.xml:840(para)
msgid ""
"You can use the <methodname>toggled()</methodname> method to toggle the "
"button, rather than forcing it to be up or down: This switches the button's "
"state, and causes the <literal>toggled</literal> signal to be emitted."
msgstr ""
"Můžete používat metodu <methodname>toggled()</methodname> k přepnutí "
"tlačítka a určitě ji dejte přednost pro vynucením zmáčknutí nebo vyskočení: "
"Přepne stav tlačítka a způsobí vyslání signálu <literal>toggled</literal>."

#: C/gtkmm-tutorial-in.xml:845(para)
msgid ""
"<classname>Gtk::ToggleButton</classname> is most useful as a base class for "
"the <classname>Gtk::CheckButton</classname> and <classname>Gtk::RadioButton</"
"classname> classes."
msgstr ""
"<classname>Gtk::ToggleButton</classname> je užitečné především jako základní "
"třída pro třídy <classname>Gtk::CheckButton</classname> a <classname>Gtk::"
"RadioButton</classname>."

#: C/gtkmm-tutorial-in.xml:856(title) C/gtkmm-tutorial-in.xml:871(title)
msgid "CheckButton"
msgstr "Zaškrtávací políčko (CheckButton)"

#: C/gtkmm-tutorial-in.xml:858(para)
msgid ""
"<classname>Gtk::CheckButton</classname> inherits from <classname>Gtk::"
"ToggleButton</classname>. The only real difference between the two is "
"<classname>Gtk::CheckButton</classname>'s appearance. You can check, set, "
"and toggle a checkbox using the same member methods as for <classname>Gtk::"
"ToggleButton</classname>."
msgstr ""
"<classname>Gtk::CheckButton</classname> je zděděné z <classname>Gtk::"
"ToggleButton</classname>. Jediný skutečný rozdíl mezi nim je ve vzhledu "
"<classname>Gtk::CheckButton</classname>. Zaškrtávací políčko můžete "
"kontrolovat, nastavovat a přepínat těmi stejnými členskými metodami, jako "
"<classname>Gtk::ToggleButton</classname>."

#: C/gtkmm-tutorial-in.xml:883(title) C/gtkmm-tutorial-in.xml:980(title)
msgid "RadioButton"
msgstr "Skupinový přepínač (RadioButton)"

#: C/gtkmm-tutorial-in.xml:885(para)
msgid ""
"Like checkboxes, radio buttons also inherit from <classname>Gtk::"
"ToggleButton</classname>, but these work in groups, and only one RadioButton "
"in a group can be selected at any one time."
msgstr ""
"Podobně jako zaškrtávací políčka, i skupinové přepínače jsou zděděné z "
"<classname>Gtk::ToggleButton</classname>, ale pracují ve skupinách, kdy v "
"jednu chvíli jen jedno z nich může být ve skupině vybráno."

#: C/gtkmm-tutorial-in.xml:891(title)
msgid "Groups"
msgstr "Skupiny"

#: C/gtkmm-tutorial-in.xml:892(para)
msgid ""
"There are two ways to set up a group of radio buttons. The first way is to "
"create the buttons, and set up their groups afterwards. Only the first two "
"constructors are used. In the following example, we make a new window class "
"called <classname>RadioButtons</classname>, and then put three radio buttons "
"in it:"
msgstr ""
"Existují dva způsoby, jak nastavit skupinovým přepínačům skupinu. První "
"způsob je vytvořit tlačítka a později jim nastavit skupinu. Používají se jen "
"první dva konstruktory. V následujícím příkladu vytvoříme novou třídu okna "
"nazvanou <classname>RadioButtons</classname> a pak do ní vložíme tři "
"skupinové přepínače:"

#: C/gtkmm-tutorial-in.xml:900(programlisting)
#, no-wrap
msgid ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"\n"
"protected:\n"
"    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"  : m_rb1(\"button1\"),\n"
"    m_rb2(\"button2\"),\n"
"    m_rb3(\"button3\")\n"
"{\n"
"    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
"    m_rb2.set_group(group);\n"
"    m_rb3.set_group(group);\n"
"}"
msgstr ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"\n"
"protected:\n"
"    Gtk::RadioButton m_rb1, m_rb2, m_rb3;\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"  : m_rb1(\"button1\"),\n"
"    m_rb2(\"button2\"),\n"
"    m_rb3(\"button3\")\n"
"{\n"
"    Gtk::RadioButton::Group group = m_rb1.get_group();\n"
"    m_rb2.set_group(group);\n"
"    m_rb3.set_group(group);\n"
"}"

#: C/gtkmm-tutorial-in.xml:918(para)
msgid ""
"We told <application>gtkmm</application> to put all three "
"<classname>RadioButton</classname>s in the same group by obtaining the group "
"with <methodname>get_group()</methodname> and using <methodname>set_group()</"
"methodname> to tell the other <classname>RadioButton</classname>s to share "
"that group."
msgstr ""
"Řekli jsme <application>gtkmm</application>, aby vložil tři widgety "
"<classname>RadioButton</classname> do stejné skupiny tak, že jsme získali "
"skupinu pomocí <methodname>get_group()</methodname> a použili "
"<methodname>set_group()</methodname>, abychom ostatním widgetům "
"<classname>RadioButton</classname> řekli, že mají tuto skupinu sdílet."

#: C/gtkmm-tutorial-in.xml:927(programlisting)
#, no-wrap
msgid "m_rb2.set_group(m_rb1.get_group()); //doesn't work"
msgstr "m_rb2.set_group(m_rb1.get_group()); // nefunguje"

#: C/gtkmm-tutorial-in.xml:925(para)
msgid ""
"Note that you can't just do <placeholder-1/> because the group is modified "
"by <methodname>set_group()</methodname> and therefore non-const."
msgstr ""
"Pamatujte, že nemůžete jen prostě provést <placeholder-1/> protože skupina "
"je voláním <methodname>set_group()</methodname> měněna a proto není "
"konstantní."

#: C/gtkmm-tutorial-in.xml:933(para)
msgid ""
"The second way to set up radio buttons is to make a group first, and then "
"add radio buttons to it. Here's an example:"
msgstr ""
"Druhým způsobem, jak vytvořit skupinové přepínače, je nejprve vytvořit "
"skupinu a pak do ní přidávat jednotlivé skupinové přepínače. Zde je příklad:"

#: C/gtkmm-tutorial-in.xml:937(programlisting)
#, no-wrap
msgid ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"{\n"
"    Gtk::RadioButton::Group group;\n"
"    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
"      new Gtk::RadioButton(group,\"button1\"));\n"
"    Gtk::RadioButton *m_rb2 = manage(\n"
"      new Gtk::RadioButton(group,\"button2\"));\n"
"      Gtk::RadioButton *m_rb3 = manage(\n"
"        new Gtk::RadioButton(group,\"button3\"));\n"
"}"
msgstr ""
"class RadioButtons : public Gtk::Window\n"
"{\n"
"public:\n"
"    RadioButtons();\n"
"};\n"
"\n"
"RadioButtons::RadioButtons()\n"
"{\n"
"    Gtk::RadioButton::Group group;\n"
"    Gtk::RadioButton *m_rb1 = Gtk::manage(\n"
"      new Gtk::RadioButton(group,\"button1\"));\n"
"    Gtk::RadioButton *m_rb2 = manage(\n"
"      new Gtk::RadioButton(group,\"button2\"));\n"
"      Gtk::RadioButton *m_rb3 = manage(\n"
"        new Gtk::RadioButton(group,\"button3\"));\n"
"}"

#: C/gtkmm-tutorial-in.xml:954(para)
msgid ""
"We made a new group by simply declaring a variable, <literal>group</"
"literal>, of type <classname>Gtk::RadioButton::Group</classname>. Then we "
"made three radio buttons, using a constructor to make each of them part of "
"<literal>group</literal>."
msgstr ""
"Jednoduchou deklarací <literal>group</literal> typu <classname>Gtk::"
"RadioButton::Group</classname> vytvoříme novou skupinu. Následně vytvoříme "
"tři skupinové přepínače pomocí konstruktoru, který z nich udělá členy "
"skupiny <literal>group</literal>."

#: C/gtkmm-tutorial-in.xml:962(title) C/gtkmm-tutorial-in.xml:1418(title)
#: C/gtkmm-tutorial-in.xml:4645(title)
msgid "Methods"
msgstr "Metody"

#: C/gtkmm-tutorial-in.xml:963(para)
msgid ""
"<classname>RadioButtons</classname> are \"off\" when created; this means "
"that when you first make a group of them, they will all be off. Don't forget "
"to turn one of them on using <methodname>set_active()</methodname>:"
msgstr ""
"<classname>RadioButtons</classname> jsou po vytvoření „vypnuté“, takže když "
"z nich poprvé vytvoříte skupinu, nebude žádný z nich vybraný. Proto před "
"jejich použitím nezapomeňte jeden znich pomocí <methodname>set_active()</"
"methodname> zapnout:"

#: C/gtkmm-tutorial-in.xml:974(para)
msgid ""
"The following example demonstrates the use of <classname>RadioButton</"
"classname>s:"
msgstr ""
"Následující příklad ukazuje použití skupinových přepínačů "
"<classname>RadioButton</classname>:"

#: C/gtkmm-tutorial-in.xml:996(title) C/gtkmm-tutorial-in.xml:1102(title)
msgid "Range Widgets"
msgstr "Widgety odvozené z Range"

#: C/gtkmm-tutorial-in.xml:998(para)
msgid ""
"<classname>Gtk::Scale</classname> and <classname>Gtk::Scrollbar</classname> "
"both inherit from <classname>Gtk::Range</classname> and share much "
"functionality. They contain a \"trough\" and a \"slider\" (sometimes called "
"a \"thumbwheel\" in other GUI environments). Dragging the slider with the "
"pointer moves it within the trough, while clicking in the trough advances "
"the slider towards the location of the click, either completely, or by a "
"designated amount, depending on which mouse button is used. This should be "
"familiar scrollbar behaviour."
msgstr ""
"Widgety <classname>Gtk::Scale</classname> a <classname>Gtk::Scrollbar</"
"classname> jsou odvozené z <classname>Gtk::Range</classname> a sdílí s ním "
"mnoho funkcionality. Obsahují „vodicí dráhu“ a „táhlo“ (v některých "
"grafických prostředích nazývané „posuvné kolečko“). Tažením táhla pomocí "
"ukazatele myši provádí posuv v mezích vodicí dráhy, klikání na vodicí dráhu "
"posouvá táhlo přímo na místo kliku nebo o určenou vzdálenost, v závislosti "
"na použitém tlačítku myši. Tohle by mělo být běžně známé chování posuvníku."

#: C/gtkmm-tutorial-in.xml:1009(para)
msgid ""
"As will be explained in the <link linkend=\"chapter-adjustment\">Adjustment</"
"link> section, all Range widgets are associated with a "
"<classname>Adjustment</classname> object. To change the lower, upper, and "
"current values used by the widget you need to use the methods of its "
"<classname>Adjustment</classname>, which you can get with the "
"<methodname>get_adjustment()</methodname> method. The <classname>Range</"
"classname> widgets' default constructors create an <classname>Adjustment</"
"classname> automatically, or you can specify an existing "
"<classname>Adjustment</classname>, maybe to share it with another widget. "
"See the <link linkend=\"chapter-adjustment\">Adjustments</link> section for "
"further details."
msgstr ""
"Jak bylo vysvětleno v kapitole <link linkend=\"chapter-adjustment"
"\">Přizpůsobení (Adjustment)</link>, všechny widgety odvozené z "
"<classname>Range</classname> jsou spřažené s objektem <classname>Adjustment</"
"classname>. Pro změnu hodnot <literal>lower</literal>, <literal>upper</"
"literal> a <literal>current</literal> použitých widgetem musíte použít "
"metody jeho objektu <classname>Adjustment</classname>, který můžete získat "
"pomocí metody <methodname>get_adjustment()</methodname>. Výchozí konstruktor "
"widgetu <classname>Range</classname> vytváří <classname>Adjustment</"
"classname> automaticky, nebo můžete určit některý existující, třeba když jej "
"chcete sdílet s jinými widgety. Další podrobnosti viz kapitola <link linkend="
"\"chapter-adjustment\">Přizpůsobení (Adjustment)</link>."

#: C/gtkmm-tutorial-in.xml:1026(title)
msgid "Scrollbar Widgets"
msgstr "Posuvníkové widgety"

#: C/gtkmm-tutorial-in.xml:1028(para)
msgid ""
"These are standard scrollbars. They should be used only to scroll another "
"widget, such as, a <classname>Gtk::Entry</classname>, or a <classname>Gtk::"
"Viewport</classname>, though it's usually easier to use the <classname>Gtk::"
"ScrolledWindow</classname> widget in most cases."
msgstr ""
"K dispozici jsou standardní posuvníky. Měly by se používat jen k posunu v "
"jiných widgetech, jako třeba v <classname>Gtk::Entry</classname> nebo "
"<classname>Gtk::Viewport</classname>, ale většinou je stejně jednodušší "
"použít widget <classname>Gtk::ScrolledWindow</classname>."

#: C/gtkmm-tutorial-in.xml:1035(para)
msgid ""
"The orientation of a <classname>Gtk::Scrollbar</classname> can be either "
"horizontal or vertical."
msgstr ""
"Orientace widgetu <classname>Gtk::Scrollbar</classname> může být vodorovná "
"nebo svislá."

#: C/gtkmm-tutorial-in.xml:1045(title)
msgid "Scale Widgets"
msgstr "Stupnicové widgety"

#: C/gtkmm-tutorial-in.xml:1047(para)
msgid ""
"<classname>Gtk::Scale</classname> widgets (or \"sliders\") allow the user to "
"visually select and manipulate a value within a specific range. You might "
"use one, for instance, to adjust the magnification level on a zoomed preview "
"of a picture, or to control the brightness of a colour, or to specify the "
"number of minutes of inactivity before a screensaver takes over the screen."
msgstr ""
"Widgety <classname>Gtk::Scale</classname> (nebo „táhla“) umožňují uživateli "
"vizuálně vybrat a měnit hodnotu v rámci určeného rozsahu. Můžete je použít "
"například ke změně úrovně přiblížení náhledu obrázku, nebo k ovládání jasu "
"barvy, nebo k určení počtu minut nečinnosti před zapnutím šetřiče obrazovky."

#: C/gtkmm-tutorial-in.xml:1056(para)
msgid ""
"As with <classname>Scrollbar</classname>s, the orientation can be either "
"horizontal or vertical. The default constructor creates an "
"<classname>Adjustment</classname> with all of its values set to "
"<literal>0.0</literal>. This isn't useful so you will need to set some "
"<classname>Adjustment</classname> details to get meaningful behaviour."
msgstr ""
"Stejně, jako u widgetů <classname>Scrollbar</classname>, může být orientace "
"buď vodorovná nebo svislá. Výchozí konstruktor vytvoří objekt "
"<classname>Adjustment</classname> se všemi jeho hodnotami nastavenými na "
"<literal>0.0</literal>. To není použitelné, takže potřebujete nastavit u "
"objektu <classname>Adjustment</classname> některé údaje, abyste získali "
"smysluplné chování."

#: C/gtkmm-tutorial-in.xml:1065(title)
msgid "Useful methods"
msgstr "Užitečné metody"

#: C/gtkmm-tutorial-in.xml:1067(para)
msgid ""
"<classname>Scale</classname> widgets can display their current value as a "
"number next to the trough. By default they show the value, but you can "
"change this with the <methodname>set_draw_value()</methodname> method."
msgstr ""
"Widgety <classname>Scale</classname> umí zobrazit vedle stupnice aktuální "
"číselnou hodnotu. Výchozí je zobrazení hodnoty, ale můžete to změnit pomocí "
"metody <methodname>set_draw_value()</methodname>."

#: C/gtkmm-tutorial-in.xml:1073(para)
msgid ""
"The value displayed by a scale widget is rounded to one decimal point by "
"default, as is the <literal>value</literal> field in its <classname>Gtk::"
"Adjustment</classname>. You can change this with the "
"<methodname>set_digits()</methodname> method."
msgstr ""
"Hodnota zobrazená u stupnicových widgetů je ve výchozím stavu zaokrouhlovaná "
"na jedno desetinné místo, stejně jako pole <literal>value</literal> v jejich "
"objektu <classname>Gtk::Adjustment</classname>. Změnit to můžete pomocí "
"metody <methodname>set_digits()</methodname>."

#: C/gtkmm-tutorial-in.xml:1080(para)
msgid ""
"Also, the value can be drawn in different positions relative to the trough, "
"specified by the <methodname>set_value_pos()</methodname> method."
msgstr ""
"Také může, pomocí metody <methodname>set_value_pos()</methodname>, nastavit "
"místo pro vykreslování hodnoty, relativně k vodicí dráze."

#: C/gtkmm-tutorial-in.xml:1093(para)
msgid ""
"This example displays a window with three range widgets all connected to the "
"same adjustment, along with a couple of controls for adjusting some of the "
"parameters mentioned above and in the section on adjustments, so you can see "
"how they affect the way these widgets work for the user."
msgstr ""
"Tento příklad zobrazuje okno se třemi widgety pro určení rozmezí, které jsou "
"všechny napojené na ten stejný widget přizpůsobení, spolu s párem ovládacích "
"prvků pro přizpůsobení některých parametrů zmíněných výše a v kapitole o "
"třídě <classname>Adjustment</classname>, takže nyní můžete vidět, jak "
"ovlivňují fungování z pohledu uživatele."

#: C/gtkmm-tutorial-in.xml:1115(title)
msgid "Miscellaneous Widgets"
msgstr "Různé widgety"

#: C/gtkmm-tutorial-in.xml:1118(title) C/gtkmm-tutorial-in.xml:1158(title)
msgid "Label"
msgstr "Popisek (Label)"

#: C/gtkmm-tutorial-in.xml:1120(para)
msgid ""
"Labels are the main method of placing non-editable text in windows, for "
"instance to place a title next to a <classname>Entry</classname> widget. You "
"can specify the text in the constructor, or later with the "
"<methodname>set_text()</methodname> or <methodname>set_markup()</methodname> "
"methods."
msgstr ""
"Popisky jsou hlavním způsobem, jak umístit neupravitelný text do oken, "
"například název vedle vstupního pole <classname>Entry</classname>. Text "
"můžete zadat v konstruktoru nebo později pomocí metody "
"<methodname>set_text()</methodname> nebo <methodname>set_markup()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1127(para)
msgid ""
"The width of the label will be adjusted automatically. You can produce multi-"
"line labels by putting line breaks (\"\\n\") in the label string."
msgstr ""
"Šířka popisku se přizpůsobuje automaticky. Můžete vytvářet i víceřádkové "
"popisky vloženém zalomení (\"\\n\") do textového řetězce popisku."

#: C/gtkmm-tutorial-in.xml:1131(para)
msgid ""
"The label text can be justified using the <methodname>set_justify()</"
"methodname> method. The widget is also capable of word-wrapping, which can "
"be activated with <methodname>set_line_wrap()</methodname>."
msgstr ""
"Text popisku může být zarovnán pomocí metody <methodname>set_justify()</"
"methodname>. Rovněž zvládá zalamování slov, které se dá aktivovat pomocí "
"<methodname>set_line_wrap()</methodname>."

#: C/gtkmm-tutorial-in.xml:1137(para)
msgid ""
"Gtk::Label support some simple formatting, for instance allowing you to make "
"some text bold, colored, or larger. You can do this by providing a string to "
"<methodname>set_markup()</methodname>, using the <ulink url=\"http://"
"developer.gnome.org/pango/unstable/PangoMarkupFormat.html\">Pango Markup "
"syntax</ulink>. For instance, <code> &lt;b&gt;bold text&lt;/b&gt; and &lt;"
"s&gt;strikethrough text&lt;/s&gt; </code> ."
msgstr ""
"Gtk::Label podporuje jednoduché formátování, například pro ztučnění, "
"obarvení nebo zvětšení textu. Docílit toho můžete tím, že metodě "
"<methodname>set_markup()</methodname> předáte řetězec, který používá <ulink "
"url=\"http://developer.gnome.org/pango/unstable/PangoMarkupFormat.html"
"\">syntax Pango Markup</ulink>. Kupříkladu <code>&lt;b&gt;bold text&lt;/"
"b&gt; and &lt;s&gt;strikethrough text&lt;/s&gt;</code> ."

#: C/gtkmm-tutorial-in.xml:1149(para)
msgid ""
"Below is a short example to illustrate these functions. This example makes "
"use of the Frame widget to better demonstrate the label styles. (The Frame "
"widget is explained in the <link linkend=\"sec-frame\">Frame</link> "
"section.) It is possible that the first character in "
"<literal>m_Label_Normal</literal> is shown underlined only when you press "
"the <keycap>Alt</keycap> key."
msgstr ""
"Níže je krátký příklad, který ilustruje tyto funkce. Pro lepší ukázku stylů "
"popisku vyžívá widget Frame. (Widget Frame je vysvětlen v kapitole <link "
"linkend=\"sec-frame\">Rám (Frame)</link>.) Podle nastavení systému je možné, "
"že první znak v <literal>m_Label_Normal</literal> se zobrazí podtržený, jen "
"když zmáčknete klávesu <keycap>Alt</keycap>."

#: C/gtkmm-tutorial-in.xml:1171(title) C/gtkmm-tutorial-in.xml:1228(title)
msgid "Entry"
msgstr "Vstupní pole (Entry)"

#: C/gtkmm-tutorial-in.xml:1174(title)
msgid "Simple Use"
msgstr "Jednoduché použití"

#: C/gtkmm-tutorial-in.xml:1176(para)
msgid ""
"Entry widgets allow the user to enter text. You can change the contents with "
"the <methodname>set_text()</methodname> method, and read the current "
"contents with the <methodname>get_text()</methodname> method."
msgstr ""
"Vstupní pole umožňují uživateli zadat text. Obsah pole můžete měnit pomocí "
"metody <methodname>set_text()</methodname> a aktuální obsah číst pomocí "
"metody <methodname>get_text()</methodname>."

#: C/gtkmm-tutorial-in.xml:1181(para)
msgid ""
"Occasionally you might want to make an <classname>Entry</classname> widget "
"read-only. This can be done by passing <literal>false</literal> to the "
"<methodname>set_editable()</methodname> method."
msgstr ""
"Příležitostně můžete potřebovat, aby byl widget <classname>Entry</classname> "
"jen ke čtení. Toho se dá dosáhnout předáním <literal>false</literal> metodě "
"<methodname>set_editable()</methodname>."

#: C/gtkmm-tutorial-in.xml:1187(para)
msgid ""
"For the input of passwords, passphrases and other information you don't want "
"echoed on the screen, calling <methodname>set_visibility()</methodname> with "
"<literal>false</literal> will cause the text to be hidden."
msgstr ""
"Pro zadávání hesel, heslových frází a jiných citlivých informací, u kterých "
"nechcete, aby se při psaní zobrazovaly, zavolejte metodu "
"<methodname>set_visibility()</methodname> s parametrem <literal>false</"
"literal>, což způsobí skrytí textu."

#: C/gtkmm-tutorial-in.xml:1193(para)
msgid ""
"You might want to be notified whenever the user types in a text entry "
"widget. <classname>Gtk::Entry</classname> provides two signals, "
"<literal>activate</literal> and <literal>changed</literal>, for this "
"purpose. <literal>activate</literal> is emitted when the user presses the "
"Enter key in a text-entry widget; <literal>changed</literal> is emitted when "
"the text in the widget changes. You can use these, for instance, to validate "
"or filter the text the user types. Moving the keyboard focus to another "
"widget may also signal that the user has finished entering text. The "
"<literal>focus_out_event</literal> signal that <classname>Gtk::Entry</"
"classname> inherits from <classname>Gtk::Widget</classname> can notify you "
"when that happens. The <link linkend=\"sec-comboboxentry\">ComboBox with an "
"Entry</link> section contains example programs that use these signals."
msgstr ""
"Můžete chtít být informováni, kdykoliv uživatel něco do textového vstupního "
"pole napíše. <classname>Gtk::Entry</classname> poskytuje za tímto účelem dva "
"signály, <literal>activate</literal> a <literal>changed</literal>. Signál "
"<literal>activate</literal> je vyslán, když uživatel zmáčkne v textovém poli "
"klávesu <keymap>Enter</keymap>. Signál <literal>changed</literal> je vyslán, "
"když se text ve widgetu změní. To můžete například využít k ověřování nebo "
"filtrování textu, který uživatel píše. Přesunutí zaměření klávesnice do "
"jiného widgetu rovněž vyšle signál, který signalizuje, že uživatel dokončil "
"zadávání textu. Jedná se o signál <literal>focus_out_event</literal>, který "
"<classname>Gtk::Entry</classname> dědí z <classname>Gtk::Widget</classname>. "
"Kapitola <link linkend=\"sec-comboboxentry\">Kombinované vstupní pole "
"(ComboBoxEntry)</link> obsahuje ukázkový program, který tyto signály používá."

#: C/gtkmm-tutorial-in.xml:1208(para)
msgid ""
"If you pass <literal>true</literal> to the "
"<methodname>set_activates_default()</methodname> method, pressing Enter in "
"the <classname>Gtk::Entry</classname> will activate the default widget for "
"the window containing the <classname>Gtk::Entry</classname>. This is "
"especially useful in dialog boxes. The default widget is usually one of the "
"dialog buttons, which e.g. will close the dialog box. To set a widget as the "
"default widget, use <methodname>Gtk::Widget::set_can_default()</methodname> "
"and <methodname>Gtk::Widget::grab_default()</methodname>."
msgstr ""
"Pokud předáte <literal>true</literal> do metody "
"<methodname>set_activates_default()</methodname>, zmáčknutí klávesy "
"<keymap>Enter</keymap> v <classname>Gtk::Entry</classname> bude aktivovat "
"výchozí widget pro okno, které tento <classname>Gtk::Entry</classname> "
"obsahuje. To je užitečné především v dialogových oknech. Výchozím widgetem "
"je obvykle jedno z tlačítek dialogového okna, které jej například zavře. Pro "
"nastavení widgetu jako výchozího použijte <methodname>Gtk::Widget::"
"set_can_default()</methodname> a <methodname>Gtk::Widget::grab_default()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1220(title)
msgid "Simple Entry Example"
msgstr "Příklad s jednoduchým vstupním polem"

#: C/gtkmm-tutorial-in.xml:1221(para)
msgid ""
"This example uses <classname>Gtk::Entry</classname>. It also has two "
"<classname>CheckButton</classname>s, with which you can toggle the editable "
"and visible flags."
msgstr ""
"Tento příklad používá <classname>Gtk::Entry</classname>. Má také dvě "
"zaškrtávací políčka <classname>CheckButton</classname>, kterými můžete "
"přepínat příznaky editovatelnosti a viditelnosti."

#: C/gtkmm-tutorial-in.xml:1241(title) C/gtkmm-tutorial-in.xml:1275(title)
msgid "Entry Completion"
msgstr "Doplňování vstupu"

#: C/gtkmm-tutorial-in.xml:1242(para)
msgid ""
"A <classname>Entry</classname> widget can offer a drop-down list of pre-"
"existing choices based on the first few characters typed by the user. For "
"instance, a search dialog could suggest text from previous searches."
msgstr ""
"Widget <classname>Entry</classname> může nabízet rozbalovací seznam s "
"přednastavenými volbami, které vychází z prvních několika znaků, které "
"uživatel napsal. Například vyhledávací pole by mohlo nabízet text, který se "
"hledal již dříve."

#: C/gtkmm-tutorial-in.xml:1247(para)
msgid ""
"To enable this functionality, you must create a <classname>EntryCompletion</"
"classname> object, and provide it to the <classname>Entry</classname> widget "
"via the <methodname>set_completion()</methodname> method."
msgstr ""
"Jestli chcete tuto funkcionalitu zprovoznit, musíte vytvořit objekt "
"<classname>EntryCompletion</classname> a poskytnout jej widgetu "
"<classname>Entry</classname> přes metodu <methodname>set_completion()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1252(para)
msgid ""
"The <classname>EntryCompletion</classname> may use a <classname>TreeModel</"
"classname> containing possible entries, specified with "
"<methodname>set_model()</methodname>. You should then call "
"<methodname>set_text_column()</methodname> to specify which of your model "
"columns should be used to match possible text entries."
msgstr ""
"Pomocí metody <methodname>set_model()</methodname> můžete pro "
"<classname>EntryCompletion</classname> určit <classname>TreeModel</"
"classname>, který bude obsahovat možné vstupy. Pak byste měli ještě zavolat "
"<methodname>set_text_column()</methodname> k určení sloupce ve vašem modelu, "
"který se má používat k porovnávání možných textových vstupů."

#: C/gtkmm-tutorial-in.xml:1258(para)
msgid ""
"Alternatively, if a complete list of possible entries would be too large or "
"too inconvenient to generate, a callback slot may instead be specified with "
"<methodname>set_match_func()</methodname>. This is also useful if you wish "
"to match on a part of the string other than the start."
msgstr ""
"Případně, když by seznam možných vstupů byl příliš dlouhý, nebo je nevhodné "
"jej přímo vygenerovat, můžete místo toho použít zpětné volání, které zadáte "
"pomocí <methodname>set_match_func()</methodname>. Hodí se to také, když "
"potřebujete porovnávat jinou část řetězce, než začátek."

#: C/gtkmm-tutorial-in.xml:1266(title)
msgid "Entry Completion Example"
msgstr "Příklad doplňování vstupu"

#: C/gtkmm-tutorial-in.xml:1267(para)
msgid ""
"This example creates a <classname>Gtk::EntryCompletion</classname> and "
"associates it with a <classname>Gtk::Entry</classname> widget. The "
"completion uses a <classname>Gtk::TreeModel</classname> of possible entries, "
"and some additional actions."
msgstr ""
"Tento příklad vytvoří <classname>Gtk::EntryCompletion</classname> a přidruží "
"jej k widgetu <classname>Gtk::Entry</classname>. Doplňování využívá "
"<classname>Gtk::TreeModel</classname> s možnými vstupy a některé doplňující "
"činnosti."

#: C/gtkmm-tutorial-in.xml:1287(title)
msgid "Entry Icons"
msgstr "Ikony ve vstupním poli"

#: C/gtkmm-tutorial-in.xml:1288(para)
msgid ""
"An <classname>Entry</classname> widget can show an icon at the start or end "
"of the text area. The icon can be specifed by methods such as "
"<methodname>set_icon_from_pixbuf()</methodname> or "
"<methodname>set_icon_from_icon_name()</methodname>. An application can "
"respond to the user pressing the icon by handling the "
"<methodname>signal_icon_press</methodname> signal."
msgstr ""
"Widget <classname>Entry</classname> umí na začátku a konci textové oblasti "
"zobrazovat ikonu. Ikona se dá určit metodami jako jsou "
"<methodname>set_icon_from_pixbuf()</methodname> nebo "
"<methodname>set_icon_from_icon_name()</methodname>. Aplikace může reagovat "
"na uživatelovo zmáčknutí ikony obsluhou signálu "
"<methodname>signal_icon_press</methodname>."

#: C/gtkmm-tutorial-in.xml:1295(title)
msgid "Entry Icon Example"
msgstr "Příklad vstupního pole s ikonami"

#: C/gtkmm-tutorial-in.xml:1296(para)
msgid ""
"This example shows a <classname>Gtk::Entry</classname> widget with a named "
"search icon, and prints text to the terminal when the icon is pressed."
msgstr ""
"Tento příklad ukazuje widget <classname>Gtk::Entry</classname> s "
"pojmenovanou vyhledávací ikonou, při jejímž zmáčknutí vypíše text do "
"terminálu."

#: C/gtkmm-tutorial-in.xml:1302(title)
msgid "Entry with Icon"
msgstr "Vstupní pole s ikonou"

#: C/gtkmm-tutorial-in.xml:1314(title)
msgid "Entry Progress"
msgstr "Vstupní pole s ukazatelem průběhu"

#: C/gtkmm-tutorial-in.xml:1315(para)
msgid ""
"An <classname>Entry</classname> widget can show a progress bar inside the "
"text area, under the entered text. The progress bar will be shown if the "
"<methodname>set_progress_fraction()</methodname> or "
"<methodname>set_progress_pulse_step()</methodname> methods are called."
msgstr ""
"Widget <classname>Entry</classname> umí zobrazovat ukazatel průběhu uvnitř "
"textové oblasti, pod zadávaným textem. Ukazatel průběhu se zobrazí, když je "
"zavolána metoda <methodname>set_progress_fraction()</methodname> nebo "
"<methodname>set_progress_pulse_step()</methodname>."

#: C/gtkmm-tutorial-in.xml:1320(title)
msgid "Entry Progress Example"
msgstr "Příklad ukazatele průběhu ve vstupním poli"

#: C/gtkmm-tutorial-in.xml:1321(para)
msgid ""
"This example shows a <classname>Gtk::Entry</classname> widget with a "
"progress bar."
msgstr ""
"Tento příklad ukazuje widget <classname>Gtk::Entry</classname> s ukazatelem "
"průběhu."

#: C/gtkmm-tutorial-in.xml:1327(title)
msgid "Entry with Progress Bar"
msgstr "Vstupní pole s ukazatelem průběhu"

#: C/gtkmm-tutorial-in.xml:1341(title) C/gtkmm-tutorial-in.xml:1463(title)
msgid "SpinButton"
msgstr "Číselník (SpinButton)"

#: C/gtkmm-tutorial-in.xml:1343(para)
msgid ""
"A <classname>SpinButton</classname> allows the user to select a value from a "
"range of numeric values. It has an <classname>Entry</classname> widget with "
"increment and decrement buttons at the side. Clicking the buttons causes the "
"value to 'spin' up and down across the range of possible values. The "
"<classname>Entry</classname> widget may also be used to enter a value "
"directly."
msgstr ""
"<classname>SpinButton</classname> umožňuje uživateli vybrat hodnotu z "
"nějakého rozsahu číselných hodnot. Jedná se o widget <classname>Entry</"
"classname> po stranně s tlačítky pro zvyšování a snižování. Klikání na "
"tlačítka způsobuje zvýšení nebo snížení hodnoty v číselníku v rámci "
"povoleného rozsahu hodnot. Widget <classname>Entry</classname> můžete použít "
"také k přímému zadání hodnoty."

#: C/gtkmm-tutorial-in.xml:1351(para)
msgid ""
"The value can have an adjustable number of decimal places, and the step size "
"is configurable. <classname>SpinButton</classname>s have an 'auto-repeat' "
"feature as well: holding down the increment or decrement button can "
"optionally cause the value to change more quickly the longer the button is "
"held down."
msgstr ""
"Hodnota má přizpůsobitelný počet desetinných míst a velikost kroku je také "
"nastavitelná. <classname>SpinButton</classname> má rovněž funkci "
"„automatického opakování“: když držíte zmáčknuté tlačítko pro zvyšování nebo "
"snižování hodnoty, může se volitelně hodnota začít měnit rychleji, v "
"závislosti na tom, jak dlouho je tlačítko drženo."

#: C/gtkmm-tutorial-in.xml:1366(para)
msgid "<literal>value</literal>: value for the Spin Button"
msgstr "<literal>value</literal>: hodnota do číselníku"

#: C/gtkmm-tutorial-in.xml:1372(para)
msgid "<literal>lower</literal>: lower range value"
msgstr "<literal>lower</literal>: spodní hranice rozsahu hodnot"

#: C/gtkmm-tutorial-in.xml:1378(para)
msgid "<literal>upper</literal>: upper range value"
msgstr "<literal>upper</literal>: horní hranice rozsahu hodnot"

#: C/gtkmm-tutorial-in.xml:1383(para)
msgid ""
"<literal>step_increment</literal>: value to increment/decrement when "
"pressing mouse button 1 on a button"
msgstr ""
"<literal>step_increment</literal>: hodnota, o kterou se provede zvýšení/"
"snížení při zmáčknutí prvního tlačítka myši na příslušném tlačítku"

#: C/gtkmm-tutorial-in.xml:1390(para)
msgid ""
"<literal>page_increment</literal>: value to increment/decrement when "
"pressing mouse button 2 on a button"
msgstr ""
"<literal>page_increment</literal>: hodnota, o kterou se provede zvýšení/"
"snížení při zmáčknutí druhého tlačítka myši na příslušném tlačítku"

#: C/gtkmm-tutorial-in.xml:1397(para)
msgid "<literal>page_size</literal>: unused"
msgstr "<literal>page_size</literal>: nepoužito"

#: C/gtkmm-tutorial-in.xml:1358(para)
msgid ""
"<classname>SpinButton</classname>s use an <link linkend=\"chapter-adjustment"
"\">Adjustment</link> object to hold information about the range of values. "
"These Adjustment attributes are used by the Spin Button like so: "
"<placeholder-1/>"
msgstr ""
"<classname>SpinButton</classname> používá objekt <link linkend=\"chapter-"
"adjustment\">Adjustment</link> k uchování informací o rozsahu hodnot. "
"Atributy tohoto objektu jsou konkrétně použity takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:1405(para)
msgid ""
"Additionally, mouse button 3 can be used to jump directly to the "
"<literal>upper</literal> or <literal>lower</literal> values."
msgstr ""
"Navíc se dá použít třetí tlačítko myši ke skokům přímo na hodnoty "
"<literal>upper</literal> nebo <literal>lower</literal>."

#: C/gtkmm-tutorial-in.xml:1410(para)
msgid ""
"The <classname>SpinButton</classname> can create a default "
"<classname>Adjustment</classname>, which you can access via the "
"<methodname>get_adjustment()</methodname> method, or you can specify an "
"existing <classname>Adjustment</classname> in the constructor."
msgstr ""
"<classname>SpinButton</classname> si umí vytvořit výchozí objekt "
"<classname>Adjustment</classname>, ke kterému se můžete dostat přes metodu "
"<methodname>get_adjustment()</methodname>, nebo můžete v konstruktoru určit "
"nějaký již existující objekt <classname>Adjustment</classname>."

#: C/gtkmm-tutorial-in.xml:1420(para)
msgid ""
"The number of decimal places can be altered using the "
"<methodname>set_digits()</methodname> method."
msgstr ""
"Počet desetinných míst můžete měnit pomocí metody <methodname>set_digits()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1425(para)
msgid ""
"You can set the spinbutton's value using the <methodname>set_value()</"
"methodname> method, and retrieve it with <methodname>get_value()</"
"methodname>."
msgstr ""
"Hodnotu číselníku můžete nastavit pomocí metody <methodname>set_value()</"
"methodname> a naopak ji získat pomocí <methodname>get_value()</methodname>."

#: C/gtkmm-tutorial-in.xml:1430(para)
msgid ""
"The <methodname>spin()</methodname> method 'spins' the "
"<classname>SpinButton</classname>, as if its increment or decrement button "
"had been clicked. You need to specify a <classname>Gtk::SpinType</classname> "
"to specify the direction or new position."
msgstr ""
"Metoda <methodname>spin</methodname> „pootočí“ číselníkem "
"<classname>SpinButton</classname> stejně, jako když uživatel klikne na "
"tlačítko pro zvýšení nebo snížení. Potřebujete určit <classname>Gtk::"
"SpinType</classname>, podle kterého se řídí směr nebo nová hodnota."

#: C/gtkmm-tutorial-in.xml:1437(para)
msgid ""
"To prevent the user from typing non-numeric characters into the entry box, "
"pass <literal>true</literal> to the <methodname>set_numeric()</methodname> "
"method."
msgstr ""
"Abyste uživateli zabránili v psaní nečíselných znaků do vstupního pole, "
"předejte metodě <methodname>set_numeric()</methodname> hodnotu "
"<literal>true</literal>."

#: C/gtkmm-tutorial-in.xml:1442(para)
msgid ""
"To make the <classname>SpinButton</classname> 'wrap' between its upper and "
"lower bounds, use the <methodname>set_wrap()</methodname> method."
msgstr ""
"Aby číselník <classname>SpinButton</classname> cyklicky přecházel mezi horní "
"a dolní hranicí, použijte metodu <methodname>set_wrap()</methodname>."

#: C/gtkmm-tutorial-in.xml:1447(para)
msgid ""
"To force it to snap to the nearest <literal>step_increment</literal>, use "
"<methodname>set_snap_to_ticks()</methodname>."
msgstr ""
"Když jej chcete přinutit, aby se automaticky dorovnával na nejbližší násobek "
"<literal>step_increment</literal>, použijte <methodname>set_snap_to_ticks()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1458(para)
msgid "Here's an example of a <classname>SpinButton</classname> in action:"
msgstr "Zde je ukázka widgetu <classname>SpinButton</classname> v akci:"

#: C/gtkmm-tutorial-in.xml:1476(title) C/gtkmm-tutorial-in.xml:1524(title)
msgid "ProgressBar"
msgstr "Ukazatel průběhu (PrograssBar)"

#: C/gtkmm-tutorial-in.xml:1478(para)
msgid ""
"Progress bars are used to show the status of an ongoing operation. For "
"instance, a <classname>ProgressBar</classname> can show how much of a task "
"has been completed."
msgstr ""
"Ukazatel průběhu zobrazuje stav probíhající operace. Například může "
"<classname>ProgressBar</classname> zobrazovat, jak velká část úlohy je "
"dokončená."

#: C/gtkmm-tutorial-in.xml:1484(para)
msgid ""
"To change the value shown, use the <methodname>set_fraction()</methodname> "
"method, passing a <type>double</type> between 0.0 and 1.0 to provide the new "
"percentage."
msgstr ""
"Když chcete změnit zobrazenou hodnotu, použijte metodu "
"<methodname>set_fraction()</methodname>, které předáte číselnou hodnotu typu "
"<type>double</type> v rozmezí 0,0 až 1,0, která se přepočítá na procenta."

#: C/gtkmm-tutorial-in.xml:1489(para)
msgid ""
"A <classname>ProgressBar</classname> is horizontal and left-to-right by "
"default, but you can change it to a vertical progress bar by using the "
"<methodname>set_orientation()</methodname> method."
msgstr ""
"Výchozí podoba widgetu <classname>ProgressBar</classname> je vodorovně a "
"zleva doprava, ale můžete to změnit na svislou zavoláním metody "
"<methodname>set_orientation()</methodname>."

#: C/gtkmm-tutorial-in.xml:1498(title)
msgid "Activity Mode"
msgstr "Režim aktivity"

#: C/gtkmm-tutorial-in.xml:1499(para)
msgid ""
"Besides indicating the amount of progress that has occured, the progress bar "
"can also be used to indicate that there is some activity; this is done by "
"placing the progress bar in <emphasis>activity mode</emphasis>. In this "
"mode, the progress bar displays a small rectangle which moves back and "
"forth. Activity mode is useful in situations where the progress of an "
"operation cannot be calculated as a value range (e.g., receiving a file of "
"unknown length)."
msgstr ""
"Mimo ukazování dosaženého pokroku, který nastal, se dá ukazatel průběhu "
"použít také k prezentaci toho, že probíhá nějaká činnost. Dělá se to "
"přepnutím ukazatele průběhu do <emphasis>režimu aktivity</emphasis>. V tomto "
"režimu ukazatel průběhu zobrazuje malý obdélník, který pobíhá tam a zpět. "
"Hodí se to v situacích, když nelze vypočítat rozsah hodnot, ve kterém bude "
"operace probíhat (např. příjem souboru neznámé délky)."

#: C/gtkmm-tutorial-in.xml:1509(para)
msgid ""
"To do this, you need to call the <methodname>pulse()</methodname> method at "
"regular intervals. You can also choose the step size, with the "
"<methodname>set_pulse_step()</methodname> method."
msgstr ""
"Abyste to mohli provést, musíte volat v pravidelných intervalech metodu "
"<methodname>pulse()</methodname>. Můžete také pomocí metody "
"<methodname>set_pulse_step()</methodname> zvolit velikost kroku."

#: C/gtkmm-tutorial-in.xml:1515(para)
msgid ""
"The progress bar can also display a configurable text string within its "
"trough, using the <methodname>set_text()</methodname> method."
msgstr ""
"Ukazatel průběhu umí také v průběhu zobrazovat nastavitelný text. K tomu "
"slouží metoda <methodname>set_text()</methodname>."

#: C/gtkmm-tutorial-in.xml:1538(title) C/gtkmm-tutorial-in.xml:1548(title)
msgid "InfoBar"
msgstr "Informační lišta (InfoBar)"

#: C/gtkmm-tutorial-in.xml:1540(para)
msgid ""
"An <classname>InfoBar</classname> may show small items of information or ask "
"brief questions. Unlike a <classname>Dialog</classname>, it appears at the "
"top of the current window instead of opening a new window. Its API is very "
"similar to the <link linkend=\"chapter-dialogs\">Gtk::Dialog</link> API."
msgstr ""
"<classname>InfoBar</classname> může zobrazovat menší počet informací nebo "
"stručné dotazy. Na rozdíl od dialogového okna <classname>Dialog</classname> "
"neotevírá nové okno, ale objeví se v horní části aktuálního okna. Jeho API "
"je velmi podobné API <link linkend=\"chapter-dialogs\">Gtk::Dialog</link>."

#: C/gtkmm-tutorial-in.xml:1561(title)
msgid "Tooltips"
msgstr "Vysvětlivky"

#: C/gtkmm-tutorial-in.xml:1563(para)
msgid ""
"Tooltips are the little information windows that pop up when you leave your "
"pointer over a widget for a few seconds. Use <methodname>set_tooltip_text()</"
"methodname> to set a text string as a tooltip on any <classname>Widget</"
"classname>. <classname>Gtk::ToolItem</classname>s are not <classname>Widget</"
"classname>s, but have the same method for convenience. <classname>Gtk::"
"Tooltip</classname> is used for more advanced tooltip usage, such as showing "
"an image as well as text."
msgstr ""
"Vysvětlivky jsou jednoduchá informační okna, která vyskočí, když nad "
"widgetem postojíte pár vteřin ukazatelem. K nastavení vysvětlivky "
"libovolného <classname>Widgetu</classname> použijte "
"<methodname>set_tooltip_text()</methodname>. Objekty <classname>Gtk::"
"ToolItem</classname> nejsou <classname>Widgety</classname>, ale kvůli "
"snadnému používání mají stejnou metodu. Pro pokročilé vysvětlivky, které "
"například zobrazují k textu i obrázek, slouží <classname>Gtk::Tooltip</"
"classname>."

#: C/gtkmm-tutorial-in.xml:1573(ulink)
msgid "Widget Reference"
msgstr "Dokumentace k obejktu Widget"

#: C/gtkmm-tutorial-in.xml:1574(ulink)
msgid "Tooltip Reference"
msgstr "Dokumentace k objektu Tooltip"

#: C/gtkmm-tutorial-in.xml:1579(title)
msgid "Tooltip"
msgstr "Vysvětlivka (Tooltip)"

#: C/gtkmm-tutorial-in.xml:1594(title)
msgid "Container Widgets"
msgstr "Kontejnerové widgety"

#: C/gtkmm-tutorial-in.xml:1596(para)
msgid ""
"All container widgets derive from <classname>Gtk::Container</classname>, not "
"always directly. Some container widgets, such as <classname>Gtk::Grid</"
"classname> can hold many child widgets, so these typically have more complex "
"interfaces. Others, such as <classname>Gtk::Frame</classname> contain only "
"one child widget."
msgstr ""
"Všechny kontejnerové widgety jsou odvozené z <classname>Gtk::Container</"
"classname>, i když ne vždy přímo. Některé kontejnerové widgety, jako třeba "
"<classname>Gtk::Grid</classname>, mohou přechovávat více synovských widgetů, "
"takže mají obvykle složitější rozhraní. Jiné, jako <classname>Gtk::Frame</"
"classname>, obsahují jen jeden synovský widget."

#: C/gtkmm-tutorial-in.xml:1605(title)
msgid "Single-item Containers"
msgstr "Jednopoložkové kontejnery"

#: C/gtkmm-tutorial-in.xml:1607(para)
msgid ""
"The single-item container widgets derive from <classname>Gtk::Bin</"
"classname>, which provides the <methodname>add()</methodname> and "
"<methodname>remove()</methodname> methods for the child widget. Note that "
"<classname>Gtk::Button</classname> and <classname>Gtk::Window</classname> "
"are technically single-item containers, but we have discussed them already "
"elsewhere."
msgstr ""
"Jednopoložkové kontejnery jsou odvozené z třídy <classname>Gtk::Bin</"
"classname>, která poskytuje pro synovský widget metody <methodname>add()</"
"methodname> a <methodname>remove()</methodname>. Pro úplnost, "
"<classname>Gtk::Button</classname> a <classname>Gtk::Window</classname> jsou "
"technicky také jednopoložkové kontejnery, ale probírány jsou na jiném místě."

#: C/gtkmm-tutorial-in.xml:1615(para)
msgid ""
"We also discuss the <classname>Gtk::Paned</classname> widget, which allows "
"you to divide a window into two separate \"panes\". This widget actually "
"contains two child widgets, but the number is fixed so it seems appropriate."
msgstr ""
"Probírán je také widget <classname>Gtk::Paned</classname>, který umožňuje "
"rozdělit okno do dvou oddělených „panelů“. Tento widget ve skutečnosti "
"obsahuje dva synovské widgety, ale tento počet je pevně dán, takže je "
"správné jej zařadit sem."

#: C/gtkmm-tutorial-in.xml:1622(title) C/gtkmm-tutorial-in.xml:1636(title)
msgid "Frame"
msgstr "Rám (Frame)"

#: C/gtkmm-tutorial-in.xml:1624(para)
msgid ""
"Frames can enclose one or a group of widgets within a box, optionally with a "
"title. For instance, you might place a group of <classname>RadioButton</"
"classname>s or <classname>CheckButton</classname>s in a <classname>Frame</"
"classname>."
msgstr ""
"Rám <classname>Frame</classname> do sebe umí uzavřít jeden widget nebo celou "
"skupinu widgetů a volitelně k nim zobrazit nadpis. Například do něj můžete "
"umístit skupinu zaškrtávacích políček <classname>CheckButton</classname> "
"nebo skupinových přepínačů <classname>RadioButton</classname>."

#: C/gtkmm-tutorial-in.xml:1650(title) C/gtkmm-tutorial-in.xml:1676(title)
msgid "Paned"
msgstr "Dvojitý panel (Paned)"

#: C/gtkmm-tutorial-in.xml:1652(para)
msgid ""
"Panes divide a widget into two halves, separated by a moveable divider. The "
"two halves (panes) can be oriented either horizontally (side by side) or "
"vertically (one above the other)."
msgstr ""
"Dvojitý panel rozdělí widget na dvě části oddělené rozdělovací čárou. Oba "
"panely mohou být orientované buďto vodorovně (vedle sebe) nebo svisle (nad "
"sebou)."

#: C/gtkmm-tutorial-in.xml:1658(para)
msgid ""
"Unlike the other widgets in this section, pane widgets contain not one but "
"two child widgets, one in each pane. Therefore, you should use "
"<methodname>add1()</methodname> and <methodname>add2()</methodname> instead "
"of the <methodname>add()</methodname> method."
msgstr ""
"Na rozdíl od jiných widgetů v tomto oddíle, obsahuje widget "
"<classname>Paned</classname> ne jeden, ale dva synovské widgety, po jednom v "
"každém z panelů. Proto musíte místo metody <methodname>add()</methodname> "
"použít <methodname>add1()</methodname> a <methodname>add2()</methodname>."

#: C/gtkmm-tutorial-in.xml:1665(para)
msgid ""
"You can adjust the position of the divider using the "
"<methodname>set_position()</methodname> method, and you will probably need "
"to do so."
msgstr ""
"Rozdělovací čáru můžete umístit pomocí metody <methodname>set_position()</"
"methodname>, a nejspíše to budete potřebovat udělat."

#: C/gtkmm-tutorial-in.xml:1689(title) C/gtkmm-tutorial-in.xml:1721(title)
msgid "ScrolledWindow"
msgstr "Okno s posuvníky (ScrolledWindow)"

#: C/gtkmm-tutorial-in.xml:1691(para)
msgid ""
"<classname>ScrolledWindow</classname> widgets create a scrollable area. You "
"can insert any type of widget into a <classname>ScrolledWindow</classname> "
"window, and it will be accessible regardless of its size by using the "
"scrollbars. Note that <classname>ScrolledWindow</classname> is not a "
"<classname>Gtk::Window</classname> despite the slightly misleading name."
msgstr ""
"Widgety <classname>ScrolledWindow</classname> vytvoří oblast s posuvníky. Do "
"okna <classname>ScrolledWindow</classname> můžete vložit widget libovolného "
"typu, který bude díky posuvníků dostupný celý bez ohledu na svoji velikost. "
"Pamatujte ale, že <classname>ScrolledWindow</classname> není <classname>Gtk::"
"Window</classname>, i když název k tomu navádí."

#: C/gtkmm-tutorial-in.xml:1700(para)
msgid ""
"Scrolled windows have <emphasis>scrollbar policies</emphasis> which "
"determine whether the <classname>Scrollbar</classname>s will be displayed. "
"The policies can be set with the <methodname>set_policy()</methodname> "
"method. The policy may be one of <literal>Gtk::POLICY_AUTOMATIC</literal> or "
"<literal>Gtk::POLICY_ALWAYS</literal>. <literal>Gtk::POLICY_AUTOMATIC</"
"literal> will cause the scrolled window to display the scrollbar only if the "
"contained widget is larger than the visible area. <literal>Gtk::"
"POLICY_ALWAYS</literal> will cause the scrollbar to be displayed always."
msgstr ""
"Okna s posuvníky mají <emphasis>pravidla pro posuvníky</emphasis>, která "
"určují, jestli jsou posuvníky <classname>Scrollbar</classname> zobrazené, "
"nebo ne. Pravidla můžete nastavit pomocí metody <methodname>set_policy()</"
"methodname>. Mohou nabývat hodnoty <literal>Gtk::POLICY_AUTOMATIC</literal> "
"nebo <literal>Gtk::POLICY_ALWAYS</literal>. <literal>Gtk::POLICY_AUTOMATIC</"
"literal> způsobí, že okno s posuvníky zobrazí posuvník jen v případě, že "
"vložený widget je větší než viditelná oblast. <literal>Gtk::POLICY_ALWAYS</"
"literal> způsobí, že posuvníky se zobrazí vždy."

#: C/gtkmm-tutorial-in.xml:1716(para)
msgid ""
"Here is a simple example that packs 100 toggle buttons into a "
"ScrolledWindow. Try resizing the window to see the scrollbars react."
msgstr ""
"Zde je jednoduchý příklad, který sbalí 100 přepínacích tlačítek do okna s "
"posuvníky. Zkuste měnit velikost okna, abyste viděli, jak posuvníky reagují."

#: C/gtkmm-tutorial-in.xml:1734(title) C/gtkmm-tutorial-in.xml:1756(title)
msgid "AspectFrame"
msgstr "AspectFrame"

#: C/gtkmm-tutorial-in.xml:1736(para)
msgid ""
"The <classname>AspectFrame</classname> widget looks like a <classname>Frame</"
"classname> widget, but it also enforces the <emphasis>aspect ratio</"
"emphasis> (the ratio of the width to the height) of the child widget, adding "
"extra space if necessary. For instance, this would allow you to display a "
"photograph without allowing the user to distort it horizontally or "
"vertically while resizing."
msgstr ""
"Widget <classname>AspectFrame</classname> vypadá podobně jako widget "
"<classname>Frame</classname>, ale navíc dodržuje <emphasis>poměr stran</"
"emphasis> (poměr mezi šířkou a výškou) synovského widgetu. Využívá k tomu "
"doplňování prázdného místa okolo widgetu v případě potřeby. Využít se dá "
"například k zobrazení fotografie, aniž by ji uživatel při změně velikosti "
"vodorovně nebo svisle deformoval."

#: C/gtkmm-tutorial-in.xml:1749(para)
msgid ""
"The following program uses a <classname>Gtk::AspectFrame</classname> to "
"present a drawing area whose aspect ratio will always be 2:1, no matter how "
"the user resizes the top-level window."
msgstr ""
"Následující program použív <classname>Gtk::AspectFrame</classname> k "
"zobrazení kreslící oblasti, jejíž poměr stran bude vždy 2∶1, bez ohledu na "
"to, jak uživatel mění velikost nadřazeného okna."

#: C/gtkmm-tutorial-in.xml:1769(title) C/gtkmm-tutorial-in.xml:1795(title)
msgid "Alignment"
msgstr "Zarovnání (Alignment)"

#: C/gtkmm-tutorial-in.xml:1771(para)
msgid ""
"The <classname>Alignment</classname> widget allows you to place a widget at "
"a position and size relative to the size of the <classname>Alignment</"
"classname> widget itself. For instance, it might be used to center a widget."
msgstr ""
"Widget <classname>Alignment</classname> umožňuje umístit widget a dát mu "
"velikost relativně k velikosti samotného widgetu <classname>Alignment</"
"classname>. Například jej můžete použít k vystředění widgetu."

#: C/gtkmm-tutorial-in.xml:1777(para)
msgid ""
"You need to specify the <classname>Alignment</classname>'s characteristics "
"to the constructor, or to the <methodname>set()</methodname> method. In "
"particular, you won't notice much effect unless you specify a number other "
"than 1.0 for the <literal>xscale</literal> and <literal>yscale</literal> "
"parameters, because 1.0 simply means that the child widget will expand to "
"fill all available space."
msgstr ""
"Potřebujete zadat vlastnosti objektu <classname>Alignment</classname>, buď "
"do konstruktoru nebo do metody <methodname>set()</methodname>. Nutno "
"podotknout, že při pokud nezadáte u parametrů <literal>xscale</literal> a "
"<literal>yscale</literal> jiné hodnoty než 1,0, nezaznamenáte žádný efekt, "
"protože 1,0 jednoduše znamená, že synovský widget se roztáhne, aby zaplnil "
"všechno dostupné místo."

#: C/gtkmm-tutorial-in.xml:1789(para)
msgid ""
"This example right-aligns a button in a window by using an "
"<classname>Alignment</classname> widget."
msgstr ""
"Tento příklad ukazuje zarovnání tlačítko v okně doprava pomocí widgetu "
"<classname>Alignment</classname>."

#: C/gtkmm-tutorial-in.xml:1803(para)
msgid ""
"See the <link linkend=\"sec-progressbar\">ProgressBar</link> section for "
"another example that uses an <classname>Alignment</classname>."
msgstr ""
"Na další příklad použití <classname>Alignment</classname> se můžete podívat "
"do oddílu <link linkend=\"sec-progressbar\">ProgressBar</link>."

#: C/gtkmm-tutorial-in.xml:1815(title)
msgid "Multiple-item widgets"
msgstr "Widgety s více položkami"

#: C/gtkmm-tutorial-in.xml:1817(para)
msgid ""
"Multiple-item widgets inherit from <classname>Gtk::Container</classname>; "
"just as with <classname>Gtk::Bin</classname>, you use the <methodname>add()</"
"methodname> and <methodname>remove()</methodname> methods to add and remove "
"contained widgets. Unlike <methodname>Gtk::Bin::remove()</methodname>, "
"however, the <methodname>remove()</methodname> method for <classname>Gtk::"
"Container</classname> takes an argument, specifiying which widget to remove."
msgstr ""
"Widgety s více položkami jsou odvozené z <classname>Gtk::Container</"
"classname>. Podobně jako <classname>Gtk::Bin</classname> používají metody "
"<methodname>add()</methodname> a <methodname>remove()</methodname> k přidání "
"a odebrání widgetů. Ale na rozdíl od <methodname>Gtk::Bin::remove()</"
"methodname> jejich metoda <methodname>remove()</methodname> přebírá "
"argument, který určuje, který widget se má odebrat."

#: C/gtkmm-tutorial-in.xml:1827(title)
msgid "Packing"
msgstr "Balení"

#: C/gtkmm-tutorial-in.xml:1828(para)
msgid ""
"You've probably noticed that <application>gtkmm</application> windows seem "
"\"elastic\" - they can usually be stretched in many different ways. This is "
"due to the <emphasis>widget packing</emphasis> system."
msgstr ""
"Nejspíše jste si všimli, že okna <application>gtkmm</application> jsou "
"„elastická“ – můžete je různě roztahovat a zase zmenšovat. Je to díky "
"systému <emphasis>balení widgetů</emphasis> (packing)."

#: C/gtkmm-tutorial-in.xml:1833(para)
msgid ""
"Many GUI toolkits require you to precisely place widgets in a window, using "
"absolute positioning, often using a visual editor. This leads to several "
"problems:"
msgstr ""
"Řada vývojářských nástrojů pro GUI vyžaduje přesné umístění widgetů v oknech "
"s použitím přesných souřadnic a často je k tomu zapotřebí vizuální editor. "
"To vede k několika problémům:"

#: C/gtkmm-tutorial-in.xml:1840(para)
msgid ""
"The widgets don't rearrange themselves when the window is resized. Some "
"widgets are hidden when the window is made smaller, and lots of useless "
"space appears when the window is made larger."
msgstr ""
"Widgety nemohou samy měnit uspořádání, když se změní velikost okna. Když je "
"okno příliš malé, tak některé widgety nejsou vidět, a naopak u příliš "
"velkého okna vzniká spousta nevyužitého místa."

#: C/gtkmm-tutorial-in.xml:1844(para)
msgid ""
"It's impossible to predict the amount of space necessary for text after it "
"has been translated to other languages, or displayed in a different font. On "
"Unix it is also impossible to anticipate the effects of every theme and "
"window manager."
msgstr ""
"Není možné odhadnou množství potřebného místa pro texty po jejich přeložení "
"do jiných národních jazyků nebo jejich zobrazení jiným písmem. V Unixu také "
"není možné předvídat, jak se projeví různé motivy a správce oken."

#: C/gtkmm-tutorial-in.xml:1848(para)
msgid ""
"Changing the layout of a window \"on the fly\", to make some extra widgets "
"appear, for instance, is complex. It requires tedious recalculation of every "
"widget's position."
msgstr ""
"Změna rozvržení okna „za běhu“, například kvůli přidání dalšího widgetu, je "
"velmi komplikovaná. Vyžaduje to unavné přepočítání pozice všech widgetů."

#: C/gtkmm-tutorial-in.xml:1854(para)
msgid ""
"<application>gtkmm</application> uses the packing system to solve these "
"problems. Rather than specifying the position and size of each widget in the "
"window, you can arrange your widgets in rows, columns, and/or grids. "
"<application>gtkmm</application> can size your window automatically, based "
"on the sizes of the widgets it contains. And the sizes of the widgets are, "
"in turn, determined by the amount of text they contain, or the minimum and "
"maximum sizes that you specify, and/or how you have requested that the "
"available space should be shared between sets of widgets. You can perfect "
"your layout by specifying padding distance and centering values for each of "
"your widgets. <application>gtkmm</application> then uses all this "
"information to resize and reposition everything sensibly and smoothly when "
"the user manipulates the window."
msgstr ""
"<application>gtkmm</application> používá k řešení tohoto problému systém "
"balení. Místo aby se určila přesná pozice a velikost jednotlivých widgetů v "
"okně, můžete uspořádat své widgety do řádků, sloupců a/nebo mřížek. "
"<application>gtkmm</application> umí automaticky určit velikost okna na "
"základě velikostí widgetů, které obsahuje. A velikost widgetů je naopak dána "
"množstvím textu, který obsahují, nebo minimální a maximální velikostí, které "
"určíte a/nebo jak jste požádali, že se má sdílet dostupné místo navzájem "
"mezi widgety. Doladit své rozložení pak můžete pomocí hodnot odsazení a "
"centrování jednotlivých widgetů. <application>gtkmm</application> použije "
"všechny tyto informace ke změně velikosti a pozice elegantně s ohledem na "
"to, jak uživatel manipuluje s oknem."

#: C/gtkmm-tutorial-in.xml:1863(para)
msgid ""
"<application>gtkmm</application> arranges widgets hierarchically, using "
"<emphasis>containers</emphasis>. A Container widget contains other widgets. "
"Most <application>gtkmm</application> widgets are containers. Windows, "
"Notebook tabs, and Buttons are all container widgets. There are two flavours "
"of containers: single-child containers, which are all descendants of "
"<classname>Gtk::Bin</classname>, and multiple-child containers, which are "
"descendants of <classname>Gtk::Container</classname>. Most widgets in "
"<application>gtkmm</application> are descendants of <classname>Gtk::Bin</"
"classname>, including <classname>Gtk::Window</classname>."
msgstr ""
"<application>gtkmm</application> uspořádává widgety hierarchicky pomocí "
"<emphasis>kontejnerů</emphasis>. Kontejnerový widget obsahuje další widgety. "
"Většina widgetů v <application>gtkmm</application> jsou kontejnerové "
"widgety. Window, Notebook a Button jsou všechno příklady kontejnerových "
"widgetů. Existují dvě varianty kontejnerů: jednopotomkové kontejnery, které "
"jsou všechny odvozené z <classname>Gtk::Bin</classname> a vícepotomkové "
"kontejnery, které jsou odvozené z <classname>Gtk::Container</classname>. "
"Většina widgetů v <application>gtkmm</application> je odvozených z "
"<classname>Gtk::Bin</classname>, včetně <classname>Gtk::Window</classname>."

#: C/gtkmm-tutorial-in.xml:1874(para)
msgid ""
"Yes, that's correct: a Window can contain at most one widget. How, then, can "
"we use a window for anything useful? By placing a multiple-child container "
"in the window. The most useful container widgets are <classname>Gtk::Grid</"
"classname> and <classname>Gtk::Box</classname>."
msgstr ""
"Ano, to je správně: Okno nemůže obsahovat více jak jeden widget. Jak jej pak "
"ale můžeme využít nějakým použitelným způsobem? Umístěním kontejneru pro "
"více potomku do okna. Nejpoužívanější kontejnery na widgety jsou "
"<classname>Gtk::Grid</classname> a <classname>Gtk::Box</classname>."

#: C/gtkmm-tutorial-in.xml:1885(para)
msgid ""
"<classname>Gtk::Grid</classname> arranges its child widgets in rows and "
"columns. Use <methodname>attach()</methodname>, "
"<methodname>attach_next_to()</methodname> and <methodname>add()</methodname> "
"to insert child widgets."
msgstr ""
"<classname>Gtk::Grid</classname> uspořádává synovské widgety do řádků a "
"sloupců. K vložení synovského widgetu použijte metody <methodname>attach()</"
"methodname>, <methodname>attach_next_to()</methodname> a <methodname>add()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1894(para)
msgid ""
"<classname>Gtk::Box</classname> arranges its child widgets vertically or "
"horizontally. Use <methodname>pack_start()</methodname> and "
"<methodname>pack_end()</methodname> to insert child widgets."
msgstr ""
"<classname>Gtk::Box</classname> uspořádává své synovské widgety svisle nebo "
"vodorovně. K vložení synovského widgetu použijte "
"metody<methodname>pack_start()</methodname> a <methodname>pack_end()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:1903(para)
msgid "There are several other containers, which we will also discuss."
msgstr "Existuje ještě několik dalších kontejnerů, které také probereme."

#: C/gtkmm-tutorial-in.xml:1907(para)
msgid ""
"If you've never used a packing toolkit before, it can take some getting used "
"to. You'll probably find, however, that you don't need to rely on visual "
"form editors quite as much as you might with other toolkits."
msgstr ""
"Jestliže jste doposud nepoužívali žádnou vývojářskou sadu pro balení, může "
"vám chvíli trvat, než si na to zvyknete. Nejspíše ale zjistíte, že nejste "
"závislí na vizuální podobě v editoru, stejně jako byste nemuseli u "
"kterékoliv jiné vývojářské sady."

#: C/gtkmm-tutorial-in.xml:1917(title)
msgid "An improved Hello World"
msgstr "Vylepšené „Hello World“"

#: C/gtkmm-tutorial-in.xml:1919(para)
msgid ""
"Let's take a look at a slightly improved <literal>helloworld</literal>, "
"showing what we've learnt."
msgstr ""
"Pojďme se podívat, jak s tím, co jsme si ukázali, trochu vylepšit "
"<literal>helloworld</literal>."

#: C/gtkmm-tutorial-in.xml:1924(title)
msgid "Hello World 2"
msgstr "„Hello World“ 2"

#: C/gtkmm-tutorial-in.xml:1932(para)
msgid ""
"After building and running this program, try resizing the window to see the "
"behaviour. Also, try playing with the options to <methodname>pack_start()</"
"methodname> while reading the <link linkend=\"sec-boxes\">Boxes</link> "
"section."
msgstr ""
"Po sestavení a spuštění tohoto programu zkuste změnit velikost okna, abyste "
"viděli, jak se bude chovat. Zkuste si také pohrát s volbami "
"<methodname>pack_start()</methodname> podle oddílu <link linkend=\"sec-boxes"
"\">Boxy</link>."

#: C/gtkmm-tutorial-in.xml:1942(title)
msgid "Boxes"
msgstr "Boxy"

#: C/gtkmm-tutorial-in.xml:1944(para)
msgid ""
"Most packing uses boxes as in the above example. These are invisible "
"containers into which we can pack our widgets. When packing widgets into a "
"horizontal box, the objects are inserted horizontally from left to right or "
"right to left depending on whether <methodname>pack_start()</methodname> or "
"<methodname>pack_end()</methodname> is used. In a vertical box, widgets are "
"packed from top to bottom or vice versa. You may use any combination of "
"boxes inside or beside other boxes to create the desired effect."
msgstr ""
"Většinou se pro balení používají boxy, stejně jako v předchozím příkladu. "
"Jedná se o neviditelné kontejnery, do kterých můžete balit své widgety. Když "
"balíte widgety do vodorovného boxu, vkládají se vodorovně zleva doprava, "
"nebo zprava doleva, podle toho, jestli použijete <methodname>pack_start()</"
"methodname> nebo <methodname>pack_end()</methodname>. U svislých boxů se "
"widgety balí shora dolů a naopak. Abyste dosáhli kýženého efektu, můžete "
"použít libovolné kombinace boxů uvnitř a vedle dalších boxů."

#: C/gtkmm-tutorial-in.xml:1955(title)
msgid "Adding widgets"
msgstr "Přidání widgetů"

#: C/gtkmm-tutorial-in.xml:1956(title)
msgid "Per-child packing options"
msgstr "Volby balení pro potomky"

#: C/gtkmm-tutorial-in.xml:1957(para)
msgid ""
"The <methodname>pack_start()</methodname> and <methodname>pack_end()</"
"methodname> methods place widgets inside these containers. The "
"<methodname>pack_start()</methodname> method will start at the top and work "
"its way down in a <classname>Box</classname> with vertical orientation, or "
"pack left to right in a <classname>Box</classname> with horizontal "
"orientation. <methodname>pack_end()</methodname> will do the opposite, "
"packing from bottom to top or from right to left. Using these methods allows "
"us to right justify or left justify our widgets. We will use "
"<methodname>pack_start()</methodname> in most of our examples."
msgstr ""
"Metody <methodname>pack_start()</methodname> a <methodname>pack_end()</"
"methodname> umisťují widgety uvnitř svých kontejnerů. Metoda "
"<methodname>pack_start()</methodname> začíná u objektu <classname>Box</"
"classname> se svislým uspořádáním shora a pokračuje dolů, u objektu "
"<classname>Box</classname> s vodorovným uspořádáním pak vlevo a pokračuje "
"doprava. <methodname>pack_end()</methodname> pracuje přesně opačně, tzn. "
"zdola nahoru nebo zprava doleva. Použití těchto metod dovoluje zarovnání "
"widgetů doprava nebo doleva. Ve většině příkladů budeme používat "
"<methodname>pack_start()</methodname>."

#: C/gtkmm-tutorial-in.xml:1969(para)
msgid ""
"There are several options governing how widgets are to be packed, and this "
"can be confusing at first. If you have difficulties then it is sometimes a "
"good idea to play with the <application>glade</application> GUI designer to "
"see what is possible. You might even decide to use the <application>Gtk::"
"Builder</application> API to load your GUI at runtime."
msgstr ""
"Existuje několik voleb řídících, jak budou widgety balené, a některé z nich "
"mohou být na první pohled matoucí. Pokud s tím budete mít problémy, je někdy "
"dobrý nápad pohrát si s návrhářem grafického uživatelského rozhraní "
"<application>glade</application>, abyste viděli, jak se co chová. Můžete se "
"také rozhodnout používat API <application>Gtk::Builder</application> pro "
"načtení vašeho návrhu GUI za běhu."

#: C/gtkmm-tutorial-in.xml:1977(para)
msgid "There are basically five different styles, as shown in this picture:"
msgstr ""
"V základu existuje pět rozdílných stylů, které můžete vidět na tomto obrázku:"

#: C/gtkmm-tutorial-in.xml:1983(title)
msgid "Box Packing 1"
msgstr "Balení boxů 1"

#: C/gtkmm-tutorial-in.xml:1989(para)
msgid ""
"Each line contains one horizontal <classname>Box</classname> with several "
"buttons. Each of the buttons on a line is packed into the <classname>Box</"
"classname> with the same arguments to the <methodname>pack_start()</"
"methodname> method."
msgstr ""
"Každý řádek obsahuje jeden vodorovný <classname>Box</classname> s několika "
"tlačítky. Každé z těchto tlačítek na řádku je sbaleno do <classname>Boxu</"
"classname> pomocí stejných argumentů předanýc metodě "
"<methodname>pack_start()</methodname>."

#: C/gtkmm-tutorial-in.xml:1996(para)
msgid ""
"This is the declaration of the <methodname>pack_start()</methodname> method:"
msgstr "Deklarace metody <methodname>pack_start()</methodname> vypadá takto:"

#: C/gtkmm-tutorial-in.xml:1999(programlisting)
#, no-wrap
msgid ""
"void pack_start(Gtk::Widget&amp; child,\n"
"                Gtk::PackOptions options = Gtk::PACK_EXPAND_WIDGET,\n"
"                guint padding = 0);"
msgstr ""
"void pack_start(Gtk::Widget&amp; child,\n"
"                Gtk::PackOptions options = Gtk::PACK_EXPAND_WIDGET,\n"
"                guint padding = 0);"

#: C/gtkmm-tutorial-in.xml:2003(para)
msgid ""
"The first argument is the widget you're packing. In our example these are "
"all <classname>Button</classname>s."
msgstr ""
"Prvním argumentem je widget, který balíme. V našem příkladu to jsou tlačítka "
"<classname>Button</classname>."

#: C/gtkmm-tutorial-in.xml:2010(para)
msgid ""
"<literal>Gtk::PACK_SHRINK</literal>: Space is contracted to the child widget "
"size. The widget will take up just-enough space and never expand."
msgstr ""
"<literal>Gtk::PACK_SHRINK</literal>: Místo je zmenšeno na velikost "
"synovského widgetu. Widget zabere místa tak akorát pro svoji potřebu a nikdy "
"se nezvětší."

#: C/gtkmm-tutorial-in.xml:2011(para)
msgid ""
"<literal>Gtk::PACK_EXPAND_PADDING</literal>: Extra space is filled with "
"padding. The widgets will be spaced out evenly, but their sizes won't change "
"- there will be empty space between the widgets instead."
msgstr ""
"<literal>Gtk::PACK_EXPAND_PADDING</literal>: Dodatečné místo je zaplněno "
"odsazením. Widgety budou rozložené rovnoměrně, ale jejich velikost se "
"nezmění – místo toho mezi nimi bude prázdné místo."

#: C/gtkmm-tutorial-in.xml:2012(para)
msgid ""
"<literal>Gtk::PACK_EXPAND_WIDGET</literal>: Extra space is taken up by "
"increasing the child widget size, without changing the amount of space "
"between widgets."
msgstr ""
"<literal>Gtk::PACK_EXPAND_WIDGET</literal>: Dodatečné místo je získáno "
"zvětšením velikost synovského widgetu, aniž by se měnilo množství místa mezi "
"widgety."

#: C/gtkmm-tutorial-in.xml:2007(para)
msgid ""
"The <parameter>options</parameter> argument can take one of these three "
"options: <placeholder-1/>"
msgstr ""
"Parametr <parameter>options</parameter> může přebírat jednu z následujících "
"tří voleb: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:2016(para)
msgid ""
"The <parameter>padding</parameter> argument specifies the width of an extra "
"border area to leave around the packed widget."
msgstr ""
"Parametr <parameter>padding</parameter> určuje šířku dodatečného volného "
"okraje, který se má ponechat okolo zabaleného widgetu."

#: C/gtkmm-tutorial-in.xml:2025(title)
msgid "Per-container packing options"
msgstr "Volby balení pro kontejner"

#: C/gtkmm-tutorial-in.xml:2029(programlisting)
#, no-wrap
msgid ""
"Gtk::Box(Gtk::Orientation orientation = Gtk::ORIENTATION_HORIZONTAL, int spacing = 0);\n"
"void set_spacing(int spacing);\n"
"void set_homogeneous(bool homogeneous = true);"
msgstr ""
"Gtk::Box(Gtk::Orientation orientation = Gtk::ORIENTATION_HORIZONTAL, int spacing = 0);\n"
"void set_spacing(int spacing);\n"
"void set_homogeneous(bool homogeneous = true);"

#: C/gtkmm-tutorial-in.xml:2026(para)
msgid ""
"Here's the constructor for the <classname>Box</classname> widget, and "
"methods that set per-container packing options: <placeholder-1/> Passing "
"<literal>true</literal> to <methodname>set_homogeneous()</methodname> will "
"cause all of the contained widgets to be the same size. <parameter>spacing</"
"parameter> is a (minimum) number of pixels to leave between each widget."
msgstr ""
"Zde je konstruktor pro widget <classname>Box</classname> a metody které "
"nastavují volby balení podle pro kontejner: <placeholder-1/> Předání "
"<literal>tru</literal> do <methodname>set_homogeneous</methodname> způsobí, "
"že všechny obsažené widgety budou mít stejnou velikost. <parameter>spacing</"
"parameter> je (minimální) počet pixelů, který se má ponechat mezi "
"jednotlivými widgety."

#: C/gtkmm-tutorial-in.xml:2038(para)
msgid ""
"What's the difference between spacing (set when the box is created) and "
"padding (set when elements are packed)? Spacing is added between objects, "
"and padding is added on either side of a widget. The following figure should "
"make it clearer:"
msgstr ""
"Jaký je rozdíl mezi rozestupy (nastavují se při vytváření boxu) a odsazením "
"(nastavuje se při balení)? Rozestupy se přidávají mezi objekty a odsazení se "
"přidává na některé strany widgetu. Následující obrázek by to měl názorně "
"objasnit:"

#: C/gtkmm-tutorial-in.xml:2046(title)
msgid "Box Packing 2"
msgstr "Balení boxů 2"

#: C/gtkmm-tutorial-in.xml:2056(title)
msgid "Gtk::Application and command-line options"
msgstr "Gtk::Application a přepínače příkazového řádku"

#: C/gtkmm-tutorial-in.xml:2057(para)
msgid ""
"The following example program requires a command-line option. The source "
"code shows two ways of handling command-line options in combination with "
"<classname>Gtk::Application</classname>."
msgstr ""
"Program v následujícím příkladu požaduje přepínače na příkazové řádce. "
"Zdrojový kód ukazuje dva způsoby, jak zpracovat přepínače příkazové řádky ve "
"spojení s <classname>Gtk::Application</classname>."

#: C/gtkmm-tutorial-in.xml:2063(para)
msgid ""
"Handle the options in <function>main()</function> and hide them from "
"<classname>Gtk::Application</classname> by setting <literal>argc = 1</"
"literal> in the call to <methodname>Gtk::Application::create()</methodname>."
msgstr ""
"Zpracovat přepínače v <function>main()</function> a skrýt je v "
"<classname>Gtk::Application</classname> nastavením <literal>argc = 1</"
"literal> ve volání <methodname>Gtk::Application::create()</methodname>."

#: C/gtkmm-tutorial-in.xml:2069(para)
msgid ""
"Give all command-line options to <methodname>Gtk::Application::create()</"
"methodname> and add the flag <literal>Gio::APPLICATION_HANDLES_COMMAND_LINE</"
"literal>. Connect a signal handler to the <literal>command_line</literal> "
"signal, and handle the command-line options in the signal handler."
msgstr ""
"Předat všechny přepínače příkazové řádky do <methodname>Gtk::Application::"
"create()</methodname> a přidat příznak <literal>Gio::"
"APPLICATION_HANDLES_COMMAND_LINE</literal>. Napojit obsluhu signálu na "
"signál <literal>command_line</literal> a zpracovat přepínače příkazové řádky "
"v obsluze signálu."

#: C/gtkmm-tutorial-in.xml:2075(para)
msgid ""
"You must set the optional parameter <literal>after = false</literal> in the "
"call to <literal>signal_command_line().connect()</literal>, because your "
"signal handler must be called before the default signal handler. You must "
"also call <methodname>Gio::Application::activate()</methodname> in the "
"signal handler, unless you want your application to exit without showing its "
"main window. (<classname>Gio::Application</classname> is a base class of "
"<classname>Gtk::Application</classname>.)"
msgstr ""
"Při volání <literal>signal_command_line().connect()</literal> musíte "
"nastavit volitelný parametr <literal>after = false</literal>, protože vaše "
"obsluha signálu musí být zavolána před výchozí obsluhou signálu. Také musíte "
"v obsluze signálu zavolat <methodname>Gio::Application::activate()</"
"methodname>, pokud tedy nechcete, aby vaše aplikace skončila dříve, než "
"zobrazí hlavní okno. (<classname>Gio::Application</classname> je základem "
"pro třídu <classname>Gtk::Application</classname>.)"

#: C/gtkmm-tutorial-in.xml:2088(para)
msgid ""
"Here is the source code for the example that produced the screenshots above. "
"When you run this example, provide a number between 1 and 3 as a command-"
"line option, to see different packing options in use."
msgstr ""
"Zde je zdrojový kód pro příklad, jehož výsledkem je to, co můžete vidět na "
"snímku obrazovky výše. Když příklad spouštíte, zadejte jako volbu "
"příkazového řádku číslo v rozmezí 1 až 3, a uvidíte, jak se použijí různé "
"volby balení."

#: C/gtkmm-tutorial-in.xml:2097(title)
msgid "ButtonBoxes"
msgstr "Kontejnery ButtonBox"

#: C/gtkmm-tutorial-in.xml:2099(para)
msgid ""
"Button boxes are a convenient way to quickly arrange a group of buttons. "
"Their orientation can be either horizontal or vertical."
msgstr ""
"Boxy na tlačítka jsou pohodlným způsobem, jak rychle uspořádat skupinu "
"tlačítek. Mohou být vodorovně vedle sebe nebo svisle pod sebou."

#: C/gtkmm-tutorial-in.xml:2104(para)
msgid ""
"<classname>ButtonBox</classname>es help to make applications appear "
"consistent because they use standard settings, such as inter-button spacing "
"and packing."
msgstr ""
"Kontejnery <classname>ButtonBox</classname> pomáhají, aby aplikace vypadaly "
"jednotně, protože používají standardní nastavení, jako je interní rozestup "
"tlačítek a jejich balení."

#: C/gtkmm-tutorial-in.xml:2109(para)
msgid ""
"Buttons are added to a <classname>ButtonBox</classname> with the "
"<methodname>add()</methodname> method."
msgstr ""
"Tlačítka se do <classname>ButtonBox</classname> přidávají pomocí metody "
"<methodname>add()</methodname>."

#: C/gtkmm-tutorial-in.xml:2114(para)
msgid ""
"Button boxes support several layout styles. The style can be retrieved and "
"changed using <methodname>get_layout()</methodname> and "
"<methodname>set_layout()</methodname>."
msgstr ""
"Boxy na tlačítka podporují několik stylů rozvržení. Styl lze získat a změnit "
"pomocí <methodname>get_layout()</methodname> a <methodname>set_layout()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:2126(title)
msgid "ButtonBox"
msgstr "ButtonBox"

#: C/gtkmm-tutorial-in.xml:2139(title) C/gtkmm-tutorial-in.xml:2168(title)
msgid "Grid"
msgstr "Mřížka (Grid)"

#: C/gtkmm-tutorial-in.xml:2141(para)
msgid ""
"A <classname>Grid</classname> dynamically lays out child widgets in rows and "
"columns. The dimensions of the grid do not need to be specified in the "
"constructor."
msgstr ""
"Kontejner <classname>Grid</classname> widgety dynamicky uspořádává do řádků "
"a sloupců. Rozměry mřížky není zapotřebí zadávat v konstruktoru."

#: C/gtkmm-tutorial-in.xml:2146(para)
msgid ""
"Child widgets can span multiple rows or columns, using <methodname>attach()</"
"methodname>, or added next to an existing widget inside the grid with "
"<methodname>attach_next_to()</methodname>. Individual rows and columns of "
"the grid can be set to have uniform height or width with "
"<methodname>set_row_homogeneous()</methodname> and "
"<methodname>set_column_homogeneous()</methodname>."
msgstr ""
"Synovské widgety mohou zabrat více řádků nebo sloupců pomocí "
"<methodname>attach()</methodname> nebo mohou být přidány vedle stávajícího "
"widgetu uvnitř mřížky pomocí <methodname>attach_next_to()</methodname>. "
"Jednotlivé řádky a sloupce mřížky mohou být nastaveny tak, aby měly "
"jednotnou výšku nebo šířku pomocí <methodname>set_row_homogeneous()</"
"methodname> a <methodname>set_column_homogeneous()</methodname>."

#: C/gtkmm-tutorial-in.xml:2153(para)
msgid ""
"You can set the <emphasis>margin</emphasis> and <emphasis>expand</emphasis> "
"properties of the child <classname>Widget</classname>s to control their "
"spacing and their behaviour when the Grid is resized."
msgstr ""
"Pro synovské <classname>Widgety</classname> můžete zadat vlastnosti "
"<emphasis>margin</emphasis> a <emphasis>expand</emphasis>, abyste určili "
"jejich rozestupy a chování při změně rozměrů mřížky."

#: C/gtkmm-tutorial-in.xml:2160(para)
msgid ""
"This example creates a window with three buttons in a grid. The first two "
"buttons are in the upper row, from left to right. A third button is attached "
"underneath the first button, in a new lower row, spanning two columns."
msgstr ""
"Tento příklad vytvoří okno se třemi tlačítky v mřížce. První dvě tlačítka "
"jsou v horním řádku, zleva doprava. Třetí tlačítko je připojeno pod prvním, "
"v novém nižším řádku a zabírá dva sloupce."

#: C/gtkmm-tutorial-in.xml:2181(title)
msgid "Table"
msgstr "Tabulka (Table)"

#: C/gtkmm-tutorial-in.xml:2183(para)
msgid ""
"<classname>Gtk::Table</classname> allows us to place widgets in a grid, "
"similar to <classname>Gtk::Grid</classname>."
msgstr ""
"<classname>Gtk::Table</classname> umožňuje umístit widgety do mřížky, "
"podobně jako <classname>Gtk::Grid</classname>."

#: C/gtkmm-tutorial-in.xml:2187(para)
msgid ""
"<classname>Gtk::Table</classname> is deprecated from <application>gtkmm</"
"application> version 3.4 and should not be used in newly-written code. Use "
"<classname>Gtk::Grid</classname> instead."
msgstr ""
"Widget <classname>Gtk::Table</classname> je od <application>gtkmm</"
"application> verze 3.4 zavržený a neměl by být používán v nově psaném kódu. "
"Místo něj použijte <classname>Gtk::Grid</classname>."

#: C/gtkmm-tutorial-in.xml:2194(title) C/gtkmm-tutorial-in.xml:2229(title)
msgid "Notebook"
msgstr "Sešit (Notebook)"

#: C/gtkmm-tutorial-in.xml:2196(para)
msgid ""
"A <classname>Notebook</classname> has a set of stacked <literal>pages</"
"literal>, each of which contains widgets. Labelled <literal>tabs</literal> "
"allow the user to select the pages. <classname>Notebook</classname>s allow "
"several sets of widgets to be placed in a small space, by only showing one "
"page at a time. For instance, they are often used in preferences dialogs."
msgstr ""
"<classname>Notebook</classname> má sadu navrstvených <literal>karet</"
"literal>, z nichž každá může obsahovat widgety. <literal>Ouška</literal> s "
"popisky umožňují uživateli vybrat požadovanou kartu. Díky objektům "
"<classname>Notebook</classname> můžete umístit několik sad widgetů na malý "
"prostor a v jednu chvíli zobrazit vždy jednu kartu. Často se používají "
"například v dialogových oknech s předvolbami."

#: C/gtkmm-tutorial-in.xml:2205(para)
msgid ""
"Use the <methodname>append_page()</methodname>, <methodname>prepend_page()</"
"methodname> and <methodname>insert_page()</methodname> methods to add tabbed "
"pages to the <literal>Notebook</literal>, supplying the child widget and the "
"name for the tab."
msgstr ""
"Pro přidání karet do objektu <literal>Notebook</literal> použijte metody "
"<methodname>append_page()</methodname>, <methodname>prepend_page()</"
"methodname> a <methodname>insert_page()</methodname>, kterým poskytnete "
"synovský widget a název karty."

#: C/gtkmm-tutorial-in.xml:2212(para)
msgid ""
"To discover the currently visible page, use the "
"<methodname>get_current_page()</methodname> method. This returns the page "
"number, and then calling <methodname>get_nth_page()</methodname> with that "
"number will give you a pointer to the actual child widget."
msgstr ""
"Ke zjištění, která stránka je právě viditelná, použijte metodu "
"<methodname>get_current_page()</methodname>. Vrátí vám číslo stránky a s "
"tímto číslem zavolejte <methodname>get_nth_page()</methodname>, abyste "
"získali ukazatel na aktuální synovský widget."

#: C/gtkmm-tutorial-in.xml:2219(para)
msgid ""
"To programmatically change the selected page, use the "
"<methodname>set_current_page()</methodname> method."
msgstr ""
"K programové změně vybrané stránky použijte metodu "
"<methodname>set_current_page()</methodname>."

#: C/gtkmm-tutorial-in.xml:2242(title) C/gtkmm-tutorial-in.xml:2269(title)
msgid "Assistant"
msgstr "Průvodce (Assistant)"

#: C/gtkmm-tutorial-in.xml:2244(para)
msgid ""
"An <classname>Assistant</classname> splits a complex operation into steps. "
"Each step is a page, containing a header, a child widget and an action area. "
"The Assistant's action area has navigation buttons which update "
"automatically depending on the type of the page, set with "
"<methodname>set_page_type()</methodname>."
msgstr ""
"Widget <classname>Assistant</classname> rozděluje složité operace do "
"několika jednodušších kroků. Každý krok je na zvláštní stránce, která "
"obsahuje záhlaví, synovský widget a oblast s akcemi. Oblast akcí obsahuje "
"navigační tlačítka, která se aktualizují automaticky podle typu stránky "
"nastaveného pomocí <methodname>set_page_type()</methodname>."

#: C/gtkmm-tutorial-in.xml:2248(para)
msgid ""
"Use the <methodname>append_page()</methodname>, <methodname>prepend_page</"
"methodname> and <methodname>insert_page()</methodname> methods to add pages "
"to the <classname>Assistant</classname>, supplying the child widget for each "
"page."
msgstr ""
"K přidání stránek do widgetu <classname>Assistant</classname> použijte "
"metody <methodname>append_page()</methodname>, <methodname>prepend_page</"
"methodname> a <methodname>insert_page()</methodname>. Ke každé stránce "
"poskytněte synovský widget."

#: C/gtkmm-tutorial-in.xml:2252(para)
msgid ""
"To determine the currently-visible page, use the "
"<methodname>get_current_page()</methodname> method, and pass the result to "
"<methodname>get_nth_page()</methodname>, which returns a pointer to the "
"actual widget. To programmatically change the current page, use the "
"<methodname>set_current_page()</methodname> method."
msgstr ""
"K určení právě viditelné stránky použijte metodu "
"<methodname>get_current_page()</methodname> a výsledek předejte metodě "
"<methodname>get_nth_page()</methodname>, která vrátí ukazatel na aktuální "
"widget. K programové změně aktuální stránky použijte metodu "
"<methodname>set_current_page()</methodname>."

#: C/gtkmm-tutorial-in.xml:2256(para)
msgid ""
"To set the title of a page, use the <methodname>set_page_title()</"
"methodname> method. The header and side images of a page can be set with the "
"<methodname>set_page_header_image()</methodname> and "
"<methodname>set_page_side_image()</methodname> methods."
msgstr ""
"K nastavení záhlaví stránky použijte metodu <methodname>set_page_title()</"
"methodname>. Nadpis a postranní obrázeki stránky mohou být nastaveny pomocí "
"metod <methodname>set_page_header_image()</methodname> a "
"<methodname>set_page_side_image()</methodname>."

#: C/gtkmm-tutorial-in.xml:2260(para)
msgid ""
"To add widgets to the action area, use the <methodname>add_action_widget()</"
"methodname> method. They will be packed alongside the default buttons. Use "
"the <methodname>remove_action_widget()</methodname> method to remove widgets."
msgstr ""
"Pro přidání widgetů do oblasti akcí použijte metodu "
"<methodname>add_action_widget()</methodname>. Budou baleny vedle výchozích "
"tlačítek. Naopak, k jejich odebrání použijte metodu "
"<methodname>remove_action_widget()</methodname>."

#: C/gtkmm-tutorial-in.xml:2287(title)
msgid "The TreeView widget"
msgstr "Widget TreeView"

#: C/gtkmm-tutorial-in.xml:2288(para)
msgid ""
"The <classname>Gtk::TreeView</classname> widget can contain lists or trees "
"of data, in columns."
msgstr ""
"Widget <classname>Gtk::TreeView</classname> může obsahovat seznam nebo strom "
"s daty ve sloupcích."

#: C/gtkmm-tutorial-in.xml:2294(title)
msgid "The Model"
msgstr "Model"

#: C/gtkmm-tutorial-in.xml:2295(para)
msgid ""
"Each <classname>Gtk::TreeView</classname> has an associated <classname>Gtk::"
"TreeModel</classname>, which contains the data displayed by the "
"<classname>TreeView</classname>. Each <classname>Gtk::TreeModel</classname> "
"can be used by more than one <classname>Gtk::TreeView</classname>. For "
"instance, this allows the same underlying data to be displayed and edited in "
"2 different ways at the same time. Or the 2 Views might display different "
"columns from the same Model data, in the same way that 2 SQL queries (or "
"\"views\") might show different fields from the same database table."
msgstr ""
"Každý widget <classname>Gtk::TreeView</classname> má přiřazený "
"<classname>Gtk::TreeModel</classname>, který obsahuje data zobrazená v "
"<classname>TreeView</classname>. Každý <classname>Gtk::TreeModel</classname> "
"může být použit i více než jedním <classname>Gtk::TreeView</classname>. "
"Umožňuje to například stejná podkladová data zobrazit a upravovat dvěma "
"různými způsoby naráz. Nebo dvě zobrazení mohou ukazovat různé sloupce ze "
"stejného datového modelu, podobně jako dva dotazy SQL (nebo pohledy) mohou "
"zobrazovat různá pole ze stejné databázové tabulky."

#: C/gtkmm-tutorial-in.xml:2305(para)
msgid ""
"Although you can theoretically implement your own Model, you will normally "
"use either the <classname>ListStore</classname> or <classname>TreeStore</"
"classname> model classes."
msgstr ""
"I když si teoreticky můžete implementovat svůj vlastní Model, normálně "
"budete používat buď třídu <classname>ListStore</classname> nebo "
"<classname>TreeStore</classname>."

#: C/gtkmm-tutorial-in.xml:2314(title)
msgid "ListStore, for rows"
msgstr "ListStore (pro řádky)"

#: C/gtkmm-tutorial-in.xml:2315(para)
msgid ""
"The <classname>ListStore</classname> contains simple rows of data, and each "
"row has no children."
msgstr ""
"<classname>ListStore</classname> obsahuje jen řádková data, řádky nemají "
"žádné potomky."

#: C/gtkmm-tutorial-in.xml:2321(title) C/gtkmm-tutorial-in.xml:2861(title)
msgid "TreeView - ListStore"
msgstr "TreeView – ListStore"

#: C/gtkmm-tutorial-in.xml:2332(title)
msgid "TreeStore, for a hierarchy"
msgstr "TreeStore (pro hierarchii)"

#: C/gtkmm-tutorial-in.xml:2333(para)
msgid ""
"The <classname>TreeStore</classname> contains rows of data, and each row may "
"have child rows."
msgstr ""
"<classname>TreeStore</classname> obsahuje řádková data a každý z řádků může "
"mít potomky v podobě dalších řádků."

#: C/gtkmm-tutorial-in.xml:2339(title) C/gtkmm-tutorial-in.xml:2880(title)
msgid "TreeView - TreeStore"
msgstr "TreeView – TreeStore"

#: C/gtkmm-tutorial-in.xml:2350(title)
msgid "Model Columns"
msgstr "Sloupce modelu"

#: C/gtkmm-tutorial-in.xml:2351(para)
msgid ""
"The <classname>TreeModelColumnRecord</classname> class is used to keep track "
"of the columns and their data types. You add <classname>TreeModelColumn</"
"classname> instances to the <classname>ColumnRecord</classname> and then use "
"those <classname>TreeModelColumns</classname> when getting and setting the "
"data in model rows. You will probably find it convenient to derive a new "
"<classname>TreeModelColumnRecord</classname> which has your "
"<classname>TreeModelColumn</classname> instances as member data."
msgstr ""
"Třída <classname>TreeModelColumnRecord</classname> se používá k udržení "
"přehledu o sloupcích a jejich datových typech. Instance "
"<classname>TreeModelColumn</classname> přidáváte do <classname>ColumnRecord</"
"classname> a pak je používáte k získávání a nastavování dat v řádkovém "
"modelu. Pravděpodobně budete považovat za vhodné odvodit novou třídu "
"<classname>TreeModelColumnRecord</classname>, kterou použije vaše instance "
"<classname>TreeModelColumn</classname> jako členská data."

#: C/gtkmm-tutorial-in.xml:2362(programlisting)
#, no-wrap
msgid ""
"class ModelColumns : public Gtk::TreeModelColumnRecord\n"
"{\n"
"public:\n"
"\n"
"  ModelColumns()\n"
"    { add(m_col_text); add(m_col_number); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_number;\n"
"};\n"
"\n"
"ModelColumns m_Columns;"
msgstr ""
"class ModelColumns : public Gtk::TreeModelColumnRecord\n"
"{\n"
"public:\n"
"\n"
"  ModelColumns()\n"
"    { add(m_col_text); add(m_col_number); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_text;\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_number;\n"
"};\n"
"\n"
"ModelColumns m_Columns;"

#: C/gtkmm-tutorial-in.xml:2375(para)
msgid ""
"You specify the <classname>ColumnRecord</classname> when creating the Model, "
"like so:"
msgstr ""
"Když vytváříte Model, určíte <classname>ColumnRecord</classname> takto:"

#: C/gtkmm-tutorial-in.xml:2379(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"
msgstr ""
"Glib::RefPtr&lt;Gtk::ListStore&gt; refListStore =\n"
"    Gtk::ListStore::create(m_Columns);"

#: C/gtkmm-tutorial-in.xml:2381(para)
msgid ""
"Note that the instance (such as m_Columns here) should usually not be "
"static, because it often needs to be instantiated after glibmm has been "
"instantiated."
msgstr ""
"Pamatujte na to, že instance (jako je zde m_Columns) by obvykle neměla být "
"statická, protože je často potřeba ji vytvořit po té, co je inicializována "
"glibmm."

#: C/gtkmm-tutorial-in.xml:2386(title)
msgid "Adding Rows"
msgstr "Přidávání řádků"

#: C/gtkmm-tutorial-in.xml:2387(para)
msgid ""
"Add rows to the model with the <methodname>append()</methodname>, "
"<methodname>prepend()</methodname>, or <methodname>insert()</methodname> "
"methods."
msgstr ""
"Řádky do modelu přidejte pomocí metod <methodname>append()</methodname>, "
"<methodname>prepend()</methodname> nebo <methodname>insert()</methodname>."

#: C/gtkmm-tutorial-in.xml:2391(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();"
msgstr "Gtk::TreeModel::iterator iter = m_refListStore-&gt;append();"

#: C/gtkmm-tutorial-in.xml:2392(para)
msgid "You can dereference the iterator to get the Row:"
msgstr ""
"Pro získání řádku <classname>Row</classname> můžete použít dereferenci "
"iterátoru:"

#: C/gtkmm-tutorial-in.xml:2394(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::Row row = *iter;"
msgstr "Gtk::TreeModel::Row row = *iter;"

#: C/gtkmm-tutorial-in.xml:2395(title)
msgid "Adding child rows"
msgstr "Přidávání synovský řádků"

#: C/gtkmm-tutorial-in.xml:2396(para)
msgid ""
"<classname>Gtk::TreeStore</classname> models can have child items. Add them "
"with the <methodname>append()</methodname>, <methodname>prepend()</"
"methodname>, or <methodname>insert()</methodname> methods, like so:"
msgstr ""
"Model <classname>Gtk::TreeStore</classname> může mít dceřiné položky. "
"Přidávají se pomocí metody <methodname>append()</methodname>, "
"<methodname>prepend()</methodname> nebo <methodname>insert()</methodname> "
"takto:"

#: C/gtkmm-tutorial-in.xml:2401(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter_child =\n"
"    m_refTreeStore-&gt;append(row.children());"
msgstr ""
"Gtk::TreeModel::iterator iter_child =\n"
"    m_refTreeStore-&gt;append(row.children());"

#: C/gtkmm-tutorial-in.xml:2408(title)
msgid "Setting values"
msgstr "Nastavení hodnot"

#: C/gtkmm-tutorial-in.xml:2409(para)
msgid ""
"You can use the <methodname>operator[]</methodname> override to set the data "
"for a particular column in the row, specifying the "
"<classname>TreeModelColumn</classname> used to create the model."
msgstr ""
"S <classname>TreeModelColumn</classname>, použitým k vytvoření modelu, a "
"<methodname>operatorem []</methodname> můžete přepsat data nastavená v "
"konkrétním sloupci v řádku."

#: C/gtkmm-tutorial-in.xml:2414(programlisting)
#, no-wrap
msgid "row[m_Columns.m_col_text] = \"sometext\";"
msgstr "row[m_Columns.m_col_text] = \"sometext\";"

#: C/gtkmm-tutorial-in.xml:2418(title)
msgid "Getting values"
msgstr "Získání hodnot"

#: C/gtkmm-tutorial-in.xml:2419(para)
msgid ""
"You can use the <methodname>operator[]</methodname> override to get the data "
"in a particular column in a row, specifiying the <classname>TreeModelColumn</"
"classname> used to create the model."
msgstr ""
"S <classname>TreeModelColumn</classname>, použitým k vytvoření modelu, a "
"<methodname>operatorem []</methodname> můžete získat data z konkrétního "
"sloupce v řádku."

#: C/gtkmm-tutorial-in.xml:2424(programlisting)
#, no-wrap
msgid ""
"Glib::ustring strText = row[m_Columns.m_col_text];\n"
"int number = row[m_Columns.m_col_number];"
msgstr ""
"Glib::ustring strText = row[m_Columns.m_col_text];\n"
"int number = row[m_Columns.m_col_number];"

#: C/gtkmm-tutorial-in.xml:2426(para)
msgid ""
"The compiler will complain if you use an inappropriate type. For instance, "
"this would generate a compiler error:"
msgstr ""
"Kompilátor vás upozorní, když použijete nesprávný typ. Například následující "
"ukázka by měla způsobit chybu kompilace:"

#: C/gtkmm-tutorial-in.xml:2430(programlisting)
#, no-wrap
msgid ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"
msgstr ""
"//compiler error - no conversion from ustring to int.\n"
"int number = row[m_Columns.m_col_text];"

#: C/gtkmm-tutorial-in.xml:2435(title)
msgid "\"Hidden\" Columns"
msgstr "„Skryté“ sloupce"

#: C/gtkmm-tutorial-in.xml:2436(para)
msgid ""
"You might want to associate extra data with each row. If so, just add it as "
"a Model column, but don't add it to the View."
msgstr ""
"Můžete potřebovat mít v řádcích zadaná nějaká doplňující data. V takovém "
"případě stačí, když je přidáte do Modelu jako další sloupec, ale ten "
"nebudete přidávat do zobrazení View."

#: C/gtkmm-tutorial-in.xml:2445(title) C/gtkmm-tutorial-in.xml:3272(title)
msgid "The View"
msgstr "Zobrazení (View)"

#: C/gtkmm-tutorial-in.xml:2446(para)
msgid ""
"The View is the actual widget (<classname>Gtk::TreeView</classname>) that "
"displays the model (<classname>Gtk::TreeModel</classname>) data and allows "
"the user to interact with it. The View can show all of the model's columns, "
"or just some, and it can show them in various ways."
msgstr ""
"<classname>View</classname> je skutečný widget (<classname>Gtk::TreeView</"
"classname>), který zobrazuje data modelu (<classname>Gtk::TreeModel</"
"classname>) a umožňuje uživateli s nimi komunikovat. Může zobrazovat všechny "
"sloupce modelu, nebo jen vybrané, a umí je zobrazovat různými způsoby."

#: C/gtkmm-tutorial-in.xml:2456(title)
msgid "Using a Model"
msgstr "Použití modelu"

#: C/gtkmm-tutorial-in.xml:2457(para)
msgid ""
"You can specify a <classname>Gtk::TreeModel</classname> when constructing "
"the <classname>Gtk::TreeView</classname>, or you can use the "
"<methodname>set_model()</methodname> method, like so:"
msgstr ""
"<classname>Gtk::TreeModel</classname> můžete určit, když konstruhujete "
"<classname>Gtk::TreeView</classname>, nebo můžete použít metodu "
"<methodname>set_model()</methodname>, nějak takto:"

#: C/gtkmm-tutorial-in.xml:2462(programlisting)
#, no-wrap
msgid "m_TreeView.set_model(m_refListStore);"
msgstr "m_TreeView.set_model(m_refListStore);"

#: C/gtkmm-tutorial-in.xml:2466(title)
msgid "Adding View Columns"
msgstr "Přidání sloupců do zobrazení"

#: C/gtkmm-tutorial-in.xml:2467(para)
msgid ""
"You can use the <methodname>append_column()</methodname> method to tell the "
"View that it should display certain Model columns, in a certain order, with "
"a certain column title."
msgstr ""
"Můžete použít metodu <methodname>append_column()</methodname>, abyste řekli "
"widgetu <classname>View</classname>, že má použít konkrétní sloupce objektu "
"<classname>Modelu</classname>, v konkrétním pořadí, s konkrétními záhlavími "
"sloupců."

#: C/gtkmm-tutorial-in.xml:2472(programlisting)
#, no-wrap
msgid "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"
msgstr "m_TreeView.append_column(\"Messages\", m_Columns.m_col_text);"

#: C/gtkmm-tutorial-in.xml:2473(para)
msgid ""
"When using this simple <methodname>append_column()</methodname> override, "
"the <classname>TreeView</classname> will display the model data with an "
"appropriate <classname>CellRenderer</classname>. For instance, strings and "
"numbers are shown in a simple <classname>Gtk::Entry</classname> widget, and "
"booleans are shown in a <classname>Gtk::CheckButton</classname>. This is "
"usually what you need. For other column types you must either connect a "
"callback that converts your type into a string representation, with "
"<methodname>TreeViewColumn::set_cell_data_func()</methodname>, or derive a "
"custom <classname>CellRenderer</classname>. Note that (unsigned) short is "
"not supported by default - You could use (unsigned) int or (unsigned) long "
"as the column type instead."
msgstr ""
"Když se použije toto jednoduché přepsání metody <methodname>append_column()</"
"methodname>, bude <classname>TreeView</classname> zobrazovat data z modelu "
"pomocí příslušné třídy <classname>CellRenderer</classname>. Například "
"řetězce a čísla se zobrazují v jednoduchém widgetu <classname>Gtk::Entry</"
"classname> a pravdivostní hodnoty se zobrazují pomocí widgetu "
"<classname>Gtk::CheckButton</classname>. Obvykle je to to, co chcete. Pro "
"další typy sloupců musíte buď pomocí <methodname>TreeViewColumn::"
"set_cell_data_func()</methodname> napojit zpětné volání, které převádí váš "
"typ na řetězcovou reprezentaci, nebo odvodit vlastní "
"<classname>CellRenderer</classname>. Upozorňujeme, že typ "
"<literal>(unsigned) short</literal> není standardně podporován – musíte "
"místo toho použít sloupec <literal>(unsigned) int</literal> nebo "
"<literal>(unsigned) long</literal>."

#: C/gtkmm-tutorial-in.xml:2489(title)
msgid "More than one Model Column per View Column"
msgstr "Více než jeden sloupec modelu ve sloupci zobrazení"

#: C/gtkmm-tutorial-in.xml:2490(para)
msgid ""
"To render more than one model column in a view column, you need to create "
"the <classname>TreeView::Column</classname> widget manually, and use "
"<methodname>pack_start()</methodname> to add the model columns to it."
msgstr ""
"Když chcete v jednom sloupci zobrazení vykreslit více než jeden sloupec z "
"modelu, musíte vytvořit widget <classname>TreeView::Column</classname> ručně "
"a k přidání sloupce modelu do něj použít <methodname>pack_start()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:2496(para)
msgid ""
"Then use <methodname>append_column()</methodname> to add the view Column to "
"the View. Notice that <methodname>Gtk::TreeView::append_column()</"
"methodname> is overridden to accept either a prebuilt <classname>Gtk::"
"TreeView::Column</classname> widget, or just the <classname>TreeModelColumn</"
"classname> from which it generates an appropriate <classname>Gtk::TreeView::"
"Column</classname> widget."
msgstr ""
"Pak použijte <methodname>append_column()</methodname> k přidání sloupce "
"zobrazení Column do zobrazení View. Upozorňujeme, že metoda <methodname>Gtk::"
"TreeView::append_column()</methodname> je přepsaná, aby přijímala buď "
"předsestavený widget <classname>Gtk::TreeView::Column</classname> nebo jen "
"prostě <classname>TreeModelColumn</classname>, ze kterého vygeneruje "
"příslušný widget <classname>Gtk::TreeView::Column</classname>."

#: C/gtkmm-tutorial-in.xml:2503(para)
msgid ""
"Here is some example code from <filename>gtkmm/demos/gtk-demo/"
"example_icontheme.cc</filename>, which has a pixbuf icon and a text name in "
"the same column:"
msgstr ""
"Zde je příklad kódu z <filename>gtkmm/demos/gtk-demo/example_icontheme.cc</"
"filename>, který má ve stejném sloupci ikonu pixbuf i textový název:"

#: C/gtkmm-tutorial-in.xml:2508(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeView::Column* pColumn =\n"
"  Gtk::manage(new Gtk::TreeView::Column(\"Icon Name\"));\n"
"\n"
"// m_columns.icon and m_columns.iconname are columns in the model.\n"
"// pColumn is the column in the TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);\n"
"pColumn-&gt;pack_start(m_columns.iconname);\n"
"\n"
"m_TreeView.append_column(*pColumn);"
msgstr ""
"Gtk::TreeView::Column* pColumn =\n"
"  Gtk::manage(new Gtk::TreeView::Column(\"Icon Name\"));\n"
"\n"
"// m_columns.icon a m_columns.iconname jsou sloupce v modelu\n"
"// pColumn je sloupec v TreeView:\n"
"pColumn-&gt;pack_start(m_columns.icon, /* expand= */ false);\n"
"pColumn-&gt;pack_start(m_columns.iconname);\n"
"\n"
"m_TreeView.append_column(*pColumn);"

#: C/gtkmm-tutorial-in.xml:2520(title)
msgid "Specifying CellRenderer details"
msgstr "Určení údajů pro CellRenderer"

#: C/gtkmm-tutorial-in.xml:2521(para)
msgid ""
"The default <classname>CellRenderers</classname> and their default behaviour "
"will normally suffice, but you might occasionally need finer control. For "
"instance, this example code from <filename>gtkmm/demos/gtk-demo/"
"example_treeview_treestore.cc</filename>, appends a <classname>Gtk::"
"CellRenderer</classname> widget and instructs it to render the data from "
"various model columns through various aspects of its appearance."
msgstr ""
"Výchozí <classname>CellRenderers</classname> a jeho výchozí chování běžně "
"postačují, ale občas může být potřeba preciznější ovládání. Například tento "
"ukázkový kód z <filename>gtkmm/demos/gtk-demo/example_treeview_treestore.cc</"
"filename> připojuje widget <classname>Gtk::CellRenderer</classname> a říká "
"mu, aby vykresloval data z různých sloupců modelu podle různých hledisek "
"jejich podoby."

#: C/gtkmm-tutorial-in.xml:2529(programlisting)
#, no-wrap
msgid ""
"int cols_count = m_TreeView.append_column_editable(\"Alex\", m_columns.alex);\n"
"Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  Gtk::CellRendererToggle* pRenderer =\n"
"    static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);"
msgstr ""
"int cols_count = m_TreeView.append_column_editable(\"Alex\", m_columns.alex);\n"
"Gtk::TreeViewColumn* pColumn = m_TreeView.get_column(cols_count-1);\n"
"if(pColumn)\n"
"{\n"
"  Gtk::CellRendererToggle* pRenderer =\n"
"    static_cast&lt;Gtk::CellRendererToggle*&gt;(pColumn-&gt;get_first_cell());\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_visible(), m_columns.visible);\n"
"  pColumn-&gt;add_attribute(pRenderer-&gt;property_activatable(), m_columns.world);"

#: C/gtkmm-tutorial-in.xml:2538(para)
msgid ""
"You can also connect to <classname>CellRenderer</classname> signals to "
"detect user actions. For instance:"
msgstr ""
"Můžete také napojit signál <classname>CellRenderer</classname>, abyste "
"odhalili uživatelské činnosti. Například:"

#: C/gtkmm-tutorial-in.xml:2542(programlisting)
#, no-wrap
msgid ""
"Gtk::CellRendererToggle* pRenderer =\n"
"    Gtk::manage( new Gtk::CellRendererToggle() );\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"
msgstr ""
"Gtk::CellRendererToggle* pRenderer =\n"
"    Gtk::manage( new Gtk::CellRendererToggle() );\n"
"pRenderer-&gt;signal_toggled().connect(\n"
"    sigc::bind( sigc::mem_fun(*this,\n"
"        &amp;Example_TreeView_TreeStore::on_cell_toggled), m_columns.dave)\n"
");"

#: C/gtkmm-tutorial-in.xml:2551(title) C/gtkmm-tutorial-in.xml:2890(title)
msgid "Editable Cells"
msgstr "Editovatelné buňky"

#: C/gtkmm-tutorial-in.xml:2554(title)
msgid "Automatically-stored editable cells."
msgstr "Editovatelné buňky s automatickým ukládáním."

#: C/gtkmm-tutorial-in.xml:2555(para)
msgid ""
"Cells in a <classname>TreeView</classname> can be edited in-place by the "
"user. To allow this, use the <classname>Gtk::TreeView</"
"classname><methodname>insert_column_editable()</methodname> and "
"<methodname>append_column_editable()</methodname> methods instead of "
"<methodname>insert_column()</methodname> and <methodname>append_column()</"
"methodname>. When these cells are edited the new values will be stored "
"immediately in the Model. Note that these methods are templates which can "
"only be instantiated for simple column types such as <classname>Glib::"
"ustring</classname>, int, and long."
msgstr ""
"Buňky v <classname>TreeView</classname> může uživatel upravovat přímo na "
"místě. Abyste mu to umožnili, použijte z <classname>Gtk::TreeView</"
"classname> na místo metod <methodname>insert_column()</methodname> a "
"<methodname>append_column()</methodname> metody "
"<methodname>insert_column_editable()</methodname> a "
"<methodname>append_column_editable()</methodname>. Když jsou tyto buňky "
"upraveny, je nová hodnota bezprostředně uložena do Modelu. Upozorňujeme ale, "
"že tyto metody jsou šablonami, ze kterých lze vytvořit instanci jen pro "
"jednoduché typy sloupců, jako je <classname>Glib::ustring</classname>, int "
"nebo long."

#: C/gtkmm-tutorial-in.xml:2569(title)
msgid "Implementing custom logic for editable cells."
msgstr "Implementace vlastní logiky pro editovatelné buňky."

#: C/gtkmm-tutorial-in.xml:2570(para)
msgid ""
"However, you might not want the new values to be stored immediately. For "
"instance, maybe you want to restrict the input to certain characters or "
"ranges of values."
msgstr ""
"Může se stát, že budete chtít, aby se nové hodnoty neukládaly okamžitě. "
"Například můžete chtít omezit vstup na konkrétní znaky nebo rozsah hodnot."

#: C/gtkmm-tutorial-in.xml:2575(para)
msgid ""
"To achieve this, you should use the normal <classname>Gtk::TreeView</"
"classname><methodname>insert_column()</methodname> and "
"<methodname>append_column()</methodname> methods, then use "
"<methodname>get_column_cell_renderer()</methodname> to get the "
"<classname>Gtk::CellRenderer</classname> used by that column."
msgstr ""
"Abyste toho dosáhli, měli byste použít normální metody "
"<methodname>insert_column()</methodname> a <methodname>append_column()</"
"methodname> z <classname>Gtk::TreeView</classname> a pak použít "
"<methodname>get_column_cell_renderer()</methodname> pro získání objektu "
"<classname>Gtk::CellRenderer</classname>, který sloupec používá."

#: C/gtkmm-tutorial-in.xml:2581(para)
msgid ""
"You should then cast that <classname>Gtk::CellRenderer*</classname> to the "
"specific <classname>CellRenderer</classname> that you expect, so you can use "
"specific API."
msgstr ""
"Měli byste pak <classname>Gtk::CellRenderer*</classname> přetypovat na "
"konkrétní <classname>CellRenderer</classname>, který očekáváte, abyste mohli "
"použít jeho API."

#: C/gtkmm-tutorial-in.xml:2585(para)
msgid ""
"For instance, for a CellRendererText, you would set the cell's "
"<emphasis>editable</emphasis> property to true, like so:"
msgstr ""
"Například, pro <classname>CellRendererText</classname> byste mohli nastavit "
"vlastnost buňky <emphasis>editable</emphasis> na <literal>true</literal> "
"takto:"

#: C/gtkmm-tutorial-in.xml:2588(programlisting)
#, no-wrap
msgid "cell.property_editable() = true;"
msgstr "cell.property_editable() = true;"

#: C/gtkmm-tutorial-in.xml:2589(para)
msgid ""
"For a CellRendererToggle, you would set the <emphasis>activatable</emphasis> "
"property instead."
msgstr ""
"U <classname>CellRendererToggle</classname> byste místo toho mohli nastavit "
"vlastnost <emphasis>activatable</emphasis>."

#: C/gtkmm-tutorial-in.xml:2593(para)
msgid ""
"You can then connect to the appropriate \"edited\" signal. For instance, "
"connect to <methodname>Gtk::CellRendererText::signal_edited()</methodname>, "
"or <methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. If "
"the column contains more than one <classname>CellRenderer</classname> then "
"you will need to use <methodname>Gtk::TreeView::get_column()</methodname> "
"and then call <methodname>get_cell_renderers()</methodname> on that view "
"Column."
msgstr ""
"Můžete provést napojení na příslušný signál „edited“, například na "
"<methodname>Gtk::CellRendererText::signal_edited()</methodname> nebo "
"<methodname>Gtk::CellRendererToggle::signal_toggled()</methodname>. Pokud "
"sloupec obsahuje víc než jeden <classname>CellRenderer</classname> budete "
"potřebovat použít <methodname>Gtk::TreeView::get_column()</methodname> a "
"zavolat na zobrazení tohoto sloupce <methodname>get_cell_renderers()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:2601(para)
msgid ""
"In your signal handler, you should examine the new value and then store it "
"in the Model if that is appropriate for your application."
msgstr ""
"Ve své obsluze signálu byste měli zkontrolovat novou hodnotu a uložit ji do "
"objektu <classname>Model</classname>, pokud se to vaší aplikaci může hodit."

#: C/gtkmm-tutorial-in.xml:2613(title)
msgid "Iterating over Model Rows"
msgstr "Iterace přes řádky modelu"

#: C/gtkmm-tutorial-in.xml:2614(para)
msgid ""
"<classname>Gtk::TreeModel</classname> provides a C++ Standard Library-style "
"container of its children, via the <methodname>children()</methodname> "
"method. You can use the familiar <methodname>begin()</methodname> and "
"<methodname>end()</methodname> methods iterator incrementing, like so:"
msgstr ""
"<classname>Gtk::TreeModel</classname> poskytuje přes metodu "
"<methodname>children()</methodname> kontejner ve stylu standardní knihovny C+"
"+ s jeho potomky. Pro iteraci můžete použít dobře známé metody "
"<methodname>begin()</methodname> a <methodname>end()</methodname>, nějak "
"takto:"

#: C/gtkmm-tutorial-in.xml:2620(programlisting)
#, no-wrap
msgid ""
"typedef Gtk::TreeModel::Children type_children; //minimise code length.\n"
"type_children children = refModel-&gt;children();\n"
"for(type_children::iterator iter = children.begin();\n"
"    iter != children.end(); ++iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"  //Do something with the row - see above for set/get.\n"
"}"
msgstr ""
"typedef Gtk::TreeModel::Children type_children; // zmenší délku kódu\n"
"type_children children = refModel-&gt;children();\n"
"for(type_children::iterator iter = children.begin();\n"
"    iter != children.end(); ++iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"  // Udělat něco s řádkem - viz set/get výše\n"
"}"

#: C/gtkmm-tutorial-in.xml:2630(title)
msgid "Row children"
msgstr "Potomci řádku"

#: C/gtkmm-tutorial-in.xml:2635(programlisting)
#, no-wrap
msgid "Gtk::TreeModel::Children children = row.children();"
msgstr "Gtk::TreeModel::Children children = row.children();"

#: C/gtkmm-tutorial-in.xml:2631(para)
msgid ""
"When using a <classname>Gtk::TreeStore</classname>, the rows can have child "
"rows, which can have their own children in turn. Use <methodname>Gtk::"
"TreeModel::Row::children()</methodname> to get the container of child "
"<classname>Row</classname>s: <placeholder-1/>"
msgstr ""
"Když používáte <classname>Gtk::TreeStore</classname>, mohou mít řádky "
"potomky v podobě řádků a ty zase další potomky a tak dál. K přístupu do "
"kontejneru těchto synovských řádků <classname>Row</classname> použijte "
"<methodname>Gtk::TreeModel::Row::children()</methodname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:2642(title)
msgid "The Selection"
msgstr "Výběr"

#: C/gtkmm-tutorial-in.xml:2643(para)
msgid ""
"To find out what rows the user has selected, get the <classname>Gtk::"
"TreeView::Selection</classname> object from the <classname>TreeView</"
"classname>, like so:"
msgstr ""
"Když potřebujete vědět, které řádky uživatel označil, získejte z "
"<classname>TreeView</classname> objekt <classname>Gtk::TreeView::Selection</"
"classname>, takto:"

#: C/gtkmm-tutorial-in.xml:2648(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"    m_TreeView.get_selection();"
msgstr ""
"Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"    m_TreeView.get_selection();"

#: C/gtkmm-tutorial-in.xml:2652(title)
msgid "Single or multiple selection"
msgstr "Jednoduchý nebo vícenásobný výběr"

#: C/gtkmm-tutorial-in.xml:2656(programlisting)
#, no-wrap
msgid "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"
msgstr "refTreeSelection-&gt;set_mode(Gtk::SELECTION_MULTIPLE);"

#: C/gtkmm-tutorial-in.xml:2653(para)
msgid ""
"By default, only single rows can be selected, but you can allow multiple "
"selection by setting the mode, like so: <placeholder-1/>"
msgstr ""
"Standardně lze označit jen jeden řádek, ale můžete povolit i označení více "
"řádků nastavením příslušného režimu: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:2661(title)
msgid "The selected rows"
msgstr "Vybrané řádky"

#: C/gtkmm-tutorial-in.xml:2662(para)
msgid ""
"For single-selection, you can just call <methodname>get_selected()</"
"methodname>, like so:"
msgstr ""
"Pro označení jednoho řádku stačí zavolat <methodname>get_selected()</"
"methodname>, takto:"

#: C/gtkmm-tutorial-in.xml:2666(programlisting)
#, no-wrap
msgid ""
"TreeModel::iterator iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) //If anything is selected\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""
"TreeModel::iterator iter = refTreeSelection-&gt;get_selected();\n"
"if(iter) // Když je něco vybráno\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  // udělat něco s řádkem\n"
"}"

#: C/gtkmm-tutorial-in.xml:2673(para)
msgid ""
"For multiple-selection, you need to define a callback, and give it to "
"<methodname>selected_foreach()</methodname>, "
"<methodname>selected_foreach_path()</methodname>, or "
"<methodname>selected_foreach_iter()</methodname>, like so:"
msgstr ""
"Pro vícenásobné označování musíte definovat zpětné volání a předat jej do "
"<methodname>selected_foreach()</methodname>, "
"<methodname>selected_foreach_path()</methodname> nebo "
"<methodname>selected_foreach_iter()</methodname>, zhruba takto:"

#: C/gtkmm-tutorial-in.xml:2679(programlisting)
#, no-wrap
msgid ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::iterator&amp; iter)\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  //Do something with the row.\n"
"}"
msgstr ""
"refTreeSelection-&gt;selected_foreach_iter(\n"
"    sigc::mem_fun(*this, &amp;TheClass::selected_row_callback) );\n"
"\n"
"void TheClass::selected_row_callback(\n"
"    const Gtk::TreeModel::iterator&amp; iter)\n"
"{\n"
"  TreeModel::Row row = *iter;\n"
"  // Udělat něco s řádkem\n"
"}"

#: C/gtkmm-tutorial-in.xml:2692(title)
msgid "The \"changed\" signal"
msgstr "Signál \"changed\""

#: C/gtkmm-tutorial-in.xml:2693(para)
msgid ""
"To respond to the user clicking on a row or range of rows, connect to the "
"signal like so:"
msgstr ""
"Když chcete reagovat na uživatelovo kliknutí na řádek nebo rozsah řádků, "
"připojte nějak takto signál:"

#: C/gtkmm-tutorial-in.xml:2697(programlisting)
#, no-wrap
msgid ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)\n"
");"
msgstr ""
"refTreeSelection-&gt;signal_changed().connect(\n"
"    sigc::mem_fun(*this, &amp;Example_IconTheme::on_selection_changed)\n"
");"

#: C/gtkmm-tutorial-in.xml:2703(title)
msgid "Preventing row selection"
msgstr "Jak zabárnit výběru řádku"

#: C/gtkmm-tutorial-in.xml:2704(para)
msgid ""
"Maybe the user should not be able to select every item in your list or tree. "
"For instance, in the gtk-demo, you can select a demo to see the source code, "
"but it doesn't make any sense to select a demo category."
msgstr ""
"Někdy může být zapotřebí, aby uživatel nemohl vybrat všechny položky v "
"seznamu nebo stromu. Například v gtk-demo může vybírat jednotlivé ukázky, "
"aby si prohlédl zdrojový kód, ale na výběr nereagují kategorie ukázek."

#: C/gtkmm-tutorial-in.xml:2709(para)
msgid ""
"To control which rows can be selected, use the "
"<methodname>set_select_function()</methodname> method, providing a "
"<classname>sigc::slot</classname> callback. For instance:"
msgstr ""
"K řízení, které řádky mohou být vybrány, použijte metodu "
"<methodname>set_select_function()</methodname> poskytující zpětné volání "
"<classname>sigc::slot</classname>. Například:"

#: C/gtkmm-tutorial-in.xml:2714(programlisting)
#, no-wrap
msgid ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"
msgstr ""
"m_refTreeSelection-&gt;set_select_function( sigc::mem_fun(*this,\n"
"    &amp;DemoWindow::select_function) );"

#: C/gtkmm-tutorial-in.xml:2716(para)
msgid "and then"
msgstr "a pak"

#: C/gtkmm-tutorial-in.xml:2719(programlisting)
#, no-wrap
msgid ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"
msgstr ""
"bool DemoWindow::select_function(\n"
"    const Glib::RefPtr&lt;Gtk::TreeModel&gt;&amp; model,\n"
"    const Gtk::TreeModel::Path&amp; path, bool)\n"
"{\n"
"  const Gtk::TreeModel::iterator iter = model-&gt;get_iter(path);\n"
"  return iter-&gt;children().empty(); // only allow leaf nodes to be selected\n"
"}"

#: C/gtkmm-tutorial-in.xml:2729(title)
msgid "Changing the selection"
msgstr "Změna výběru"

#: C/gtkmm-tutorial-in.xml:2730(para)
msgid ""
"To change the selection, specify a <classname>Gtk::TreeModel::iterator</"
"classname> or <classname>Gtk::TreeModel::Row</classname>, like so:"
msgstr ""
"Pro změnu výběru určete <classname>Gtk::TreeModel::iterator</classname> nebo "
"<classname>Gtk::TreeModel::Row</classname>, takto:"

#: C/gtkmm-tutorial-in.xml:2735(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row);"
msgstr ""
"Gtk::TreeModel::Row row = m_refModel-&gt;children()[5]; //The fifth row.\n"
"if(row)\n"
"  refTreeSelection-&gt;select(row);"

#: C/gtkmm-tutorial-in.xml:2738(para)
msgid "or"
msgstr "nebo"

#: C/gtkmm-tutorial-in.xml:2741(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"
msgstr ""
"Gtk::TreeModel::iterator iter = m_refModel-&gt;children().begin()\n"
"if(iter)\n"
"  refTreeSelection-&gt;select(iter);"

#: C/gtkmm-tutorial-in.xml:2750(title)
msgid "Sorting"
msgstr "Řazení"

#: C/gtkmm-tutorial-in.xml:2751(para)
msgid ""
"The standard tree models (<classname>TreeStore</classname> and "
"<classname>ListStore</classname>) derive from <classname>TreeSortable</"
"classname>, so they offer sorting functionality. For instance, call "
"<methodname>set_sort_column()</methodname>, to sort the model by the "
"specified column. Or supply a callback function to "
"<methodname>set_sort_func()</methodname> to implement a more complicated "
"sorting algorithm."
msgstr ""
"Standardní stromové modely (<classname>TreeStore</classname> a "
"<classname>ListStore</classname>) jsou odvozené z <classname>TreeSortable</"
"classname>, takže nabízejí funkci řazení. Například zavoláním "
"<methodname>set_sort_column()</methodname> seřadíte model podle určeného "
"sloupce. Nebo, když chcete složitější algoritmus řazení, poskytněte funkci "
"zpětného volání do <methodname>set_sort_func()</methodname>."

#: C/gtkmm-tutorial-in.xml:2755(ulink)
msgid "TreeSortable Reference"
msgstr "Referenční příručka k TreeSortable"

#: C/gtkmm-tutorial-in.xml:2758(title)
msgid "Sorting by clicking on columns"
msgstr "Řazení klikáním na sloupce"

#: C/gtkmm-tutorial-in.xml:2759(para)
msgid ""
"So that a user can click on a <classname>TreeView</classname>'s column "
"header to sort the <classname>TreeView</classname>'s contents, call "
"<methodname>Gtk::TreeView::Column::set_sort_column()</methodname>, supplying "
"the model column on which model should be sorted when the header is clicked. "
"For instance:"
msgstr ""
"Aby uživatel mohl kliknutím na záhlaví sloupce v <classname>TreeView</"
"classname> seřadit obsah <classname>TreeView</classname>, je potřeba zavolat "
"metodu <methodname>Gtk::TreeView::Column::set_sort_column()</methodname>, "
"které předáte sloupec modelu, na jehož modelu se má řadit, když uživatel na "
"záhlaví klikne. Například:"

#: C/gtkmm-tutorial-in.xml:2762(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeView::Column* pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"
msgstr ""
"Gtk::TreeView::Column* pColumn = treeview.get_column(0);\n"
"if(pColumn)\n"
"  pColumn-&gt;set_sort_column(m_columns.m_col_id);"

#: C/gtkmm-tutorial-in.xml:2768(title)
msgid "Independently sorted views of the same model"
msgstr "Nezávisle řazená zobrazení téhož modelu"

#: C/gtkmm-tutorial-in.xml:2769(para)
msgid ""
"The <classname>TreeView</classname> already allows you to show the same "
"<classname>TreeModel</classname> in two <classname>TreeView</classname> "
"widgets. If you need one of these TreeViews to sort the model differently "
"than the other then you should use a <classname>TreeModelSort</classname> "
"instead of just, for instance, <methodname>Gtk::TreeViewModel::"
"set_sort_column()</methodname>. <classname>TreeModelSort</classname> is a "
"model that contains another model, presenting a sorted version of that "
"model. For instance, you might add a sorted version of a model to a "
"<classname>TreeView</classname> like so:"
msgstr ""
"<classname>TreeView</classname> již umožňuje zobrazit ten samý "
"<classname>TreeModel</classname> ve dvou widgetech <classname>TreeView</"
"classname>. Jestliže potřebujete, aby jeden z nich řadil model jiným "
"způsobem, než ten druhý, měli byste místo toho použít "
"<classname>TreeModelSort</classname>, například <methodname>Gtk::"
"TreeViewModel::set_sort_column()</methodname>. <classname>TreeModelSort</"
"classname> je model, který obsahuje jiný model a podává jeho seřazenou "
"verzi. Například můžete přidat řazenou verzi modelu do <classname>TreeView</"
"classname> takto:"

#: C/gtkmm-tutorial-in.xml:2772(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TreeModelSort&gt; sorted_model =\n"
"    Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TreeModelSort&gt; sorted_model =\n"
"    Gtk::TreeModelSort::create(model);\n"
"sorted_model-&gt;set_sort_column(columns.m_col_name, Gtk::SORT_ASCENDING);\n"
"treeview.set_model(sorted_model);"

#: C/gtkmm-tutorial-in.xml:2777(para)
msgid ""
"Note, however, that the TreeView will provide iterators to the sorted model. "
"You must convert them to iterators to the underlying child model in order to "
"perform actions on that model. For instance:"
msgstr ""
"Všimněte si, že <classname>TreeView</classname> bude poskytovat iterátory "
"řazenému modelu. Abyste mohli provádět akce na daném modelu, musíte je "
"převést na iterátory do podkladového podřízeného modelu. Například:"

#: C/gtkmm-tutorial-in.xml:2779(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"      m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    Gtk::TreeModel::iterator sorted_iter =\n"
"        m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      Gtk::TreeModel::iterator iter =\n"
"          m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"
msgstr ""
"void ExampleWindow::on_button_delete()\n"
"{\n"
"  Glib::RefPtr&lt;Gtk::TreeSelection&gt; refTreeSelection =\n"
"      m_treeview.get_selection();\n"
"  if(refTreeSelection)\n"
"  {\n"
"    Gtk::TreeModel::iterator sorted_iter =\n"
"        m_refTreeSelection-&gt;get_selected();\n"
"    if(sorted_iter)\n"
"    {\n"
"      Gtk::TreeModel::iterator iter =\n"
"          m_refModelSort-&gt;convert_iter_to_child_iter(sorted_iter);\n"
"      m_refModel-&gt;erase(iter);\n"
"    }\n"
"  }\n"
"}"

#: C/gtkmm-tutorial-in.xml:2796(ulink)
msgid "TreeModelSort Reference"
msgstr "Referenční příručka k TreeModelSort"

#: C/gtkmm-tutorial-in.xml:2802(title) C/gtkmm-tutorial-in.xml:2909(title)
#: C/gtkmm-tutorial-in.xml:3576(title) C/gtkmm-tutorial-in.xml:4616(title)
#: C/gtkmm-tutorial-in.xml:4780(title)
msgid "Drag and Drop"
msgstr "Táhni a upusť"

#: C/gtkmm-tutorial-in.xml:2803(para)
msgid ""
"<classname>Gtk::TreeView</classname> already implements simple drag-and-drop "
"when used with the <classname>Gtk::ListStore</classname> or <classname>Gtk::"
"TreeStore</classname> models. If necessary, it also allows you to implement "
"more complex behaviour when items are dragged and dropped, using the normal "
"<link linkend=\"chapter-draganddrop\">Drag and Drop</link> API."
msgstr ""
"Pokud <classname>Gtk::TreeView</classname> použijete s modelem "
"<classname>Gtk::ListStore</classname> nebo <classname>Gtk::TreeStore</"
"classname>, bude již sám o sobě umět jednoduché „táhni a upusť“. Jestliže je "
"to nezbytné, umožňuje také implementaci složitějšího chování při přetahování "
"položek pomocí API <link linkend=\"chapter-draganddrop\">Táhni a upusť</"
"link>."

#: C/gtkmm-tutorial-in.xml:2812(title)
msgid "Reorderable rows"
msgstr "Seřaditelné řádky"

#: C/gtkmm-tutorial-in.xml:2813(para)
msgid ""
"If you call <methodname>Gtk::TreeView::set_reorderable()</methodname> then "
"your TreeView's items can be moved within the treeview itself. This is "
"demonstrated in the <classname>TreeStore</classname> example."
msgstr ""
"Když zavoláte <methodname>Gtk::TreeView::set_reorderable()</methodname>, "
"bude možné přesouvat položky v rámci stromového zobrazení. Ukázáno je to v "
"příkladu <classname>TreeStore</classname>."

#: C/gtkmm-tutorial-in.xml:2818(para)
msgid ""
"However, this does not allow you any control of which items can be dragged, "
"and where they can be dropped. If you need that extra control then you might "
"create a derived <literal>Gtk::TreeModel</literal> from <literal>Gtk::"
"TreeStore</literal> or <literal>Gtk::ListStore</literal> and override the "
"<literal>Gtk::TreeDragSource::row_draggable()</literal> and <literal>Gdk::"
"TreeDragDest::row_drop_possible()</literal> virtual methods. You can examine "
"the <literal>Gtk::TreeModel::Path</literal>s provided and allow or disallow "
"dragging or dropping by returning <literal>true</literal> or <literal>false</"
"literal>."
msgstr ""
"Neumožňuje to ale řídit, které položky lze přetáhnout a kam je lze upustit. "
"Pokud potřebujete širší možnosti ovládání, můžete vytvořit odvozený "
"<literal>Gtk::TreeModel</literal> z <literal>Gtk::TreeStore</literal> nebo "
"<literal>Gtk::ListStore</literal> a přepsat virtuální metody <literal>Gtk::"
"TreeDragSource::row_draggable()</literal> a <literal>Gdk::TreeDragDest::"
"row_drop_possible()</literal>. Můžete si prohlédnout poskytovanou cestu "
"<literal>Gtk::TreeModel::Path</literal> a podle ní povolit nebo zakázat "
"přetažení nebo upuštění tím, že vrátíte <literal>true</literal> nebo "
"<literal>false</literal>."

#: C/gtkmm-tutorial-in.xml:2819(para)
msgid "This is demonstrated in the drag_and_drop example."
msgstr "Ukázané to je v příkladu drag_and_drop."

#: C/gtkmm-tutorial-in.xml:2825(title) C/gtkmm-tutorial-in.xml:2931(title)
msgid "Popup Context Menu"
msgstr "Vyskakovací kontextová nabídka"

#: C/gtkmm-tutorial-in.xml:2826(para)
msgid ""
"Lots of people need to implement right-click context menus for "
"<classname>TreeView</classname>'s so we will explain how to do that here to "
"save you some time. Apart from one or two points, it's much the same as a "
"normal context menu, as described in the <link linkend=\"sec-menus-popup"
"\">menus chapter</link>."
msgstr ""
"Spousta lidí potřebuje pro <classname>TreeView</classname> implementovat "
"kontextovou nabídku pod pravé kliknutí, takže abychom vám ušetřili čas, "
"vysvětlíme vám, jak na to. Krom jedné dvou věcí je to stejné, jako normální "
"kontextová nabídka popsaná v <link linkend=\"sec-menus-popup\">kapitole o "
"nabídkách</link>."

#: C/gtkmm-tutorial-in.xml:2835(title)
msgid "Handling <literal>button_press_event</literal>"
msgstr "Obsluha <literal>button_press_event</literal>"

#: C/gtkmm-tutorial-in.xml:2836(para)
msgid ""
"To detect a click of the right mouse button, you need to handle the "
"<literal>button_press_event</literal> signal, and check exactly which button "
"was pressed. Because the <classname>TreeView</classname> normally handles "
"this signal completely, you need to either override the default signal "
"handler in a derived <classname>TreeView</classname> class, or use "
"<methodname>connect_notify()</methodname> instead of <methodname>connect()</"
"methodname>. You probably also want to call the default handler before doing "
"anything else, so that the right-click will cause the row to be selected "
"first."
msgstr ""
"Abyste mohli detekovat kliknutí pravým tlačítkem myši, potřebujete "
"obsluhovat signál <literal>button_press_event</literal> a kontrolovat, které "
"přesně tlačítko bylo zmáčknuto. Protože <classname>TreeView</classname> "
"normálně tento signál obsluhuje zcela sám, musíte buď přepsat výchozí "
"obsluhu signálu v odvozené třídě <classname>TreeView</classname>, nebo "
"použít místo metody <methodname>connect()</methodname> metodu "
"<methodname>connect_notify()</methodname>. Než provedete cokoliv dalšího, "
"bude nejspíše chtít zavolat výchozí obsluhu, takže kliknutí pravým tlačítkem "
"způsobí nejprve vybrání řádku."

#: C/gtkmm-tutorial-in.xml:2846(para)
msgid "This is demonstrated in the Popup Context Menu example."
msgstr "Ukázáné je to v příkladu s vyskakovací kontextovou nabídkou."

#: C/gtkmm-tutorial-in.xml:2851(title) C/gtkmm-tutorial-in.xml:3339(title)
#: C/gtkmm-tutorial-in.xml:3512(title) C/gtkmm-tutorial-in.xml:4935(title)
msgid "Examples"
msgstr "Příklady"

#: C/gtkmm-tutorial-in.xml:2853(title)
msgid "ListStore"
msgstr "ListStore"

#: C/gtkmm-tutorial-in.xml:2854(para)
msgid ""
"This example has a <classname>Gtk::TreeView</classname> widget, with a "
"<classname>Gtk::ListStore</classname> model."
msgstr ""
"Tento příklad obsahuje widget <classname>Gtk::TreeView</classname> s modelem "
"<classname>Gtk::ListStore</classname>."

#: C/gtkmm-tutorial-in.xml:2871(title)
msgid "TreeStore"
msgstr "TreeStore"

#: C/gtkmm-tutorial-in.xml:2873(para)
msgid ""
"This example is very similar to the <classname>ListStore</classname> "
"example, but uses a <classname>Gtk::TreeStore</classname> model instead, and "
"adds children to the rows."
msgstr ""
"Tento příklad je velmi podobný příkladu s <classname>ListStore</classname>, "
"ale místo něj používá <classname>Gtk::TreeStore</classname> a přidává "
"potomky do řádků."

#: C/gtkmm-tutorial-in.xml:2892(para)
msgid ""
"This example is identical to the <classname>ListStore</classname> example, "
"but it uses <methodname>TreeView::append_column_editable()</methodname> "
"instead of <methodname>TreeView::append_column()</methodname>."
msgstr ""
"Tento příklad je stejný jako příklad s <classname>ListStore</classname>, ale "
"používá <methodname>TreeView::append_column_editable()</methodname> místo "
"<methodname>TreeView::append_column()</methodname>."

#: C/gtkmm-tutorial-in.xml:2899(title)
msgid "TreeView - Editable Cells"
msgstr "TreeView – editovatelné buňky"

#: C/gtkmm-tutorial-in.xml:2911(para)
msgid ""
"This example is much like the <classname>TreeStore</classname> example, but "
"has 2 extra columns to indicate whether the row can be dragged, and whether "
"it can receive drag-and-dropped rows. It uses a derived <classname>Gtk::"
"TreeStore</classname> which overrides the virtual functions as described in "
"the <link linkend=\"sec-treeview-draganddrop\">TreeView Drag and Drop</link> "
"section."
msgstr ""
"Tento příklad je hodně podobný příkladu pro <classname>TreeStore</"
"classname>, ale má navíc dva sloupce, které ukazují, jestli se dá řádek "
"přesunout a jestli může řádek přijmout jiný přetahovaný řádek. Příklad "
"používá <classname>Gtk::TreeStore</classname>, ve které přepisuje virtuální "
"funkce, jak bylo ukázáno v kapitole <link linkend=\"sec-treeview-draganddrop"
"\">Táhni a upusť ve stromovém zobrazení</link>."

#: C/gtkmm-tutorial-in.xml:2921(title)
msgid "TreeView - Drag And Drop"
msgstr "TreeView – táhni a upusť"

#: C/gtkmm-tutorial-in.xml:2933(para)
msgid ""
"This example is much like the <classname>ListStore</classname> example, but "
"derives a custom <classname>TreeView</classname> in order to override the "
"<literal>button_press_event</literal>, and also to encapsulate the tree "
"model code in our derived class. See the <link linkend=\"sec-treeview-"
"contextmenu\">TreeView Popup Context Menu</link> section."
msgstr ""
"Tento příklad se velmi podobá příkladu <classname>ListStore</classname>, "
"akorát odvozuje vlastní <classname>TreeView</classname>, aby se mohla "
"přepsat  <literal>button_press_event</literal> a zapouzdřit kód stromového "
"modelu do naší odvozené třídy. Viz kapitola <link linkend=\"sec-treeview-"
"contextmenu\">Vyskakovací kontextová nabídka v TreeView</link>."

#: C/gtkmm-tutorial-in.xml:2943(title)
msgid "TreeView - Popup Context Menu"
msgstr "TreeView – vyskakovací kontextová nabídka"

#: C/gtkmm-tutorial-in.xml:2960(title)
msgid "Combo Boxes"
msgstr "Rozbalovací seznamy (ComboBox)"

#: C/gtkmm-tutorial-in.xml:2962(para)
msgid ""
"The <classname>ComboBox</classname> widget offers a list (or tree) of "
"choices in a dropdown menu. If appropriate, it can show extra information "
"about each item, such as text, a picture, a checkbox, or a progress bar. The "
"<classname>ComboBox</classname> widget usually restricts the user to the "
"available choices, but it can optionally have an <classname>Entry</"
"classname>, allowing the user to enter arbitrary text if none of the "
"available choices are suitable."
msgstr ""
"Widget <classname>ComboBox</classname> poskytuje seznam (nebo strom) voleb v "
"rozbalovací nabídce. Je-li to vhodné, může u každé položky zobrazovat "
"doplňující informace, jako text, ikonu, zaškrtávací políčko nebo ukazatel "
"průběhu. Widget <classname>ComboBox</classname> obvykle omezuje uživatele v "
"dostupných volbách, ale může mít volitelně textové vstupní pole "
"<classname>Entry</classname>, do kterého může uživatel vložit libovolný "
"text, když se mu nehodí žádná z dostupných voleb."

#: C/gtkmm-tutorial-in.xml:2965(para)
msgid ""
"The list is provided via a <classname>TreeModel</classname>, and columns "
"from this model are added to the ComboBox's view with the "
"<methodname>ComboBox::pack_start()</methodname> method. This provides "
"flexibility and compile-time type-safety, but the <classname>ComboBoxText</"
"classname> class provides a simpler text-based specialization in case that "
"flexibility is not required."
msgstr ""
"Seznam je poskytován přes objekt <classname>TreeModel</classname> a sloupce "
"tohoto modelu se přidávají do objektu <classname>ComboBox</classname>, který "
"provádí zobrazení, pomocí metody <methodname>ComboBox::pack_start()</"
"methodname>. Poskytuje to pružnost a typovou bezpečnost při kompilaci. Pokud "
"ale tyto vymoženosti nejsou zrovna zapotřebí, je k dispozici zjednodušená "
"třída <classname>ComboBoxText</classname> specializovaná čistě na textové "
"položky."

#: C/gtkmm-tutorial-in.xml:2971(title)
msgid "The model"
msgstr "Model"

#: C/gtkmm-tutorial-in.xml:2972(para)
msgid ""
"The model for a ComboBox can be defined and filled exactly as for a "
"<classname>TreeView</classname>. For instance, you might derive a ComboBox "
"class with one integer and one text column, like so:"
msgstr ""
"Model pro <classname>ComboBox</classname> se dá definovat a vyplnit úplně "
"stejně, jako pro <classname>TreeView</classname>. Například můžete odvodit "
"třídu <classname>ComboBox</classname> s jedním celočíselným a jedním "
"textovým sloupce, nějak takto:"

#: C/gtkmm-tutorial-in.xml:2974(programlisting)
#, no-wrap
msgid ""
"ModelColumns()\n"
"{ add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"
msgstr ""
"ModelColumns()\n"
"{ add(m_col_id); add(m_col_name); }\n"
"\n"
"  Gtk::TreeModelColumn&lt;int&gt; m_col_id;\n"
"  Gtk::TreeModelColumn&lt;Glib::ustring&gt; m_col_name;\n"
"};\n"
"\n"
"ModelColumns m_columns;"

#: C/gtkmm-tutorial-in.xml:2983(para)
msgid ""
"After appending rows to this model, you should provide the model to the "
"<classname>ComboBox</classname> with the <methodname>set_model()</"
"methodname> method. Then use the <methodname>pack_start()</methodname> or "
"<methodname>pack_end()</methodname> methods to specify what columns will be "
"displayed in the ComboBox. As with the TreeView you may either use the "
"default cell renderer by passing the <classname>TreeModelColumn</classname> "
"to the pack methods, or you may instantiate a specific "
"<classname>CellRenderer</classname> and specify a particular mapping with "
"either <methodname>add_attribute()</methodname> or "
"<methodname>set_cell_data_func()</methodname>. Note that these methods are "
"in the <classname>CellLayout</classname> base class."
msgstr ""
"Po přidání řádků do tohoto modelu byste jej měli pomocí metody "
"<methodname>set_model()</methodname> předat do objektu <classname>ComboBox</"
"classname>. Pak použijte metodu <methodname>pack_start()</methodname> nebo "
"<methodname>pack_end()</methodname> k určení, které sloupce se budou v "
"rozbalovacím seznamu zobrazovat. Stejně jako u <classname>TreeView</"
"classname>, můžete buď nastavit výchozí vykreslování buněk předáním "
"<classname>TreeModelColumn</classname> do balicí metody, nebo můžete "
"vytvořit instanci konkrétní třídy <classname>CellRenderer</classname> a "
"určit konkrétní mapování buď pomocí <methodname>add_attribute()</methodname> "
"nebo <methodname>set_cell_data_func()</methodname>. Tyto metody pochází ze "
"základní třídy <classname>CellLayout</classname>."

#: C/gtkmm-tutorial-in.xml:2987(title)
msgid "The chosen item"
msgstr "Vybraná položka"

#: C/gtkmm-tutorial-in.xml:2988(para)
msgid ""
"To discover what item, if any, the user has chosen from the ComboBox, call "
"<methodname>ComboBox::get_active()</methodname>. This returns a "
"<classname>TreeModel::iterator</classname> that you can dereference to a "
"<classname>Row</classname> in order to read the values in your columns. For "
"instance, you might read an integer ID value from the model, even though you "
"have chosen only to show the human-readable description in the ComboBox. For "
"instance:"
msgstr ""
"Chcete-li zjistit, kterou položku uživatel v rozbalovacím seznamu zvolil, "
"pokud vůbec nějakou, zavolejte metodu <methodname>ComboBox::get_active()</"
"methodname>. Ta vrací <classname>TreeModel::iterator</classname>, který "
"můžete použít jako zpětný odkaz na objekt <classname>Row</classname>, abyste "
"mohli číst hodnoty ve vašich sloupcích. Třeba můžete číst celočíselnou "
"hodnotu ID z modelu, zatímco uživateli jste v rozbalovacím seznamu zobrazili "
"pouze pro člověka čitelný textový popis. Například:"

#: C/gtkmm-tutorial-in.xml:2990(programlisting)
#, no-wrap
msgid ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"\n"
"  //Get the data for the selected row, using our knowledge\n"
"  //of the tree model:\n"
"  int id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); //Your own function.\n"
"}\n"
"else\n"
"  set_nothing_chosen(); //Your own function."
msgstr ""
"Gtk::TreeModel::iterator iter = m_Combo.get_active();\n"
"if(iter)\n"
"{\n"
"  Gtk::TreeModel::Row row = *iter;\n"
"\n"
"  // Získáme data pro vybraný řádek s pomocí naší znalosti\n"
"  // stromového modelu:\n"
"  int id = row[m_Columns.m_col_id];\n"
"  set_something_id_chosen(id); // Vaše vlastní funkce\n"
"}\n"
"else\n"
"  set_nothing_chosen(); // Vaše vlastní funkce"

#: C/gtkmm-tutorial-in.xml:3005(title) C/gtkmm-tutorial-in.xml:3061(title)
msgid "Responding to changes"
msgstr "Reagování na změny"

#: C/gtkmm-tutorial-in.xml:3006(para)
msgid ""
"You might need to react to every change of selection in the ComboBox, for "
"instance to update other widgets. To do so, you should handle the "
"<literal>changed</literal> signal. For instance:"
msgstr ""
"Můžete chtít reagovat na všechny změny výběru v rozbalovacím seznamu, "
"například kvůli aktualizaci ostatních widgetů. K tomu byste měli obsluhovat "
"signál <literal>changed</literal>. Například:"

#: C/gtkmm-tutorial-in.xml:3009(programlisting)
#, no-wrap
msgid ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"
msgstr ""
"m_combo.signal_changed().connect( sigc::mem_fun(*this,\n"
"      &amp;ExampleWindow::on_combo_changed) );"

#: C/gtkmm-tutorial-in.xml:3013(title) C/gtkmm-tutorial-in.xml:3097(title)
msgid "Full Example"
msgstr "Úplný příklad"

#: C/gtkmm-tutorial-in.xml:3016(title)
msgid "ComboBox"
msgstr "ComboBox"

#: C/gtkmm-tutorial-in.xml:3026(title) C/gtkmm-tutorial-in.xml:3110(title)
msgid "Simple Text Example"
msgstr "Jednoduchý textový příklad"

#: C/gtkmm-tutorial-in.xml:3029(title)
msgid "ComboBoxText"
msgstr "Kombinované vstupní pole (ComboBoxText)"

#: C/gtkmm-tutorial-in.xml:3040(title)
msgid "ComboBox with an Entry"
msgstr "ComboBox se vstupním polem"

#: C/gtkmm-tutorial-in.xml:3042(para)
msgid ""
"A <classname>ComboBox</classname> may contain an <classname>Entry</"
"classname> widget for entering of arbitrary text, by specifying "
"<literal>true</literal> for the constructor's <literal>has_entry</literal> "
"parameter."
msgstr ""
"<classname>ComboBox</classname> může obsahovat widget <classname>Entry</"
"classname> pro zadávání libovolného textu. Stačí zadat <literal>true</"
"literal> do parametru <literal>has_entry</literal> v konstruktoru."

#: C/gtkmm-tutorial-in.xml:3045(title)
msgid "The text column"
msgstr "Textový sloupec"

#: C/gtkmm-tutorial-in.xml:3047(programlisting)
#, no-wrap
msgid "m_combo.set_entry_text_column(m_columns.m_col_name);"
msgstr "m_combo.set_entry_text_column(m_columns.m_col_name);"

#: C/gtkmm-tutorial-in.xml:3046(para)
msgid ""
"So that the <classname>Entry</classname> can interact with the drop-down "
"list of choices, you must specify which of your model columns is the text "
"column, with <methodname>set_entry_text_column()</methodname>. For instance: "
"<placeholder-1/>"
msgstr ""
"Aby vstupní pole <classname>Entry</classname> mohlo spolupracovat s "
"rozbalovacím seznamem voleb, musíte určit, který z vašich sloupců v modelu "
"je textový, pomocí  <methodname>set_entry_text_column()</methodname>. "
"Například: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:3049(para)
msgid ""
"When you select a choice from the drop-down menu, the value from this column "
"will be placed in the <classname>Entry</classname>."
msgstr ""
"Když vyberete položku z robalovací nabídky, umístí se hodnota z tohoto "
"sloupce do <classname>Entry</classname>."

#: C/gtkmm-tutorial-in.xml:3055(title)
msgid "The entry"
msgstr "Vstupní pole"

#: C/gtkmm-tutorial-in.xml:3056(para)
msgid ""
"Because the user may enter arbitrary text, an active model row isn't enough "
"to tell us what text the user has entered. Therefore, you should retrieve "
"the <classname>Entry</classname> widget with the <methodname>ComboBox::"
"get_entry()</methodname> method and call <methodname>get_text()</methodname> "
"on that."
msgstr ""
"Protože uživatel může zadat libovolný text, aktivní model řádku není "
"dostačující, abychom zjistili, jaký text uživatel zadal. Proto byste měli za "
"tímto účelem získat widget <classname>Entry</classname> pomocí metody "
"<methodname>ComboBox::get_entry()</methodname> a zavolat "
"<methodname>get_text()</methodname>."

#: C/gtkmm-tutorial-in.xml:3070(programlisting)
#, no-wrap
msgid ""
"Gtk::Entry* entry = m_Combo.get_entry();\n"
"if (entry)\n"
"{\n"
"  // The Entry shall receive focus-out events.\n"
"  entry-&gt;add_events(Gdk::FOCUS_CHANGE_MASK);\n"
"\n"
"  // Alternatively you can connect to m_Combo.signal_changed().\n"
"  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_changed) );\n"
"\n"
"  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_activate) );\n"
"\n"
"  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_focus_out_event) );\n"
"}"
msgstr ""
"Gtk::Entry* entry = m_Combo.get_entry();\n"
"if (entry)\n"
"{\n"
"  // Entry by měl přijmout událost focus-out.\n"
"  entry-&gt;add_events(Gdk::FOCUS_CHANGE_MASK);\n"
"\n"
"  // Případně se můžete napojit k m_Combo.signal_changed().\n"
"  entry-&gt;signal_changed().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_changed) );\n"
"\n"
"  entry-&gt;signal_activate().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_activate) );\n"
"\n"
"  entry-&gt;signal_focus_out_event().connect(sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_entry_focus_out_event) );\n"
"}"

#: C/gtkmm-tutorial-in.xml:3062(para)
msgid ""
"When the user enters arbitrary text, it may not be enough to connect to the "
"<literal>changed</literal> signal, which is emitted for every typed "
"character. It is not emitted when the user presses the Enter key. Pressing "
"the Enter key or moving the keyboard focus to another widget may signal that "
"the user has finished entering text. To be notified of these events, connect "
"to the <classname>Entry</classname>'s <literal>activate</literal> and "
"<literal>focus_out_event</literal> signals, like so <placeholder-1/> The "
"<literal>changed</literal> signals of <classname>ComboBox</classname> and "
"<classname>Entry</classname> are both emitted for every change. It doesn't "
"matter which one you connect to. But only <classname>Entry</classname>'s "
"<literal>focus_out_event</literal> signal is useful here."
msgstr ""
"Když uživatel zadává libovolný text, nemusí být dostačující napojit se na "
"signál <literal>changed</literal>, který se vysílá po napsání každého znaku. "
"Nevyšle se totiž při zmáčknutí klávesy <keycap>Enter</keycap> uživatelem. "
"Zmáčknutí klávesy <keycap>Enter</keycap> nebo přesun zaměření na jiný widget "
"může znamenat, že uživatel dokončil zadávání textu. Abyste byli o této "
"události informováni, napojte se takto na signály <classname>activate</"
"classname> a <literal>focus_out_event</literal> z třídy <literal>Entry</"
"literal> <placeholder-1/> Signály <literal>changed</literal> třídy "
"<classname>ComboBox</classname> i <classname>Entry</classname> jsou vysílány "
"při každé změně. Je tak jedno, na který z nich se napojíte. Ale signál "
"<literal>focus_out_event</literal> je zde použitelný pouze z třídy "
"<classname>Entry</classname>."

#: C/gtkmm-tutorial-in.xml:3091(para)
msgid ""
"X events are described in more detail in the <link linkend=\"sec-"
"xeventsignals\">X Event signals</link> section in the appendix."
msgstr ""
"Události X jsou podrobněji popsané v dodatku v oddílu <link linkend=\"sec-"
"xeventsignals\">Signály událostí X</link>."

#: C/gtkmm-tutorial-in.xml:3100(title)
msgid "ComboBox with Entry"
msgstr "Rozbalovací seznam (ComboBox) se vstupním polem (Entry)"

#: C/gtkmm-tutorial-in.xml:3113(title)
msgid "ComboBoxText with Entry"
msgstr "Textový rozbalovací seznam (ComboBoxText) se vstupním polem (Entry)"

#: C/gtkmm-tutorial-in.xml:3132(title) C/gtkmm-tutorial-in.xml:3344(title)
msgid "TextView"
msgstr "Zobrazení textu (TextView)"

#: C/gtkmm-tutorial-in.xml:3133(para)
msgid ""
"The <classname>TextView</classname> widget can be used to display and edit "
"large amounts of formatted text. Like the <classname>TreeView</classname>, "
"it has a model/view design. In this case the <classname>TextBuffer</"
"classname> is the model."
msgstr ""
"Widget <classname>TextView</classname> se dá použít k zobrazení a úpravám "
"velkého množství formátovaného textu. Podobně jako <classname>TreeView</"
"classname>, má design model/zobrazení. Modelem je v tomto případě "
"<classname>TextBuffer</classname>."

#: C/gtkmm-tutorial-in.xml:3141(title)
msgid "The Buffer"
msgstr "Vyrovnávací paměť"

#: C/gtkmm-tutorial-in.xml:3142(para)
msgid ""
"<classname>Gtk::TextBuffer</classname> is a model containing the data for "
"the <classname>Gtk::TextView</classname>, like the <classname>Gtk::"
"TreeModel</classname> used by <classname>Gtk::TreeView</classname>. This "
"allows two or more <classname>Gtk::TextView</classname>s to share the same "
"<classname>TextBuffer</classname>, and allows those TextBuffers to be "
"displayed slightly differently. Or you could maintain several "
"<classname>Gtk::TextBuffer</classname>s and choose to display each one at "
"different times in the same <classname>Gtk::TextView</classname> widget."
msgstr ""
"<classname>Gtk::TextBuffer</classname> je model obsahující data pro "
"<classname>Gtk::TextView</classname>, podobně jako je <classname>Gtk::"
"TreeModel</classname> používán <classname>Gtk::TreeView</classname>. To "
"umožňuje dvěma a více <classname>Gtk::TextView</classname> sdílet stejný "
"<classname>TextBuffer</classname> a při tom to umožňuje zobrazit textový "
"obsah vyrovnávací paměti trochu odlišně. Nebo byste mohli spravovat několik "
"objektů <classname>Gtk::TextBuffer</classname> a v různou dobu volit vždy "
"jeden z nich pro zobrazení ve widgetu <classname>Gtk::TextView</classname>."

#: C/gtkmm-tutorial-in.xml:3152(para)
msgid ""
"The <classname>TextView</classname> creates its own default "
"<classname>TextBuffer</classname>, which you can access via the "
"<methodname>get_buffer()</methodname> method."
msgstr ""
"<classname>TextView</classname> vytváří svůj vlastní výchozí "
"<classname>TextBuffer</classname>, ke kterému se můžete dostat přes metodu "
"<methodname>get_buffer()</methodname>."

#: C/gtkmm-tutorial-in.xml:3161(title)
msgid "Iterators"
msgstr "Iterátory"

#: C/gtkmm-tutorial-in.xml:3167(title)
msgid "Tags and Formatting"
msgstr "Formátovací značky a formátování"

#: C/gtkmm-tutorial-in.xml:3170(title)
msgid "Tags"
msgstr "Formátovací značky (Tag)"

#: C/gtkmm-tutorial-in.xml:3171(para)
msgid ""
"To specify that some text in the buffer should have specific formatting, you "
"must define a tag to hold that formatting information, and then apply that "
"tag to the region of text. For instance, to define the tag and its "
"properties:"
msgstr ""
"K určení, že nějaký text ve vyrovnávací paměti by měl být nějak "
"naformátován, musíte definovat formátovací značku, která si drží informaci o "
"formátování, a pak ji použít na část textu. Příklad definice formátovací "
"značky a jejích vlastností:"

#: C/gtkmm-tutorial-in.xml:3174(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch =\n"
"    Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Tag&gt; refTagMatch =\n"
"    Gtk::TextBuffer::Tag::create();\n"
"refTagMatch-&gt;property_background() = \"orange\";"

#: C/gtkmm-tutorial-in.xml:3177(para)
msgid ""
"You can specify a name for the <classname>Tag</classname> when using the "
"<methodname>create()</methodname> method, but it is not necessary."
msgstr ""
"Při použití metody <methodname>create()</methodname> můžete určit pro objekt "
"<classname>Tag</classname> název, ale není to nutné."

#: C/gtkmm-tutorial-in.xml:3182(para)
msgid "The <classname>Tag</classname> class has many other properties."
msgstr "Třída <classname>Tag</classname> má mnoho dalších vlastností."

#: C/gtkmm-tutorial-in.xml:3191(title)
msgid "TagTable"
msgstr "Tabulka formátovacích značek (TagTable)"

#: C/gtkmm-tutorial-in.xml:3193(para)
msgid ""
"Each <classname>Gtk::TextBuffer</classname> uses a <classname>Gtk::"
"TextBuffer::TagTable</classname>, which contains the <classname>Tag</"
"classname>s for that buffer. 2 or more <classname>TextBuffer</classname>s "
"may share the same <classname>TagTable</classname>. When you create "
"<classname>Tag</classname>s you should add them to the <classname>TagTable</"
"classname>. For instance:"
msgstr ""
"Každý <classname>Gtk::TextBuffer</classname> používá <classname>Gtk::"
"TextBuffer::TagTable</classname>, který obsahuje objekty <classname>Tag</"
"classname> pro vyrovnávací paměť. Dva nebo více objektů "
"<classname>TextBuffer</classname> může sdílet stejnou instanci "
"<classname>TagTable</classname>. Když vytvoříte objekty <classname>Tag</"
"classname>, měli byste je přidat do <classname>TagTable</classname>. "
"Například:"

#: C/gtkmm-tutorial-in.xml:3201(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable =\n"
"    Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"//Hopefully a future version of <application>gtkmm</application> will have a set_tag_table() method,\n"
"//for use after creation of the buffer.\n"
"Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer =\n"
"    Gtk::TextBuffer::create(refTagTable);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextBuffer::TagTable&gt; refTagTable =\n"
"    Gtk::TextBuffer::TagTable::create();\n"
"refTagTable-&gt;add(refTagMatch);\n"
"// V budoucích verzích snad bude mít  <application>gtkmm</application> metodu\n"
"// set_tag_table() pro použití až po vytvoření vyrovnávací paměti.\n"
"Glib::RefPtr&lt;Gtk::TextBuffer&gt; refBuffer =\n"
"    Gtk::TextBuffer::create(refTagTable);"

#: C/gtkmm-tutorial-in.xml:3209(para)
msgid ""
"You can also use <methodname>get_tag_table()</methodname> to get, and maybe "
"modify, the <classname>TextBuffer</classname>'s default <classname>TagTable</"
"classname> instead of creating one explicitly."
msgstr ""
"Můžete také použít <methodname>get_tag_table()</methodname> pro získání, a "
"případné změny, výchozího objektu <classname>TagTable</classname> z objektu "
"<classname>TextBuffer</classname>, místo abyste jej přímo vytvářeli."

#: C/gtkmm-tutorial-in.xml:3220(title)
msgid "Applying Tags"
msgstr "Použití formátovacích značek"

#: C/gtkmm-tutorial-in.xml:3221(para)
msgid ""
"If you have created a <classname>Tag</classname> and added it to the "
"<classname>TagTable</classname>, you may apply that tag to part of the "
"<classname>TextBuffer</classname> so that some of the text is displayed with "
"that formatting. You define the start and end of the range of text by "
"specifying <classname>Gtk::TextBuffer::iterator</classname>s. For instance:"
msgstr ""
"Když vytvoříte objekt <classname>Tag</classname> a přidáte jej do "
"<classname>TagTable</classname>, můžete použít tuto formátovací značku na "
"část textu v <classname>TextBuffer</classname>, takže tento text se zobrazí "
"s formátováním. Začátek a konec rozsahu definujete pomocí <classname>Gtk::"
"TextBuffer::iterator</classname>. Například:"

#: C/gtkmm-tutorial-in.xml:3228(programlisting)
#, no-wrap
msgid "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"
msgstr "refBuffer-&gt;apply_tag(refTagMatch, iterRangeStart, iterRangeStop);"

#: C/gtkmm-tutorial-in.xml:3231(programlisting)
#, no-wrap
msgid "refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"
msgstr "refBuffer-&gt;insert_with_tag(iter, \"Some text\", refTagMatch);"

#: C/gtkmm-tutorial-in.xml:3229(para)
msgid ""
"Or you could specify the tag when first inserting the text: <placeholder-1/>"
msgstr ""
"Nebo můžete formátovací značku určit při prvním vložení textu: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:3234(para)
msgid ""
"You can apply more than one <classname>Tag</classname> to the same text, by "
"using <methodname>apply_tag()</methodname> more than once, or by using "
"<methodname>insert_with_tags()</methodname>. The <classname>Tag</classname>s "
"might specify different values for the same properties, but you can resolve "
"these conflicts by using <methodname>Tag::set_priority()</methodname>."
msgstr ""
"Na ten samý text můžete použít i více formátovacích značek použitím metody "
"<methodname>apply_tag()</methodname> vícekrát, nebo pomocí "
"<methodname>insert_with_tags()</methodname>. Více objektů <classname>Tag</"
"classname> může určit pro tu samou vlastnost různé hodnoty, ale tyto "
"konflikty se dají řešit pomocí <methodname>Tag::set_priority()</methodname>."

#: C/gtkmm-tutorial-in.xml:3246(title)
msgid "Marks"
msgstr "Poziční značky (Mark)"

#: C/gtkmm-tutorial-in.xml:3247(para)
msgid ""
"<classname>TextBuffer</classname> iterators are generally invalidated when "
"the text changes, but you can use a <classname>Gtk::TextBuffer::Mark</"
"classname> to remember a position in these situations. For instance,"
msgstr ""
"Iterátory třídy <classname>TextBuffer</classname> jsou obecně zneplatněny, "
"když dojde ke změně textu, ale v těchto situacích můžete použít "
"<classname>Gtk::TextBuffer::Mark</classname> k zapamatování pozice. "
"Například:"

#: C/gtkmm-tutorial-in.xml:3252(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark =\n"
"    refBuffer-&gt;create_mark(iter);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextBuffer::Mark&gt; refMark =\n"
"    refBuffer-&gt;create_mark(iter);"

#: C/gtkmm-tutorial-in.xml:3255(para)
msgid ""
"You can then use the <methodname>get_iter()</methodname> method later to "
"create an iterator for the <classname>Mark</classname>'s new position."
msgstr ""
"Později můžete použít metodu <methodname>get_iter()</methodname> k vytvoření "
"iterátoru pro novou pozici v objektu <classname>Mark</classname>."

#: C/gtkmm-tutorial-in.xml:3260(para)
msgid ""
"There are two built-in <classname>Mark</classname>s - <literal>insert</"
"literal> and <literal>selection_bound</literal>, which you can access with "
"<classname>TextBuffer</classname>'s <methodname>get_insert()</methodname> "
"and <methodname>get_selection_bound()</methodname> methods."
msgstr ""
"Existují dvě vestavěné poziční značky <classname>Mark</classname> – "
"<literal>insert</literal> a <literal>selection_bound</literal>, ke kterým se "
"můžete dostat přes metody <methodname>get_insert()</methodname> a "
"<methodname>get_selection_bound()</methodname> třídy <classname>TextBuffer</"
"classname>."

#: C/gtkmm-tutorial-in.xml:3273(para)
msgid ""
"As mentioned above, each <classname>TextView</classname> has a "
"<classname>TextBuffer</classname>, and one or more <classname>TextView</"
"classname>s can share the same <classname>TextBuffer</classname>."
msgstr ""
"Jak bylo zmíněno výše, každý <classname>TextView</classname> má "
"<classname>TextBuffer</classname> a jeden nebo více <classname>TextView</"
"classname> může sdílet stejný <classname>TextBuffer</classname>."

#: C/gtkmm-tutorial-in.xml:3280(para)
msgid ""
"Like the <classname>TreeView</classname>, you should probably put your "
"<classname>TextView</classname> inside a <classname>ScrolledWindow</"
"classname> to allow the user to see and move around the whole text area with "
"scrollbars."
msgstr ""
"Obdobně jako u <classname>TreeView</classname>, byste měli svůj "
"<classname>TextView</classname> nejspíše vložit do "
"<classname>ScrolledWindow</classname>, aby uživatelé mohli vidět i "
"přesahující text a mohli se po celém textu pohybovat pomocí posuvníků."

#: C/gtkmm-tutorial-in.xml:3290(title)
msgid "Default formatting"
msgstr "Výchozí formátování"

#: C/gtkmm-tutorial-in.xml:3291(para)
msgid ""
"<classname>TextView</classname> has various methods which allow you to "
"change the presentation of the buffer for this particular view. Some of "
"these may be overridden by the <classname>Gtk::TextTag</classname>s in the "
"buffer, if they specify the same things. For instance, "
"<methodname>set_left_margin()</methodname>, <methodname>set_right_margin()</"
"methodname>, <methodname>set_indent()</methodname>, etc."
msgstr ""
"<classname>TextView</classname> má různé metody, které umožňují měnit "
"prezentovanou podobu vyrovnávací paměti pro konkrétní zobrazení. Některé jde "
"přepsat pomocí objektů <classname>Gtk::TextTag</classname> ve vyrovnávací "
"paměti, pokud určují ty stejné věci. Například pomocí "
"<methodname>set_left_margin()</methodname>, <methodname>set_right_margin()</"
"methodname>, <methodname>set_indent()</methodname> atd."

#: C/gtkmm-tutorial-in.xml:3302(title)
msgid "Scrolling"
msgstr "Posouvání"

#: C/gtkmm-tutorial-in.xml:3303(para)
msgid ""
"<classname>Gtk::TextView</classname> has various <methodname>scroll_to_*()</"
"methodname> methods. These allow you to ensure that a particular part of the "
"text buffer is visible. For instance, your application's Find feature might "
"use <methodname>Gtk::TextView::scroll_to_iter()</methodname> to show the "
"found text."
msgstr ""
"<classname>Gtk::TextView</classname> má různé metody "
"<methodname>scroll_to_*()</methodname>. Ty dokážou zajistit, aby byla "
"viditelná konkrétní část textové vyrovnávací paměti. Například funkce "
"hledání ve vaší aplikaci může použít <methodname>Gtk::TextView::"
"scroll_to_iter()</methodname> k zobrazení nalezeného textu."

#: C/gtkmm-tutorial-in.xml:3318(title)
msgid "Widgets and ChildAnchors"
msgstr "Widgety a kotvy potomků (ChildAnchors)"

#: C/gtkmm-tutorial-in.xml:3319(para)
msgid ""
"You can embed widgets, such as <classname>Gtk::Button</classname>s, in the "
"text. Each such child widget needs a <classname>ChildAnchor</classname>. "
"ChildAnchors are associated with <classname>iterators</classname>. For "
"instance, to create a child anchor at a particular position, use "
"<methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:"
msgstr ""
"Widgety, jako je <classname>Gtk::Button</classname>, můžete vkládat do "
"textu. Každý takový synovský widget potřebuje objekt <classname>ChildAnchor</"
"classname>. Tyto objekty jsou propojené s iterátory. Například, abyste "
"vytvořili kotvu pro potomka na konkrétní pozici v textu, použijte "
"<methodname>Gtk::TextBuffer::create_child_anchor()</methodname>:"

#: C/gtkmm-tutorial-in.xml:3326(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor =\n"
"    refBuffer-&gt;create_child_anchor(iter);"
msgstr ""
"Glib::RefPtr&lt;Gtk::TextChildAnchor&gt; refAnchor =\n"
"    refBuffer-&gt;create_child_anchor(iter);"

#: C/gtkmm-tutorial-in.xml:3329(para)
msgid ""
"Then, to add a widget at that position, use <methodname>Gtk::TextView::"
"add_child_at_anchor()</methodname>:"
msgstr ""
"Pro přidání widgetu na tuto pozici použijte <methodname>Gtk::TextView::"
"add_child_at_anchor()</methodname>:"

#: C/gtkmm-tutorial-in.xml:3333(programlisting)
#, no-wrap
msgid "m_TextView.add_child_at_anchor(m_Button, refAnchor);"
msgstr "m_TextView.add_child_at_anchor(m_Button, refAnchor);"

#: C/gtkmm-tutorial-in.xml:3359(title)
msgid "Menus and Toolbars"
msgstr "Nabídky a nástrojové lišty"

#: C/gtkmm-tutorial-in.xml:3361(para)
msgid ""
"There are specific APIs for Menus and toolbars, but you should usually deal "
"with them together, using the <classname>UIManager</classname> to define "
"<classname>Action</classname>s which you can then arrange in menus and "
"toolbars. In this way you can handle activation of the action instead of "
"responding to the menu and toolbar items separately. And you can enable or "
"disable both the menu and toolbar item via the action."
msgstr ""
"Pro nabídky a nástrojové lišty existují speciální API, ale běžně byste s "
"nimi měli zacházet dohromady pomocí třídy <classname>UIManager</classname>, "
"s kterou nadefinujete akce <classname>Action</classname> a ty pak rozmístíte "
"do nabídek a nástrojových lišt. Tímto způsobem můžete obsluhovat aktivaci "
"akce namísto reagování na položky nabídky a nástrojové lišty odděleně. Navíc "
"můžete přes akci naráz povolit nebo zakázat položku jak v nabídce, tak na "
"nástrojové liště."

#: C/gtkmm-tutorial-in.xml:3369(para)
msgid ""
"This involves the use of the <classname>Gtk::ActionGroup</classname>, "
"<classname>Gtk::Action</classname>, and <classname>UIManager</classname> "
"classes, all of which should be instantiated via their <methodname>create()</"
"methodname> methods, which return <classname>RefPtr</classname>s."
msgstr ""
"J k tomu zapotřebí použití tříd <classname>Gtk::ActionGroup</classname>, "
"<classname>Gtk::Action</classname> a <classname>UIManager</classname>. U "
"všech by se měla vytvářet instance pomocí jejich metody "
"<methodname>create()</methodname>, která vrací <classname>RefPtr</classname>."

#: C/gtkmm-tutorial-in.xml:3378(title)
msgid "Actions"
msgstr "Akce"

#: C/gtkmm-tutorial-in.xml:3379(para)
msgid ""
"First create the <classname>Action</classname>s and add them to an "
"<classname>ActionGroup</classname>, with <methodname>ActionGroup::add()</"
"methodname>."
msgstr ""
"Nejprv vytvořte akce <classname>Action</classname> a pak je přidejte do "
"<classname>ActionGroup</classname> pomocí <methodname>ActionGroup::add()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:3385(para)
msgid ""
"The arguments to <methodname>Action::create()</methodname> specify the "
"action's name and how it will appear in menus and toolbars."
msgstr ""
"Argumenty metody <methodname>Action::create()</methodname> určují název akce "
"a jak bude v nabídkách a nástrojových lištách vypadat."

#: C/gtkmm-tutorial-in.xml:3389(para)
msgid ""
"You can also specify a signal handler when calling <methodname>ActionGroup::"
"add()</methodname>. This signal handler will be called when the action is "
"activated via either a menu item or a toolbar button."
msgstr ""
"Při volání <methodname>ActionGroup::add()</methodname> můžete také určit "
"obsluhu signálu. Ta pak bude vyvolána, kdykoliv bude akce aktivována přes "
"svojí položku nabídky nebo tlačítko na nástrojové liště."

#: C/gtkmm-tutorial-in.xml:3394(para)
msgid "Note that you must specify actions for sub menus as well as menu items."
msgstr ""
"Všimněte si, že musíte definovat akce i pro podnabídky, úplně stejně jako "
"pro položky nabídek."

#: C/gtkmm-tutorial-in.xml:3396(para)
msgid "For instance:"
msgstr "Například:"

#: C/gtkmm-tutorial-in.xml:3398(programlisting)
#, no-wrap
msgid ""
"m_refActionGroup = Gtk::ActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"MenuFile\", \"_File\") );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"New\", \"_New\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"ExportData\", \"Export Data\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"Quit\", \"_Quit\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );"
msgstr ""
"m_refActionGroup = Gtk::ActionGroup::create();\n"
"\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"MenuFile\", \"_File\") );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"New\", \"_New\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_new) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"ExportData\", \"Export Data\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_open) );\n"
"m_refActionGroup-&gt;add( Gtk::Action::create(\"Quit\", \"_Quit\"),\n"
"  sigc::mem_fun(*this, &amp;ExampleWindow::on_action_file_quit) );"

#: C/gtkmm-tutorial-in.xml:3408(para)
msgid ""
"Note that this is where we specify the names of the actions as they will be "
"seen by users in menus and toolbars. Therefore, this is where you should "
"make strings translatable, by putting them inside the _() macro."
msgstr ""
"Poznamenejme, že tohle je místo, kde definujeme název akce tak, jak jej "
"uživatelé uvidí v nabídkách a v nástrojových lištách. Protože je to zároveň "
"místo, kde byste měli poskytnou řetězce k překladu, vložte je do makra _()."

#: C/gtkmm-tutorial-in.xml:3413(title)
msgid "UIManager"
msgstr "UIManager"

#: C/gtkmm-tutorial-in.xml:3414(para)
msgid ""
"Next you should create a <classname>UIManager</classname> and add the "
"<classname>ActionGroup</classname> to the <classname>UIManager</classname> "
"with <methodname>insert_action_group()</methodname> At this point is also a "
"good idea to tell the parent window to respond to the specified keyboard "
"shortcuts, by using <methodname>add_accel_group()</methodname>."
msgstr ""
"Následně byste měli vytvořit <classname>UIManager</classname> a pomocí "
"<methodname>insert_action_group()</methodname> do něj přidat "
"<classname>ActionGroup</classname>. V tento okamžik je také dobré říci "
"rodičovskému oknu pomocí <methodname>add_accel_group()</methodname>, aby "
"reagovalo na patřičné klávesové zkratky."

#: C/gtkmm-tutorial-in.xml:3422(para) C/gtkmm-tutorial-in.xml:4856(para)
msgid "For instance,"
msgstr "Například"

#: C/gtkmm-tutorial-in.xml:3424(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager =\n"
"    Gtk::UIManager::create();\n"
"m_refUIManager-&gt;insert_action_group(m_refActionGroup);\n"
"add_accel_group(m_refUIManager-&gt;get_accel_group());"
msgstr ""
"Glib::RefPtr&lt;Gtk::UIManager&gt; m_refUIManager =\n"
"    Gtk::UIManager::create();\n"
"m_refUIManager-&gt;insert_action_group(m_refActionGroup);\n"
"add_accel_group(m_refUIManager-&gt;get_accel_group());"

#: C/gtkmm-tutorial-in.xml:3428(para)
msgid ""
"Then, you can define the actual visible layout of the menus and toolbars, "
"and add the UI layout to the <classname>UIManager</classname>. This \"ui "
"string\" uses an XML format, in which you should mention the names of the "
"actions that you have already created. For instance:"
msgstr ""
"Pak můžete definovat skutečné viditelné rozvržení nabídek a nástrojových "
"lišt a přidat je do rozvržení uživatelského rozhraní v instanci "
"<classname>UIManager</classname>. Tyto „řetězce uživatelského rozhraní“ "
"používají formát XML, ve kterém byste měli použít názvy činností, které jste "
"již vytvořili. Například:"

#: C/gtkmm-tutorial-in.xml:3434(programlisting)
#, no-wrap
msgid ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;menubar name='MenuBar'&gt;\"\n"
"    \"    &lt;menu action='MenuFile'&gt;\"\n"
"    \"      &lt;menuitem action='New'/&gt;\"\n"
"    \"      &lt;menuitem action='Open'/&gt;\"\n"
"    \"      &lt;separator/&gt;\"\n"
"    \"      &lt;menuitem action='Quit'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"    &lt;menu action='MenuEdit'&gt;\"\n"
"    \"      &lt;menuitem action='Cut'/&gt;\"\n"
"    \"      &lt;menuitem action='Copy'/&gt;\"\n"
"    \"      &lt;menuitem action='Paste'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"  &lt;/menubar&gt;\"\n"
"    \"  &lt;toolbar  name='ToolBar'&gt;\"\n"
"    \"    &lt;toolitem action='Open'/&gt;\"\n"
"    \"    &lt;toolitem action='Quit'/&gt;\"\n"
"    \"  &lt;/toolbar&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"
msgstr ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;menubar name='MenuBar'&gt;\"\n"
"    \"    &lt;menu action='MenuFile'&gt;\"\n"
"    \"      &lt;menuitem action='New'/&gt;\"\n"
"    \"      &lt;menuitem action='Open'/&gt;\"\n"
"    \"      &lt;separator/&gt;\"\n"
"    \"      &lt;menuitem action='Quit'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"    &lt;menu action='MenuEdit'&gt;\"\n"
"    \"      &lt;menuitem action='Cut'/&gt;\"\n"
"    \"      &lt;menuitem action='Copy'/&gt;\"\n"
"    \"      &lt;menuitem action='Paste'/&gt;\"\n"
"    \"    &lt;/menu&gt;\"\n"
"    \"  &lt;/menubar&gt;\"\n"
"    \"  &lt;toolbar  name='ToolBar'&gt;\"\n"
"    \"    &lt;toolitem action='Open'/&gt;\"\n"
"    \"    &lt;toolitem action='Quit'/&gt;\"\n"
"    \"  &lt;/toolbar&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"

#: C/gtkmm-tutorial-in.xml:3457(para)
msgid ""
"Remember that these names are just the identifiers that we used when "
"creating the actions. They are not the text that the user will see in the "
"menus and toolbars. We provided those human-readable names when we created "
"the actions."
msgstr ""
"Pamatujte, že tyto názvy jsou jen obyčejné identifikátory, které jste "
"použili při vytváření akcí. Nejedná se o text, který by viděl uživatel v "
"nabídkách nebo nástrojových lištách. Názvy čitelné pro lidi jsme poskytli "
"při vytváření akcí."

#: C/gtkmm-tutorial-in.xml:3458(para)
msgid ""
"To instantiate a <classname>Gtk::MenuBar</classname> or <classname>Gtk::"
"Toolbar</classname> which you can actually show, you should use the "
"<methodname>UIManager::get_widget()</methodname> method, and then add the "
"widget to a container. For instance:"
msgstr ""
"K vytvoření instance <classname>Gtk::MenuBar</classname> nebo "
"<classname>Gtk::Toolbar</classname>, které chcete skutečně zobrazit, byste "
"měli použít metodu <methodname>UIManager::get_widget()</methodname> a pak "
"přidat widget do kontejneru. Například:"

#: C/gtkmm-tutorial-in.xml:3464(programlisting)
#, no-wrap
msgid ""
"Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget(\"/MenuBar\");\n"
"pBox-&gt;add(*pMenuBar, Gtk::PACK_SHRINK);"
msgstr ""
"Gtk::Widget* pMenubar = m_refUIManager-&gt;get_widget(\"/MenuBar\");\n"
"pBox-&gt;add(*pMenuBar, Gtk::PACK_SHRINK);"

#: C/gtkmm-tutorial-in.xml:3470(title)
msgid "Popup Menus"
msgstr "Vyskakovací nabídky"

#: C/gtkmm-tutorial-in.xml:3471(para)
msgid ""
"<classname>Menus</classname> are normally just added to a window, but they "
"can also be displayed temporarily as the result of a mouse button click. For "
"instance, a context menu might be displayed when the user clicks their right "
"mouse button."
msgstr ""
"Nabídky <classname>Menu</classname> jsou normálně jen přidané do okna, ale "
"mohou být také jen dočasně zobrazené na základě kliknutí myší. Například "
"kontextová nabídka se může zobrazit, když uživatel klikne druhým tlačítkem "
"myši."

#: C/gtkmm-tutorial-in.xml:3478(para)
msgid ""
"The UI layout for a popup menu should use the <literal>popup</literal> node. "
"For instance:"
msgstr ""
"Návrh uživatelského rozhraní by pro vyskakovací nabídku měl použít uzel "
"<literal>popup</literal>. Například:"

#: C/gtkmm-tutorial-in.xml:3480(programlisting)
#, no-wrap
msgid ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;popup name='PopupMenu'&gt;\"\n"
"    \"    &lt;menuitem action='ContextEdit'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextProcess'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextRemove'/&gt;\"\n"
"    \"  &lt;/popup&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"
msgstr ""
"Glib::ustring ui_info =\n"
"    \"&lt;ui&gt;\"\n"
"    \"  &lt;popup name='PopupMenu'&gt;\"\n"
"    \"    &lt;menuitem action='ContextEdit'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextProcess'/&gt;\"\n"
"    \"    &lt;menuitem action='ContextRemove'/&gt;\"\n"
"    \"  &lt;/popup&gt;\"\n"
"    \"&lt;/ui&gt;\";\n"
"\n"
"m_refUIManager-&gt;add_ui_from_string(ui_info);"

#: C/gtkmm-tutorial-in.xml:3491(para)
msgid ""
"To show the popup menu, use <classname>Gtk::Menu</classname>'s "
"<methodname>popup()</methodname> method, providing the button identifier and "
"the time of activation, as provided by the <literal>button_press_event</"
"literal> signal, which you will need to handle anyway. For instance:"
msgstr ""
"K zobrazení vyskakovací nabídky použijte metodu <methodname>popup()</"
"methodname> třídy <classname>Gtk::Menu</classname>, poskytněte ji "
"identifikátor tlačítka a čas aktivace tak, jak to dělá signál "
"<literal>button_press_event</literal>, který stejně budete muset obsluhovat. "
"Například:"

#: C/gtkmm-tutorial-in.xml:3497(programlisting)
#, no-wrap
msgid ""
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;\n"
"      (event-&gt;button == 3) )\n"
"  {\n"
"    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; //It has been handled.\n"
"  }\n"
"  else\n"
"    return false;\n"
"}"
msgstr ""
"bool ExampleWindow::on_button_press_event(GdkEventButton* event)\n"
"{\n"
"  if( (event-&gt;type == GDK_BUTTON_PRESS) &amp;&amp;\n"
"      (event-&gt;button == 3) )\n"
"  {\n"
"    m_Menu_Popup-&gt;popup(event-&gt;button, event-&gt;time);\n"
"    return true; // Bylo obslouženo\n"
"  }\n"
"  else\n"
"    return false;\n"
"}"

#: C/gtkmm-tutorial-in.xml:3514(title)
msgid "Main Menu example"
msgstr "Příklad hlavní nabídky"

#: C/gtkmm-tutorial-in.xml:3517(title)
msgid "Main Menu"
msgstr "Hlavní nabídka"

#: C/gtkmm-tutorial-in.xml:3527(title)
msgid "Popup Menu example"
msgstr "Příklad vyskakovací nabídky"

#: C/gtkmm-tutorial-in.xml:3530(title)
msgid "Popup Menu"
msgstr "Vyskakovací nabídka"

#: C/gtkmm-tutorial-in.xml:3545(title) C/gtkmm-tutorial-in.xml:3586(title)
msgid "ToolPalette"
msgstr "Paleta nástrojů (ToolPalette)"

#: C/gtkmm-tutorial-in.xml:3547(para)
msgid ""
"A <classname>ToolPalette</classname> is similar to a <classname>Toolbar</"
"classname> but can contain a grid of items, categorized into groups. The "
"user may hide or expand each group. As in a toolbar, the items may be "
"displayed as only icons, as only text, or as icons with text."
msgstr ""
"Widget <classname>ToolPalette</classname> je podobný widgetu "
"<classname>Toolbar</classname>, ale na rozdíl od něj může obsahovat mřížku "
"položek roztříděných do skupin. Uživatel může jednotlivé skupiny skrývat "
"nebo rozbalovat. Obdobně jako v nástrojové liště, mohou být položky "
"zobrazené jako ikony, texty nebo ikony s textem."

#: C/gtkmm-tutorial-in.xml:3549(para)
msgid ""
"The <classname>ToolPalette</classname>'s items might be dragged or simply "
"activated. For instance, the user might drag objects to a canvas to create "
"new items there. Or the user might click an item to activate a certain brush "
"size in a drawing application."
msgstr ""
"Položky z <classname>ToolPalette</classname> se dají přetahovat nebo prostě "
"aktivovat. Například může uživatel přetáhnout položky na plátno, aby na něm "
"vytvořit nové objekty. Nebo může kliknutím na položku aktivovat konkrétní "
"velikost štětce v aplikaci na kreslení."

#: C/gtkmm-tutorial-in.xml:3550(para)
msgid ""
"<classname>ToolItemGroup</classname>s should be added to the tool palette "
"via the base class's <function>Gtk::Container::add()</function> method, for "
"instance like so:"
msgstr ""
"<classname>ToolItemGroup</classname> byste měli do palety nástrojů přidávat "
"přes metodu základní třídy <function>Gtk::Container::add()</function>, "
"například takto:"

#: C/gtkmm-tutorial-in.xml:3553(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::ToolItemGroup* group_brushes =\n"
"  Gtk::manage(new Gtk::ToolItemGroup(\"Brushes\"));\n"
"m_ToolPalette.add(*group_brushes);\n"
msgstr ""
"\n"
"Gtk::ToolItemGroup* group_brushes =\n"
"  Gtk::manage(new Gtk::ToolItemGroup(\"Brushes\"));\n"
"m_ToolPalette.add(*group_brushes);\n"

#: C/gtkmm-tutorial-in.xml:3559(para)
msgid ""
"<classname>Gtk::ToolItem</classname>s can then be added to the group. For "
"instance, like so:"
msgstr ""
"Položky <classname>Gtk::ToolItem</classname> se dají přidávat do skupin. "
"Například takto:"

#: C/gtkmm-tutorial-in.xml:3563(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, \"Big\"));\n"
"button-&gt;set_tooltip_text(\"Big Brush);\n"
"group_brushes-&gt;insert(*button);\n"
msgstr ""
"\n"
"Gtk::ToolButton* button = Gtk::manage(new Gtk::ToolButton(icon, \"Big\"));\n"
"button-&gt;set_tooltip_text(\"Big Brush);\n"
"group_brushes-&gt;insert(*button);\n"

#: C/gtkmm-tutorial-in.xml:3569(para)
msgid ""
"You might then handle the <classname>ToolButton</classname>'s "
"<literal>clicked</literal> signal. Alternatively, you could allow the item "
"to be dragged to another widget, by calling <methodname>Gtk::ToolPalette::"
"add_drag_dest()</methodname> and then using <methodname>Gtk::ToolPalette::"
"get_drag_item()</methodname> in the other widget's "
"<literal>drag_data_received</literal> signal handler."
msgstr ""
"Pak můžete obsluhovat signál <literal>clicked</literal> objektu "
"<classname>ToolButton</classname>. Případně byste mohli umožnit položce její "
"přetažení do jiného widgetu pomocí volání <methodname>Gtk::ToolPalette::"
"add_drag_dest()</methodname> a následného použití <methodname>Gtk::"
"ToolPalette::get_drag_item()</methodname> v obsluze signálu "
"<literal>drag_data_received</literal> v onom jiném widgetu."

#: C/gtkmm-tutorial-in.xml:3571(ulink)
msgid "ToolPalette Reference"
msgstr "Referenční příručka třídy ToolPalette"

#: C/gtkmm-tutorial-in.xml:3572(ulink)
msgid "ToolItemGroup Reference"
msgstr "Referenční příručka třídy ToolItemGroup"

#: C/gtkmm-tutorial-in.xml:3573(ulink)
msgid "ToolItem Reference"
msgstr "Referenční příručka třídy ToolItem"

#: C/gtkmm-tutorial-in.xml:3577(para)
msgid ""
"Call <methodname>add_drag_dest()</methodname> to allow items or groups to be "
"dragged from the tool palette to a particular destination widget. You can "
"then use <methodname>get_drag_item()</methodname> to discover which ToolItem "
"or ToolItemGroup is being dragged. You can use <literal>dynamic_cast</"
"literal> to discover whether it is an item or a group. For instance, you "
"might use this in your <literal>drag_data_received</literal> signal handler, "
"to add a dropped item, or to show a suitable icon while dragging."
msgstr ""
"Zavoláním <methodname>add_drag_dest()</methodname> umožníte položkám nebo "
"skupinám jejich přetažení z palety nástrojů na konkrétní cílový widget. "
"Následně můžete použít <methodname>get_drag_item()</methodname> ke zjištění, "
"který objekt <classname>TollItem</classname> nebo <classname>ToolItemGroup</"
"classname> je přetahován. Ke zjištění, jestli jde o položku nebo skupiny, "
"můžete použít <literal>dynamic_cast</literal>. Hodit se vám to bude "
"například ve vaší obsluze signálu <literal>drag_data_received</literal> k "
"přidání upuštěné položky nebo k zobrazení názorné ikony během přetahování."

#: C/gtkmm-tutorial-in.xml:3578(para)
msgid ""
"See the <link linkend=\"chapter-draganddrop\">Drag and Drop</link> chapter "
"for general advice about Drag and Drop with gtkmm."
msgstr ""
"Obecné rady k „Táhni a upusť“ pomocí gtkmm najdete v kapitole <link linkend="
"\"chapter-draganddrop\">Táhni a upusť</link>"

#: C/gtkmm-tutorial-in.xml:3581(title)
msgid "ToolPalette Example"
msgstr "Příklad s ToolPalette"

#: C/gtkmm-tutorial-in.xml:3583(para)
msgid ""
"This example adds a <classname>ToolPalette</classname> and a "
"<classname>DrawingArea</classname> to a window and allows the user to drag "
"icons from the tool palette to the drawing area. The tool palette contains "
"several groups of items. The combo boxes allow the user to change the style "
"and orientation of the tool palette."
msgstr ""
"Tento příklad přidává do okna <classname>ToolPalette</classname> a "
"<classname>DrawingArea</classname> a umožňuje uživateli přetáhnout ikony z "
"palety nástrojů do kreslící oblasti. Paleta nástrojů obsahuje několik skupin "
"položek. Rozbalovací seznamy umožňují uživateli měnit styl a otočení palety "
"nástrojů."

#: C/gtkmm-tutorial-in.xml:3599(title)
msgid "Adjustments"
msgstr "Přizpůsobení (Adjustment)"

#: C/gtkmm-tutorial-in.xml:3601(para)
msgid ""
"<application>gtkmm</application> has various widgets that can be visually "
"adjusted using the mouse or the keyboard, such as the <classname>Range</"
"classname> widgets (described in the <link linkend=\"chapter-range-widgets"
"\">Range Widgets</link> section). There are also a few widgets that display "
"some adjustable part of a larger area, such as the <classname>Viewport</"
"classname> widget. These widgets have <classname>Gtk::Adjustment</classname> "
"objects that express this common part of their API."
msgstr ""
"<application>gtkmm</application> má řadu widgetů, které mohou vizuálně měnit "
"nějakou hodnotu pomocí myši nebo kalávesnice, např. widgety "
"<classname>Range</classname> (popsané v kapitole <link linkend=\"chapter-"
"range-widgets\">Widgety Range</link>). Existuje také několik widgetů, které "
"zobrazují z velké oblasti jen nějakou zvolenou část, např. widget  "
"<classname>Viewport</classname>. Tyto widgety mají objekty <classname>Gtk::"
"Adjustment</classname>, které jsou vyjádřením této části jejich API."

#: C/gtkmm-tutorial-in.xml:3611(para)
msgid ""
"So that applications can react to changes, for instance when a user moves a "
"scrollbar, <classname>Gtk::Adjustment</classname> has a "
"<literal>value_changed</literal> signal. You can then use the "
"<methodname>get_value()</methodname> method to discover the new value."
msgstr ""
"Aby aplikace mohly reagovat na změny, například když uživatel posune "
"posuvníkem, má <classname>Gtk::Adjustment</classname> signál "
"<literal>value_changed</literal>. Vy pak můžete použít metodu "
"<methodname>get_value()</methodname> ke zjištění nové hodnoty."

#: C/gtkmm-tutorial-in.xml:3619(title)
msgid "Creating an Adjustment"
msgstr "Vytváření objektů Adjustment"

#: C/gtkmm-tutorial-in.xml:3621(para)
msgid ""
"The <classname>Gtk::Adjustment</classname> is created by its "
"<methodname>create()</methodname> method which is as follows:"
msgstr ""
"<classname>Gtk::Adjustment</classname> se vytváří jeho metodou "
"<methodname>create()</methodname>, která vypadá takto:"

#: C/gtkmm-tutorial-in.xml:3626(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(\n"
"  double value,\n"
"  double lower,\n"
"  double upper,\n"
"  double step_increment = 1,\n"
"  double page_increment = 10,\n"
"  double page_size = 0);"
msgstr ""
"Glib::RefPtr&lt;Gtk::Adjustment&gt; Gtk::Adjustment::create(\n"
"  double value,\n"
"  double lower,\n"
"  double upper,\n"
"  double step_increment = 1,\n"
"  double page_increment = 10,\n"
"  double page_size = 0);"

#: C/gtkmm-tutorial-in.xml:3634(para)
msgid ""
"The <parameter>value</parameter> argument is the initial value of the "
"adjustment, usually corresponding to the topmost or leftmost position of an "
"adjustable widget. The <parameter>lower</parameter> and <parameter>upper</"
"parameter> arguments specify the possible range of values which the "
"adjustment can hold. The <parameter>step_increment</parameter> argument "
"specifies the smaller of the two increments by which the user can change the "
"value, while the <parameter>page_increment</parameter> is the larger one. "
"The <parameter>page_size</parameter> argument usually corresponds somehow to "
"the visible area of a panning widget. The <parameter>upper</parameter> "
"argument is used to represent the bottommost or rightmost coordinate in a "
"panning widget's child."
msgstr ""
"Argument <parameter>value</parameter> je počáteční hodnota přizpůsobení, "
"obvykle odpovídající nejvyšší nebo nejlevější pozici ve widgetu. Argumenty "
"<parameter>lower</parameter> a <parameter>upper</parameter> určují možný "
"rozsah hodnot, kterých se má přizpůsobení držet. Argument "
"<parameter>step_increment</parameter> určuje menší ze dvou kroků, po kterých "
"uživatel může hodnotu měnit, zatímco <parameter>page_increment</parameter> "
"určuje tu větší. Argument <parameter>page_size</parameter> obvykle nějak "
"koresponduje s viditelnou oblastí pohybovaného widgetu. Argument "
"<parameter>upper</parameter> se používá k reprezentaci nejnižší nebo "
"nejpravější souřadnice v pohybovaném widgetu."

#: C/gtkmm-tutorial-in.xml:3653(title)
msgid "Using Adjustments the Easy Way"
msgstr "Snadné použití objektů Adjustment"

#: C/gtkmm-tutorial-in.xml:3655(para)
msgid ""
"The adjustable widgets can be roughly divided into those which use and "
"require specific units for these values, and those which treat them as "
"arbitrary numbers."
msgstr ""
"Widgety přizpůsobení lze zhruba rozdělit na ty, které používají a vyžadují "
"pro hodnoty konkrétní jednotky, a ty, které pracují s libovolnými čísly."

#: C/gtkmm-tutorial-in.xml:3660(para)
msgid ""
"The group which treats the values as arbitrary numbers includes the "
"<classname>Range</classname> widgets (<classname>Scrollbar</classname> and "
"<classname>Scale</classname>), the <classname>ScaleButton</classname> "
"widget, and the <classname>SpinButton</classname> widget. These widgets are "
"typically \"adjusted\" directly by the user with the mouse or keyboard. They "
"will treat the <parameter>lower</parameter> and <parameter>upper</parameter> "
"values of an adjustment as a range within which the user can manipulate the "
"adjustment's <parameter>value</parameter>. By default, they will only modify "
"the <parameter>value</parameter> of an adjustment."
msgstr ""
"Skupina, která zachází s hodnotami jako s libovolnými čísly, zahrnuje "
"widgety <classname>Range</classname> (<classname>Scrollbar</classname> a "
"<classname>Scale</classname>), widget <classname>ScaleButton</classname> a "
"widget <classname>SpinButton</classname>. Tyto widgety typicky "
"„přizpůsobují“ přímo podle uživatelova ovládání myší nebo klávesnicí. S "
"hodnotami přizpůsobení <parameter>lower</parameter> a <parameter>upper</"
"parameter> zachází jako s rozmezími, v rámci kterých uživatel může měnit "
"<parameter>value</parameter> v přizpůsobení. Standardně bude měnit jen údaj "
"<parameter>value</parameter>."

#: C/gtkmm-tutorial-in.xml:3672(para)
msgid ""
"The other group includes the <classname>Viewport</classname> widget and the "
"<classname>ScrolledWindow</classname> widget. All of these widgets use pixel "
"values for their adjustments. These are also typically adjusted indirectly "
"using scrollbars. While all widgets which use adjustments can either create "
"their own adjustments or use ones you supply, you'll generally want to let "
"this particular category of widgets create its own adjustments."
msgstr ""
"Do druhé skupiny patří widget <classname>Viewport</classname> a widget "
"<classname>ScrolledWindow</classname>. Všechny tyto widgety používají pro "
"svá přizpůsobení údaje v pixelech. Typicky přizpůsobují nepřímo přes "
"posuvníky. Zatímco všechny widgety, které používají přizpůsobení, mohou buď "
"vytvořit svá vlastní přizpůsobení, nebo použít ta, která dodáte, u této "
"konkrétní skupiny widgetů bude obecně chtít nechat widgety, ať si vytvoří "
"svá vlastní přizpůsobení."

#: C/gtkmm-tutorial-in.xml:3681(para)
msgid ""
"If you share an adjustment object between a Scrollbar and a TextView widget, "
"manipulating the scrollbar will automagically adjust the TextView widget. "
"You can set it up like this:"
msgstr ""
"Pokud sdílíte objekt přizpůsobení mezi widgety <classname>Scrollbar</"
"classname> a <classname>TextView</classname>, manipulace s posuvníkem bude "
"automaticky ovlivňovat widget <classname>TextView</classname>. Natavit to "
"můžete takto:"

#: C/gtkmm-tutorial-in.xml:3686(programlisting)
#, no-wrap
msgid ""
"// creates its own adjustments\n"
"Gtk::TextView textview;\n"
"// uses the newly-created adjustment for the scrollbar as well\n"
"Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);"
msgstr ""
"// vytvoří své vlastní přizpůsobení\n"
"Gtk::TextView textview;\n"
"// použije nově vytvořené přizpůsobení pro posuvník\n"
"Gtk::Scrollbar vscrollbar (textview.get_vadjustment(), Gtk::ORIENTATION_VERTICAL);"

#: C/gtkmm-tutorial-in.xml:3694(title)
msgid "Adjustment Internals"
msgstr "Objekty Adjustment zevnitř"

#: C/gtkmm-tutorial-in.xml:3696(para)
msgid ""
"OK, you say, that's nice, but what if I want to create my own handlers to "
"respond when the user adjusts a <classname>Range</classname> widget or a "
"<classname>SpinButton</classname>. To access the value of a <classname>Gtk::"
"Adjustment</classname>, you can use the <methodname>get_value()</methodname> "
"and <methodname>set_value()</methodname> methods:"
msgstr ""
"Bezva, řeknete že je to pěkné, ale co když si chcete vytvořit vlastní "
"obsluhu, abyste reagovali na uživatelovy změny hodnoty ve widgetu "
"<classname>Range</classname> nebo <classname>SpinButton</classname>. Pro "
"přístup k hondote z <classname>Gtk::Adjustment</classname> můžete použít "
"metody <methodname>get_value()</methodname> a <methodname>set_value()</"
"methodname>:"

#: C/gtkmm-tutorial-in.xml:3704(para)
msgid ""
"As mentioned earlier, <classname>Gtk::Adjustment</classname> can emit "
"signals. This is, of course, how updates happen automatically when you share "
"an <classname>Adjustment</classname> object between a <classname>Scrollbar</"
"classname> and another adjustable widget; all adjustable widgets connect "
"signal handlers to their adjustment's <literal>value_changed</literal> "
"signal, as can your program."
msgstr ""
"Jak již byl zmíněno, <classname>Gtk::Adjustment</classname> může vysílat "
"signály. To je samozřejmě ta finta, jak se automaticky dějí aktualizace, "
"když sdílíte objekt <classname>Adjustment</classname> mezi widgetem "
"<classname>Scrollbar</classname> a jiným přizpůsobitelným widgetem. Všechny "
"přizpůsobitelné widgety mohou napojit obsluhy signálů na svůj signál "
"<literal>value_changed</literal>, stejně jako to může váš program."

#: C/gtkmm-tutorial-in.xml:3713(para)
msgid ""
"So, for example, if you have a <classname>Scale</classname> widget, and you "
"want to change the rotation of a picture whenever its value changes, you "
"would create a signal handler like this:"
msgstr ""
"Takže, když například máte widget <classname>Scale</classname> a chcete "
"změnit otočení obrázku, kdykoliv se změní jeho hodnota, vytvořili byste "
"obsluhu signálu nějak takto:"

#: C/gtkmm-tutorial-in.xml:3718(programlisting)
#, no-wrap
msgid ""
"void cb_rotate_picture (MyPicture* picture)\n"
"{\n"
"  picture-&gt;set_rotation(adj-&gt;get_value());\n"
"..."
msgstr ""
"void cb_rotate_picture (MyPicture* picture)\n"
"{\n"
"  picture-&gt;set_rotation(adj-&gt;get_value());\n"
"…"

#: C/gtkmm-tutorial-in.xml:3722(para)
msgid "and connect it to the scale widget's adjustment like this:"
msgstr ""
"a napojili byste jej na přizpůsobení widgetu <classname>Scale</classname> "
"nějak takto:"

#: C/gtkmm-tutorial-in.xml:3725(programlisting)
#, no-wrap
msgid ""
"adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"
msgstr ""
"adj-&gt;signal_value_changed().connect(sigc::bind&lt;MyPicture*&gt;(sigc::mem_fun(*this,\n"
"    &amp;cb_rotate_picture), picture));"

#: C/gtkmm-tutorial-in.xml:3728(para)
msgid ""
"What if a widget reconfigures the <parameter>upper</parameter> or "
"<parameter>lower</parameter> fields of its <classname>Adjustment</"
"classname>, such as when a user adds more text to a text widget? In this "
"case, it emits the <literal>changed</literal> signal."
msgstr ""
"Co když widget změní nastavení polí <parameter>upper</parameter> nebo "
"<parameter>lower</parameter> ve svém objektu <classname>Adjustment</"
"classname>, třeba když uživatel přidá další text do textového widgetu? V "
"tomto případě vyšle signál <literal>changed</literal>."

#: C/gtkmm-tutorial-in.xml:3735(para)
msgid ""
"<classname>Range</classname> widgets typically connect a handler to this "
"signal, which changes their appearance to reflect the change - for example, "
"the size of the slider in a scrollbar will grow or shrink in inverse "
"proportion to the difference between the <parameter>lower</parameter> and "
"<parameter>upper</parameter> values of its <classname>Adjustment</classname>."
msgstr ""
"Widgety <classname>Range</classname> typicky napojují obsluhu na tento "
"signál, který mění jejich vzhled s ohledem na změny – například velikost "
"táhla v posuvníku roste, nebo se zmenšuje, v opačném poměru k rozdílu mezi "
"hodnotami <parameter>lower</parameter> a <parameter>upper</parameter> jeho "
"objektu <classname>Adjustment</classname>."

#: C/gtkmm-tutorial-in.xml:3744(para)
msgid ""
"You probably won't ever need to attach a handler to this signal, unless "
"you're writing a new type of range widget."
msgstr ""
"Pravděpodobně nebudete muset pokaždé napojit obsluhu k tomuto signálu, vyjma "
"případů, kdy používáte nový typ widgetu <classname>Range</classname>."

#: C/gtkmm-tutorial-in.xml:3748(programlisting)
#, no-wrap
msgid "adjustment-&gt;signal_changed();"
msgstr "adjustment-&gt;signal_changed();"

#: C/gtkmm-tutorial-in.xml:3755(title)
msgid "Widgets Without X-Windows"
msgstr "Widgety bez X-Windows"

#: C/gtkmm-tutorial-in.xml:3757(para)
msgid ""
"Some Widgets do not have an associated X-Window, so they therefore do not "
"receive X events. This means that the signals described in the <link linkend="
"\"sec-xeventsignals\">X event signals</link> section will not be emitted. If "
"you want to capture events for these widgets you can use a special container "
"called <classname>Gtk::EventBox</classname>, which is described in the <link "
"linkend=\"sec-eventbox\">EventBox</link> section."
msgstr ""
"Některé  widget nemají přiřazené X-Window, takže nepřijímají události od X "
"Serveru. Z toho důvodu nejsou vysílány signály popsané v oddíle <link "
"linkend=\"sec-xeventsignals\">Signály událostí X</link>. Jestliže chcete "
"zachytávat události pro tyto widgety, můžete použít speciální kontejner "
"<classname>Gtk::EventBox</classname>, který je popsán v oddíle <link linkend="
"\"sec-eventbox\">EventBox</link>."

#: C/gtkmm-tutorial-in.xml:3766(para)
msgid "Here is a list of some of these Widgets:"
msgstr "Zde je seznam některých těchto widgetů:"

#: C/gtkmm-tutorial-in.xml:3769(programlisting)
#, no-wrap
msgid ""
"Gtk::Alignment\n"
"Gtk::Arrow\n"
"Gtk::AspectFrame\n"
"Gtk::Bin\n"
"Gtk::Box\n"
"Gtk::Button\n"
"Gtk::CheckButton\n"
"Gtk::Fixed\n"
"Gtk::Frame\n"
"Gtk::Grid\n"
"Gtk::Image\n"
"Gtk::Label\n"
"Gtk::MenuItem\n"
"Gtk::Notebook\n"
"Gtk::Paned\n"
"Gtk::RadioButton\n"
"Gtk::Range\n"
"Gtk::ScrolledWindow\n"
"Gtk::Separator\n"
"Gtk::Table (deprecated from <application>gtkmm</application> version 3.4)\n"
"Gtk::Toolbar"
msgstr ""
"Gtk::Alignment\n"
"Gtk::Arrow\n"
"Gtk::AspectFrame\n"
"Gtk::Bin\n"
"Gtk::Box\n"
"Gtk::Button\n"
"Gtk::CheckButton\n"
"Gtk::Fixed\n"
"Gtk::Frame\n"
"Gtk::Grid\n"
"Gtk::Image\n"
"Gtk::Label\n"
"Gtk::MenuItem\n"
"Gtk::Notebook\n"
"Gtk::Paned\n"
"Gtk::RadioButton\n"
"Gtk::Range\n"
"Gtk::ScrolledWindow\n"
"Gtk::Separator\n"
"Gtk::Table (zavrženo od <application>gtkmm</application> verze 3.4)\n"
"Gtk::Toolbar"

#: C/gtkmm-tutorial-in.xml:3791(para)
msgid ""
"These widgets are mainly used for decoration or layout, so you won't often "
"need to capture events on them. They are intended to have no X-Window in "
"order to improve performance."
msgstr ""
"Tyto widgety se používají hlavně k dekoracím a rozvržení, takže u nich často "
"nepotřebujete zachytávat události. Jsou předurčené k tomu, nemít žádné "
"vlastní okno X, aby se dosáhlo lepší výkonnosti."

#: C/gtkmm-tutorial-in.xml:3797(title) C/gtkmm-tutorial-in.xml:3841(title)
msgid "EventBox"
msgstr "Schránka událostí (EventBox)"

#: C/gtkmm-tutorial-in.xml:3799(para)
msgid ""
"Some <application>gtkmm</application> widgets don't have associated X "
"windows; they draw on their parents' windows. Because of this, they cannot "
"receive events. Also, if they are incorrectly sized, they don't clip, so you "
"can get messy overwriting etc. To receive events on one of these widgets, "
"you can place it inside an <classname>EventBox</classname> widget and then "
"call <methodname>Gtk::Widget::set_events()</methodname> on the EventBox "
"before showing it."
msgstr ""
"Některé widgety <application>gtkmm</application> nemají přidružené okno X a "
"kreslí do oken svých rodičů. Kvůli tomu ale nemohou přijímat události. "
"Navíc, když mají špatně nastavenou velikost, neprovádí ořezání, takže může "
"docházet k různému přepisování obsahuj apod. Když chcete přijímat události v "
"nějakém takovém widgetu, můžete jej umístit dovnitř widgetu "
"<classname>EventBox</classname> a pak před zobrazením zavolat na "
"<classname>EventBox</classname> metodu <methodname>Gtk::Widget::"
"set_events()</methodname>."

#: C/gtkmm-tutorial-in.xml:3807(para)
msgid ""
"Although the name <classname>EventBox</classname> emphasises the event-"
"handling method, the widget can also be used for clipping (and more; see the "
"example below)."
msgstr ""
"Ačkoliv název <classname>EventBox</classname> zdůrazňuje metodu obsluhy "
"událostí, dá se widget používat také k ořezávání (a dalším věcem; viz "
"příklad dále)."

#. <para>TODO: Why don't they have X Windows - explain clipping.
#. Also, how does this affect platform such as Windows and MacOS that don't use X.
#. </para>
#: C/gtkmm-tutorial-in.xml:3817(para)
msgid "The constructor for <classname>Gtk::EventBox</classname> is:"
msgstr "Konstruktor pro <classname>Gtk::EventBox</classname> je:"

#: C/gtkmm-tutorial-in.xml:3821(programlisting)
#, no-wrap
msgid "Gtk::EventBox();"
msgstr "Gtk::EventBox();"

#: C/gtkmm-tutorial-in.xml:3823(para)
msgid ""
"A child widget can be added to the <classname>EventBox</classname> using:"
msgstr ""
"Synovský widget je možné přidat do <classname>EventBox</classname> pomocí:"

#: C/gtkmm-tutorial-in.xml:3827(programlisting)
#, no-wrap
msgid "event_box.add(child_widget);"
msgstr "event_box.add(child_widget);"

#: C/gtkmm-tutorial-in.xml:3833(para)
msgid ""
"The following example demonstrates both uses of an <classname>EventBox</"
"classname> - a label is created that is clipped to a small box, and set up "
"so that a mouse-click on the label causes the program to exit. Resizing the "
"window reveals varying amounts of the label."
msgstr ""
"Následující příklad ukazuje obojí využití třídy <classname>EventBox</"
"classname> – popisek je vytvořen tak, že je oříznut do malého boxu a "
"nastaven tak, že kliknutí myší na něm způsobí ukončení programu. Změna "
"velikosti okna odkryje další část popisku."

#: C/gtkmm-tutorial-in.xml:3855(title)
msgid "Dialogs"
msgstr "Dialogová okna"

#: C/gtkmm-tutorial-in.xml:3857(para)
msgid ""
"Dialogs are used as secondary windows, to provide specific information or to "
"ask questions. <classname>Gtk::Dialog</classname> windows contain a few pre-"
"packed widgets to ensure consistency, and a <methodname>run()</methodname> "
"method which blocks until the user dismisses the dialog."
msgstr ""
"Dialogová okna se používají jako podružná okna pro poskytování informací "
"nebo pokládání dotazů. Okna <classname>Gtk::Dialog</classname> obsahují "
"několik předbalených widgetů pro zajištění jednotného vzhledu a fungování a "
"metodu <methodname>run()</methodname>, která blokuje další činnost, dokud "
"dialogové okno nezmizí."

#: C/gtkmm-tutorial-in.xml:3864(para)
msgid ""
"There are several derived <classname>Dialog</classname> classes which you "
"might find useful. <classname>Gtk::MessageDialog</classname> is used for "
"most simple notifications. But at other times you might need to derive your "
"own dialog class to provide more complex functionality."
msgstr ""
"Od třídy <classname>Dialog</classname> je odvozeno několik dalších tříd, "
"které by se vám mohly hodit. <classname>Gtk::MessageDialog</classname> se "
"používá pro úplně nejjednodušší oznámení. Časem ale můžete potřebovat "
"odvodit svá vlastní dialogová okna, abyste mohli poskytnout ucelenější "
"funkcionalitu."

#: C/gtkmm-tutorial-in.xml:3871(para)
msgid ""
"To pack widgets into a custom dialog, you should pack them into the "
"<classname>Gtk::Box</classname>, available via "
"<methodname>get_content_area()</methodname>. To just add a "
"<classname>Button</classname> to the bottom of the <classname>Dialog</"
"classname>, you could use the <methodname>add_button()</methodname> method."
msgstr ""
"Když chcete do vlastního dialogového okna zabalit widgety, měli byste je "
"balit do instance <classname>Gtk::Box</classname> dostupné přes "
"<methodname>get_content_area()</methodname>. Když chcete jen přidat tlačítko "
"do dolní části dialogového okna, můžete použít metodu "
"<methodname>add_button()</methodname>."

#: C/gtkmm-tutorial-in.xml:3879(para)
msgid ""
"The <methodname>run()</methodname> method returns an <literal>int</literal>. "
"This may be a value from the <literal>Gtk::ResponseType</literal> if the "
"user closed the dialog by clicking a standard button, or it could be the "
"custom response value that you specified when using "
"<methodname>add_button()</methodname>."
msgstr ""
"Metoda <methodname>run()</methodname> vrací hodnotu typu <literal>int</"
"literal>. Může jít o hodnotu z <literal>Gtk::ResponseType</literal>, když "
"uživatel zavře dialogové okno kliknutím na standardní tlačítko, nebo by "
"mohlo jít o vlastní návratovou hodnotu, kterou jste určili při použití "
"<methodname>add_button()</methodname>."

#: C/gtkmm-tutorial-in.xml:3888(title) C/gtkmm-tutorial-in.xml:3903(title)
msgid "MessageDialog"
msgstr "Dialogové okno se zprávou (MessageDialog)"

#: C/gtkmm-tutorial-in.xml:3889(para)
msgid ""
"<classname>MessageDialog</classname> is a convenience class, used to create "
"simple, standard message dialogs, with a message, an icon, and buttons for "
"user response. You can specify the type of message and the text in the "
"constructor, as well as specifying standard buttons via the <literal>Gtk::"
"ButtonsType</literal> enum."
msgstr ""
"<classname>MessageDialog</classname> je užitečná třída používaná k vytváření "
"jednoduchých a standardních dialogových oken se zprávou, ikonou a tlačítky, "
"pomocí kterých může uživatel reagovat. V konstruktoru můžete určit typ "
"zprávy a text a k tomu, pomocí výčtu <literal>Gtk::ButtonsType</literal>, "
"standardní tlačítka."

#: C/gtkmm-tutorial-in.xml:3914(title)
msgid "FileChooserDialog"
msgstr "Dialogové okno pro výběr souboru (FileChooserDialog)"

#: C/gtkmm-tutorial-in.xml:3915(para)
msgid ""
"The <classname>FileChooserDialog</classname> is suitable for use with \"Open"
"\" or \"Save\" menu items."
msgstr ""
"Třída <classname>FileChooserDialog</classname> je užitečná ve spojení s "
"funkcemi „Otevřít“ a „Uložit“."

#: C/gtkmm-tutorial-in.xml:3919(para)
msgid ""
"Most of the useful member methods for this class are actually in the "
"<classname>Gtk::FileChooser</classname> base class."
msgstr ""
"Většina užitečných členských metod této třídy se ve skutečnosti nachází v "
"rodičovské třídě <classname>Gtk::FileChooser</classname>."

#: C/gtkmm-tutorial-in.xml:3930(title)
msgid "FileChooser"
msgstr "Výběr souboru (FileChooser)"

#: C/gtkmm-tutorial-in.xml:3940(title) C/gtkmm-tutorial-in.xml:3953(title)
msgid "ColorChooserDialog"
msgstr "Dialogové okno pro výběr barvy (ColorChooserDialog)"

#: C/gtkmm-tutorial-in.xml:3941(para)
msgid ""
"The <classname>ColorChooserDialog</classname> allows the user to choose a "
"color. The <classname>ColorButton</classname> opens a color selection dialog "
"when it is clicked."
msgstr ""
"<classname>ColorChooserDialog</classname> umožňuje uživateli výběr barvy. "
"Tlačítko <classname>ColorButton</classname> otevře po kliknutí právě toto "
"dialogové okno."

#: C/gtkmm-tutorial-in.xml:3964(title) C/gtkmm-tutorial-in.xml:3977(title)
msgid "FontChooserDialog"
msgstr "Dialogové okno pro výběr písma (FontChooserDialog)"

#: C/gtkmm-tutorial-in.xml:3965(para)
msgid ""
"The <classname>FontChooserDialog</classname> allows the user to choose a "
"font. The <classname>FontButton</classname> opens a font chooser dialog when "
"it is clicked."
msgstr ""
"<classname>FontChooserDialog</classname> umožňuje uživateli výběr fontu. "
"Tlačítko <classname>FontButton</classname> otevře po kliknutí právě toto "
"dialogové okno."

#: C/gtkmm-tutorial-in.xml:3988(title)
msgid "Non-modal AboutDialog"
msgstr "Nemodální dialogové okno s informacemi o aplikaci (AboutDialog)"

#: C/gtkmm-tutorial-in.xml:3989(para)
msgid ""
"The <classname>AboutDialog</classname> offers a simple way to display "
"information about a program, like its logo, name, copyright, website and "
"license."
msgstr ""
"<classname>AboutDialog</classname> nabízí jednoduchý způsob pro zobrazení "
"informací o programu, jako je jeho logo, název, copyright, webové stránky a "
"licence."

#: C/gtkmm-tutorial-in.xml:3993(para)
msgid ""
"Most dialogs in this chapter are modal, that is, they freeze the rest of the "
"application while they are shown. It's also possible to create a non-modal "
"dialog, which does not freeze other windows in the application. The "
"following example shows a non-modal <classname>AboutDialog</classname>. This "
"is perhaps not the kind of dialog you would normally make non-modal, but non-"
"modal dialogs can be useful in other cases. E.g. <application>gedit</"
"application>'s search-and-replace dialog is non-modal."
msgstr ""
"Většina dialogových oken v této kapitole je modálních, což znamená, že po "
"dobu co jsou zobrazená, zmrazí zbytek aplikace. Je možné vytvářet i "
"nemodální dialogová okna, která ostatní okna v aplikaci nezmrazí. "
"Následující příklad ukazuje nemodální <classname>AboutDialog</classname>. "
"Není to ale druh dialogového okna, které byste běžně dělali jako nemodální, "
"ale nemodální dialogová okna se hodí v různých jiných situacích. Např. "
"dialogové okno pro hledání a nahrazování v aplikaci <application>gedit</"
"application> je nemodální."

#: C/gtkmm-tutorial-in.xml:4009(title)
msgid "AboutDialog"
msgstr "Dialogové okno s informacemi o aplikaci (AboutDialog)"

#: C/gtkmm-tutorial-in.xml:4023(title)
msgid "The Drawing Area Widget"
msgstr "Widget sloužící jako plocha pro kreslení"

#: C/gtkmm-tutorial-in.xml:4024(para)
msgid ""
"The <classname>DrawingArea</classname> widget is a blank window that gives "
"you the freedom to create any graphic you desire. Along with that freedom "
"comes the responsibility to handle draw signals on the widget. When a widget "
"is first shown, or when it is covered and then uncovered again it needs to "
"redraw itself. Most widgets have code to do this, but the DrawingArea does "
"not, allowing you to write your own draw signal handler to determine how the "
"contents of the widget will be drawn. This is most often done by overriding "
"the virtual <methodname>on_draw()</methodname> member function."
msgstr ""
"Widget <classname>DrawingArea</classname> je prázdné okno, které vám dává "
"svobodu ve vytváření libovolné grafiky dle přání. Spolu s touto svobodou "
"přichází zodpovědnost za obsluhu kreslicích signálů ve widgetu. Když je "
"widget poprvé zobrazen, nebo když je skryt a pak znovu odkryt, potřebuje se "
"překreslit. Většina widgetů k tomu má kód, ale <classname>DrawingArea</"
"classname> ne, abyste si mohli napsat svoji vlastní obsluhu signálu, která "
"určí, jak se má obsah widgetu nakreslit. Většinou se to dělá přepsáním "
"virtuální členské funkce <methodname>on_draw()</methodname>."

#: C/gtkmm-tutorial-in.xml:4036(para)
msgid ""
"GTK+ uses the <ulink url=\"http://cairographics.org\">Cairo</ulink> drawing "
"API. With <application>gtkmm</application>, you may use the <ulink url="
"\"http://www.cairographics.org/cairomm/\">cairomm</ulink> C++ API for cairo."
msgstr ""
"GTK+ používá kreslicí API <ulink url=\"http://cairographics.org\">Cairo</"
"ulink>. S <application>gtkmm</application> můžete používat <ulink url="
"\"http://www.cairographics.org/cairomm/\">cairomm</ulink>, což je API C++."

#: C/gtkmm-tutorial-in.xml:4041(para)
msgid ""
"You can draw very sophisticated shapes using Cairo, but the methods to do so "
"are quite basic. Cairo provides methods for drawing straight lines, curved "
"lines, and arcs (including circles). These basic shapes can be combined to "
"create more complex shapes and paths which can be filled with solid colors, "
"gradients, patterns, and other things. In addition, Cairo can perform "
"complex transformations, do compositing of images, and render antialiased "
"text."
msgstr ""
"Pomocí Cairo můžete kreslit i velmi složité tvary, ale metody k tomu "
"používané jsou vcelku základní. Cairo poskytuje metody pro kreslení rovných "
"čar, křivek a oblouků (včetně celých kružnic). Tyto základní tvary můžete "
"kombinovat, abyste vytvořili složitější tvary a cesty, které můžete vyplnit "
"plnou barvou, přechody, vzory a dalšími věcmi. Navíc Cairo zvládá komplexní "
"transformace, skládání obrázků a vykreslování vyhlazeného textu."

#: C/gtkmm-tutorial-in.xml:4051(title)
msgid "Cairo and Pango"
msgstr "Cairo a Pango"

#: C/gtkmm-tutorial-in.xml:4052(para)
msgid ""
"Although Cairo can render text, it's not meant to be a replacement for "
"Pango. Pango is a better choice if you need to perform more advanced text "
"rendering such as wrapping or ellipsizing text. Drawing text with Cairo "
"should only be done if the text is part of a graphic."
msgstr ""
"Ačkoliv Cairo umí vykreslit text, neznamená to, že by mohlo nahradit Pango. "
"Pango je lepší volbou, když potřebujete provádět pokročilejší vykreslování "
"textu, jako je zalamování nebo vypouštění textu. Kreslení textu pomocí Cairo "
"by se mělo dělat je v případě, že je text součástí grafiky."

#: C/gtkmm-tutorial-in.xml:4057(para)
msgid ""
"In this section of the tutorial, we'll cover the basic Cairo drawing model, "
"describe each of the basic drawing elements in some detail (with examples), "
"and then present a simple application that uses Cairo to draw a custom clock "
"widget."
msgstr ""
"V této části výukového textu pokryjeme základní kreslicí model Cairo, "
"popíšeme podrobně jednotlivé základní kreslicí prvky (včetně příkladů) a "
"ukážeme si jednoduchou aplikaci, která používá Cairo ke kreslení widgetu s "
"hodinami."

#: C/gtkmm-tutorial-in.xml:4064(title)
msgid "The Cairo Drawing Model"
msgstr "Kreslicí model Cairo"

#: C/gtkmm-tutorial-in.xml:4065(para)
msgid ""
"The basic concept of drawing in Cairo involves defining 'invisible' paths "
"and then stroking or filling them to make them visible."
msgstr ""
"Základní koncept kreslení v Cairo obnáší definici „neviditelných“ cest a "
"jejich následné obtažení a vyplnění, aby byly viditelné."

#: C/gtkmm-tutorial-in.xml:4069(para)
msgid ""
"To do any drawing in <application>gtkmm</application> with Cairo, you must "
"first create a <classname>Cairo::Context</classname> object. This class "
"holds all of the graphics state parameters that describe how drawing is to "
"be done. This includes information such as line width, color, the surface to "
"draw to, and many other things. This allows the actual drawing functions to "
"take fewer arguments to simplify the interface. In <application>gtkmm</"
"application>, a <classname>Cairo::Context</classname> is created by calling "
"the <methodname>Gdk::Window::create_cairo_context()</methodname> function. "
"Since Cairo contexts are reference-counted objects, this function returns a "
"<classname>Cairo::RefPtr&lt;Cairo::Context&gt;</classname> object."
msgstr ""
"Abyste mohli v <application>gtkmm</application> kreslit pomocí Cairo, musíte "
"nejprve vytvořit objekt <classname>Cairo::Context</classname>. Tato třída "
"udržuje všechny parametry s grafickými stavy, které popisují, jak se "
"kreslení provádí. Patří k nim takové informace, jako je tloušťka čáry, "
"barva, plocha, která se má kreslit a mnoho dalších věcí. Díky tomu může "
"aktuální kreslicí funkce přebírat méně parametrů a rozhraní je tak "
"jednodušší. V <application>gtkmm</application> se <classname>Cairo::Context</"
"classname> vytváří voláním funkce <methodname>Gdk::Window::"
"create_cairo_context()</methodname>. Protože kontext Cairo je objekt s "
"počítáním referencí, vrací tato funkce objekt <classname>Cairo::RefPtr&lt;"
"Cairo::Context&gt;</classname>."

#: C/gtkmm-tutorial-in.xml:4082(para)
msgid ""
"The following example shows how to set up a Cairo context with a foreground "
"color of red and a width of 2. Any drawing functions that use this context "
"will use these settings."
msgstr ""
"Následující příklad ukazuje, jak nastavit kontext Cairo s červenou barvou "
"pozadí a tloušťkou 2. Kterákoliv kreslicí funkce, která použije tento "
"kontext, použije toto nastavení."

#: C/gtkmm-tutorial-in.xml:4087(programlisting)
#, no-wrap
msgid ""
"Gtk::DrawingArea myArea;\n"
"Cairo::RefPtr&lt;Cairo::Context&gt; myContext = myArea.get_window()-&gt;create_cairo_context();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);"
msgstr ""
"Gtk::DrawingArea myArea;\n"
"Cairo::RefPtr&lt;Cairo::Context&gt; myContext = myArea.get_window()-&gt;create_cairo_context();\n"
"myContext-&gt;set_source_rgb(1.0, 0.0, 0.0);\n"
"myContext-&gt;set_line_width(2.0);"

#: C/gtkmm-tutorial-in.xml:4091(para)
msgid ""
"Each <classname>Cairo::Context</classname> is associated with a particular "
"<classname>Gdk::Window</classname>, so the first line of the above example "
"creates a <classname>Gtk::DrawingArea</classname> widget and the second line "
"uses its associated <classname>Gdk::Window</classname> to create a "
"<classname>Cairo::Context</classname> object. The final two lines change the "
"graphics state of the context."
msgstr ""
"Každá instance <classname>Cairo::Context</classname> patří k nějakému "
"konkrétnímu <classname>Gdk::Window</classname>., takže první řádek příkladu "
"výše vytvoří widget <classname>Gtk::DrawingArea</classname> a druhý řádek "
"využije k němu patřící <classname>Gdk::Window</classname> k vytvoření "
"objektu <classname>Cairo::Context</classname>. Poslední dva řádky mění "
"grafický stav kontextu."

#: C/gtkmm-tutorial-in.xml:4100(para)
msgid ""
"There are a number of graphics state variables that can be set for a Cairo "
"context. The most common context attributes are color (using "
"<methodname>set_source_rgb()</methodname> or <methodname>set_source_rgba()</"
"methodname> for translucent colors), line width (using "
"<methodname>set_line_width()</methodname>), line dash pattern (using "
"<methodname>set_dash()</methodname>), line cap style (using "
"<methodname>set_line_cap()</methodname>), and line join style (using "
"<methodname>set_line_join()</methodname>), and font styles (using "
"<methodname>set_font_size()</methodname>, <methodname>set_font_face()</"
"methodname> and others). There are many other settings as well, such as "
"transformation matrices, fill rules, whether to perform antialiasing, and "
"others. For further information, see the <ulink url=\"http://www."
"cairographics.org/cairomm/\">cairomm</ulink> API documentation."
msgstr ""
"Existuje řada proměnných s grafickými stavy, které se dají nastavit pro "
"kontext Cairo. Nejběžnějšími atributy kontextu jsou barvy (použijte "
"<methodname>set_source_rgb()</methodname> nebo "
"<methodname>set_source_rgba()</methodname> pro průsvitné barvy), tloušťka "
"čáry (použijte <methodname>set_line_width()</methodname>), vzorek čáry "
"(použijte <methodname>set_dash()</methodname>), styl zakončení čáry "
"(použijte <methodname>set_line_cap()</methodname>), styl spojení čar "
"(použijte <methodname>set_line_join()</methodname>) a styly fontu (použijte "
"<methodname>set_font_size()</methodname>, <methodname>set_font_face()</"
"methodname> atd). Existují i další nastavení, jako jsou transformační "
"matice, pravidla vyplňování, povolení vyhlazování a další. Více informací "
"najdete v dokumentaci k API <ulink url=\"http://www.cairographics.org/"
"cairomm/\">cairomm</ulink>."

#: C/gtkmm-tutorial-in.xml:4132(para)
msgid ""
"It is good practice to put all modifications to the graphics state between "
"<methodname>save()</methodname>/<methodname>restore()</methodname> function "
"calls. For example, if you have a function that takes a <classname>Cairo::"
"Context</classname> reference as an argument, you might implement it as "
"follows:"
msgstr ""
"Je dobrou praxí vložit všechny změny do grafického stavu mezi voláním funkcí "
"<methodname>save()</methodname>/<methodname>restore()</methodname>. "
"Například, když máte funkci, která přebírá jako argument ukazatel na "
"<classname>Cairo::Context</classname>, můžete to implementovat nějak takto:"

#: C/gtkmm-tutorial-in.xml:4138(programlisting)
#, no-wrap
msgid ""
"void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // change graphics state\n"
"    // perform drawing operations\n"
"    context-&gt;restore();\n"
"}"
msgstr ""
"void doSomething(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; context, int x)\n"
"{\n"
"    context-&gt;save();\n"
"    // změna grafického stavu\n"
"    // provedení kreslící operace\n"
"    context-&gt;restore();\n"
"}"

#: C/gtkmm-tutorial-in.xml:4115(para)
msgid ""
"The current state of a <classname>Cairo::Context</classname> can be saved to "
"an internal stack of saved states and later be restored to the state it was "
"in when you saved it. To do this, use the <methodname>save()</methodname> "
"method and the <methodname>restore()</methodname> method. This can be useful "
"if you need to temporarily change the line width and color (or any other "
"graphics setting) in order to draw something and then return to the previous "
"settings. In this situation, you could call <methodname>Cairo::Context::"
"save()</methodname>, change the graphics settings, draw the lines, and then "
"call <methodname>Cairo::Context::restore()</methodname> to restore the "
"original graphics state. Multiple calls to <methodname>save()</methodname> "
"and <methodname>restore()</methodname> can be nested; each call to "
"<methodname>restore()</methodname> restores the state from the matching "
"paired <methodname>save()</methodname>. <placeholder-1/>"
msgstr ""
"Aktuální stav <classname>Cairo::Context</classname> se dá uložit do "
"interního zásobníku stavů a později jej obnovit do stejného stavu, jako byl "
"při uložení. K tomu použijte metodu <methodname>save()</methodname> a metodu "
"<methodname>restore()</methodname>. Může se to hodit, když potřebujete "
"dočasně změnit např. tloušťku a barvu čáry (nebo jiné grafické nastavení), "
"abyste něco nakreslili, a pak se vrátit k předchozímu nastavení. V takové "
"situaci byste mohli zavolat <methodname>Cairo::Context::save()</methodname>, "
"změnit grafické nastavení, nakreslit čáru a zavolat <methodname>Cairo::"
"Context::restore()</methodname> pro obnovení původního grafického stavu. Dá "
"se do sebe postupně vložit i více volání metod <methodname>save()</"
"methodname> a <methodname>restore()</methodname>. Každé volání "
"<methodname>restore()</methodname> pak obnoví stav z příslušného páru volání "
"<methodname>save()</methodname>. <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4147(para)
msgid ""
"The virtual <methodname>on_draw()</methodname> method provides a Cairo "
"context that you shall use for drawing in the <classname>Gtk::DrawingArea</"
"classname> widget. It is not necessary to save and restore this Cairo "
"context in <methodname>on_draw()</methodname>."
msgstr ""
"Virtuální metoda <methodname>on_draw()</methodname> poskytuje kontext Cairo, "
"který byste měli použít ke kreslení ve widgetu <classname>Gtk::DrawingArea</"
"classname>. V <methodname>on_draw()</methodname> není potřeba si tento "
"kontext Cairo ukládat a obnovovat."

#: C/gtkmm-tutorial-in.xml:4155(title)
msgid "Drawing Straight Lines"
msgstr "Kreslení rovných čar"

#: C/gtkmm-tutorial-in.xml:4164(para)
msgid ""
"Since the Cairo graphics library was written with support for multiple "
"output targets (the X window system, PNG images, OpenGL, etc), there is a "
"distinction between user-space and device-space coordinates. The mapping "
"between these two coordinate systems defaults to one-to-one so that integer "
"values map roughly to pixels on the screen, but this setting can be adjusted "
"if desired. Sometimes it may be useful to scale the coordinates so that the "
"full width and height of a window both range from 0 to 1 (the 'unit square') "
"or some other mapping that works for your application. This can be done with "
"the <methodname>Cairo::Context::scale()</methodname> function."
msgstr ""
"Vzhledem k tomu, že grafická knihovna Cairo byla napsána s podporou více "
"výstupních cílů (systém X window, obrázky PNG, OpenGL atd.), existuje zde "
"rozdíl mezi souřadnicemi v uživatelském prostoru a v prostoru zařízení. "
"Výchozí mapování mezi těmito dvěma souřadnicovými systémy je jedna ku jedné, "
"takže celočíselné hodnoty se mapují zhruba na jednotlivé pixely na "
"obrazovce, nastavení se ale klidně můžete přizpůsobit svým potřebám. Někdy "
"může být výhodné změnit měřítko, aby souřadnice měly pro celou šířku i výšku "
"rozsah od 0 do 1 („čtvercové jednotky“) nebo nějaké jiné mapování, které "
"bude vaší aplikaci vyhovovat. Provést to můžete pomocí funkce "
"<methodname>Cairo::Context::scale()</methodname>."

#: C/gtkmm-tutorial-in.xml:4156(para)
msgid ""
"Now that we understand the basics of the Cairo graphics library, we're "
"almost ready to start drawing. We'll start with the simplest of drawing "
"elements: the straight line. But first you need to know a little bit about "
"Cairo's coordinate system. The origin of the Cairo coordinate system is "
"located in the upper-left corner of the window with positive x values to the "
"right and positive y values going down. <placeholder-1/>"
msgstr ""
"Teď, když rozumíme základům grafické knihovny Cairo, jsme více méně "
"připravení začít kreslit. Pojďme začít s nejjednodušším možným útvarem – "
"rovnu čárou. Nejdříve ale musíte něco málo vědět o systému souřadnic v "
"Cairo. Počátek systému souřadnic v Cairo je v levém horním rohu okna s "
"rostoucími kladnými hodnotami x doprava a hodnotami y dolů. <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4179(para)
msgid ""
"In this example, we'll construct a small but fully functional "
"<application>gtkmm</application> program and draw some lines into the "
"window. The lines are drawn by creating a path and then stroking it. A path "
"is created using the functions <methodname>Cairo::Context::move_to()</"
"methodname> and <methodname>Cairo::Context::line_to()</methodname>. The "
"function <methodname>move_to()</methodname> is similar to the act of lifting "
"your pen off of the paper and placing it somewhere else -- no line is drawn "
"between the point you were at and the point you moved to. To draw a line "
"between two points, use the <methodname>line_to()</methodname> function."
msgstr ""
"V tomto příkladu sestavíme malý, ale plně funkční program používající "
"<application>gtkmm</application> a nakreslíme do okna pár čar. Čáry se "
"kreslí vytvořením cesty a jejím obtažením. Cesta se vytváří pomocí funkcí "
"<methodname>Cairo::Context::move_to()</methodname> a <methodname>Cairo::"
"Context::line_to()</methodname>. Funkce <methodname>move_to()</methodname> "
"funguje podobně, jako když zvednete pero nad papír a posunete ruku jinam a "
"znovu jej přiložíte – během přesunu ruky pero nic nekreslilo. Pro kreslení "
"čáry mezi dvěma body se používá funkce <methodname>line_to()</methodname>."

#: C/gtkmm-tutorial-in.xml:4191(para)
msgid ""
"After you've finished creating your path, you still haven't drawn anything "
"visible yet. To make the path visible, you must use the function "
"<methodname>stroke()</methodname> which will stroke the current path with "
"the line width and style specified in your <classname>Cairo::Context</"
"classname> object. After stroking, the current path will be cleared so that "
"you can start on your next path."
msgstr ""
"Po dokončení tvorby cesty pořád nemáte nakreslené nic viditelného. Aby se "
"cesta zviditelnila, musíte použít funkci <methodname>stroke()</methodname>, "
"která obtáhne cestu čarou s tloušťkou a stylem definovanými v objektu "
"<classname>Cairo::Context</classname>. Po obtažení se aktuální cesta smaže a "
"můžete začít s novou cestou."

#: C/gtkmm-tutorial-in.xml:4200(para)
msgid ""
"Many Cairo drawing functions have a <methodname>_preserve()</methodname> "
"variant. Normally drawing functions such as <methodname>clip()</methodname>, "
"<methodname>fill()</methodname>, or <methodname>stroke()</methodname> will "
"clear the current path. If you use the <methodname>_preserve()</methodname> "
"variant, the current path will be retained so that you can use the same path "
"with the next drawing function."
msgstr ""
"Mnoho kreslicích funkcí Cairo má variantu <methodname>_preserve()</"
"methodname>. Normální kreslicí funkce, jako jsou <methodname>clip()</"
"methodname>, <methodname>fill()</methodname> nebo <methodname>stroke()</"
"methodname>, mažou aktuální cestu. Když použijete variantu "
"<methodname>_preserve()</methodname>, bude aktuální cesta ponechána, takže "
"ji můžete použít v následující kreslicí funkci."

#: C/gtkmm-tutorial-in.xml:4210(title) C/gtkmm-tutorial-in.xml:4328(title)
msgid "Drawing Area - Lines"
msgstr "Kreslicí oblast – čáry"

#: C/gtkmm-tutorial-in.xml:4218(para)
msgid ""
"This program contains a single class, <classname>MyArea</classname>, which "
"is a subclass of <classname>Gtk::DrawingArea</classname> and contains an "
"<methodname>on_draw()</methodname> member function. This function is called "
"whenever the image in the drawing area needs to be redrawn. It is passed a "
"<classname>Cairo::RefPtr</classname> pointer to a <classname>Cairo::Context</"
"classname> that we use for the drawing. The actual drawing code sets the "
"color we want to use for drawing by using <methodname>set_source_rgb()</"
"methodname> which takes arguments defining the Red, Green, and Blue "
"components of the desired color (valid values are between 0 and 1). After "
"setting the color, we created a new path using the functions "
"<methodname>move_to()</methodname> and <methodname>line_to()</methodname>, "
"and then stroked this path with <methodname>stroke()</methodname>."
msgstr ""
"Tento program obsahuje jednu třídu, <classname>MyArea</classname>, která je "
"podtřídou <classname>Gtk::DrawingArea</classname> a obsahuje členskou funkci "
"<methodname>on_draw()</methodname>. Tato funkce je zavolána vždy, když se má "
"překreslit obrázek v kreslicí oblasti. Je jí předán ukazatel "
"<classname>Cairo::RefPtr</classname> na <classname>Cairo::Context</"
"classname>, který použijeme ke kreslení. Skutečný kreslicí kód nastavuje "
"barvu, kterou chceme použít ke kreslení pomocí <methodname>set_source_rgb()</"
"methodname>, která má argumenty definující červenou, zelenou a modrou složku "
"požadované barvy (platné jsou hodnoty mezi 0 a 1). Po nastavení barvy "
"vytvoříme novou cestu pomocí funkcí <methodname>move_to()</methodname> a "
"<methodname>line_to()</methodname> a obtáhneme ji pomocí "
"<methodname>stroke()</methodname>."

#: C/gtkmm-tutorial-in.xml:4235(title)
msgid "Drawing with relative coordinates"
msgstr "Kreslení s relativními souřadnicemi"

#: C/gtkmm-tutorial-in.xml:4236(para)
msgid ""
"In the example above we drew everything using absolute coordinates. You can "
"also draw using relative coordinates. For a straight line, this is done with "
"the function <methodname>Cairo::Context::rel_line_to()</methodname>."
msgstr ""
"V příkladu výše jsme všechno nakreslili pomocí absolutních souřadnic. Můžeme "
"kreslit také pomocí relativních souřadnic. Pro přímé čáry se to dělá pomocí "
"funkce <methodname>Cairo::Context::rel_line_to()</methodname>."

#: C/gtkmm-tutorial-in.xml:4242(title)
msgid "Line styles"
msgstr "Styly čar"

#: C/gtkmm-tutorial-in.xml:4243(para)
msgid ""
"In addition to drawing basic straight lines, there are a number of things "
"that you can customize about a line. You've already seen examples of setting "
"a line's color and width, but there are others as well."
msgstr ""
"Mimo kreslení základních rovných čar, existuje řada věcí, které si u čar "
"můžete přizpůsobit. Již jste viděli příklad nastavení barvy a tloušťky čáry, "
"ale jsou tu i další."

#: C/gtkmm-tutorial-in.xml:4249(para)
msgid ""
"If you've drawn a series of lines that form a path, you may want them to "
"join together in a certain way. Cairo offers three different ways to join "
"lines together: Miter, Bevel, and Round. These are show below:"
msgstr ""
"Když kreslíte posloupnost čar ve formě cesty, můžete je chtít spojovat "
"dohromady konkrétním způsobem. Cairo nabízí tři různé způsoby, jak čáry "
"spojit: hranatý spoj – Miter, zkosený spoj – Bevel a zaoblený spoj – Round. "
"Zde jsou ukázané ve zmíněném pořadí:"

#: C/gtkmm-tutorial-in.xml:4256(title)
msgid "Different join types in Cairo"
msgstr "Různé typy spojů v Cairo"

#: C/gtkmm-tutorial-in.xml:4261(para)
msgid ""
"The line join style is set using the function <methodname>Cairo::Context::"
"set_line_join()</methodname>."
msgstr ""
"Styl spojování čar se nastavuje pomocí funkce <methodname>Cairo::Context::"
"set_line_join()</methodname>."

#: C/gtkmm-tutorial-in.xml:4265(para)
msgid ""
"Line ends can have different styles as well. The default style is for the "
"line to start and stop exactly at the destination points of the line. This "
"is called a Butt cap. The other options are Round (uses a round ending, with "
"the center of the circle at the end point) or Square (uses a squared ending, "
"with the center of the square at the end point). This setting is set using "
"the function <methodname>Cairo::Context::set_line_cap()</methodname>."
msgstr ""
"Stejně tak mohou mít různé styly konce čar. Výchozí styl pro čáru je začínat "
"a končit přesně v koncových bodech čáry. To se nazývá rovný konec – Butt. "
"Dalšími volbami jsou zaoblení – Round (zaoblení má střed v koncovém bodu) a "
"čtvercový konec – Square (rovněž čtverec má střed v koncovém bodu). Tyto "
"volby se nastavují pomocí funkce <methodname>Cairo::Context::set_line_cap()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:4275(para)
msgid ""
"There are other things you can customize as well, including creating dashed "
"lines and other things. For more information, see the Cairo API "
"documentation."
msgstr ""
"Existují i další věci, které si můžete přizpůsobit, včetně vytváření "
"přerušovaných čar a jiného. Více informací najdete v dokumentaci k API Cairo."

#: C/gtkmm-tutorial-in.xml:4282(title)
msgid "Drawing thin lines"
msgstr "Kreslení tenkých čar"

#: C/gtkmm-tutorial-in.xml:4283(para)
msgid ""
"If you try to draw one pixel wide lines, you may notice that the line "
"sometimes comes up blurred and wider than it ought to be. This happens "
"because Cairo will try to draw from the selected position, to both sides "
"(half to each), so if you're positioned right on the intersection of the "
"pixels, and want a one pixel wide line, Cairo will try to use half of each "
"adjacent pixel, which isn't possible (a pixel is the smallest unit "
"possible). This happens when the width of the line is an odd number of "
"pixels (not just one pixel)."
msgstr ""
"Když zkusíte kreslit čáru tlustou jeden pixel, můžete být překvapeni, že "
"místy bude čára rozmazaná a širší, než by měla. To se děje, protože Cairo se "
"snaží kreslit z vybraných souřadnic obě strany (polovinu tloušťky na každou "
"stranu), takže když zadáte umístění přesně mezi pixely a chcete jeden pixel "
"tlustou čáru, pokouší se Cairo použí polovinu z každého pixelu, což není "
"možní (pixel je nejmenší možná jednotka). Děje se to pokaždé, když je "
"tloušťka čáry lichý počet pixelů (ne jen pro jeden pixel)."

#: C/gtkmm-tutorial-in.xml:4293(para)
msgid ""
"The trick is to position in the middle of the pixel where you want the line "
"to be drawn, and thus guaranteeing you get the desired results. See <ulink "
"url=\"http://cairographics.org/FAQ/#sharp_lines\">Cairo FAQ</ulink>."
msgstr ""
"Trik je v umístění uprostřed pixelu, kde chcete čáru nakreslit, čímž se "
"garantuje, že dostanete požadované výsledky. Viz <ulink url=\"http://"
"cairographics.org/FAQ/#sharp_lines\">Časté dotazy a odpovědi ke knihovně "
"Cairo</ulink>."

#: C/gtkmm-tutorial-in.xml:4300(title)
msgid "Drawing Area - Thin Lines"
msgstr "Kreslicí oblast – tenké čáry"

#: C/gtkmm-tutorial-in.xml:4311(title)
msgid "Drawing Curved Lines"
msgstr "Kreslení křivek"

#: C/gtkmm-tutorial-in.xml:4312(para)
msgid ""
"In addition to drawing straight lines Cairo allows you to easily draw curved "
"lines (technically a cubic Bézier spline) using the <methodname>Cairo::"
"Context::curve_to()</methodname> and <methodname>Cairo::Context::"
"rel_curve_to()</methodname> functions. These functions take coordinates for "
"a destination point as well as coordinates for two 'control' points. This is "
"best explained using an example, so let's dive in."
msgstr ""
"Mimo rovných čar umožňuje Cairo kreslit jednoduše i křivky (přesný technický "
"termín je kubické Bézierovy splajny) pomocí funkcí <methodname>Cairo::"
"Context::curve_to()</methodname> a <methodname>Cairo::Context::"
"rel_curve_to()</methodname>. Tyto funkce přebírají souřadnice pro cílový bod "
"a souřadnice dvou „řídících“ bodů. Nejlépe to bude vysvětlit na příkladu, "
"tak pojďme na to."

#: C/gtkmm-tutorial-in.xml:4323(para)
msgid ""
"This simple application draws a curve with Cairo and displays the control "
"points for each end of the curve."
msgstr ""
"Tato jednoduchá aplikace kreslí pomocí Cairo křivku a zobrazuje řídící body "
"pro její jednotlivé konce."

#: C/gtkmm-tutorial-in.xml:4335(para)
msgid ""
"The only difference between this example and the straight line example is in "
"the <methodname>on_draw()</methodname> function, but there are a few new "
"concepts and functions introduced here, so let's examine them briefly."
msgstr ""
"Jediný rozdíl mezi tímto příkladem a příkladem s rovnými čárami je ve funkci "
"<methodname>on_draw()</methodname>, ale je zde uvedeno pár nových konceptů a "
"funkcí, tak si je pojďme ve stručnosti vysvětlit."

#: C/gtkmm-tutorial-in.xml:4341(para)
msgid ""
"We make a call to <methodname>Cairo::Context::scale()</methodname>, passing "
"in the width and height of the drawing area. This scales the user-space "
"coordinate system such that the width and height of the widget are both "
"equal to 1.0 'units'. There's no particular reason to scale the coordinate "
"system in this case, but sometimes it can make drawing operations easier."
msgstr ""
"Voláme metodu <methodname>Cairo::Context::scale()</methodname> a předáváme "
"jí šířku a výšku kreslicí oblasti. Tím se přepočítá systém souřadnic v "
"uživatelském prostoru, jako by tato šířka a výška widgetu byly obojí rovny "
"1,0 „jednotek“. K tomuto systému přepočítání není žádný konkrétní důvod, ale "
"občas to může kreslení zjednodušit."

#: C/gtkmm-tutorial-in.xml:4350(para)
msgid ""
"The call to <methodname>Cairo::Context::curve_to()</methodname> should be "
"fairly self-explanatory. The first pair of coordinates define the control "
"point for the beginning of the curve. The second set of coordinates define "
"the control point for the end of the curve, and the last set of coordinates "
"define the destination point. To make the concept of control points a bit "
"easier to visualize, a line has been drawn from each control point to the "
"end-point on the curve that it is associated with. Note that these control "
"point lines are both translucent. This is achieved with a variant of "
"<methodname>set_source_rgb()</methodname> called "
"<methodname>set_source_rgba()</methodname>. This function takes a fourth "
"argument specifying the alpha value of the color (valid values are between 0 "
"and 1)."
msgstr ""
"Volání metody <methodname>Cairo::Context::curve_to()</methodname> by mělo "
"být pochopitelné na pohled. První pár souřadnic definuje řídící bod pro "
"začátek křivky. Druhá sada souřadnic definuje řídící bod pro konec křivky a "
"poslední sada souřadnic definuje cílový bod. Abyste si dokázali koncept "
"řídících bodů snáze vizuálně představit, nakreslí se čára z obou řídících "
"bodů do příslušných koncových bodů křivky. Tyto pomocné čáry jsou průsvitné, "
"čehož se dosáhne zavoláním metody <methodname>set_source_rgba()</"
"methodname>, která je jen rozšířenou variantou <methodname>set_source_rgb()</"
"methodname>. Přebírá navíc čtvrtý argument určující alfakanál barvy (platné "
"hodnoty jsou mezi 0 a 1)."

#: C/gtkmm-tutorial-in.xml:4368(title)
msgid "Drawing Arcs and Circles"
msgstr "Kreslení oblouků a kružnic"

#: C/gtkmm-tutorial-in.xml:4369(para)
msgid ""
"With Cairo, the same function is used to draw arcs, circles, or ellipses: "
"<methodname>Cairo::Context::arc()</methodname>. This function takes five "
"arguments. The first two are the coordinates of the center point of the arc, "
"the third argument is the radius of the arc, and the final two arguments "
"define the start and end angle of the arc. All angles are defined in "
"radians, so drawing a circle is the same as drawing an arc from 0 to 2 * "
"M_PI radians. An angle of 0 is in the direction of the positive X axis (in "
"user-space). An angle of M_PI/2 radians (90 degrees) is in the direction of "
"the positive Y axis (in user-space). Angles increase in the direction from "
"the positive X axis toward the positive Y axis. So with the default "
"transformation matrix, angles increase in a clockwise direction. (Remember "
"that the positive Y axis points downwards.)"
msgstr ""
"Ke kreslení oblouků, kružnic a elips se v Cairo používá ta samá funkce: "
"<methodname>Cairo::Context::arc()</methodname>. Tato funkce má pět "
"argumentů. První dva jsou souřadnice středu oblouku, třetí je poloměr "
"oblouku a konečně poslední dva argumenty definují počáteční a koncový úhel "
"oblouku. Všechny úhly se určují v radiánech, takže nakreslení kružnice je to "
"stejné, jako nakreslení oblouku od 0 do 2 * M_PI radiánů. Úhel 0 leží na "
"kladné ose X (v uživatelském prostoru). Úhel M_PI/2 radiánů (90 stupňů) je v "
"kladném směru osy Y (v uživatelském prostoru). Úhel se zvyšuje ve směru z "
"kladné osy X ke kladné ose Y. Takže s výchozí transformační maticí se úhel "
"zvyšuje po směru hodinových ručiček. (Vzpomeňte, že kladná osa Y jde směrem "
"dolů.)"

#: C/gtkmm-tutorial-in.xml:4390(programlisting)
#, no-wrap
msgid ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"
msgstr ""
"context-&gt;save();\n"
"context-&gt;translate(x, y);\n"
"context-&gt;scale(width / 2.0, height / 2.0);\n"
"context-&gt;arc(0.0, 0.0, 1.0, 0.0, 2 * M_PI);\n"
"context-&gt;restore();"

#: C/gtkmm-tutorial-in.xml:4384(para)
msgid ""
"To draw an ellipse, you can scale the current transformation matrix by "
"different amounts in the X and Y directions. For example, to draw an ellipse "
"with center at <varname>x</varname>, <varname>y</varname> and size "
"<varname>width</varname>, <varname>height</varname>: <placeholder-1/>"
msgstr ""
"Abyste nakreslili elipsu, můžete změnit měřítko na různé hodnoty ve směru X "
"a Y v transformační matici. Například, když chcete nakreslit elipsu se "
"středem v <varname>x</varname>, <varname>y</varname> a s šířkou "
"<varname>width</varname> a výškou <varname>height</varname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4398(para)
msgid ""
"Here's an example of a simple program that draws an arc, a circle and an "
"ellipse into a drawing area."
msgstr ""
"Zde je příklad jednoduchého programu, který kreslí do kreslicí oblasti "
"oblouk, kružnici a elipsu."

#: C/gtkmm-tutorial-in.xml:4403(title)
msgid "Drawing Area - Arcs"
msgstr "Kreslicí oblast – oblouky"

#: C/gtkmm-tutorial-in.xml:4412(para)
msgid ""
"There are a couple of things to note about this example code. Again, the "
"only real difference between this example and the previous ones is the "
"<methodname>on_draw()</methodname> function, so we'll limit our focus to "
"that function. In addition, the first part of the function is nearly "
"identical to the previous examples, so we'll skip that portion."
msgstr ""
"Je tu pár věcí, které v tomto příkladu stojí za zmínku. Ještě jednou, jediný "
"skutečný rozdíl mezi tímto příkladem a předchozím je ve funkci "
"<methodname>on_draw()</methodname>, takže se zaměříme jen na ni. Navíc, "
"první část této funkce je hodně podobná předchozímu příkladu, takže ji "
"přeskočíme."

#: C/gtkmm-tutorial-in.xml:4420(para)
msgid ""
"Note that in this case, we've expressed nearly everything in terms of the "
"height and width of the window, including the width of the lines. Because of "
"this, when you resize the window, everything scales with the window. Also "
"note that there are three drawing sections in the function and each is "
"wrapped with a <methodname>save()</methodname>/<methodname>restore()</"
"methodname> pair so that we're back at a known state after each drawing."
msgstr ""
"Všimněte si, že v tomto případě jsme téměř vše vyjádřili v pojmech výšky a "
"šířky okna, včetně tloušťky čar. Díky tomu vše při změně velikosti okna "
"správně změní měřítko. Navíc si všimněte, že jsou ve funkci tři samostatné "
"celky kreslení, které jsou obalené v páru funkcí <methodname>save()</"
"methodname> a <methodname>restore()</methodname>, takže po každém kreslení "
"se vrátíme zpět do známého stavu."

#: C/gtkmm-tutorial-in.xml:4429(para)
msgid ""
"The section for drawing an arc introduces one new function, "
"<methodname>close_path()</methodname>. This function will in effect draw a "
"straight line from the current point back to the first point in the path. "
"There is a significant difference between calling <methodname>close_path()</"
"methodname> and manually drawing a line back to the starting point, however. "
"If you use <methodname>close_path()</methodname>, the lines will be nicely "
"joined together. If you use <methodname>line_to()</methodname> instead, the "
"lines will end at the same point, but Cairo won't do any special joining."
msgstr ""
"V části kreslící oblouk můžete potkat novou funkci <methodname>close_path()</"
"methodname>. Tato funkce se projevuje nakreslením rovné čáry z aktuálního do "
"prvního bodu cesty. Je ale podstatný rozdíl mezi zavoláním "
"<methodname>close_path()</methodname> a ručním nakreslením čáry zpět k "
"počátečnímu bodu. Když použijete <methodname>close_path()</methodname>, "
"budou čáry spolu pěkně spojené. Když místo toho použijete "
"<methodname>line_to()</methodname>, budou čáry sice končit ve stejném bodě, "
"ale Cairo je nijak speciálně nespojí."

#: C/gtkmm-tutorial-in.xml:4442(title)
msgid "Drawing counter-clockwise"
msgstr "Kreslení po směru hodinových ručiček"

#: C/gtkmm-tutorial-in.xml:4443(para)
msgid ""
"The function <methodname>Cairo::Context::arc_negative()</methodname> is "
"exactly the same as <methodname>Cairo::Context::arc()</methodname> but the "
"angles go the opposite direction."
msgstr ""
"Funkce <methodname>Cairo::Context::arc_negative()</methodname> je úplně "
"stejná, jako <methodname>Cairo::Context::arc()</methodname>, jen úhly se "
"počítají v opačném směru."

#: C/gtkmm-tutorial-in.xml:4455(title)
msgid "Drawing Text"
msgstr "Kreslení textu"

#: C/gtkmm-tutorial-in.xml:4457(title)
msgid "Drawing Text with Pango"
msgstr "Kreslení textu pomocí knihovny Pango"

#: C/gtkmm-tutorial-in.xml:4458(para)
msgid ""
"Text is drawn via Pango Layouts. The easiest way to create a "
"<classname>Pango::Layout</classname> is to use <methodname>Gtk::Widget::"
"create_pango_layout()</methodname>. Once created, the layout can be "
"manipulated in various ways, including changing the text, font, etc. "
"Finally, the layout can be rendered using the <methodname>Pango::Layout::"
"show_in_cairo_context()</methodname> method."
msgstr ""
"Text se kreslí pomocí <classname>Layout</classname> z knihovny Pango. "
"Nejjednodušším způsobem, jak vytvořit <classname>Pango::Layout</classname>, "
"je použít <methodname>Gtk::Widget::create_pango_layout()</methodname>. Když "
"je vytvořený, dá se s ním pracovat několika způsoby, včetně změny textu, "
"fontu apod. Nakonec jej můžete vykreslit pomocí metody <methodname>Pango::"
"Layout::show_in_cairo_context()</methodname>."

#: C/gtkmm-tutorial-in.xml:4470(para)
msgid ""
"Here is an example of a program that draws some text, some of it upside-"
"down. The Printing chapter contains another <link linkend=\"sec-printing-"
"example\">example</link> of drawing text."
msgstr ""
"Zde je příklad programu, který vykreslí nějaký text a pak ten stejný vzhůru "
"nohama. Kapitola o tisku obsahuje další <link linkend=\"sec-printing-example"
"\">příklad</link> s kreslením textu."

#: C/gtkmm-tutorial-in.xml:4476(title)
msgid "Drawing Area - Text"
msgstr "Kreslicí oblast – text"

#: C/gtkmm-tutorial-in.xml:4493(title)
msgid "Drawing Images"
msgstr "Kreslení obrázků"

#: C/gtkmm-tutorial-in.xml:4494(para)
msgid ""
"There is a method for drawing from a <classname>Gdk::Pixbuf</classname> to a "
"<classname>Cairo::Context</classname>. A <classname>Gdk::Pixbuf</classname> "
"buffer is a useful wrapper around a collection of pixels, which can be read "
"from files, and manipulated in various ways."
msgstr ""
"Existuje metoda pro kreslení z <classname>Gdk::Pixbuf</classname> do "
"<classname>Cairo::Context</classname>. Vyrovnávací paměť <classname>Gdk::"
"Pixbuf</classname> je užitečná jako obal okolo množiny pixelů tvořících "
"obrázek, které můžete načíst ze souboru a pak s nimi různým způsobem "
"pracovat."

#: C/gtkmm-tutorial-in.xml:4501(para)
msgid ""
"Probably the most common way of creating <classname>Gdk::Pixbuf</classname>s "
"is to use <methodname>Gdk::Pixbuf::create_from_file()</methodname>, which "
"can read an image file, such as a png file into a pixbuf ready for rendering."
msgstr ""
"Pravděpodobně nejčastějším způsobem vytváření objektů <classname>Gdk::"
"Pixbuf</classname> je použití metody <methodname>Gdk::Pixbuf::"
"create_from_file()</methodname>, která načte obrázek ze souboru, jako je "
"soubor <filename>.png</filename>, do pixelové vyrovnávací paměti připravené "
"k vykreslování."

#: C/gtkmm-tutorial-in.xml:4508(para)
msgid ""
"The <classname>Gdk::Pixbuf</classname> can be rendered by setting it as the "
"source pattern of the Cairo context with <methodname>Gdk::Cairo::"
"set_source_pixbuf()</methodname>. Then draw the image with either "
"<methodname>Cairo::Context::paint()</methodname> (to draw the whole image), "
"or <methodname>Cairo::Context::rectangle()</methodname> and "
"<methodname>Cairo::Context::fill()</methodname> (to fill the specified "
"rectangle). <methodname>set_source_pixbuf()</methodname> is not a member of "
"<classname>Cairo::Context</classname>. It takes a <classname>Cairo::Context</"
"classname> as its first parameter."
msgstr ""
"<classname>Gdk::Pixbuf</classname> lze vykreslit jeho nastavením jako "
"zdrojového vzorku v kontextu Cairo pomocí <methodname>Gdk::Cairo::"
"set_source_pixbuf()</methodname>. Pak obrázek nakreslíte pomocí "
"<methodname>Cairo::Context::paint()</methodname> (nakreslí celý obrázek), "
"nebo pomocí <methodname>Cairo::Context::rectangle()</methodname> a "
"<methodname>Cairo::Context::fill()</methodname> (vyplní určený obdélník). "
"<methodname>set_source_pixbuf()</methodname> není členská metoda z "
"<classname>Cairo::Context</classname>. Jako první parametr je vyžadován "
"<classname>Cairo::Context</classname>."

#: C/gtkmm-tutorial-in.xml:4519(para)
msgid ""
"Here is a small bit of code to tie it all together: (Note that usually you "
"wouldn't load the image every time in the draw signal handler! It's just "
"shown here to keep it all together.)"
msgstr ""
"Zde je malý kousek kódu, který dává vše dohromady: (Samozřejmě, že obvykle "
"byste obrázek v obsluze kreslicího signálu nenačítali pokaždé! Zde je to jen "
"proto, aby bylo ukázané vše pohromadě.)"

#: C/gtkmm-tutorial-in.xml:4524(programlisting)
#, no-wrap
msgid ""
"bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)\n"
"{\n"
"  Glib::RefPtr&lt;Gdk::Pixbuf&gt; image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"  // Draw the image at 110, 90, except for the outermost 10 pixels.\n"
"  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);\n"
"  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);\n"
"  cr-&gt;fill();\n"
"  return true;\n"
"}"
msgstr ""
"bool MyArea::on_draw(const Cairo::RefPtr&lt;Cairo::Context&gt;&amp; cr)\n"
"{\n"
"  Glib::RefPtr&lt;Gdk::Pixbuf&gt; image = Gdk::Pixbuf::create_from_file(\"myimage.png\");\n"
"  // Vykreslíme obrázek na 110, 90, vyjma úplně krajních 10 pixelů.\n"
"  Gdk::Cairo::set_source_pixbuf(cr, image, 100, 80);\n"
"  cr-&gt;rectangle(110, 90, image-&gt;get_width()-20, image-&gt;get_height()-20);\n"
"  cr-&gt;fill();\n"
"  return true;\n"
"}"

#: C/gtkmm-tutorial-in.xml:4535(para)
msgid "Here is an example of a simple program that draws an image."
msgstr "Zde je příklad jednoduchého programu, který kreslí obrázek."

#: C/gtkmm-tutorial-in.xml:4539(title)
msgid "Drawing Area - Image"
msgstr "Kreslicí oblast – obrázek"

#: C/gtkmm-tutorial-in.xml:4559(title)
msgid "Example Application: Creating a Clock with Cairo"
msgstr "Ukázková aplikace: Kreslení hodin pomocí knihovny Cairo"

#: C/gtkmm-tutorial-in.xml:4560(para)
msgid ""
"Now that we've covered the basics of drawing with Cairo, let's try to put it "
"all together and create a simple application that actually does something. "
"The following example uses Cairo to create a custom <classname>Clock</"
"classname> widget. The clock has a second hand, a minute hand, and an hour "
"hand, and updates itself every second."
msgstr ""
"Tímto jsme pokryli všechny základy o kreslení pomocí Cairo. Takže to zkusme "
"dát vše dohromady a vytvořit jednoduchou aplikaci, která bude dělat něco "
"reálného. Následující příklad používá Cairo k vytvoření vlastního widgetu s "
"hodinami <classname>Clock</classname>. Hodiny mají sekundovou, minutovou a "
"hodinovou ručičku a aktualizují se po sekundě."

#: C/gtkmm-tutorial-in.xml:4572(para)
msgid ""
"As before, almost all of the interesting stuff is done in the draw signal "
"handler <methodname>on_draw()</methodname>. Before we dig into the draw "
"signal handler, notice that the constructor for the <classname>Clock</"
"classname> widget connects a handler function <methodname>on_timeout()</"
"methodname> to a timer with a timeout period of 1000 milliseconds (1 "
"second). This means that <methodname>on_timeout()</methodname> will get "
"called once per second. The sole responsibility of this function is to "
"invalidate the window so that <application>gtkmm</application> will be "
"forced to redraw it."
msgstr ""
"Stejně jako před tím, se většina zajímavých věcí děje v obsluze kreslicího "
"signálu <methodname>on_draw()</methodname>. Než se ponoříme do této obsluhy "
"signálu, všimněte si, že konstruktor widgetu <classname>Clock</classname> "
"napojuje obsluhu funkce <methodname>on_timeout()</methodname> na časovač s "
"periodou 1000 milisekund (1 sekunda). To znamená, že "
"<methodname>on_timeout()</methodname> bude voláno jednou za sekundu. Jedinou "
"povinností této funkce je zneplatnit obsah okna, takže <application>gtkmm</"
"application> je nuceno jej znovu překreslit."

#: C/gtkmm-tutorial-in.xml:4583(para)
msgid ""
"Now let's take a look at the code that performs the actual drawing. The "
"first section of <methodname>on_draw()</methodname> should be pretty "
"familiar by now. This example again scales the coordinate system to be a "
"unit square so that it's easier to draw the clock as a percentage of window "
"size so that it will automatically scale when the window size is adjusted. "
"Furthermore, the coordinate system is scaled over and down so that the (0, "
"0) coordinate is in the very center of the window."
msgstr ""
"Nyní se zaměřme na kód, který provádí skutečné vykreslení. První část funkce "
"<methodname>on_draw()</methodname> by vám měla být dobře známá. Tento "
"příklad znovu mění měřítko systému souřadnic na čtvercovou jednotku, takže "
"bude jednodušší vykreslit hodiny jako procentní část velikosti okna a při "
"změně velikosti okna dojde k automatickému přizpůsobení velikosti hodin. "
"Navíc je systém souřadnic posunut vpřed a dolů, takže souřadnice (0, 0) je "
"přímo uprostřed okna."

#: C/gtkmm-tutorial-in.xml:4593(para)
msgid ""
"The function <methodname>Cairo::Context::paint()</methodname> is used here "
"to set the background color of the window. This function takes no arguments "
"and fills the current surface (or the clipped portion of the surface) with "
"the source color currently active. After setting the background color of the "
"window, we draw a circle for the clock outline, fill it with white, and then "
"stroke the outline in black. Notice that both of these actions use the "
"<methodname>_preserve</methodname> variant to preserve the current path, and "
"then this same path is clipped to make sure that our next lines don't go "
"outside the outline of the clock."
msgstr ""
"Funkce <methodname>Cairo::Context::paint()</methodname> je zde použita k "
"nastavení barvy pozadí okna. Tato funkce nepřebírá žádný argument a vyplní "
"aktuální povrch (nebo oříznutou část povrchu) právě aktivní zdrojovou "
"barvou. Po nastavení barvy pozadí okna nakreslíme kružnici tvořící obrys "
"hodin a následně tu stejnou cestu ořízneme, abychom si zajistili, že naše "
"následující čáry nepůjdou mimo hodiny."

#: C/gtkmm-tutorial-in.xml:4605(para)
msgid ""
"After drawing the outline, we go around the clock and draw ticks for every "
"hour, with a larger tick at 12, 3, 6, and 9. Now we're finally ready to "
"implement the time-keeping functionality of the clock, which simply involves "
"getting the current values for hours, minutes and seconds, and drawing the "
"hands at the correct angles."
msgstr ""
"Po nakreslení obrysu projdeme po ciferníku a nakreslíme značky pro každou "
"hodinu, s výraznějšími značkami pro 3, 6, 9 a 12 hodin. Nyní máme vše "
"připravené k implementaci funkcionality udržování času na hodinách, což "
"představuje získání aktuální hodnoty pro hodiny, minuty a sekundy a "
"vykreslení ručiček v příslušném úhlu."

#: C/gtkmm-tutorial-in.xml:4617(para)
msgid ""
"<classname>Gtk::Widget</classname> has several methods and signals which are "
"prefixed with \"drag_\". These are used for Drag and Drop."
msgstr ""
"<classname>Gtk::Widget</classname> má několik metod a signálů s předponou "
"„drag_“. Používají se k technice „táhni a upusť“."

#: C/gtkmm-tutorial-in.xml:4622(title)
msgid "Sources and Destinations"
msgstr "Zdroje a cíle"

#: C/gtkmm-tutorial-in.xml:4623(para)
msgid ""
"Things are dragged from <literal>sources</literal> to be dropped on "
"<literal>destinations</literal>. Each source and destination has infomation "
"about the data formats that it can send or receive, provided by "
"<classname>Gtk::TargetEntry</classname> items. A drop destination will only "
"accept a dragged item if they both share a compatible <classname>Gtk::"
"TargetEntry</classname> item. Appropriate signals will then be emitted, "
"telling the signal handlers which <classname>Gtk::TargetEntry</classname> "
"was used."
msgstr ""
"Věci se přetahují ze <literal>zdrojů</literal> a upouští na <literal>cílech</"
"literal>. Jednotlivé zdroje a cíle musí informovat o datových formátech, "
"které umí odesílat a přijímat pomocí položek <classname>Gtk::TargetEntry</"
"classname>. Cíl pro upuštění přijímá přetahovanou položku jen, když oba "
"sdílejí kompatibilní položku <classname>Gtk::TargetEntry</classname>. Pak je "
"vyslán příslušný signál, které říká obsluze signálu, která položka "
"<classname>Gtk::TargetEntry</classname> byla použita."

#: C/gtkmm-tutorial-in.xml:4636(para)
msgid "target: A name, such as \"STRING\""
msgstr "target: Název cíle, jako třeba „STRING“"

#: C/gtkmm-tutorial-in.xml:4637(para)
msgid ""
"info: An identifier which will be sent to your signals to tell you which "
"TargetEntry was used."
msgstr ""
"info: Identifikátor, který bude vyslán do vašeho signálu, aby sdělil, který "
"<classname>TargetEntry</classname> byl použit"

#: C/gtkmm-tutorial-in.xml:4638(para)
msgid ""
"flags: Used only for drag and drop, this specifies whether the data may be "
"dragged to other widgets and applications, or only to the same ones."
msgstr ""
"flags: Příznaky, používané jen pro táhni a upusť, které určují, zda se data "
"smí přetáhnout do jiného widgetu a aplikace, nebo jen do toho stejného."

#: C/gtkmm-tutorial-in.xml:4633(para)
msgid ""
"<classname>Gtk::TargetEntry</classname> objects contain this information: "
"<placeholder-1/>"
msgstr ""
"Objekty <classname>Gtk::TargetEntry</classname> obsahují tyto informace: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4646(para)
msgid ""
"<classname>Widget</classname>s can be identified as sources or destinations "
"using these <classname>Gtk::Widget</classname> methods:"
msgstr ""
"<classname>Widget</classname> může být rozpoznán jako zdroj nebo cíl pomocí "
"těchto metod <classname>Gtk::Widget</classname>:"

#: C/gtkmm-tutorial-in.xml:4650(programlisting)
#, no-wrap
msgid ""
"void drag_source_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);"
msgstr ""
"void drag_source_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"      Gdk::ModifierType start_button_mask, Gdk::DragAction actions);"

#: C/gtkmm-tutorial-in.xml:4655(para)
msgid ""
"<literal>targets</literal> is a vector of <classname>Gtk::TargetEntry</"
"classname> elements."
msgstr ""
"<literal>targets</literal> je vektor prvků <classname>Gtk::TargetEntry</"
"classname>."

#: C/gtkmm-tutorial-in.xml:4661(para)
msgid ""
"<literal>start_button_mask</literal> is an ORed combination of values, which "
"specify which modifier key or mouse button must be pressed to start the drag."
msgstr ""
"<literal>start_button_mask</literal> jsou hodnoty kombinované bitovým NEBO, "
"které určují, jaké modifikační klávesy nebo tlačítka myši musí být "
"zmáčknuty, aby se začalo přetahovat."

#: C/gtkmm-tutorial-in.xml:4668(para)
msgid ""
"<literal>actions</literal> is an ORed combination of values, which specified "
"which Drag and Drop operations will be possible from this source - for "
"instance, copy, move, or link. The user can choose between the actions by "
"using modifier keys, such as <keycap>Shift</keycap> to change from "
"<literal>copy</literal> to <literal>move</literal>, and this will be shown "
"by a different cursor."
msgstr " \t"

#: C/gtkmm-tutorial-in.xml:4679(programlisting)
#, no-wrap
msgid ""
"void drag_dest_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"    Gtk::DestDefaults flags, Gdk::DragAction actions);"
msgstr ""
"void drag_dest_set(const std::vector&lt;Gtk::TargetEntry&gt;&amp; targets,\n"
"    Gtk::DestDefaults flags, Gdk::DragAction actions);"

#: C/gtkmm-tutorial-in.xml:4684(para)
msgid ""
"<literal>flags</literal> is an ORed combination of values which indicates "
"how the widget will respond visually to Drag and Drop items."
msgstr ""
"<literal>flags</literal> jsou hodnoty kombinované pomocí bitového NEBO, "
"které říkají, jak má widget vizuálně reagovat na přetahované položky."

#: C/gtkmm-tutorial-in.xml:4690(para)
msgid ""
"<literal>actions</literal> indicates the Drag and Drop actions which this "
"destination can receive - see the description above."
msgstr ""
"<literal>actions</literal> říká, které akce „Táhni a upusť“ může tento cíl "
"přijímat – viz popis výše."

#: C/gtkmm-tutorial-in.xml:4700(para)
msgid ""
"When a drop destination has accepted a dragged item, certain signals will be "
"emitted, depending on what action has been selected. For instance, the user "
"might have held down the <keycap>Shift</keycap> key to specify a "
"<literal>move</literal> rather than a <literal>copy</literal>. Remember that "
"the user can only select the actions which you have specified in your calls "
"to <methodname>drag_dest_set()</methodname> and "
"<methodname>drag_source_set()</methodname>."
msgstr ""
"Když cíl pro upuštění přijme přetahovanou položku, jsou vyslány některé "
"signály, podle toho, jaká akce byla vybrána. Například, uživatel může držet "
"zmáčknutou klávesu <keycap>Shift</keycap>, aby řekl že chce "
"<literal>přesouvat</literal> a ne <literal>kopírovat</literal>. Pamatujte, "
"že uživatel může vybrat jen akci, kterou jste určili ve svém volání metod "
"<methodname>drag_dest_set()</methodname> a <methodname>drag_source_set()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:4711(title) C/gtkmm-tutorial-in.xml:4848(title)
msgid "Copy"
msgstr "Kopírování"

#: C/gtkmm-tutorial-in.xml:4715(para)
msgid "<literal>drag_begin</literal>: Provides DragContext."
msgstr "<literal>drag_begin</literal>: Poskytuje DragContext."

#: C/gtkmm-tutorial-in.xml:4716(para)
msgid ""
"<literal>drag_data_get</literal>: Provides <literal>info</literal> about the "
"dragged data format, and a <literal>Gtk::SelectionData</literal> structure, "
"in which you should put the requested data."
msgstr ""
"<literal>drag_data_get</literal>: Poskytuje <literal>info</literal> o "
"přetahovaném formátu dat a strukturu <literal>Gtk::SelectionData</literal>, "
"do které byste měli vložit požadovaná data."

#: C/gtkmm-tutorial-in.xml:4717(para)
msgid "<literal>drag_end</literal>: Provides DragContext."
msgstr "<literal>drag_end</literal>: Poskytuje DragContext."

#: C/gtkmm-tutorial-in.xml:4712(para)
msgid ""
"The source widget will emit these signals, in this order: <placeholder-1/>"
msgstr "Zdrojový widget vyšle tyto signály, v tomto pořadí: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4723(para)
msgid ""
"<literal>drag_motion</literal>: Provides DragContext and coordinates. You "
"can call the <methodname>drag_status()</methodname> method of the "
"DragContext to indicate which action will be accepted."
msgstr ""
"<literal>drag_motion</literal>: Poskytuje <classname>DragContext</classname> "
"a souřadnice. Můžete zavolat metodu <methodname>drag_status()</methodname> "
"třídy <classname>DragContext</classname>, abyste zjistili, které akce budou "
"přijaty."

#: C/gtkmm-tutorial-in.xml:4726(para)
msgid ""
"<literal>drag_drop</literal>: Provides DragContext and coordinates. You can "
"call <methodname>drag_get_data()</methodname>, which triggers the "
"<literal>drag_data_get</literal> signal in the source widget, and then the "
"<literal>drag_data_received</literal> signal in the destination widget."
msgstr ""
"<literal>drag_drop</literal>: Poskytuje <classname>DragContext</classname> a "
"souřadnice.. Můžete zavolat metodu <methodname>drag_get_data()</methodname>, "
"která spustí signál <literal>drag_data_get</literal> ve zdrojovém widgetu a "
"signál <literal>drag_data_received</literal> v cílovém widgetu."

#: C/gtkmm-tutorial-in.xml:4731(para)
msgid ""
"<literal>drag_data_received</literal>: Provides <literal>info</literal> "
"about the dragged data format, and a <literal>Gtk::SelectionData</literal> "
"structure which contains the dropped data. You should call the "
"<methodname>drag_finish()</methodname> method of the <literal>DragContext</"
"literal> to indicate whether the operation was successful."
msgstr ""
"<literal>drag_data_received</literal>: Poskytuje <literal>info</literal> o "
"přetahovaném formátu dat a strukturu <literal>Gtk::SelectionData</literal>, "
"která obsahuje upuštěná data. Měli byste zavolat metodu "
"<methodname>drag_finish()</methodname> z <literal>DragContext</literal>, "
"abyste dali najevo, že operace proběhla úspěšně."

#: C/gtkmm-tutorial-in.xml:4720(para)
msgid ""
"The destination widget will emit these signals, in this order: "
"<placeholder-1/>"
msgstr "Cílový widget vyšle tyto signály, v tomto pořadí: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4746(title)
msgid "Move"
msgstr "Přesun"

#: C/gtkmm-tutorial-in.xml:4749(para)
msgid ""
"<literal>drag_data_delete</literal>: Gives the source the opportunity to "
"delete the original data if that's appropriate."
msgstr ""
"<literal>drag_data_delete</literal>: Poskytuje zdroji příležitost smazat "
"původní data, pokud je to vhodné."

#: C/gtkmm-tutorial-in.xml:4747(para)
msgid ""
"During a <literal>move</literal>, the source widget will also emit this "
"signal: <placeholder-1/>"
msgstr ""
"Při <literal>přesouvání</literal> zdrojový widget vyšle také tento signál: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:4763(title)
msgid "DragContext"
msgstr "Kontext přetahování (DragContext)"

#: C/gtkmm-tutorial-in.xml:4764(para)
msgid ""
"The drag and drop signals provide a DragContext, which contains some "
"information about the drag and drop operation and can be used to influence "
"the process. For instance, you can discover the source widget, or change the "
"drag and drop icon, by using the <methodname>set_icon()</methodname> "
"methods. More importantly, you should call the <methodname>drag_finish()</"
"methodname> method from your <literal>drag_data_received</literal> signal "
"handler to indicate whether the drop was successful."
msgstr ""
"Signály pro „táhni a upusť“ poskytuje třída <classname>DragContext</"
"classname>, která obsahuje některé informace o operaci tažení a upuštění a "
"může být použita k ovlivnění procesu. Například můžete najít zdrojový "
"widget, nebo změnit ikonu taženého objektu, pomocí metody "
"<methodname>set_icon()</methodname>. Podstatnější je, že byste měli ze své "
"obsluhy signálu <literal>drag_data_received</literal> zavolat metodu "
"<methodname>drag_finish()</methodname>, abyste dali vědět, jestli upuštění "
"bylo úspěšné."

#: C/gtkmm-tutorial-in.xml:4777(para)
msgid ""
"Here is a very simple example, demonstrating a drag and drop <literal>Copy</"
"literal> operation:"
msgstr ""
"Zde je velmi jednoduchý příklad předvádějící operaci <literal>kopírování</"
"literal> pomocí tažení a upuštění:"

#: C/gtkmm-tutorial-in.xml:4788(para)
msgid "There is a more complex example in examples/others/dnd."
msgstr "V <filename>examples/others/dnd</filename> najdete ucelenější příklad."

#: C/gtkmm-tutorial-in.xml:4797(title)
msgid "The Clipboard"
msgstr "Schránka"

#: C/gtkmm-tutorial-in.xml:4798(para)
msgid ""
"Simple text copy-paste functionality is provided for free by widgets such as "
"<classname>Gtk::Entry</classname> and <classname>Gtk::TextView</classname>, "
"but you might need special code to deal with your own data formats. For "
"instance, a drawing program would need special code to allow copy and paste "
"within a view, or between documents."
msgstr ""
"Jednoduchá funkcionalita kopírování/vložení textu je volně poskytována "
"widgety, jako jsou <classname>Gtk::Entry</classname> a <classname>Gtk::"
"TextView</classname>. Pro zacházení se svým vlastním datovým formátem ale "
"budete potřebovat speciální kód. Například kreslicí program by potřeboval "
"speciální kód, který by zprovoznil kopírování a vkládání v rámci zobrazení, "
"nebo mezi dokumenty."

#: C/gtkmm-tutorial-in.xml:4804(para)
msgid ""
"You can usually pretend that <classname>Gtk::Clipboard</classname> is a "
"singleton. You can get the default clipboard instance with <methodname>Gtk::"
"Clipboard::get()</methodname>. This is probably the only clipboard you will "
"ever need."
msgstr ""
"Obvykle můžete předstírat, že je <classname>Gtk::Clipboard</classname> "
"jedináček. Výchozí instanci schránky můžete získat pomocí <methodname>Gtk::"
"Clipboard::get()</methodname>. Je to pravděpodobně jediná schránka, kterou "
"kdy budete potřebovat."

#: C/gtkmm-tutorial-in.xml:4810(para)
msgid ""
"Your application doesn't need to wait for clipboard operations, particularly "
"between the time when the user chooses Copy and then later chooses Paste. "
"Most <classname>Gtk::Clipboard</classname> methods take <classname>sigc::"
"slot</classname>s which specify callback methods. When <classname>Gtk::"
"Clipboard</classname> is ready, it will call these methods, either providing "
"the requested data, or asking for data."
msgstr ""
"Vaše aplikace nepotřebuje na operace se schránkou čekat, zejména v čase mezi "
"tím, co uživatel použil „Kopírovat“ a chystá se použít „Vložit“. Většina "
"metod <classname>Gtk::Clipboard</classname> přebírá objekty <classname>sigc::"
"slot</classname>, které specifikují metody zpětného volání. Když je "
"<classname>Gtk::Clipboard</classname> připravený, zavolá tyto metody a buď "
"jim poskytne požadovaná data nebo si o data požádá."

#: C/gtkmm-tutorial-in.xml:4822(title)
msgid "Targets"
msgstr "Cíle"

#: C/gtkmm-tutorial-in.xml:4823(para)
msgid ""
"Different applications contain different types of data, and they might make "
"that data available in a variety of formats. <application>gtkmm</"
"application> calls these data types <literal>target</literal>s."
msgstr ""
"Různé aplikace obsahují různé typy dat a ta data mohou zpřístupňovat v "
"různých formátech. <application>gtkmm</application> nazývá takovéto datové "
"typy <literal>cíle</literal> (targets)."

#: C/gtkmm-tutorial-in.xml:4827(para)
msgid ""
"For instance, <application>gedit</application> can supply and receive the "
"<literal>\"UTF8_STRING\"</literal> target, so you can paste data into "
"<application>gedit</application> from any application that supplies that "
"target. Or two different image editing applications might supply and receive "
"a variety of image formats as targets. As long as one application can "
"receive one of the targets that the other supplies then you will be able to "
"copy data from one to the other."
msgstr ""
"Například <application>gedit</application> může dodávat a přijímat cíl "
"<literal>\"UTF8_STRING\"</literal>, takže můžete do aplikace "
"<application>gedit</application> vkládat z libovolné aplikace, která dodává "
"takovýto cíl. Nebo dvě různé aplikace pro úpravy obrázků mohou dodávat a "
"přijímat jako cíle různorodé formáty obrázků. Pokud aplikace umí přijímat "
"jeden z cílů, který ostatní aplikace dodávají, může uživatel kopírovat data "
"z jedné do druhé."

#: C/gtkmm-tutorial-in.xml:4834(para)
msgid ""
"A target can be in a variety of binary formats. This chapter, and the "
"examples, assume that the data is 8-bit text. This would allow us to use an "
"XML format for the clipboard data. However this would probably not be "
"appropriate for binary data such as images. <classname>Gtk::Clipboard</"
"classname> provides overloads that allow you to specify the format in more "
"detail if necessary."
msgstr ""
"Cíle mohou být v různých binárních formátech. Tato kapitola a příklady "
"operují s 8bitovým textem. To by umožnilo používat pro data ve schránce "
"formát XML. Není to ale nejspíše úplně vhodné pro binární data, jako jsou "
"obrázky. <classname>Gtk::Clipboard</classname> poskytuje přetěžování, které "
"vám v případě potřeby umožňuje určit formát mnohem podrobněji."

#: C/gtkmm-tutorial-in.xml:4843(para)
msgid ""
"The <link linkend=\"chapter-draganddrop\">Drag and Drop</link> API uses the "
"same mechanism. You should probably use the same data targets and formats "
"for both Clipboard and Drag and Drop operations."
msgstr ""
"API <link linkend=\"chapter-draganddrop\">Táhni a upusť</link> používá ten "
"stejný mechanizmus. Asi byste měli používat stejné datové cíle a formáty jak "
"pro operace se schránkou, tak pro „táhni a upusť“."

#: C/gtkmm-tutorial-in.xml:4849(para)
msgid ""
"When the user asks to copy some data, you should tell the "
"<classname>Clipboard</classname> what targets are available, and provide the "
"callback methods that it can use to get the data. At this point you should "
"store a copy of the data, to be provided when the clipboard calls your "
"callback method in response to a paste."
msgstr ""
"Když uživatel žádá o zkopírování nějakých dat, měli byste objektu "
"<classname>Clipboard</classname> říci, jaké cíle jsou k dispozici a "
"poskytnout metodu zpětného volání, kterou může použít k získání dat. V tuto "
"chvíli byste si měli uložit kopii dat, abyste je mohli poskytnout, až "
"schránka zavolá vaše zpětné volání v reakci na uživatelovo vložení."

#: C/gtkmm-tutorial-in.xml:4858(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();\n"
"\n"
"//Targets:\n"
"std::vector&lt;Gtk::TargetEntry&gt; targets;\n"
"targets.push_back( Gtk::TargetEntry(\"example_custom_target\") );\n"
"targets.push_back( Gtk::TargetEntry(\"UTF8_STRING\") );\n"
"\n"
"refClipboard-&gt;set( targets,\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );"
msgstr ""
"Glib::RefPtr&lt;Gtk::Clipboard&gt; refClipboard = Gtk::Clipboard::get();\n"
"\n"
"// Cíle:\n"
"std::vector&lt;Gtk::TargetEntry&gt; targets;\n"
"targets.push_back( Gtk::TargetEntry(\"example_custom_target\") );\n"
"targets.push_back( Gtk::TargetEntry(\"UTF8_STRING\") );\n"
"\n"
"refClipboard-&gt;set( targets,\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_get),\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_clear) );"

#: C/gtkmm-tutorial-in.xml:4869(para)
msgid ""
"Your callback will then provide the stored data when the user chooses to "
"paste the data. For instance:"
msgstr ""
"Až uživatel zvolí vložení dat, vaše zpětné volání poskytne uložená data. "
"Například:"

#: C/gtkmm-tutorial-in.xml:4871(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_get(\n"
"    Gtk::SelectionData&amp; selection_data, guint /* info */)\n"
"{\n"
"  const std::string target = selection_data.get_target();\n"
"\n"
"  if(target == \"example_custom_target\")\n"
"    selection_data.set(\"example_custom_target\", m_ClipboardStore);\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_get(\n"
"    Gtk::SelectionData&amp; selection_data, guint /* info */)\n"
"{\n"
"  const std::string target = selection_data.get_target();\n"
"\n"
"  if(target == \"example_custom_target\")\n"
"    selection_data.set(\"example_custom_target\", m_ClipboardStore);\n"
"}"

#: C/gtkmm-tutorial-in.xml:4879(para)
msgid ""
"The <literal>ideal</literal> example below can supply more than one "
"clipboard target."
msgstr ""
"<literal>Ideální</literal> příklad níže by mohl dodávat více než jeden cíl "
"schránky."

#: C/gtkmm-tutorial-in.xml:4883(para)
msgid ""
"The clear callback allows you to free the memory used by your stored data "
"when the clipboard replaces its data with something else."
msgstr ""
"Čistící zpětné volání vám ve chvíli, kdy schránka nahradí stávající data "
"jinými, dá prostor k uvolnění paměti, kterou jste použili u chování dat."

#: C/gtkmm-tutorial-in.xml:4889(title)
msgid "Paste"
msgstr "Vložení"

#: C/gtkmm-tutorial-in.xml:4890(para)
msgid ""
"When the user asks to paste data from the <classname>Clipboard</classname>, "
"you should request a specific format and provide a callback method which "
"will be called with the actual data. For instance:"
msgstr ""
"Když uživatel požádá o vložení dat ze schránky, tj. z objektu "
"<classname>Clipboard</classname>, měli byste si požádat o konkrétní formát a "
"poskytnout metodu zpětného volání, která bude zavolána na skutečná data. "
"Například:"

#: C/gtkmm-tutorial-in.xml:4895(programlisting)
#, no-wrap
msgid ""
"refClipboard-&gt;request_contents(\"example_custom_target\",\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );"
msgstr ""
"refClipboard-&gt;request_contents(\"example_custom_target\",\n"
"    sigc::mem_fun(*this, &amp;ExampleWindow::on_clipboard_received) );"

#: C/gtkmm-tutorial-in.xml:4898(para)
msgid "Here is an example callback method:"
msgstr "Zde je příklad metody zpětného volání:"

#: C/gtkmm-tutorial-in.xml:4900(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_received(\n"
"    const Gtk::SelectionData&amp; selection_data)\n"
"{\n"
"  Glib::ustring clipboard_data = selection_data.get_data_as_string();\n"
"  //Do something with the pasted data.\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_received(\n"
"    const Gtk::SelectionData&amp; selection_data)\n"
"{\n"
"  Glib::ustring clipboard_data = selection_data.get_data_as_string();\n"
"  // Udělat něco s vloženými daty\n"
"}"

#: C/gtkmm-tutorial-in.xml:4908(title)
msgid "Discovering the available targets"
msgstr "Vyhledání dostupných cílů"

#: C/gtkmm-tutorial-in.xml:4909(para)
msgid ""
"To find out what targets are currently available on the "
"<classname>Clipboard</classname> for pasting, call the "
"<methodname>request_targets()</methodname> method, specifying a method to be "
"called with the information. For instance:"
msgstr ""
"Když chcete najít, jaké cíle jsou aktuálně v objektu <classname>Clipboard</"
"classname> dostupné pro vkládání, zavolejte metodu "
"<methodname>request_targets()</methodname> a určete jí svoji metodu, která "
"se má zavolat s informacemi. Například:"

#: C/gtkmm-tutorial-in.xml:4915(programlisting)
#, no-wrap
msgid ""
"refClipboard-&gt;request_targets( sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_clipboard_received_targets) );"
msgstr ""
"refClipboard-&gt;request_targets( sigc::mem_fun(*this,\n"
"    &amp;ExampleWindow::on_clipboard_received_targets) );"

#: C/gtkmm-tutorial-in.xml:4918(para)
msgid ""
"In your callback, compare the vector of available targets with those that "
"your application supports for pasting. You could enable or disable a Paste "
"menu item, depending on whether pasting is currently possible. For instance:"
msgstr ""
"Ve svém zpětném volání porovnejte vektor dostupných cílů s těmi, které vaše "
"aplikace podporuje pro vložení. Mohli byste i povolit nebo zakázat položku "
"nabídky „Vložit“, v závislosti na tom, jestli je vložení zrovna možné. "
"Například:"

#: C/gtkmm-tutorial-in.xml:4921(programlisting)
#, no-wrap
msgid ""
"void ExampleWindow::on_clipboard_received_targets(\n"
"  const std::vector&lt;Glib::ustring&gt;&amp; targets)\n"
"{\n"
"  const bool bPasteIsPossible =\n"
"    std::find(targets.begin(), targets.end(),\n"
"      example_target_custom) != targets.end();\n"
"\n"
"  // Enable/Disable the Paste button appropriately:\n"
"  m_Button_Paste.set_sensitive(bPasteIsPossible);\n"
"}"
msgstr ""
"void ExampleWindow::on_clipboard_received_targets(\n"
"  const std::vector&lt;Glib::ustring&gt;&amp; targets)\n"
"{\n"
"  const bool bPasteIsPossible =\n"
"    std::find(targets.begin(), targets.end(),\n"
"      example_target_custom) != targets.end();\n"
"\n"
"  // Příslušně povolí/zakáže tlačítko pro vložení:\n"
"  m_Button_Paste.set_sensitive(bPasteIsPossible);\n"
"}"

#: C/gtkmm-tutorial-in.xml:4937(title) C/gtkmm-tutorial-in.xml:5330(title)
msgid "Simple"
msgstr "Jednoduchý"

#: C/gtkmm-tutorial-in.xml:4938(para)
msgid ""
"This example allows copy and pasting of application-specific data, using the "
"standard text target. Although this is simple, it's not ideal because it "
"does not identify the <classname>Clipboard</classname> data as being of a "
"particular type."
msgstr ""
"Tento příklad umožňuje kopírovat a vkládat data specifická pro aplikaci "
"pomocí standardního textového cíle. I když je příklad jednoduchý, není "
"ideální, protože nezjišťuje, jestli jsou dat v objektu <classname>Clipboard</"
"classname> konkrétního typu."

#: C/gtkmm-tutorial-in.xml:4946(title)
msgid "Clipboard - Simple"
msgstr "Schránka – jednoduchý příklad"

#: C/gtkmm-tutorial-in.xml:4956(title)
msgid "Ideal"
msgstr "Ideální"

#: C/gtkmm-tutorial-in.xml:4959(simpara)
msgid ""
"Defines a custom clipboard target, though the format of that target is still "
"text."
msgstr "Definuje vlastní cíl schránky, ačkoliv formát cíle zůstává textový."

#: C/gtkmm-tutorial-in.xml:4960(simpara)
msgid ""
"It supports pasting of 2 targets - both the custom one and a text one that "
"creates an arbitrary text representation of the custom data."
msgstr ""
"Podporuje vložení dvou cílů – jak vlastní, tak textový vytváří reprezentaci "
"libovolného textu z vlastních dat."

#: C/gtkmm-tutorial-in.xml:4961(simpara)
msgid ""
"It uses <methodname>request_targets()</methodname> and the "
"<literal>owner_change</literal> signal and disables the Paste button if it "
"can't use anything on the clipboard."
msgstr ""
"Používá <methodname>request_targets()</methodname> a signál "
"<literal>owner_change</literal> a zakazuje tlačítko <guilabel>Paste</"
"guilabel>, když není nic k dispozici pro vložení."

#: C/gtkmm-tutorial-in.xml:4957(para)
msgid "This is like the simple example, but it <placeholder-1/>"
msgstr "Je to hodně podobné jednoduchému příkladu, ale"

#: C/gtkmm-tutorial-in.xml:4966(title)
msgid "Clipboard - Ideal"
msgstr "Schránka – ideální příklad"

#: C/gtkmm-tutorial-in.xml:4982(title)
msgid "Printing"
msgstr "Tisk"

#: C/gtkmm-tutorial-in.xml:4984(para)
msgid ""
"At the application development level, <application>gtkmm</application>'s "
"printing API provides dialogs that are consistent across applications and "
"allows use of Cairo's common drawing API, with Pango-driven text rendering. "
"In the implementation of this common API, platform-specific backends and "
"printer-specific drivers are used."
msgstr ""
"Z hlediska vývoje aplikací, poskytuje tiskové API v <application>gtkmm</"
"application> dialogová okna, která jsou jednotná napříč aplikacemi a "
"umožňují používat běžné kreslicí API Cairo, spolu s vykreslováním textu "
"pomocí knihovny Pango. V implementaci tohoto společného API se používají "
"výkonné části specifické pro platformu a ovladače specifické pro tiskárnu."

#: C/gtkmm-tutorial-in.xml:4990(title)
msgid "PrintOperation"
msgstr "Tisková operace (PrintOperation)"

#: C/gtkmm-tutorial-in.xml:4992(para)
msgid ""
"The primary object is <classname>Gtk::PrintOperation</classname>, allocated "
"for each print operation. To handle page drawing connect to its signals, or "
"inherit from it and override the default virtual signal handlers. "
"<classname>PrintOperation</classname> automatically handles all the settings "
"affecting the print loop."
msgstr ""
"Hlavním objektem je <classname>Gtk::PrintOperation</classname>, který se "
"alokuje zvlášť pro jednotlivé tiskové operace. Abyste mohli obsluhovat "
"kreslení stránky, musíte se napojit na jeho signály, nebo jej zdědit a "
"přepsat jeho výchozí virtuální obsluhy signálů. <classname>PrintOperation</"
"classname> automaticky obsluhuje všechna nastavení ovlivňující tiskovou "
"smyčku."

#: C/gtkmm-tutorial-in.xml:5009(para)
msgid ""
"<literal>begin_print</literal>: You must handle this signal, because this is "
"where you create and set up a <classname>Pango::Layout</classname> using the "
"provided <classname>Gtk::PrintContext</classname>, and break up your "
"printing output into pages."
msgstr ""
"<literal>begin_print</literal>: Tento signál musíte obsluhovat, protože to "
"je místo, kde vytvoříte a nastavíte <classname>Pango::Layout</classname> "
"používaný k poskytnutí <classname>Gtk::PrintContext</classname> a rozdělíte "
"tiskový výstup na stránky."

#: C/gtkmm-tutorial-in.xml:5019(para)
msgid ""
"<literal>paginate</literal>: Pagination is potentially slow so if you need "
"to monitor it you can call the <methodname>PrintOperation::"
"set_show_progress()</methodname> method and handle this signal."
msgstr ""
"<literal>paginate</literal>: Zalomení na stránky může být časově náročná "
"operace, takže jestli ji potřebujete sledovat, můžete zavolat "
"<methodname>PrintOperation::set_show_progress()</methodname> a obsluhovat "
"tento signál."

#: C/gtkmm-tutorial-in.xml:5033(para)
msgid ""
"<literal>request_page_setup</literal>: Provides a <classname>PrintContext</"
"classname>, page number and <classname>Gtk::PageSetup</classname>. Handle "
"this signal if you need to modify page setup on a per-page basis."
msgstr ""
"<literal>request_page_setup</literal>: Poskytuje <classname>PrintContext</"
"classname>, číslo stránky a <classname>Gtk::PageSetup</classname>. "
"Obsluhujte tento signál, když potřebujete měnit nastavení stránek jednotlivě."

#: C/gtkmm-tutorial-in.xml:5042(para)
msgid ""
"<literal>draw_page</literal>: You must handle this signal, which provides a "
"<classname>PrintContext</classname> and a page number. The "
"<classname>PrintContext</classname> should be used to create a "
"<classname>Cairo::Context</classname> into which the provided page should be "
"drawn. To render text, iterate over the <classname>Pango::Layout</classname> "
"you created in the <literal>begin_print</literal> handler."
msgstr ""
"<literal>draw_page</literal>: Musíte obsluhovat tento signál, který "
"poskytuje <classname>PrintContext</classname> a číslo stránky. "
"<classname>PrintContext</classname> by se měl použít k vytvoření "
"<classname>Cairo::Context</classname> a do něj pak nakreslit požadovanou "
"stránku. Když chcete vykreslit text, použijte iteraci nad <classname>Pango::"
"Layout</classname>, který jste vytvořili v obsluze signálu "
"<literal>begin_print</literal>."

#: C/gtkmm-tutorial-in.xml:5028(para)
msgid ""
"For each page that needs to be rendered, the following signals are emitted: "
"<placeholder-1/>"
msgstr ""
"Pro každou stránku, která potřebujete vykreslit, je vyslán následující "
"signál: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5057(para)
msgid ""
"<literal>end_print</literal>: A handler for it is a safe place to free any "
"resources related to a <classname>PrintOperation</classname>. If you have "
"your custom class that inherits from <classname>PrintOperation</classname>, "
"it is naturally simpler to do it in the destructor."
msgstr ""
"<literal>end_print</literal>: Obsluha tohoto signálu je bezpečné místo k "
"uvolnění libovolných prostředků, které se vztahují k objektu "
"<classname>PrintOperation</classname>. Pokud máte vlastní třídu zděděnou z "
"<classname>PrintOperation</classname>, je přirozeně jednodušší to udělat v "
"destruktoru."

#: C/gtkmm-tutorial-in.xml:5067(para)
msgid ""
"<literal>done</literal>: This signal is emitted when printing is finished, "
"meaning when the print data is spooled. Note that the provided <literal>Gtk::"
"PrintOperationResult</literal> may indicate that an error occurred. In any "
"case you probably want to notify the user about the final status."
msgstr ""
"<literal>done</literal>: Signál je vyslán, když je tisk dokončen, míněno, "
"když jsou tisková data zařazena do tiskové fronty. Pamatujte, že poskytnutý "
"objekt <literal>Gtk::PrintOperationResult</literal> může oznamovat chybu, "
"která se při tisku objevila. V takovém případě nejspíše budete chtít na "
"výsledek upozornit uživatele."

#: C/gtkmm-tutorial-in.xml:5077(para)
msgid ""
"<literal>status_changed</literal>: Emitted whenever a print job's status "
"changes, until it is finished. Call the <methodname>PrintOperation::"
"set_track_print_status()</methodname> method to monitor the job status after "
"spooling. To see the status, use <methodname>get_status()</methodname> or "
"<methodname>get_status_string()</methodname>."
msgstr ""
"<literal>status_changed</literal>: Vyšle se, kdykoliv se změní stav tiskové "
"úlohy. Pro sledování stavu úlohy po zařazení do tiskové fronty použijte "
"metodu <methodname>PrintOperation::set_track_print_status()</methodname>. "
"Když chcete zjistit stav, použijte <methodname>get_status()</methodname> "
"nebo <methodname>get_status_string()</methodname>."

#: C/gtkmm-tutorial-in.xml:5003(para)
msgid ""
"The <methodname>PrintOperation::run()</methodname> method starts the print "
"loop, during which various signals are emitted: <placeholder-1/>"
msgstr ""
"Metoda <methodname>PrintOperation::run()</methodname> spouští tiskovou "
"smyčku, během které jsou vyslány různé signály: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5099(title)
msgid "Page setup"
msgstr "Nastavení stránky"

#: C/gtkmm-tutorial-in.xml:5101(para)
msgid ""
"The <classname>PrintOperation</classname> class has a method called "
"<methodname>set_default_page_setup()</methodname> which selects the default "
"paper size, orientation and margins. To show a page setup dialog from your "
"application, use the <methodname>Gtk::run_page_setup_dialog()</methodname> "
"method, which returns a <classname>Gtk::PageSetup</classname> object with "
"the chosen settings. Use this object to update a <classname>PrintOperation</"
"classname> and to access the selected <classname>Gtk::PaperSize</classname>, "
"<literal>Gtk::PageOrientation</literal> and printer-specific margins."
msgstr ""
"Třída <classname>PrintOperation</classname> má metodu nazvanou "
"<methodname>set_default_page_setup()</methodname>, která vybírá výchozí "
"velikost papíru, jeho otočení a okraje. K zobrazení dialogového okna s "
"nastavením stránky pro svoji aplikaci použijte metodu <methodname>Gtk::"
"run_page_setup_dialog()</methodname>, která vrací objekt <classname>Gtk::"
"PageSetup</classname> se zvolený nastavením. Tento objek použijte k "
"aktualizaci <classname>PrintOperation</classname> a k přístupu k vybrané "
"velikosti papíru <classname>Gtk::PaperSize</classname>, otočení papíru "
"<literal>Gtk::PageOrientation</literal> a okrajům, které se liší podle "
"tiskárny."

#: C/gtkmm-tutorial-in.xml:5111(para)
msgid ""
"You should save the chosen <classname>Gtk::PageSetup</classname> so you can "
"use it again if the page setup dialog is shown again."
msgstr ""
"Zvolený <classname>Gtk::PageSetup</classname> byste si měli uložit, abyste "
"jej mohli opětovně použít, když se znovu zobrazí dialogové okno nastavení "
"stránky."

#: C/gtkmm-tutorial-in.xml:5115(programlisting)
#, no-wrap
msgid ""
"\n"
"//Within a class that inherits from Gtk::Window and keeps m_refPageSetup and m_refSettings as members...\n"
"Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"
msgstr ""
"\n"
"// Ve třídě, která je zděděná z Gtk::Window a pamatuje si jako členy m_refPageSetup a m_refSettings…\n"
"Glib::RefPtr&lt;Gtk::PageSetup&gt; new_page_setup = Gtk::run_page_setup_dialog(*this, m_refPageSetup, m_refSettings);\n"
"m_refPageSetup = new_page_setup;\n"

#: C/gtkmm-tutorial-in.xml:5114(para) C/gtkmm-tutorial-in.xml:5179(para)
#: C/gtkmm-tutorial-in.xml:9985(para)
msgid "For instance, <placeholder-1/>"
msgstr "Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5126(para)
msgid ""
"The Cairo coordinate system, in the <literal>draw_page</literal> handler, is "
"automatically rotated to the current page orientation. It is normally within "
"the printer margins, but you can change that via the "
"<methodname>PrintOperation::set_use_full_page()</methodname> method. The "
"default measurement unit is device pixels. To select other units, use the "
"<methodname>PrintOperation::set_unit()</methodname> method."
msgstr ""
"Systém souřadnic v Cairo, v obsluze <literal>draw_page</literal>, je "
"automaticky otočen podle aktuálního otočení stránky. Normálně je v rozmezí "
"tiskových okrajů, ale to můžete změnit pomocí metody "
"<methodname>PrintOperation::set_use_full_page()</methodname>. Výchozí měrnou "
"jednotkou jsou pixely zařízení. K výběru jiných jednotek použijte metodu "
"<methodname>PrintOperation::set_unit()</methodname>."

#: C/gtkmm-tutorial-in.xml:5138(title)
msgid "Rendering text"
msgstr "Vykreslování textu"

#: C/gtkmm-tutorial-in.xml:5140(para)
msgid ""
"Text rendering is done using Pango. The <classname>Pango::Layout</classname> "
"object for printing should be created by calling the "
"<methodname>PrintContext::create_pango_layout()</methodname> method. The "
"<classname>PrintContext</classname> object also provides the page metrics, "
"via <methodname>get_width()</methodname> and <methodname>get_height()</"
"methodname>. The number of pages can be set with <methodname>PrintOperation::"
"set_n_pages()</methodname>. To actually render the Pango text in "
"<literal>on_draw_page</literal>, get a <classname>Cairo::Context</classname> "
"with <methodname>PrintContext::get_cairo_context()</methodname> and show the "
"<classname>Pango::LayoutLine</classname>s that appear within the requested "
"page number."
msgstr ""
"Vykreslování textu se provádí pomocí knihovny Pango. Objekt "
"<classname>Pango::Layout</classname> pro tisk by se měl vytvořit zavoláním "
"metody <methodname>PrintContext::create_pango_layout()</methodname>. Objekt "
"<classname>PrintContext</classname> poskytuje také metriku stránky, přes "
"<methodname>get_width()</methodname> a <methodname>get_height()</"
"methodname>. Počet stránek můžete nastavit pomocí "
"<methodname>PrintOperation::set_n_pages()</methodname>. Abyste mohli v "
"<literal>on_draw_page</literal> provést skutečné vykreslení textu Pango, "
"získejte <classname>Cairo::Context</classname> pomocí "
"<methodname>PrintContext::get_cairo_context()</methodname> a zobrazte "
"objekty <classname>Pango::LayoutLine</classname>, které se tím objeví na "
"příslušné stránce."

#: C/gtkmm-tutorial-in.xml:5155(para)
msgid ""
"See <link linkend=\"sec-printing-example-simple\">an example</link> of "
"exactly how this can be done."
msgstr ""
"Viz <link linkend=\"sec-printing-example-simple\">příklad</link>, jak udělat "
"právě toto."

#: C/gtkmm-tutorial-in.xml:5163(title)
msgid "Asynchronous operations"
msgstr "Asynchronní operace"

#: C/gtkmm-tutorial-in.xml:5165(para)
msgid ""
"By default, <methodname>PrintOperation::run()</methodname> returns when a "
"print operation is completed. If you need to run a non-blocking print "
"operation, call <methodname>PrintOperation::set_allow_async()</methodname>. "
"Note that <methodname>set_allow_async()</methodname> is not supported on all "
"platforms, however the <literal>done</literal> signal will still be emitted."
msgstr ""
"Standardně se <methodname>PrintOperation::run()</methodname> vrací po té, co "
"je tisková operace dokončená. Pokud potřebujete spustit neblokující tiskovou "
"operaci, zavolejte <methodname>PrintOperation::set_allow_async()</"
"methodname>. Pamatujte ale, že <methodname>set_allow_async()</methodname> "
"není podporováno na všech platformách, ale signál <literal>done</literal> "
"bude i tak vyslán."

#: C/gtkmm-tutorial-in.xml:5172(para)
msgid ""
"<methodname>run()</methodname> may return "
"<literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>. To track status and "
"handle the result or error you need to implement signal handlers for the "
"<literal>done</literal> and <literal>status_changed</literal> signals:"
msgstr ""
"<methodname>run()</methodname> může vracet "
"<literal>PRINT_OPERATION_RESULT_IN_PROGRESS</literal>. Abyste mohli sledovat "
"stav a reagovat na výsledky nebo chyby, potřebujete implementovat obsluhu "
"signálu pro signály <literal>done</literal> a <literal>status_changed</"
"literal>:"

#: C/gtkmm-tutorial-in.xml:5180(programlisting)
#, no-wrap
msgid ""
"\n"
"// in class ExampleWindow's method...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// run the op\n"
msgstr ""
"\n"
"// v metodě třídy ExampleWindow …\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// … nastavení operace …\n"
"op-&gt;signal_done().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_done), op));\n"
"// spuštění operace\n"

#: C/gtkmm-tutorial-in.xml:5190(programlisting)
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    //notify user\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    //Update PrintSettings with the ones used in this PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"
msgstr ""
"\n"
"void ExampleWindow::on_printoperation_done(Gtk::PrintOperationResult result, const Glib::RefPtr&lt;PrintOperation&gt;&amp; op)\n"
"{\n"
"  if (result == Gtk::PRINT_OPERATION_RESULT_ERROR)\n"
"    // upozornění uživatele\n"
"  else if (result == Gtk::PRINT_OPERATION_RESULT_APPLY)\n"
"    // Aktualizace PrintSettings s tím, co bylo použito v této PrintOperation\n"
"\n"
"  if (! op-&gt;is_finished())\n"
"    op-&gt;signal_status_changed().connect(sigc::bind(sigc::mem_fun(*this, &amp;ExampleWindow::on_printoperation_status_changed), op));\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:5189(para)
msgid ""
"Second, check for an error and connect to the <literal>status_changed</"
"literal> signal. For instance: <placeholder-1/>"
msgstr ""
"Za druhé zkontrolujeme chyby a napojíme na signál <literal>status_changed</"
"literal>. Například: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5205(programlisting)
#, no-wrap
msgid ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    //the print job is finished\n"
"  else\n"
"    //get the status with get_status() or get_status_string()\n"
"\n"
"  //update UI\n"
"}\n"
msgstr ""
"\n"
"void ExampleWindow::on_printoperation_status_changed(const Glib::RefPtr&lt;PrintFormOperation&gt;&amp; op)\n"
"{\n"
"  if (op-&gt;is_finished())\n"
"    // tisková úloha je dokončená\n"
"  else\n"
"    // získat stav pomocí get_status() nebo get_status_string()\n"
"\n"
"  // aktualizovat uživatelské rozhraní\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:5204(para)
msgid "Finally, check the status. For instance, <placeholder-1/>"
msgstr "Nakonec zkontrolujeme stav. Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5221(title)
msgid "Export to PDF"
msgstr "Export do PDF"

#: C/gtkmm-tutorial-in.xml:5225(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::PrintOperation&gt; op = Gtk::PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"Gtk::PrintOperationResult res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::PrintOperation&gt; op = Gtk::PrintOperation::create();\n"
"// … nastavení operace …\n"
"op-&gt;set_export_filename(\"test.pdf\");\n"
"Gtk::PrintOperationResult res = op-&gt;run(Gtk::PRINT_OPERATION_ACTION_EXPORT);\n"

#: C/gtkmm-tutorial-in.xml:5222(para)
msgid ""
"The 'Print to file' option is available in the print dialog, without the "
"need for extra implementation. However, it is sometimes useful to generate a "
"pdf file directly from code. For instance, <placeholder-1/>"
msgstr ""
"Volba „Tisk do souboru“, která je dostupná v dialogovém okně tisku, "
"nepotřebuje žádnou zvláštní implementaci. Někdy ale může být užitečné "
"vygenerovat soubor PDF přímo z kódu. Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5237(title)
msgid "Extending the print dialog"
msgstr "Rozšířené dialogové okno tisku"

#: C/gtkmm-tutorial-in.xml:5244(para)
msgid ""
"Set the title of the tab via <methodname>PrintOperation::"
"set_custom_tab_label()</methodname>, create a new widget and return it from "
"the <literal>create_custom_widget</literal> signal handler. You'll probably "
"want this to be a container widget, packed with some others."
msgstr ""
"Nastavte název karty přes <methodname>PrintOperation::"
"set_custom_tab_label()</methodname>, vytvořte nový widget a vraťte je z "
"obsluhy signálu <literal>create_custom_widget</literal>. Pravděpodobně "
"budete chtít, aby to byl kontejnerový widget, ve kterém budou zabalené další "
"widgety."

#: C/gtkmm-tutorial-in.xml:5254(para)
msgid ""
"Get the data from the widgets in the <literal>custom_widget_apply</literal> "
"signal handler."
msgstr ""
"Získejte data z widgetů v obsluze signálu <literal>custom_widget_apply</"
"literal>."

#: C/gtkmm-tutorial-in.xml:5239(para)
msgid "You may add a custom tab to the print dialog: <placeholder-1/>"
msgstr ""
"Do tiskového dialogového okna můžete přidat vlastní kartu: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5269(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  Gtk::Box* hbox = new Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 8);\n"
"  hbox-&gt;set_border_width(6);\n"
"\n"
"  Gtk::Label* label = Gtk::manage(new Gtk::Label(\"Enter some text: \"));\n"
"  hbox-&gt;pack_start(*label, false, false);\n"
"  label-&gt;show();\n"
"\n"
"  hbox-&gt;pack_start(m_Entry, false, false);\n"
"  m_Entry.show();\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  Glib::ustring user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"
msgstr ""
"\n"
"Gtk::Widget* CustomPrintOperation::on_create_custom_widget()\n"
"{\n"
"  set_custom_tab_label(\"My custom tab\");\n"
"\n"
"  Gtk::Box* hbox = new Gtk::Box(Gtk::ORIENTATION_HORIZONTAL, 8);\n"
"  hbox-&gt;set_border_width(6);\n"
"\n"
"  Gtk::Label* label = Gtk::manage(new Gtk::Label(\"Enter some text: \"));\n"
"  hbox-&gt;pack_start(*label, false, false);\n"
"  label-&gt;show();\n"
"\n"
"  hbox-&gt;pack_start(m_Entry, false, false);\n"
"  m_Entry.show();\n"
"\n"
"  return hbox;\n"
"}\n"
"\n"
"void CustomPrintOperation::on_custom_widget_apply(Gtk::Widget* /* widget */)\n"
"{\n"
"  Glib::ustring user_input = m_Entry.get_text();\n"
"  //...\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:5262(para)
msgid ""
"Although the <literal>custom_widget_apply</literal> signal provides the "
"widget you previously created, to simplify things you can keep the widgets "
"you expect to contain some user input as class members. For example, let's "
"say you have a <classname>Gtk::Entry</classname> called <literal>m_Entry</"
"literal> as a member of your <classname>CustomPrintOperation</classname> "
"class: <placeholder-1/>"
msgstr ""
"Ačkoliv signál <literal>custom_widget_apply</literal> poskytuje widget, "
"který jste před tím vytvořili, pro zjednodušení věcí si můžete widget, který "
"očekáváte, že obsahuje uživatelův vstup, pamatovat jako člena třídy. "
"Například řekněme, že máme <classname>Gtk::Entry</classname> nazvanou "
"<literal>m_Entry</literal> jako člena vaší třídy "
"<classname>CustomPrintOperation</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5296(para)
msgid "The example in examples/book/printing/advanced demonstrates this."
msgstr "Prakticky to předvádí příklad v examples/book/printing/advanced."

#: C/gtkmm-tutorial-in.xml:5303(title)
msgid "Preview"
msgstr "Náhled"

#: C/gtkmm-tutorial-in.xml:5309(programlisting)
#, no-wrap
msgid ""
"\n"
"// in a class that inherits from Gtk::Window...\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// ...set up op...\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"
msgstr ""
"\n"
"// ve třídě, která je zděděná z Gtk::Window …\n"
"Glib::RefPtr&lt;PrintOperation&gt; op = PrintOperation::create();\n"
"// … nastavení operace …\n"
"op-&gt;run(Gtk::PRINT_OPERATION_ACTION_PREVIEW, *this);\n"

#: C/gtkmm-tutorial-in.xml:5305(para)
msgid ""
"The native GTK+ print dialog has a preview button, but you may also start a "
"preview directly from an application: <placeholder-1/>"
msgstr ""
"Standardní dialogové okno tisku z GTK+ má tlačítko <guilabel>Náhled</"
"guilabel>, ale náhled můžete spustit i přímo z aplikace: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5317(para)
msgid ""
"On Unix, the default preview handler uses an external viewer program. On "
"Windows, the native preview dialog will be shown. If necessary you may "
"override this behaviour and provide a custom preview dialog. See the example "
"located in /examples/book/printing/advanced."
msgstr ""
"V Unixu výchozí obsluha náhledu používá externí prohlížeč. Ve Windows se "
"zobrazí nativní dialogové okno s náhledem. V případě potřeby můžete toto "
"chování přepsat a poskytnout vlastní dialogové okno s náhledem. Viz příklad "
"v /examples/book/printing/advanced."

#: C/gtkmm-tutorial-in.xml:5332(para)
msgid ""
"The following example demonstrates how to print some input from a user "
"interface. It shows how to implement <literal>on_begin_print</literal> and "
"<literal>on_draw_page</literal>, as well as how to track print status and "
"update the print settings."
msgstr ""
"Následující příklad předvádí, jak vytisknout nějaký vstup z uživatelského "
"rozhraní. Ukazuje, jak implementovat <literal>on_begin_print</literal> a "
"<literal>on_draw_page</literal>, a navíc jak sledovat stav tisku a jak "
"aktualizovat nastavení tisku."

#: C/gtkmm-tutorial-in.xml:5340(title)
msgid "Printing - Simple"
msgstr "Tisk – jednoduchý příklad"

#: C/gtkmm-tutorial-in.xml:5355(title)
msgid "Recently Used Documents"
msgstr "Nedávno použité dokumenty"

#: C/gtkmm-tutorial-in.xml:5357(para)
msgid ""
"<application>gtkmm</application> provides an easy way to manage recently "
"used documents. The classes involved in implementing this functionality are "
"<classname>RecentManager</classname>, <classname>RecentChooserDialog</"
"classname>, <classname>RecentChooserMenu</classname>, "
"<classname>RecentChooserWidget</classname>, <classname>RecentAction</"
"classname>, and <classname>RecentFilter</classname>."
msgstr ""
"<application>gtkmm</application> poskytuje jednoduchý způsob, jak spravovat "
"nedávno použité dokumenty. Třídy, které se starají o implementaci této "
"funkcionality, jsou <classname>RecentManager</classname>, "
"<classname>RecentChooserDialog</classname>, <classname>RecentChooserMenu</"
"classname>, <classname>RecentChooserWidget</classname>, "
"<classname>RecentAction</classname> a <classname>RecentFilter</classname>."

#: C/gtkmm-tutorial-in.xml:5367(para)
msgid ""
"Each item in the list of recently used files is identified by its URI, and "
"can have associated metadata. The metadata can be used to specify how the "
"file should be displayed, a description of the file, its mime type, which "
"application registered it, whether it's private to the registering "
"application, and several other things."
msgstr ""
"Jednotlivé položky v seznamu nedávno použitých souborů jsou identifikovány "
"jejich adresou URI a mohou mít přiřazena metadata. Metadata se dají využít k "
"určení, jak se má soubor zobrazovat, popisu souboru, jeho typu MIME, která "
"aplikace jej má registrovaný, jestli je soukromý jen pro registrující "
"aplikaci a dalším věcí."

#: C/gtkmm-tutorial-in.xml:5375(title)
msgid "RecentManager"
msgstr "Správa nedávno použitých (RecentManager)"

#: C/gtkmm-tutorial-in.xml:5376(para)
msgid ""
"<classname>RecentManager</classname> acts as a database of recently used "
"files. You use this class to register new files, remove files from the list, "
"or look up recently used files. There is one list of recently used files per "
"user."
msgstr ""
"<classname>RecentManager</classname> funguje jako databáze nedávno použitých "
"souborů. Tuto třídu můžete použít k registraci nových souborů, odstranění "
"souborů ze seznamu a vyhledání nedávno použitých souborů. Každý uživatel má "
"svůj vlastní seznam nedávno použitých souborů."

#: C/gtkmm-tutorial-in.xml:5382(para)
msgid ""
"You can create a new <classname>RecentManager</classname>, but you'll most "
"likely just want to use the default one. You can get a reference to the "
"default <classname>RecentManager</classname> with <methodname>get_default()</"
"methodname>."
msgstr ""
"Můžete vytvořit nový <classname>RecentManager</classname>, ale nejspíše "
"budete chtít používat výchozí. Ukazatel na výchozí <classname>RecentManager</"
"classname> získáte pomocí metody <methodname>get_default()</methodname>."

#: C/gtkmm-tutorial-in.xml:5388(para)
msgid ""
"<classname>RecentManager</classname> is the model of a model-view pattern, "
"where the view is a class that implements the <classname>RecentChooser</"
"classname> interface."
msgstr ""
"<classname>RecentManager</classname> je model v návrhovém vzoru model-"
"zobrazení. Pro zobrazení slouží třída, která implementuje rozhraní "
"<classname>RecentChooser</classname>."

#: C/gtkmm-tutorial-in.xml:5394(title)
msgid "Adding Items to the List of Recent Files"
msgstr "Přidání položek do seznamu nedávných souborů"

#: C/gtkmm-tutorial-in.xml:5395(para)
msgid ""
"To add a new file to the list of recent documents, in the simplest case, you "
"only need to provide the URI. For example:"
msgstr ""
"Když chcete do seznamu nedávných dokumentů přidat novou položku, v "
"nejjednodušším případě stačí poskytnou adresu URI. Například:"

#: C/gtkmm-tutorial-in.xml:5399(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::RecentManager&gt; recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"
msgstr ""
"Glib::RefPtr&lt;Gtk::RecentManager&gt; recent_manager = Gtk::RecentManager::get_default();\n"
"recent_manager-&gt;add_item(uri);"

#: C/gtkmm-tutorial-in.xml:5401(para)
msgid ""
"If you want to register a file with metadata, you can pass a "
"<classname>RecentManager::Data</classname> parameter to "
"<methodname>add_item()</methodname>. The metadata that can be set on a "
"particular file item is as follows:"
msgstr ""
"Když chcete zaregistrovat soubor včetně metadat, můžete předat do "
"<methodname>add_item()</methodname> parametr <classname>RecentManager::Data</"
"classname>. Metadata mohou být nastavena pro konkrétní položku souboru "
"následovně:"

#: C/gtkmm-tutorial-in.xml:5409(para)
msgid ""
"<varname>app_exec</varname>: The command line to be used to launch this "
"resource. This string may contain the \"f\" and \"u\" escape characters "
"which will be expanded to the resource file path and URI respectively"
msgstr ""
"<varname>app_exec</varname>: Příkazový řádek, který bude použitý ke spuštění "
"tohoto prostředku. Tento řetězec může obsahovat ošetřené znaky „f“ a „u“, "
"které se nahradí souborovou cestou prostředku, respektive jeho adresou URI."

#: C/gtkmm-tutorial-in.xml:5415(para)
msgid ""
"<varname>app_name</varname>: The name of the application that registered the "
"resource"
msgstr ""
"<varname>app_name</varname>: Název aplikace, která registruje prostředky."

#: C/gtkmm-tutorial-in.xml:5419(para)
msgid ""
"<varname>description</varname>: A short description of the resource as a "
"UTF-8 encoded string"
msgstr ""
"<varname>description</varname>: Krátký popis prostředku v podobě řetězce "
"kódovaného v UTF-8."

#: C/gtkmm-tutorial-in.xml:5423(para)
msgid ""
"<varname>display_name</varname>: The name of the resource to be used for "
"display as a UTF-8 encoded string"
msgstr ""
"<varname>display_name</varname>: Název prostředku v podobě řetězce "
"kódovaného v UTF-8, který se použije k zobrazení."

#: C/gtkmm-tutorial-in.xml:5427(para)
msgid ""
"<varname>groups</varname>: A list of groups associated with this item. "
"Groups are essentially arbitrary strings associated with a particular "
"resource. They can be thought of as 'categories' (such as \"email\", "
"\"graphics\", etc) or tags for the resource."
msgstr ""
"<varname>groups</varname>: Seznam skupin přidružených k položce. Skupiny "
"jsou v podstatě libovolné řetězce přidružené ke konkrétnímu prostředku. "
"Můžete o nich uvažovat, jako o kategoriích (třeba „e-mail“, „grafika“, atd.) "
"nebo o štítcích pro prostředek."

#: C/gtkmm-tutorial-in.xml:5433(para)
msgid ""
"<varname>is_private</varname>: Whether this resource should be visible only "
"to applications that have registered it or not"
msgstr ""
"<varname>is_private</varname>:Jestli má být tento prostředek viditelný jen "
"aplikacím, které mají registraci, či nikoliv."

#: C/gtkmm-tutorial-in.xml:5437(para)
msgid "<varname>mime_type</varname>: The MIME type of the resource"
msgstr "<varname>mime_type</varname>: Typ MIME prostředku."

#: C/gtkmm-tutorial-in.xml:5440(para)
msgid ""
"In addition to adding items to the list, you can also look up items from the "
"list and modify or remove items."
msgstr ""
"Mimo přidávání položek do seznamu, můžete položky v seznamu také vyhledávat "
"a měnit nebo odebírat."

#: C/gtkmm-tutorial-in.xml:5446(title)
msgid "Looking up Items in the List of Recent Files"
msgstr "Vyhledávání položek v seznamu nedávných souborů"

#: C/gtkmm-tutorial-in.xml:5447(para)
msgid ""
"To look up recently used files, <classname>RecentManager</classname> "
"provides several functions. To look up a specific item by its URI, you can "
"use the <methodname>lookup_item()</methodname> function, which will return a "
"<classname>RecentInfo</classname> class. If the specified URI did not exist "
"in the list of recent files, <methodname>lookup_item()</methodname> throws a "
"<classname>RecentManagerError</classname> exception. For example:"
msgstr ""
"Pro vyhledání nedávno použitých souborů <classname>RecentManager</classname> "
"poskytuje několik funkcí. K vyhledání konkrétní položky podle její URI "
"můžete použít funkci <methodname>lookup_item()</methodname>, která vrací "
"třídu <classname>RecentInfo</classname>. Pokud zadaná adresa URI v seznamu "
"nedávných souborů neexistuje <methodname>lookup_item()</methodname> vyhodí "
"výjimku <classname>RecentManagerError</classname>. Například:"

#: C/gtkmm-tutorial-in.xml:5456(programlisting)
#, no-wrap
msgid ""
"Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;\n"
"try\n"
"{\n"
"  info = recent_manager-&gt;lookup_item(uri);\n"
"}\n"
"catch(const Gtk::RecentManagerError&amp; ex)\n"
"{\n"
"  std::cerr &lt;&lt; \"RecentManagerError: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n"
"}\n"
"if (info)\n"
"{\n"
"  // item was found\n"
"}"
msgstr ""
"Glib::RefPtr&lt;Gtk::RecentInfo&gt; info;\n"
"try\n"
"{\n"
"  info = recent_manager-&gt;lookup_item(uri);\n"
"}\n"
"catch(const Gtk::RecentManagerError&amp; ex)\n"
"{\n"
"  std::cerr &lt;&lt; \"RecentManagerError: \" &lt;&lt; ex.what() &lt;&lt; std::endl;\n"
"}\n"
"if (info)\n"
"{\n"
"  // položka byla nalezena\n"
"}"

#: C/gtkmm-tutorial-in.xml:5469(para)
msgid ""
"A <classname>RecentInfo</classname> object is essentially an object "
"containing all of the metadata about a single recently-used file. You can "
"use this object to look up any of the properties listed <link linkend=\"list-"
"file-metadata\">above</link>."
msgstr ""
"Objekt <classname>RecentInfo</classname> je v podstatě objekt obsahující "
"všechna metadata o jednom nedávno použitém souboru. Můžete jej využít k "
"vyhledání vlastností uvedených <link linkend=\"list-file-metadata\">v "
"předchozím</link>."

#: C/gtkmm-tutorial-in.xml:5475(para)
msgid ""
"If you don't want to look for a specific URI, but instead want to get a list "
"of all recently used items, <classname>RecentManager</classname> provides "
"the <methodname>get_items()</methodname> function. The return value of this "
"function is a <classname>std::vector</classname> of all recently used files. "
"The following code demonstrates how you might get a list of recently used "
"files:"
msgstr ""
"Pokud nechcete vyhledávat podle konkrétní URI, ale místo toho chcete získat "
"seznam všech nedávno použitých položek, poskytuje <classname>RecentManager</"
"classname> funkci <methodname>get_items()</methodname>. Návratová hodnota "
"této funkce je <classname>std::vector</classname> se všemi nedávno použitými "
"soubory. Následující kód ukazuje, jak můžete seznam nedávno použitých "
"souborů získat:"

#: C/gtkmm-tutorial-in.xml:5483(programlisting)
#, no-wrap
msgid "std::vector&lt; Glib::RefPtr&lt;Gtk::RecentInfo&gt; &gt; info_list = recent_manager-&gt;get_items();"
msgstr "std::vector&lt; Glib::RefPtr&lt;Gtk::RecentInfo&gt; &gt; info_list = recent_manager-&gt;get_items();"

#: C/gtkmm-tutorial-in.xml:5484(para)
msgid ""
"The maximum age of items in the recently used files list can be set with "
"<methodname>Gtk::Settings::property_gtk_recent_files_max_age()</methodname>. "
"Default value: 30 days."
msgstr ""
"Maximální stáří položek v seznamu nedávno použitých položek se dá nastavit "
"pomocí <methodname>Gtk::Settings::property_gtk_recent_files_max_age()</"
"methodname>. Výchozí hodnota je 30 dní."

#: C/gtkmm-tutorial-in.xml:5491(title)
msgid "Modifying the List of Recent Files"
msgstr "Změny seznamu nedávných souborů"

#: C/gtkmm-tutorial-in.xml:5492(para)
msgid ""
"There may be times when you need to modify the list of recent files. For "
"instance, if a file is moved or renamed, you may need to update the file's "
"location in the recent files list so that it doesn't point to an incorrect "
"location. You can update an item's location by using "
"<methodname>move_item()</methodname>."
msgstr ""
"Mohou nastat situace, kdy budete chtít seznam nedávných souborů změnit. "
"Například, když je soubor přesunut nebo přejmenován, můžete potřebovat "
"aktualizovat umístění souboru v seznamu nedávných souborů, aby neodkazoval "
"na nesprávné místo. Aktualizovat umístění položky můžete pomocí "
"<methodname>move_item()</methodname>."

#: C/gtkmm-tutorial-in.xml:5499(para)
msgid ""
"In addition to changing a file's URI, you can also remove items from the "
"list, either one at a time or by clearing them all at once. The former is "
"accomplished with <methodname>remove_item()</methodname>, the latter with "
"<methodname>purge_items()</methodname>."
msgstr ""
"Mimo změny URI souboru můžete také položky ze seznam odstranit, buď po jedné "
"nebo smazat všechny naráz. Prvního zmíněného dosáhnete pomocí "
"<methodname>remove_item()</methodname>, druhého pomocí "
"<methodname>purge_items()</methodname>."

#: C/gtkmm-tutorial-in.xml:5506(para)
msgid ""
"The functions <methodname>move_item()</methodname>, "
"<methodname>remove_item()</methodname> and <methodname>purge_items()</"
"methodname> have no effect on the actual files that are referred to by the "
"URIs, they only modify the list of recent files."
msgstr ""
"Funkce <methodname>move_item()</methodname>, <methodname>remove_item()</"
"methodname> a <methodname>purge_items()</methodname> nemají žádný vliv na "
"skutečné soubory, na které odkazují adresy URI, mění pouze seznam nedávných "
"souborů."

#: C/gtkmm-tutorial-in.xml:5518(title)
msgid "RecentChooser"
msgstr "Výběr nedávno použitých (RecentChooser)"

#: C/gtkmm-tutorial-in.xml:5519(para)
msgid ""
"<classname>RecentChooser</classname> is an interface that can be implemented "
"by widgets displaying the list of recently used files. <application>gtkmm</"
"application> provides four built-in implementations for choosing recent "
"files: <classname>RecentChooserWidget</classname>, "
"<classname>RecentChooserDialog</classname>, <classname>RecentChooserMenu</"
"classname>, and <classname>RecentAction</classname>."
msgstr ""
"<classname>RecentChooser</classname> je rozhraní, které může být "
"implementováno widgety zobrazujícími seznam nedávných souborů. "
"<application>gtkmm</application> poskytuje čtyři vestavěné implementace pro "
"výběr nedávných souborů: <classname>RecentChooserWidget</classname>, "
"<classname>RecentChooserDialog</classname>, <classname>RecentChooserMenu</"
"classname> a <classname>RecentAction</classname>."

#: C/gtkmm-tutorial-in.xml:5528(para)
msgid ""
"<classname>RecentChooserWidget</classname> is a simple widget for displaying "
"a list of recently used files. <classname>RecentChooserWidget</classname> is "
"the basic building block for <classname>RecentChooserDialog</classname>, but "
"you can embed it into your user interface if you want to."
msgstr ""
"<classname>RecentChooserWidget</classname> je jednoduchý widget pro "
"zobrazení seznamu nedávno použitých souborů. <classname>RecentChooserWidget</"
"classname> je základním stavebním kamenem pro "
"<classname>RecentChooserDialog</classname>, ale pokud chcete, můžete jej "
"vestavět do svého uživatelského rozhraní."

#: C/gtkmm-tutorial-in.xml:5535(para)
msgid ""
"<classname>RecentChooserMenu</classname> and <classname>RecentAction</"
"classname> allow you to list recently used files as a menu."
msgstr ""
"Třídy <classname>RecentChooserMenu</classname> a <classname>RecentAction</"
"classname> umožňují vypsat nedávno použité soubory v podobě nabídky."

#: C/gtkmm-tutorial-in.xml:5541(title)
msgid "Simple RecentChooserDialog example"
msgstr "Jednoduchý příklad s RecentChooserDialog"

#: C/gtkmm-tutorial-in.xml:5542(para)
msgid ""
"Shown below is a simple example of how to use the "
"<classname>RecentChooserDialog</classname> and the <classname>RecentAction</"
"classname> classes in a program. This simple program has a menubar with a "
"<guimenuitem>Recent Files Dialog</guimenuitem> menu item. When you select "
"this menu item, a dialog pops up showing the list of recently used files."
msgstr ""
"Níže je zobrazený jednoduchý příklad, jak použít v programu třídy "
"<classname>RecentChooserDialog</classname> a <classname>RecentAction</"
"classname>. Tento jednoduchý příklad má nabídkovou lištu s položkou "
"<guimenuitem>Recent Files Dialog</guimenuitem>. Když tuto položku vyberete, "
"vyskočí dialogové okno, které zobrazí seznam nedávno použitých souborů."

#: C/gtkmm-tutorial-in.xml:5552(para)
msgid ""
"If this is the first time you're using a program that uses the Recent Files "
"framework, the dialog may be empty at first. Otherwise it should show the "
"list of recently used documents registered by other applications."
msgstr ""
"Když je to poprvé, co používáte program, který využívá nedávné soubory, může "
"být dialogové okno napoprvé prázdné. Jinak v něm uvidíte zobrazený seznam "
"nedávno použitých dokumentů zaregistrovaných jinými aplikacemi."

#: C/gtkmm-tutorial-in.xml:5559(para)
msgid ""
"After selecting the <guimenuitem>Recent Files Dialog</guimenuitem> menu "
"item, you should see something similar to the following window."
msgstr ""
"Po vybrání položky <guimenuitem>Recent Files Dialog</guimenuitem> v nabídce "
"byste měli vidět něco podobného následujícímu oknu."

#: C/gtkmm-tutorial-in.xml:5568(para)
msgid ""
"The constructor for <classname>ExampleWindow</classname> creates the menu "
"using <classname>UIManager</classname> (see <xref linkend=\"chapter-menus-"
"and-toolbars\"/> for more information). It then adds the menu and the "
"toolbar to the window."
msgstr ""
"Konstruktor pro <classname>ExampleWindow</classname> vytvoří nabídku pomocí "
"<classname>UIManager</classname> (více informací viz <xref linkend=\"chapter-"
"menus-and-toolbars\"/>). Pak přidá do okna nabídku a nástrojovou lištu."

#: C/gtkmm-tutorial-in.xml:5576(title)
msgid "Filtering Recent Files"
msgstr "Filtrování nedávných souborů"

#: C/gtkmm-tutorial-in.xml:5577(para)
msgid ""
"For any of the <classname>RecentChooser</classname> classes, if you don't "
"wish to display all of the items in the list of recent files, you can filter "
"the list to show only those that you want. You can filter the list with the "
"help of the <classname>RecentFilter</classname> class. This class allows you "
"to filter recent files by their name (<methodname>add_pattern()</"
"methodname>), their mime type (<methodname>add_mime_type()</methodname>), "
"the application that registered them (<methodname>add_application()</"
"methodname>), or by a custom filter function (<methodname>add_custom()</"
"methodname>). It also provides the ability to filter based on how long ago "
"the file was modified and which groups it belongs to."
msgstr ""
"Pře kteroukoliv z tříd <classname>RecentChooser</classname> platí, že když "
"si nepřejete zobrazit všechny položky v seznam nedávných souborů, můžete "
"seznam vyfiltrovat, aby zobrazoval jen ty, které chcete. Seznam se dá "
"filtrovat s pomocí třídy <classname>RecentFilter</classname>. Tato třída vám "
"umožňuje filtrovat nedávné soubory podle jejich názvu "
"(<methodname>add_pattern()</methodname>), typu MIME "
"(<methodname>add_mime_type()</methodname>), aplikace, která je registruje "
"(<methodname>add_application()</methodname>) nebo pomocí vlastní filtrační "
"funkce (<methodname>add_custom()</methodname>). Poskytuje rovněž schopnost "
"filtrovat na základě toho, před jakou dobou byl soubor změněn a jaké patří "
"skupině."

#: C/gtkmm-tutorial-in.xml:5590(para)
msgid ""
"After you've created and set up the filter to match only the items you want, "
"you can apply a filter to a chooser widget with the "
"<methodname>RecentChooser::add_filter()</methodname> function."
msgstr ""
"Po té, co jste vytvořili a nastavili filtr, který vyfiltruje jen ty položky, "
"které chcete, můžete jej použít s widgetem pro výběr pomocí funkce "
"<methodname>RecentChooser::add_filter()</methodname>."

#: C/gtkmm-tutorial-in.xml:5600(title)
msgid "Plugs and Sockets"
msgstr "Zástrčky (Plug) a zásuvky (Socket)"

#: C/gtkmm-tutorial-in.xml:5602(title) C/gtkmm-tutorial-in.xml:5759(title)
msgid "Overview"
msgstr "Přehled"

#: C/gtkmm-tutorial-in.xml:5603(para)
msgid ""
"From time to time, it may be useful to be able to embed a widget from "
"another application within your application. <application>gtkmm</"
"application> allows you to do this with the <classname>Gtk::Socket</"
"classname> and <classname>Gtk::Plug</classname> classes. It is not "
"anticipated that very many applications will need this functionality, but in "
"the rare case that you need to display a widget that is running in a "
"completely different process, these classes can be very helpful."
msgstr ""
"Čas od času by se mohlo hodit mít možnost vložit widget z jiné aplikace do "
"svojí aplikace. <application>gtkmm</application> to umožňuje udělat pomocí "
"tříd <classname>Gtk::Socket</classname> a <classname>Gtk::Plug</classname>. "
"Neočekává se, že by tuto funkcionalitu potřebovalo moc aplikací, ale ve "
"zřídkavých případech můžete potřebovat zobrazit widget, který běží v úplně "
"jiném procesu, a pak se vám tyto třídy mohou hodit."

#: C/gtkmm-tutorial-in.xml:5612(para)
msgid ""
"The communication between a <classname>Socket</classname> and a "
"<classname>Plug</classname> follows the XEmbed protocol. This protocol has "
"also been implemented in other toolkits (e.g. Qt), which allows the same "
"level of integration when embedding a Qt widget in GTK+ or vice versa."
msgstr ""
"Komunikace mezi objekty <classname>Socket</classname> a <classname>Plug</"
"classname> probíhá podle protokolu XEmbed. Tento protokol je implementován i "
"v jiných vývojářských sadách (např. Qt), které umožňují stejnou úroveň "
"integrace při vkládání widgetu Qt do widgetu GTK+ a naopak."

#: C/gtkmm-tutorial-in.xml:5618(para)
msgid ""
"The way that <classname>Sockets</classname> and <classname>Plugs</classname> "
"work together is through their window ids. Both a <classname>Socket</"
"classname> and a <classname>Plug</classname> have IDs that can be retrieved "
"with their <methodname>get_id()</methodname> member functions. The use of "
"these IDs will be explained below in <xref linkend=\"sec-connecting-plugs-"
"sockets\"/>."
msgstr ""
"Způsob, jakým <classname>Socket</classname> a <classname>Plug</classname> "
"spolu fungují, je přes ID jejich oken. Jak <classname>Socket</classname>, "
"tak <classname>Plug</classname>, mají ID, která lze získat přes jejich "
"členské funkce <methodname>get_id()</methodname>. Použití těchto ID bude "
"vysvětleno dále v kapitole <xref linkend=\"sec-connecting-plugs-sockets\"/>."

#: C/gtkmm-tutorial-in.xml:5627(title)
msgid "Sockets"
msgstr "Socket"

#: C/gtkmm-tutorial-in.xml:5628(para)
msgid ""
"A <classname>Socket</classname> is a special kind of container widget that "
"provides the ability to embed widgets from one process into another process "
"in a way that is transparent to the user."
msgstr ""
"Třída <classname>Socket</classname> je speciální druh kontejnerového "
"widgetu, který poskytuje možnost vložit widget z jednoho procesu do jiného "
"procesu způsobem, který je pro uživatele transparentní."

#: C/gtkmm-tutorial-in.xml:5635(title)
msgid "Plugs"
msgstr "Plug"

#: C/gtkmm-tutorial-in.xml:5636(para)
msgid ""
"A <classname>Plug</classname> is a special kind of Window that can be "
"plugged into a <classname>Socket</classname>. Besides the normal properties "
"and methods of <classname>Gtk::Window</classname>, a <classname>Plug</"
"classname> provides a constructor that takes the ID of a <classname>Socket</"
"classname>, which will automatically embed the <classname>Plug</classname> "
"into the <classname>Socket</classname> that matches that ID."
msgstr ""
"<classname>Plug</classname> je speciální druh okna, které lze vložit do "
"objektu <classname>Socket</classname>. Mimo běžných vlastností a metod třídy "
"<classname>Gtk::Window</classname> poskytuje <classname>Plug</classname> "
"konstruktor, který přebírá ID objektu <classname>Socket</classname>, čímž se "
"automaticky vloží objekt <classname>Plug</classname> do objektu "
"<classname>Socket</classname> s příslušným ID."

#: C/gtkmm-tutorial-in.xml:5645(para)
msgid ""
"Since a <classname>Plug</classname> is just a special type of "
"<classname>Gtk::Window</classname> class, you can add containers or widgets "
"to it like you would to any other window."
msgstr ""
"Protože je <classname>Plug</classname> jen speciálním typem třídy "
"<classname>Gtk::Window</classname>, můžete do něj přidávat kontejnery nebo "
"widgety úplně stejným způsobem, jako u jiných oken."

#: C/gtkmm-tutorial-in.xml:5652(title)
msgid "Connecting Plugs and Sockets"
msgstr "Připojení zástrčky do zásuvky"

#: C/gtkmm-tutorial-in.xml:5653(para)
msgid ""
"After a <classname>Socket</classname> or <classname>Plug</classname> object "
"is realized, you can obtain its ID with its <methodname>get_id()</"
"methodname> function. This ID can then be shared with other processes so "
"that other processes know how to connect to each other."
msgstr ""
"Po té, co je objekt <classname>Socket</classname> nebo <classname>Plug</"
"classname> realizován, můžete získat jeho ID pomocí jeho metody "
"<methodname>get_id()</methodname>. Toto ID pak může být sdíleno s jiným "
"procesy, aby věděly, jak se navzájem připojit."

#: C/gtkmm-tutorial-in.xml:5664(para)
msgid ""
"Create a <classname>Socket</classname> object in one process and pass the ID "
"of that <classname>Socket</classname> to another process so that it can "
"create a <classname>Plug</classname> object by specifying the given "
"<classname>Socket</classname> ID in its constructor. There is no way to "
"assign a <classname>Plug</classname> to a particular <classname>Socket</"
"classname> after creation, so you must pass the <classname>Socket</"
"classname> ID to the <classname>Plug</classname>'s constructor."
msgstr ""
"Vytvořte objekt <classname>Socket</classname> v jednom procesu a předejte "
"jeho ID do jiného procesu, aby mohl vytvořit objekt <classname>Plug</"
"classname> s uvedením daného ID objektu <classname>Socket</classname> ve "
"svém konstruktoru. Neexistuje žádný způsob, jak přiřadit <classname>Plug</"
"classname> konkrétnímu objektu <classname>Socket</classname> později po "
"vytvoření, takže musíte ID opravdu předat do konstruktoru třídy "
"<classname>Plug</classname>."

#: C/gtkmm-tutorial-in.xml:5677(para)
msgid ""
"Create a <classname>Plug</classname> independantly from any particular "
"<classname>Socket</classname> and pass the ID of the <classname>Plug</"
"classname> to other processes that need to use it. The ID of the "
"<classname>Plug</classname> can be associated with a particular "
"<classname>Socket</classname> object using the <methodname>Socket::add_id()</"
"methodname> function. This is the approach used in the example below."
msgstr ""
"Vytvořte objekt <classname>Plug</classname> nezávisle na konkrétním objektu "
"<classname>Socket</classname> a předejte jeho ID do jinému procesu, který "
"jej potřebuje použít. ID objektu <classname>Plug</classname> se dá spřáhnout "
"s konkrétním objektem <classname>Socket</classname> pomocí funkce "
"<classname>Socket::add_id()</classname>. Tohle je přístup použitý v příkladu "
"níže."

#: C/gtkmm-tutorial-in.xml:5660(para)
msgid "There are two basic strategies that can be used: <placeholder-1/>"
msgstr "Existují dvě základní strategie, které můžete použít: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5692(title)
msgid "Plugs and Sockets Example"
msgstr "Příklad s třídami Plug a Socket"

#: C/gtkmm-tutorial-in.xml:5693(para)
msgid ""
"The following is a simple example of using sockets and plugs. The method of "
"communication between processes is deliberately kept very simple: The "
"<classname>Plug</classname> writes its ID out to a text file named "
"<filename>plug.id</filename> and the process with the socket reads the ID "
"from this file. In a real program, you may want to use a more sophisticated "
"method of inter-process communication."
msgstr ""
"Následuje jednoduchý příklad použití tříd <classname>Socket</classname> a "
"<filename>Plug</filename>. Metoda komunikace mezi procesy je záměrně "
"udržována velmi jednoduchá: <classname>Plug</classname> zapíše své ID do "
"textového souboru nazvaného <filename>plug.id</filename> a proces s objektem "
"<classname>Socket</classname> přečte ID z tohoto souboru. Ve skutečném "
"programu byste mohli použít mnohem promyšlenější způsob meziprocesové "
"komunikace."

#: C/gtkmm-tutorial-in.xml:5702(para)
msgid ""
"This example creates two executable programs: <filename>socket</filename> "
"and <filename>plug</filename>. The idea is that <filename>socket</filename> "
"has an application window that will embed a widget from the <filename>plug</"
"filename> program. The way this example is designed, <filename>plug</"
"filename> must be running first before starting <filename>socket</filename>. "
"To see the example in action, execute the following commands in order from "
"within the example directory:"
msgstr ""
"V příkladu se vytvoří dva spustitelné programy: <filename>socket</filename> "
"a <filename>plug</filename>. Myšlenka je taková, že <filename>socket</"
"filename> má aplikační okno, které vloží widget z programu <filename>plug</"
"filename>. Příklad je navržený tak, že než spustíte <filename>socket</"
"filename>, musíte jako první spustit <filename>plug</filename>. Abyste "
"viděli příklad v činnosti, spusťte následující příkazy v uvedeném pořadí ze "
"složky z příklady:"

#: C/gtkmm-tutorial-in.xml:5711(para)
msgid ""
"Start the <filename>plug</filename> program and send it to the background "
"(or just use a different terminal)."
msgstr ""
"Spusťte program <filename>plug</filename> a pošlete jej do pozadí (nebo "
"stačí použít jiný terminál)."

#: C/gtkmm-tutorial-in.xml:5715(screen)
#, no-wrap
msgid "$ ./plug &amp;"
msgstr "$ ./plug &amp;"

#: C/gtkmm-tutorial-in.xml:5716(para)
msgid "After which you should see something like the following:"
msgstr "Po té byste měli uvidět něco takovéhoto:"

#: C/gtkmm-tutorial-in.xml:5719(screen)
#, no-wrap
msgid "The window ID is: 69206019"
msgstr "The window ID is: 69206019"

#: C/gtkmm-tutorial-in.xml:5720(para)
msgid "Then start the <filename>socket</filename> program:"
msgstr "Pak spusťte program <filename>socket</filename>:"

#: C/gtkmm-tutorial-in.xml:5721(screen)
#, no-wrap
msgid "$ ./socket"
msgstr "$ ./socket"

#: C/gtkmm-tutorial-in.xml:5722(para)
msgid ""
"After starting <filename>socket</filename>, you should see the following "
"output in the terminal:"
msgstr "Po jeho spuštění byste měli v terminálu vidět následující výstup:"

#: C/gtkmm-tutorial-in.xml:5726(screen)
#, no-wrap
msgid ""
"I've been embedded.\n"
"A plug was added"
msgstr ""
"I've been embedded.\n"
"A plug was added"

#: C/gtkmm-tutorial-in.xml:5728(para)
msgid ""
"The first line of output is from <filename>plug</filename>, after it has "
"been notified that it has been embedded inside of a <classname>Socket</"
"classname>. The second line was emitted by <filename>socket</filename> in "
"response to its <methodname>plug_added</methodname> signal. If everything "
"was done as described above, the <filename>socket</filename> window should "
"look roughly like the following:"
msgstr ""
"První řádek výstupu je z programu <filename>plug</filename> po té, co byl "
"informován, že byl vložen do objektu <classname>Socket</classname>. Druhý "
"řádek byl vypsán programem <filename>socket</filename> v reakci na jeho "
"signál <methodname>plug_added</methodname>. Pokud vše proběhne, jak bylo "
"popsáno výše, mělo by okno programu <filename>socket</filename> vypadat "
"zhruba takto:"

#: C/gtkmm-tutorial-in.xml:5740(para)
msgid ""
"If for some reason the <classname>Socket</classname> couldn't attach the "
"<classname>Plug</classname>, the window would look something like this:"
msgstr ""
"Pokud by <classname>Socket</classname> z nějakého důvodu nemohl připojit "
"<classname>Plug</classname>, vypadalo by okno nějak takto:"

#: C/gtkmm-tutorial-in.xml:5751(title)
msgid "Keyboard Events"
msgstr "Události klávesnice"

#: C/gtkmm-tutorial-in.xml:5752(para)
msgid ""
"X events differ in some ways from other signals. These differences are "
"described in the <link linkend=\"sec-xeventsignals\">X Event signals</link> "
"section in the appendix. Here we will use keyboard events to show how X "
"events can be used in a program."
msgstr ""
"Události X se v některých věcech liší od ostatních signálů. Tyto rozdíly "
"jsou popsané v oddílu <link linkend=\"sec-xeventsignals\">Signály událostí "
"X</link> v dodatku. Zde použijeme události klávesnice k předvedení, jak se "
"dají události X použít v programu."

#: C/gtkmm-tutorial-in.xml:5760(para)
msgid ""
"Whenever you press or release a key, an event is emitted. You can connect a "
"signal handler to handle such events."
msgstr ""
"Kdykoliv zmáčknete nebo uvolníte klávesu, je vyslána událost. Můžete se "
"napojit na obsluhu signálu a takovéto události zpracovávat."

#: C/gtkmm-tutorial-in.xml:5764(para)
msgid ""
"To receive the keyboard events, you must first call the <methodname>Gtk::"
"Widget::add_events()</methodname> function with a bit mask of the events "
"you're interested in. The event signal handler will receive an argument that "
"depends on the type of event. For keyboard events it's a <type>GdkEventKey*</"
"type>. As discribed in the <link linkend=\"sec-xeventsignals\">appendix</"
"link>, the event signal handler returns a <type>bool</type> value, to "
"indicate that the signal is fully handled (<literal>true</literal>) or allow "
"event propagation (<literal>false</literal>)."
msgstr ""
"Abyste přijímali události klávesnice, musíte nejprve zavolat funkci "
"<methodname>Gtk::Widget::add_events()</methodname> s bitovou maskou "
"událostí, které vás zajímají. Obsluha signálu události obdrží argument, "
"který závisí na typu události. Pro události klávesnice je to "
"<type>GdkEventKey*</type>. Jak je popsáno v <link linkend=\"sec-xeventsignals"
"\">dodatku</link>, obsluha signálu události vrací hodnotu <type>bool</type>, "
"kterou říká, že signál byl plně obsloužen (<literal>true</literal>) nebo "
"povolí propagaci události (<literal>false</literal>)."

#: C/gtkmm-tutorial-in.xml:5775(para)
msgid ""
"To determine which key was pressed or released, you read the value of "
"<varname>GdkEventKey::keyval</varname> and compare it with a constant in the "
"<filename>&lt;gdk/gdkkeysyms.h&gt;</filename> header file. The states of "
"modifier keys (shift, ctrl, etc.) are available as bit-flags in "
"<varname>GdkEventKey::state</varname>."
msgstr ""
"Pro určení, která klávesa byl zmáčknuta nebo uvolněna, můžete číst hodnotu "
"<varname>GdkEventKey::keyval</varname> a porovnat ji s konstantou v "
"hlavičkovém souboru <filename>&lt;gdk/gdkkeysyms.h&gt;</filename>. Stav "
"modifikačních kláves (Shift, Ctrl, atd.) je dostupný v podobě bitových "
"příznaků v <varname>GdkEventKey::state</varname>."

#: C/gtkmm-tutorial-in.xml:5784(programlisting)
#, no-wrap
msgid ""
"\n"
"bool on_key_press_or_release_event(GdkEventKey* event)\n"
"{\n"
"  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;\n"
"    event-&gt;keyval == GDK_KEY_1 &amp;&amp;\n"
"    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)\n"
"  {\n"
"    handle_alt_1_press(); // GDK_MOD1_MASK is normally the Alt key\n"
"    return true;\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"Gtk::Entry m_entry; // in a class definition\n"
"\n"
"// in the class constructor\n"
"m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.add_events(Gdk::KEY_PRESS_MASK | Gdk::KEY_RELEASE_MASK);\n"
msgstr ""
"\n"
"bool on_key_press_or_release_event(GdkEventKey* event)\n"
"{\n"
"  if (event-&gt;type == GDK_KEY_PRESS &amp;&amp;\n"
"    event-&gt;keyval == GDK_KEY_1 &amp;&amp;\n"
"    (event-&gt;state &amp; (GDK_SHIFT_MASK | GDK_CONTROL_MASK | GDK_MOD1_MASK)) == GDK_MOD1_MASK)\n"
"  {\n"
"    handle_alt_1_press(); // GDK_MOD1_MASK je normálně klávesa Alt\n"
"    return true;\n"
"  }\n"
"  return false;\n"
"}\n"
"\n"
"Gtk::Entry m_entry; // v definici třídy\n"
"\n"
"// v konstruktoru třídy\n"
"m_entry.signal_key_press_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.signal_key_release_event().connect( sigc::ptr_fun(&amp;on_key_press_or_release_event) );\n"
"m_entry.add_events(Gdk::KEY_PRESS_MASK | Gdk::KEY_RELEASE_MASK);\n"

#: C/gtkmm-tutorial-in.xml:5782(para) C/gtkmm-tutorial-in.xml:8087(para)
msgid "Here's a simple example: <placeholder-1/>"
msgstr "Zde je jednoduchý příklad: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5808(para)
msgid ""
"In this example there are three keyboard shortcuts: <keycap>Alt</keycap>"
"+<keycap>1</keycap> selects the first radio button, <keycap>Alt</keycap>"
"+<keycap>2</keycap> selects the second one, and the <keycap>Esc</keycap> key "
"hides (closes) the window. The default event signal handler is overridden, "
"as described in the <link linkend=\"sec-overriding-default-signal-handlers"
"\">Overriding default signal handlers</link> section in the appendix."
msgstr ""
"V tomto příkladu jsou tři klávesové zkratky: <keycap>Alt</keycap>+<keycap>1</"
"keycap> vybírá první skupinový přepínač, <keycap>Alt</keycap>+<keycap>2</"
"keycap> vybírá druhý a klávesa <keycap>Esc</keycap> skryje (zavře) okno. "
"Výchozí obsluha signálu události je přepsaná tak, jak je popsáno v oddílu "
"<link linkend=\"sec-overriding-default-signal-handlers\">Přepisování výchozí "
"obsluhy signálu</link> v dodatku."

#: C/gtkmm-tutorial-in.xml:5819(title)
msgid "Keyboard Events - Simple"
msgstr "Události klávesnice – jednoduchý příklad"

#: C/gtkmm-tutorial-in.xml:5830(title)
msgid "Event Propagation"
msgstr "Propagace události"

#: C/gtkmm-tutorial-in.xml:5831(para)
msgid ""
"Event propagation means that, when an event is emitted on a particular "
"widget, it can be passed to its parent widget (and that widget can pass it "
"to its parent, and so on) and, if the parent has an event handler, that "
"handler will be called."
msgstr ""
"Propagace událostí znamená, že když je událost vyslána na konkrétní widget, "
"může být předána do rodičovského widgetu (a ten ji může předat do svého "
"rodičovského widgetu atd.) a pokud má rodič obsluhu události, je tato "
"obsluha zavolána."

#: C/gtkmm-tutorial-in.xml:5837(para)
msgid ""
"Contrary to other events, keyboard events are first sent to the toplevel "
"window (<classname>Gtk::Window</classname>), where it will be checked for "
"any keyboard shortcuts that may be set (accelerator keys and mnemonics, used "
"for selecting menu items from the keyboard). After this (and assuming the "
"event wasn't handled), it is sent to the widget which has focus, and the "
"propagation begins from there."
msgstr ""
"Na rozdíl od jiných událostí, události klávesnice jsou nejprve zaslány do "
"okna nejvyšší úrovně (<classname>Gtk::Window</classname>), kde jsou "
"zkontrolovány vůči případným klávesovým zkratkám (akcelerátory a horké "
"klávesy používané k výběru položek v nabídkách pomocí klávesnice). Po té (za "
"předpokladu, že událost nebyla obsloužena) jsou zaslány do widgetu, který má "
"zaměření a z něj jsou pak propagovány."

#: C/gtkmm-tutorial-in.xml:5845(para)
msgid ""
"The event will propagate until it reaches the top-level widget, or until you "
"stop the propagation by returning <literal>true</literal> from an event "
"handler."
msgstr ""
"Událost se bude propagovat, dokud nedosáhne widgetu v nejvyšší úrovni, nebo "
"dokud propagaci nezastavíte vrácením <literal>true</literal> z obsluhy "
"události."

#: C/gtkmm-tutorial-in.xml:5850(para)
msgid ""
"Notice, that after canceling an event, no other function will be called "
"(even if it is from the same widget)."
msgstr ""
"Dejte pozor na to, že po zastavení události nebude už zavolána žádná funkce "
"(i kdyby byla z toho stejného widgetu)."

#: C/gtkmm-tutorial-in.xml:5857(para)
msgid ""
"In this example there are three event handlers that are called after "
"<classname>Gtk::Window</classname>'s default event handler, one in the "
"<classname>Gtk::Entry</classname>, one in the <classname>Gtk::Grid</"
"classname> and one in the <classname>Gtk::Window</classname>."
msgstr ""
"V tomto příkladu jsou tři obsluhy událostí, které se nazývají podle "
"výchozích obsluh událostí v <classname>Gtk::Window</classname>. Jedna je "
"<classname>Gtk::Entry</classname>, druhá <classname>Gtk::Grid</classname> a "
"třetí <classname>Gtk::Window</classname>."

#: C/gtkmm-tutorial-in.xml:5863(para)
msgid ""
"In the <classname>Gtk::Window</classname>, we have also the default handler "
"overridden (<methodname>on_key_release_event()</methodname>), and another "
"handler being called before the default handler "
"(<methodname>windowKeyReleaseBefore()</methodname>)."
msgstr ""
"V <classname>Gtk::Window</classname> máme také přepsanou výchozí obsluhu "
"(<methodname>on_key_release_event()</methodname>) a další obsluha je volaná "
"před výchozí obsluhou (<methodname>windowKeyReleaseBefore()</methodname>)."

#: C/gtkmm-tutorial-in.xml:5869(para)
msgid ""
"The purpose of this example is to show the steps the event takes when it is "
"emitted."
msgstr ""
"Účelem tohoto příkladu je ukázat kroky, které událost podstoupí, když je "
"vyslána."

#: C/gtkmm-tutorial-in.xml:5872(para)
msgid ""
"When you write in the entry, a key release event will be emitted, which will "
"go first to the toplevel window (<classname>Gtk::Window</classname>), since "
"we have one event handler set to be called before, that's what is called "
"first (<methodname>windowKeyReleaseBefore()</methodname>). Then the default "
"handler is called (which we have overridden), and after that the event is "
"sent to the widget that has focus, the <classname>Entry</classname> in our "
"example and, depending on whether we let it propagate, it can reach the "
"<classname>Grid</classname>'s and the <classname>Window</classname>'s event "
"handlers. If it propagates, the text you're writing will appear in the "
"<classname>Label</classname> above the <classname>Entry</classname>."
msgstr ""
"Když píšete do vstupního pole, vyšle se událost o uvolnění klávesy, která "
"jde nejprve do okna nejvyšší úrovně (<classname>Gtk::Window</classname>), "
"protože máme nastavenou jednu obsluhu události, aby byla zavolaná napřed, "
"bude to ona, co bude zavolána první (<methodname>windowKeyReleaseBefore()</"
"methodname>). Pak je zavolána výchozí obsluha (kterou máme přepsanou) a "
"následně je událost zaslána widgetu, který má zaměření, což je v našem "
"příkladu <classname>Entry</classname>. Podle toho, jak budeme událost "
"propagovat, může dorazit až k obsluhám událostí objektů <classname>Grid</"
"classname> a <classname>Window</classname>. Pokud bude propagována, bude se "
"text, který píšete objevovat v popisku <classname>Label</classname> nad "
"vstupním polem <classname>Entry</classname>."

#: C/gtkmm-tutorial-in.xml:5887(title)
msgid "Keyboard Events - Event Propagation"
msgstr "Události klávesnice – propagace událostí"

#: C/gtkmm-tutorial-in.xml:5899(title)
msgid "Timeouts, I/O and Idle Functions"
msgstr "Časové limity, V/V a funkce při nečinnosti"

#: C/gtkmm-tutorial-in.xml:5902(title)
msgid "Timeouts"
msgstr "Časové limity"

#: C/gtkmm-tutorial-in.xml:5904(para)
msgid ""
"You may be wondering how to make <application>gtkmm</application> do useful "
"work while it's idling along. Happily, you have several options. Using the "
"following methods you can create a timeout method that will be called every "
"few milliseconds."
msgstr ""
"Možná vás zajímá, jak to udělat, aby <application>gtkmm</application> dělalo "
"něco užitečného, když je v nečinném stavu. Máte štěstí, protože máte dokonce "
"hned několik možností, jak to udělat. Pomocí následujících metod můžete "
"vytvořit časovanou metodu, která bude zavolaná každých pár milisekund."

#: C/gtkmm-tutorial-in.xml:5911(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""
"\n"
"sigc::connection Glib::SignalTimeout::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                      unsigned int interval, int priority = Glib::PRIORITY_DEFAULT);\n"

#: C/gtkmm-tutorial-in.xml:5917(para)
msgid ""
"The first argument is a <classname>slot</classname> you wish to have called "
"when the timeout occurs. The second argument is the number of milliseconds "
"between calls to that method. You receive a <classname>sigc::connection</"
"classname> object that can be used to deactivate the connection using its "
"<methodname>disconnect()</methodname> method:"
msgstr ""
"První argument je <classname>slot</classname>, který si přejete mít "
"zavolaný, když doběhne časový odpočet. Druhý argument je počet milisekund "
"mezi voláními této metody. Obdržíte objekt <classname>sigc::connection</"
"classname>, který můžete použít k deaktivaci napojení pomocí metody "
"<methodname>disconnect()</methodname>:"

#: C/gtkmm-tutorial-in.xml:5927(programlisting)
#, no-wrap
msgid ""
"\n"
"my_connection.disconnect();\n"
msgstr ""
"\n"
"my_connection.disconnect();\n"

#: C/gtkmm-tutorial-in.xml:5939(programlisting)
#, no-wrap
msgid ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n\" &lt;&lt; std::endl; return true; }\n"
msgstr ""
"\n"
"bool MyCallback() { std::cout &lt;&lt; \"Hello World!\\n\" &lt;&lt; std::endl; return true; }\n"

#: C/gtkmm-tutorial-in.xml:5932(para)
msgid ""
"Another way of destroying the connection is your signal handler. It has to "
"be of the type <classname>sigc::slot&lt;bool&gt;</classname>. As you see "
"from the definition your signal handler has to return a value of the type "
"<literal>bool</literal>. A definition of a sample method might look like "
"this: <placeholder-1/>"
msgstr ""
"Jiným způsobme, jak zlikvidovat připojení, je vaše obsluha signálu. Musí být "
"typu <classname>sigc::slot&lt;bool&gt;</classname>. Jak vidíte z definice, "
"vaše obsluha signálu musí vracet hodnotu typu <literal>bool</literal>. "
"Definice ukázkové metody může vypadat nějak takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:5945(para)
msgid ""
"You can stop the timeout method by returning <literal>false</literal> from "
"your signal handler. Therefore, if you want your method to be called "
"repeatedly, it should return <literal>true</literal>."
msgstr ""
"Metodu <methodname>timetout</methodname> můžete zastavit vrácením "
"<literal>false</literal> z vaší obsluhy signálu. Pokud chcete, aby vaše "
"metoda byla volána pravidelně, měli byste vrátit <literal>true</literal>."

#: C/gtkmm-tutorial-in.xml:5951(para)
msgid "Here's an example of this technique:"
msgstr "Zde je příklad této techniky:"

#: C/gtkmm-tutorial-in.xml:5960(title)
msgid "Monitoring I/O"
msgstr "Sledování V/V"

#: C/gtkmm-tutorial-in.xml:5962(para)
msgid ""
"A nifty feature of Glib (one of the libraries underlying <application>gtkmm</"
"application>) is the ability to have it check for data on a file descriptor "
"for you. This is especially useful for networking applications. The "
"following method is used to do this:"
msgstr ""
"Šikovnou funkcí knihovny Glib (jedna z knihoven ležících pod "
"<application>gtkmm</application>) je schopnost mít kontrolu nad daty z "
"popisovače souborů pro vaše potřeby. To se hodí hlavně pro síťové aplikace. "
"Následující metoda přesně tohle využívá:"

#: C/gtkmm-tutorial-in.xml:5970(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,\n"
"                                 int fd, Glib::IOCondition condition,\n"
"                                 int priority = Glib::PRIORITY_DEFAULT);\n"
msgstr ""
"\n"
"sigc::connection Glib::SignalIO::connect(const sigc::slot&lt;bool,Glib::IOCondition&gt;&amp; slot,\n"
"                                 int fd, Glib::IOCondition condition,\n"
"                                 int priority = Glib::PRIORITY_DEFAULT);\n"

#: C/gtkmm-tutorial-in.xml:5977(para)
msgid ""
"The first argument is a slot you wish to have called when the specified "
"event (see argument 3) occurs on the file descriptor you specify using "
"argument two. Argument three may be one or more (using <literal>|</literal>) "
"of:"
msgstr ""
"První argument je slot, který si přejete mít volaný, když nastane určená "
"událost (viz třetí argument) na popisovači souboru, který jste určili druhým "
"argumentem. Třetí argument může být jedna nebo více (pomocí <literal>|</"
"literal>) hodnot z:"

#: C/gtkmm-tutorial-in.xml:5987(para)
msgid ""
"Glib::IO_IN - Call your method when there is data ready for reading on your "
"file descriptor."
msgstr ""
"Glib::IO_IN – Zavolat vaši metodu, když jsou připravena data ke čtení na "
"popisovači vašeho souboru."

#: C/gtkmm-tutorial-in.xml:5995(para)
msgid ""
"Glib::IO_OUT - Call your method when the file descriptor is ready for "
"writing."
msgstr ""
"Glib::IO_OUT – Zavolat vaši metodu, když je popisovač souboru připravený k "
"zápisu."

#: C/gtkmm-tutorial-in.xml:6003(para)
msgid ""
"Glib::IO_PRI - Call your method when the file descriptor has urgent data to "
"be read."
msgstr ""
"Glib::IO_PRI – Zavolat vaši metodu, když má popisovač souboru neodkladná "
"data k přečtení."

#: C/gtkmm-tutorial-in.xml:6010(para)
msgid ""
"Glib::IO_ERR - Call your method when an error has occurred on the file "
"descriptor."
msgstr ""
"Glib::IO_ERR – Zavolat vaši metodu, když se na popisovači souboru vyskytla "
"nějaká chyba."

#: C/gtkmm-tutorial-in.xml:6017(para)
msgid ""
"Glib::IO_HUP - Call your method when hung up (the connection has been broken "
"usually for pipes and sockets)."
msgstr ""
"Glib::IO_HUP – Zavolat vaši metodu, když došlo k zaseknutí (připojení bylo "
"porušeno, obvykle kvůli rouře nebo soketu)."

#: C/gtkmm-tutorial-in.xml:6024(para)
msgid ""
"The return value is a <classname>sigc::connection</classname> that may be "
"used to stop monitoring this file descriptor using its "
"<methodname>disconnect()</methodname> method. The <parameter>slot</"
"parameter> signal handler should be declared as follows:"
msgstr ""
"Vrácená hodnota je <classname>sigc::connection</classname>, kterou můžete "
"použít k zastavení sledování tohoto popisovače souboru pomocí jeho metody "
"<methodname>disconnect()</methodname>. Obsluha signálu <parameter>slot</"
"parameter> by měla být deklarovaná následovně:"

#: C/gtkmm-tutorial-in.xml:6031(programlisting)
#, no-wrap
msgid ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"
msgstr ""
"\n"
"bool input_callback(Glib::IOCondition condition);\n"

#: C/gtkmm-tutorial-in.xml:6036(para)
msgid ""
"where <parameter>condition</parameter> is as specified above. As usual the "
"slot is created with <function>sigc::mem_fun()</function> (for a member "
"method of an object), or <function>sigc::ptr_fun()</function> (for a "
"function)."
msgstr ""
"kde argument <parameter>condition</parameter> je takový, jak byl určen ve "
"funkci zmíněné výše. Jako obvykle je slot vytvořen pomocí <function>sigc::"
"mem_fun()</function> (pro členské metody objektu), nebo pomocí "
"<function>sigc::ptr_fun()</function> (pro funkce)."

#: C/gtkmm-tutorial-in.xml:6043(para)
msgid ""
"A little example follows. To use the example just execute it from a "
"terminal; it doesn't create a window. It will create a pipe named "
"<literal>testfifo</literal> in the current directory. Then start another "
"shell and execute <literal>echo \"Hello\" &gt; testfifo</literal>. The "
"example will print each line you enter until you execute <literal>echo \"Q\" "
"&gt; testfifo</literal>."
msgstr ""
"Následuje menší příklad. Pokud jej chcete použít, spusťte jej z terminálu – "
"nevytváří žádné okno. Co ale vytvoří, je pojmenovaná roura "
"<literal>testfifo</literal> v aktuální složce. Pak spusťte další shell a v "
"něm <literal>echo \"Hello\" &gt; testinfo</literal>. Příklad bude vypisovat "
"jednotlivé řádky, které takto zadáte, až dokud nespustíte <literal>echo \"Q"
"\" &gt; testfifo</literal>."

#: C/gtkmm-tutorial-in.xml:6057(title)
msgid "Idle Functions"
msgstr "Funkce při nečinnosti"

#: C/gtkmm-tutorial-in.xml:6059(para)
msgid ""
"If you want to specify a method that gets called when nothing else is "
"happening, use the following:"
msgstr ""
"Když chcete určit metodu, která má být zavolána, když se nic jiného neděje, "
"použijte následující:"

#: C/gtkmm-tutorial-in.xml:6064(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"
msgstr ""
"\n"
"sigc::connection  Glib::SignalIdle::connect(const sigc::slot&lt;bool&gt;&amp; slot,\n"
"                                    int priority = Glib::PRIORITY_DEFAULT_IDLE);\n"

#: C/gtkmm-tutorial-in.xml:6070(para)
msgid ""
"This causes <application>gtkmm</application> to call the specified method "
"whenever nothing else is happening. You can add a priority (lower numbers "
"are higher priorities). There are two ways to remove the signal handler: "
"calling <methodname>disconnect()</methodname> on the <classname>sigc::"
"connection</classname> object, or returning <literal>false</literal> in the "
"signal handler, which should be declared as follows:"
msgstr ""
"Způsobí to, že <application>gtkmm</application> zavolá určenou metodu "
"kdykoliv, když se nic neděje. Můžete přidat prioritu (nižší čísla znamenají "
"vyšší prioritu). Jsou dva způsoby, jak obsluhu signálu odstranit: zavolat "
"<methodname>disconnect()</methodname> na objektu <classname>sigc::"
"connection</classname>, nebo vrátit <literal>false</literal> z obsluhy "
"signálu, která byla deklarována následovně:"

#: C/gtkmm-tutorial-in.xml:6080(programlisting)
#, no-wrap
msgid ""
"\n"
"bool idleFunc();\n"
msgstr ""
"\n"
"bool idleFunc();\n"

#: C/gtkmm-tutorial-in.xml:6085(para)
msgid ""
"Since this is very similar to the methods above this explanation should be "
"sufficient to understand what's going on. However, here's a little example:"
msgstr ""
"Protože je tahle metoda velmi podobná metodě rozebrané v předchozím, mělo by "
"tohle vysvětlení k pochopení fungování stačit. Pro jistotu je zde ale "
"příklad:"

#: C/gtkmm-tutorial-in.xml:6092(para)
msgid ""
"This example points out the difference of idle and timeout methods a little. "
"If you need methods that are called periodically, and speed is not very "
"important, then you want timeout methods. If you want methods that are "
"called as often as possible (like calculating a fractal in background), then "
"use idle methods."
msgstr ""
"Tento příklad ukazuje malý rozdíl mezi metodou <methodname>idle</methodname> "
"a <methodname>timeout</methodname>. Když potřebujete metodu, která je volána "
"pravidelně a rychlost není důležitá, pak budete chtít metodu "
"<methodname>timeout</methodname>. Pokud potřebujete takovou, která je volána "
"tak často, jak je to možné (např. výpočet fraktálu na pozadí), pak použijte "
"metodu <methodname>idle</methodname>."

#: C/gtkmm-tutorial-in.xml:6100(para)
msgid ""
"Try executing the example and increasing the system load. The upper progress "
"bar will increase steadily; the lower one will slow down."
msgstr ""
"Zkuste příklad spustit a zvýšit zátěž systému. Horní ukazatel průběhu bude "
"nabývat rovnoměrně, dolní se zpomalí."

#: C/gtkmm-tutorial-in.xml:6110(title)
msgid "Memory management"
msgstr "Správa paměti"

#: C/gtkmm-tutorial-in.xml:6116(title)
msgid "Normal C++ memory management"
msgstr "Normální správa paměti v C++"

#: C/gtkmm-tutorial-in.xml:6118(para)
msgid ""
"<application>gtkmm</application> allows the programmer to control the "
"lifetime (that is, the construction and destruction) of any widget in the "
"same manner as any other C++ object. This flexibility allows you to use "
"<literal>new</literal> and <literal>delete</literal> to create and destroy "
"objects dynamically or to use regular class members (that are destroyed "
"automatically when the class is destroyed) or to use local instances (that "
"are destroyed when the instance goes out of scope). This flexibility is not "
"present in some C++ GUI toolkits, which restrict the programmer to only a "
"subset of C++'s memory management features."
msgstr ""
"<application>gtkmm</application> dává programům kontrolu nad životností (tj. "
"konstrukcí a destrukcí) kteréhokoliv widgetu stejným způsobme, jako nad "
"kterýmkoliv jiným objektem C++. Díky této flexibilitě můžete použit "
"<literal>new</literal> a <literal>delete</literal> k vytvoření a zničení "
"objektu dynamicky, nebo můžete použít běžného člena třídy (který je zničen "
"automaticky při zničení instance třídy), nebo použít lokální instanci (která "
"zanikne při opuštění jejího rozsahu působnosti). Takovouto flexibilitu "
"nenajdete v každé vývojářské sade GUI v C++, mnohé omezují programátory jen "
"na nějakou podmnožinu funkcí správy paměti v C++."

#: C/gtkmm-tutorial-in.xml:6130(para)
msgid "Here are some examples of normal C++ memory management:"
msgstr "Zde je nějaký příklad normální správy paměti v C++:"

#: C/gtkmm-tutorial-in.xml:6133(title)
msgid "Class Scope widgets"
msgstr "Widgety v rozsahu působnosti třídy"

#: C/gtkmm-tutorial-in.xml:6135(para)
msgid ""
"If a programmer does not need dynamic memory allocation, automatic widgets "
"in class scope may be used. One advantage of automatic widgets in class "
"scope is that memory management is grouped in one place. The programmer does "
"not risk memory leaks from failing to <literal>delete</literal> a widget."
msgstr ""
"Pokud programátor nepotřebuje dynamickou alokaci paměti, dají se použít "
"automatické widgety v rozsahu působnosti třídy. Jedním z přínosů "
"automatických widgetů v rozsahu působnosti třídy je, že správa paměti je na "
"jednom místě jako celek. Programátor neriskuje úniky paměti vlivem selhání "
"<literal>delete</literal> u widgetu."

#: C/gtkmm-tutorial-in.xml:6142(para)
msgid ""
"The primary disadvantage of using class scope widgets is revealing the class "
"implementation rather than the class interface in the class header."
msgstr ""
"Hlavním přínosem použití widgetů v rozsahu působnosti třídy je odhalení "
"implementace třídy, místo rozhraní třídy v hlavičce třídy."

#: C/gtkmm-tutorial-in.xml:6148(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"#include &lt;gtkmm/window.h&gt;\n"
"class Foo : public Gtk::Window\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // will be destroyed when the Foo object is destroyed\n"
"};\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"#include &lt;gtkmm/window.h&gt;\n"
"class Foo : public Gtk::Window\n"
"{\n"
"private:\n"
"  Gtk::Button theButton;\n"
"  // bude zlikvidováno, když je zlikvidován objekt Foo\n"
"};\n"

#: C/gtkmm-tutorial-in.xml:6162(title)
msgid "Function scope widgets"
msgstr "Widgety v rozsahu působnosti funkce"

#: C/gtkmm-tutorial-in.xml:6168(programlisting)
#, no-wrap
msgid ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"{\n"
"  Gtk::Button aButton;\n"
"  aButton.show();\n"
"  ...\n"
"  app-&gt;run();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6164(para)
msgid ""
"If a programmer does not need a class scope widget, a function scope widget "
"may also be used. The advantages to function scope over class scope are the "
"increased data hiding and reduced dependencies. <placeholder-1/>"
msgstr ""
"Pokud programátor nepotřebuje widgety v rozsahu působnosti třídy, může "
"použít také widgety v rozsahu působnosti funkce. Přínosem oproti rozsahu "
"působnosti třídy jsou zvýšené skrytí dat a omezení závislostí. "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6180(title)
msgid "Dynamic allocation with new and delete"
msgstr "Dynamická alokace pomocí new a delete"

#: C/gtkmm-tutorial-in.xml:6188(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Button* pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// do something useful with pButton\n"
"\n"
"delete pButton;\n"
msgstr ""
"\n"
"Gtk::Button* pButton = new Gtk::Button(\"Test\");\n"
"\n"
"// zde se dělá něco užitečného s pButton\n"
"\n"
"delete pButton;\n"

#: C/gtkmm-tutorial-in.xml:6182(para)
msgid ""
"Although, in most cases, the programmer will prefer to allow containers to "
"automatically destroy their children using <function>Gtk::manage()</"
"function> (see below), the programmer is not required to use <function>Gtk::"
"manage()</function>. The traditional <literal>new</literal> and "
"<literal>delete</literal> operators may also be used. <placeholder-1/> Here, "
"the programmer deletes <varname>pButton</varname> to prevent a memory leak."
msgstr ""
"Ačkoliv ve většině případů programátoři dávají přednost tomu, aby kontejnery "
"automaticky ničily své potomky pomocí <function>Gtk::manage()</function> "
"(viz dále), není po programátorech použití <function>Gtk::manage()</"
"function> vyžadováno. Dají se použít i tradiční operátory <literal>new</"
"literal> a <literal>delete</literal>. <placeholder-1/> Zde programátor "
"smazal <varname>pButton</varname>, aby zabránil úniku paměti."

#: C/gtkmm-tutorial-in.xml:6202(title)
msgid "Managed Widgets"
msgstr "Widgety pod správou"

#: C/gtkmm-tutorial-in.xml:6204(para)
msgid ""
"Alternatively, you can let a widget's container control when the widget is "
"destroyed. In most cases, you want a widget to last only as long as the "
"container it is in. To delegate the management of a widget's lifetime to its "
"container, first create it with <function>Gtk::manage()</function> and pack "
"it into its container with <methodname>Gtk::Container::add()</methodname>, "
"<methodname>Gtk::Box::pack_start()</methodname>, or a similar method. Now "
"the widget will be destroyed whenever its container is destroyed."
msgstr ""
"Jinou možností je nechat na kontejnerovém widgetu rozhodování, kdy se má "
"widget zničit. Ve většině případů chcete, aby widget existoval tak dlouho, "
"jako kontejner, ve kterém je. Když chcete přenést správu životnosti widgetu "
"na jeho kontejner, nejprve jej vytvořte pomocí <function>Gtk::manage()</"
"function> a zabalte jej do jeho kontejneru pomocí <methodname>Gtk::"
"Container::add()</methodname>, <methodname>Gtk::Box::pack_start()</"
"methodname> nebo podobné metody. Takto bude widget zničen, kdykoliv bude "
"zničen jeho kontejner."

#: C/gtkmm-tutorial-in.xml:6215(title)
msgid "Dynamic allocation with manage() and add()"
msgstr "Dynamická alokace pomocí manage() a add()"

#: C/gtkmm-tutorial-in.xml:6217(para)
msgid ""
"<application>gtkmm</application> provides the <function>manage()</function> "
"function and <methodname>add()</methodname> methods to create and destroy "
"widgets. Every widget except a top-level window must be added or packed into "
"a container in order to be displayed. The <function>manage()</function> "
"function marks a widget so that when the widget is added to a container, the "
"container becomes responsible for deleting the widget."
msgstr ""
"<application>gtkmm</application> poskytuje funkci <function>manage()</"
"function> a metody <methodname>add()</methodname> pro vytvoření a zničení "
"widgetu. Každý widget vyjma okna nejvyšší úrovně musí být přidán nebo "
"zabalen do kontejneru v pořadí, v jakém se má zobrazit. Funkce "
"<function>manage()</function> widgety označuje, takže když je widget přidán "
"do kontejneru, stane se kontejner zodpovědný za jeho smazání."

#: C/gtkmm-tutorial-in.xml:6227(programlisting)
#, no-wrap
msgid ""
"\n"
"MyContainer::MyContainer()\n"
"{\n"
"  Gtk::Button* pButton = Gtk::manage(new Gtk::Button(\"Test\"));\n"
"  add(*pButton); //add *pButton to MyContainer\n"
"}\n"
msgstr ""
"\n"
"MyContainer::MyContainer()\n"
"{\n"
"  Gtk::Button* pButton = Gtk::manage(new Gtk::Button(\"Test\"));\n"
"  add(*pButton); //add *pButton to MyContainer\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6226(para)
msgid ""
"<placeholder-1/> Now, when objects of type <classname>MyContainer</"
"classname> are destroyed, the button will also be deleted. It is no longer "
"necessary to delete <varname>pButton</varname> to free the button's memory; "
"its deletion has been delegated to the <classname>MyContainer</classname> "
"object."
msgstr ""
"<placeholder-1/> Nyní, když jsou objekty typu <classname>MyContainer</"
"classname> zničené, je smazáné i tlačítko. Není již potřeba mazat "
"<varname>pButton</varname>, aby se uvolnila jeho paměť. Jeho smazání bylo "
"předáno za úkol kontejneru <classname>MyContainer</classname>."

#: C/gtkmm-tutorial-in.xml:6240(para)
msgid ""
"Of course, a top-level container will not be added to another container. The "
"programmer is responsible for destroying the top-level container using one "
"of the traditional C++ techniques. For instance, your top-level Window might "
"just be an instance in your <function>main()</function> function."
msgstr ""
"Kontejner nejvyšší úrovně samozřejmě nebude přidán do jiného kontejneru. "
"Program je zodpovědný za zničení kontejneru nejvyšší úrovně pomocí jedné z "
"tradičních technik C++. Například vaše okno nejvyšší úrovně může být jen "
"instancí vaší funkce <function>main()</function>."

#: C/gtkmm-tutorial-in.xml:6252(title)
msgid "Shared resources"
msgstr "Sdílené prostředky"

#: C/gtkmm-tutorial-in.xml:6254(para)
msgid ""
"Some objects, such as <classname>Gdk::Pixbuf</classname>s and "
"<classname>Pango::Font</classname>s, are obtained from a shared store. "
"Therefore you cannot instantiate your own instances. These classes typically "
"inherit from <classname>Glib::Object</classname>. Rather than requiring you "
"to reference and unreference these objects, <application>gtkmm</application> "
"uses the <classname>Glib::RefPtr&lt;&gt;</classname> smartpointer. Cairomm "
"has its own smartpointer, <classname>Cairo::RefPtr&lt;&gt;</classname>."
msgstr ""
"Některé objekty, jako jsou <classname>Gdk::Pixbuf</classname> a "
"<classname>Pango::Font</classname>, se získávají ze sdíleného úložiště. "
"Proto u nich nemůžete vytvářet své vlastní instance. Tyto třídy bývají "
"typicky zděděné z <classname>Glib::Object</classname>. Místo aby "
"<application>gtkmm</application> vyžadovalo reference a dereference na "
"takovéto objekty, používá chytré ukazatele <classname>Glib::RefPtr&lt;&gt;</"
"classname>. Cairomm má svůj vlastní chytrý ukazatel <classname>Cairo::"
"RefPtr&lt;&gt;</classname>."

#: C/gtkmm-tutorial-in.xml:6267(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf = Gdk::Pixbuf::create_from_file(filename);\n"

#: C/gtkmm-tutorial-in.xml:6264(para)
msgid ""
"Objects such as <classname>Gdk::Pixbuf</classname> can only be instantiated "
"with a <methodname>create()</methodname> function. For instance, "
"<placeholder-1/>"
msgstr ""
"U objektů, jako je <classname>Gdk::Pixbuf</classname>, lze vytvořit instanci "
"jen pomocí funkce <methodname>create()</methodname>. Například "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6276(programlisting)
#, no-wrap
msgid ""
"\n"
"int width = 0;\n"
"if(pixbuf)\n"
"{\n"
"  width = pixbuf-&gt;get_width();\n"
"}\n"
msgstr ""
"\n"
"int width = 0;\n"
"if(pixbuf)\n"
"{\n"
"  width = pixbuf-&gt;get_width();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6272(para)
msgid ""
"You have no way of getting a bare <classname>Gdk::Pixbuf</classname>. In the "
"example, <varname>pixbuf</varname> is a smart pointer, so you can do this, "
"much like a normal pointer: <placeholder-1/>"
msgstr ""
"Nemáte žádnou možnost, jak získat holý <classname>Gdk::Pixbuf</classname>. V "
"příkladu je <varname>pixbuf</varname> chytrý ukazatel, takže to můžete "
"udělat podobně, jako u normálního ukazatele: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6285(para)
msgid ""
"When <varname>pixbuf</varname> goes out of scope an <methodname>unref()</"
"methodname> will happen in the background and you don't need to worry about "
"it anymore. There's no <literal>new</literal> so there's no <literal>delete</"
"literal>."
msgstr ""
"Kdy <varname>pixbuf</varname> přejde mimo rozsah působnosti, provede se na "
"pozadí <methodname>unref()</methodname> a dále se o něj již nemusíte starat. "
"Nebylo zde žádné <literal>new</literal>, tak není ani žádné <literal>delete</"
"literal>."

#: C/gtkmm-tutorial-in.xml:6293(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf2 = pixbuf;\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; pixbuf2 = pixbuf;\n"

#: C/gtkmm-tutorial-in.xml:6291(para)
msgid ""
"If you copy a <classname>RefPtr</classname>, for instance <placeholder-1/> , "
"or if you pass it as a method argument or a return type, then "
"<classname>RefPtr</classname> will do any necessary referencing to ensure "
"that the instance will not be destroyed until the last <classname>RefPtr</"
"classname> has gone out of scope."
msgstr ""
"Když kopírujete <classname>RefPtr</classname>, například <placeholder-1/>, "
"nebo jej předáte jako argument metody, nebo jej vrátíte jako typ, pak "
"<classname>RefPtr</classname> nebude provádět počítání referencí, aby se "
"zajistilo, že instance nebude zničena dříve, než poslední <classname>RefPtr</"
"classname> přejde mimo rozsah působnosti."

#: C/gtkmm-tutorial-in.xml:6301(para)
msgid ""
"See the <link linkend=\"chapter-refptr\">appendix</link> for detailed "
"information about RefPtr."
msgstr ""
"Podrobné informace o RefPtr viz <link linkend=\"chapter-refptr\">dodatek</"
"link>."

#: C/gtkmm-tutorial-in.xml:6306(para)
msgid ""
"Bjarne Stroustrup, \"The C++ Programming Language\" Forth Edition - section "
"34.3"
msgstr ""
"Bjarne Stroustrup, „The C++ Programming Language“ čtvrté vydání – kapitola "
"34.3"

#: C/gtkmm-tutorial-in.xml:6309(para)
msgid "Nicolai M. Josuttis, \"The C++ Standard Library\" - section 4.2"
msgstr "Nicolai M. Josuttis, „The C++ Standard Library“ – kapitola 4.2"

#: C/gtkmm-tutorial-in.xml:6302(para)
msgid ""
"If you wish to learn more about smartpointers, you might look in these "
"books: <placeholder-1/>"
msgstr ""
"Jestli se chcete o chytrých ukazatelích dozvědět více, můžete si přečíst "
"tyto knihy: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6320(title)
msgid "Glade and Gtk::Builder"
msgstr "Glade a Gtk::Builder"

#: C/gtkmm-tutorial-in.xml:6321(para)
msgid ""
"Although you can use C++ code to instantiate and arrange widgets, this can "
"soon become tedious and repetitive. And it requires a recompilation to show "
"changes. The <application>Glade</application> application allows you to "
"layout widgets on screen and then save an XML description of the "
"arrangement. Your application can then use the <application>Gtk::Builder</"
"application> API to load that XML file at runtime and obtain a pointer to "
"specifically named widget instances."
msgstr ""
"Ačkoliv můžete k vytváření a uspořádání widgetů používat kód v C++, rychle "
"se to zvrhne v úmornou a opakující se činnost. A kvůli shlédnutí každé změny "
"musíte znovu kompilovat. Aplikace <application>Glade</application> umožňuje "
"rozvrhnout widgety na obrazovce a uložit jejich uspořádání popsané pomocí "
"XML. Vaše aplikace pak může použít API <application>Gtk::Builder</"
"application> k načtení souboru XML za běhu a k získání ukazatele na "
"konkrétně nazvanou instanci widgetu."

#: C/gtkmm-tutorial-in.xml:6334(simpara)
msgid "Less C++ code is required."
msgstr "Je potřeba méně kódu v C++."

#: C/gtkmm-tutorial-in.xml:6335(simpara)
msgid "UI changes can be seen more quickly, so UIs are able to improve."
msgstr ""
"Změny v uživatelském rozhraní jsou rychleji viditelné, takže se dobře "
"vylepšuje."

#: C/gtkmm-tutorial-in.xml:6336(simpara)
msgid "Designers without programming skills can create and edit UIs."
msgstr ""
"Vytvářet a upravovat uživatelské rozhraní mohou návrháři bez "
"programátorských znalostí"

#: C/gtkmm-tutorial-in.xml:6331(para)
msgid "This has the following advantages: <placeholder-1/>"
msgstr "Má to následující výhody: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6340(para)
msgid ""
"You still need C++ code to deal with User Interface changes triggered by "
"user actions, but using <application>Gtk::Builder</application> for the "
"widget layout allows you to focus on implementing that functionality."
msgstr ""
"Stále budete potřebovat nějaký kód v C++ k obsluze změn v uživatelském "
"rozhraní spouštěných uživatelovou činností, ale použití <application>Gtk::"
"Builder</application> pro rozvržení vám uvolní ruce pro práci na "
"funkcionalitě."

#: C/gtkmm-tutorial-in.xml:6347(title)
msgid "Loading the .glade file"
msgstr "Načtení souboru .glade"

#: C/gtkmm-tutorial-in.xml:6352(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\");\n"

#: C/gtkmm-tutorial-in.xml:6348(para)
msgid ""
"<classname>Gtk::Builder</classname> must be used via a <classname>Glib::"
"RefPtr</classname>. Like all such classes, you need to use a "
"<methodname>create()</methodname> method to instantiate it. For instance, "
"<placeholder-1/> This will instantiate the windows defined in the .glade "
"file, though they will not be shown immediately unless you have specified "
"that via the <guilabel>Properties</guilabel> window in <application>Glade</"
"application>."
msgstr ""
"<classname>Gtk::Builder</classname> se musí používat přes <classname>Glib::"
"RefPtr</classname>. Podobně jako u všech takovýchto tříd, musíte pro "
"vytvoření instance použít metodu <methodname>create()</methodname>. "
"Například <placeholder-1/> Tím se vytvoří instance oken definovaných v "
"souboru .glade, které se ale hned nezobrazí, pokud to výslovně neřeknete "
"nastavením v okně <guilabel>Vlastnosti</guilabel> a aplikaci "
"<application>Glade</application>."

#: C/gtkmm-tutorial-in.xml:6361(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::Builder&gt; builder = Gtk::Builder::create_from_file(\"basic.glade\", \"treeview_products\");\n"

#: C/gtkmm-tutorial-in.xml:6360(para)
msgid ""
"To instantiate just one window, or just one of the child widgets, you can "
"specify the name of a widget as the second parameter. For instance, "
"<placeholder-1/>"
msgstr ""
"Když chcete vytvořit instanci jen jednoho okna, nebo jen jednoho synovského "
"widgetu, můžete určit název widgetu jako druhý parametr. Například "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6369(title)
msgid "Accessing widgets"
msgstr "Přístup k widgetům"

#: C/gtkmm-tutorial-in.xml:6377(programlisting)
#, no-wrap
msgid ""
"\n"
"Gtk::Dialog* pDialog = 0;\n"
"builder-&gt;get_widget(\"DialogBasic\", pDialog);\n"
msgstr ""
"\n"
"Gtk::Dialog* pDialog = 0;\n"
"builder-&gt;get_widget(\"DialogBasic\", pDialog);\n"

#: C/gtkmm-tutorial-in.xml:6371(para)
msgid ""
"To access a widget, for instance to <methodname>show()</methodname> a "
"dialog, use the <methodname>get_widget()</methodname> method, providing the "
"widget's name. This name should be specified in the <application>Glade</"
"application> Properties window. If the widget could not be found, or is of "
"the wrong type, then the pointer will be set to 0. <placeholder-1/>"
msgstr ""
"Pro přístup k widgetu, například kvůli zavolání <methodname>show()</"
"methodname> dialogového okna, použijte metodu <methodname>get_widget()</"
"methodname>, které poskytnete název widgetu. Tento název by měl být zadaný v "
"okně vlastností v <application>Glade</application>. Když se widget nepodaří "
"najít, nebo je nesprávného typu, bude ukazatel nastaven na NULL. "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6383(para)
msgid ""
"<application>Gtk::Builder</application> checks for a null pointer, and "
"checks that the widget is of the expected type, and will show warnings on "
"the command line about these."
msgstr ""
"<application>Gtk::Builder</application> kontroluje widget na prázdný "
"ukazatel a na očekávaný typ a případně o těchto problémech vypíše varování "
"do příkazové řádky."

#: C/gtkmm-tutorial-in.xml:6389(para)
msgid ""
"Remember that you are not instantiating a widget with "
"<methodname>get_widget()</methodname>, you are just obtaining a pointer to "
"one that already exists. You will always receive a pointer to the same "
"instance when you call <methodname>get_widget()</methodname> on the same "
"<classname>Gtk::Builder</classname>, with the same widget name. The widgets "
"are instantiated during <methodname>Gtk::Builder::create_from_file()</"
"methodname>."
msgstr ""
"Pamatujte, že instanci widgetu nevytváříte pomocí metody "
"<methodname>get_widget()</methodname>, tou jen získáváte ukazatel na "
"instanci, která již existuje. Pokaždé, když zavoláte "
"<methodname>get_widget()</methodname> na ten samý objekt <classname>Gtk::"
"Builder</classname>, měli byste obdržet ukazatel na tu samou instanci. "
"Instance widgetů se vytváří během <methodname>Gtk::Builder::"
"create_from_file()</methodname>."

#: C/gtkmm-tutorial-in.xml:6398(para)
msgid ""
"<methodname>get_widget()</methodname> returns child widgets that are "
"<function>manage()</function>ed (see the <link linkend=\"chapter-memory"
"\">Memory Management</link> chapter), so they will be deleted when their "
"parent container is deleted. So, if you get only a child widget from "
"<application>Gtk::Builder</application>, instead of a whole window, then you "
"must either put it in a <classname>Container</classname> or delete it. "
"<classname>Windows</classname> (such as <classname>Dialogs</classname>) "
"cannot be managed because they have no parent container, so you must delete "
"them at some point."
msgstr ""
"<methodname>get_widget()</methodname> vrací synovské widgety, které jsou "
"spravované přes <methodname>managed()</methodname> (viz kapitola <link "
"linkend=\"chapter-memory\">Správa paměti</link>), a tím pádem budou smazané, "
"když je smazán jejich rodičovský kontejner. Takže když dostanete jen "
"synovské widgety z <application>Gtk::Builder</application>, místo z celého "
"okna, pak je buď musíte vložit do kontejneru nebo je smazat. Třídy "
"<classname>Windows</classname> (jako je <classname>Dialogs</classname>) "
"nemohou být spravované, protože nemají rodičovský kontejner, a proto je "
"musíte v některém okamžiku smazat sami."

#: C/gtkmm-tutorial-in.xml:6412(para)
msgid ""
"This simple example shows how to load a <application>Glade</application> "
"file at runtime and access the widgets with <application>Gtk::Builder</"
"application>."
msgstr ""
"Tento příklad ukazuje, jak načíst soubor <application>Glade</application> za "
"běhu a jak přistupovat k widgetům pomocí <application>Gtk::Builder</"
"application>."

#: C/gtkmm-tutorial-in.xml:6425(title)
msgid "Using derived widgets"
msgstr "Používání odvozených widgetů"

#: C/gtkmm-tutorial-in.xml:6426(para)
msgid ""
"You can use <application>Glade</application> to layout your own custom "
"widgets derived from <application>gtkmm</application> widget classes. This "
"keeps your code organized and encapsulated. Of course you won't see the "
"exact appearance and properties of your derived widget in "
"<application>Glade</application>, but you can specify its location and child "
"widgets and the properties of its <application>gtkmm</application> base "
"class."
msgstr ""
"<application>Glade</application> můžete použít k umístění svého vlastního "
"widgetu odvozeného z třídy widgetu z <application>gtkmm</application>. Tím "
"udržíte v kódu pořádek a zapouzdřenost. Samozřejmě nemůžete v "
"<application>Glade</application> vidět přesný vzhled a vlastnosti odvozeného "
"widgetu, ale můžete určit jeho pozici a potomky a vlastnosti jeho podkladové "
"třídy z <application>gtkmm</application>."

#: C/gtkmm-tutorial-in.xml:6435(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog* pDialog = 0;\n"
"builder-&gt;get_widget_derived(\"DialogBasic\", pDialog);\n"
msgstr ""
"\n"
"DerivedDialog* pDialog = 0;\n"
"builder-&gt;get_widget_derived(\"DialogBasic\", pDialog);\n"

#: C/gtkmm-tutorial-in.xml:6434(para)
msgid ""
"Use <methodname>Gtk::Builder::get_widget_derived()</methodname> like so: "
"<placeholder-1/>"
msgstr ""
"Použijte <methodname>Gtk::Builder::get_widget_derived()</methodname> nějak "
"takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6441(para)
msgid ""
"Your derived class must have a constructor that takes a pointer to the "
"underlying C type, and the <classname>Gtk::Builder</classname> instance. All "
"relevant classes of <application>gtkmm</application> typedef their "
"underlying C type as <classname>BaseObjectType</classname> (<classname>Gtk::"
"Dialog</classname> typedefs <classname>BaseObjectType</classname> as "
"<type>GtkDialog</type>, for instance)."
msgstr ""
"Vaše odvozená třída musí mít konstruktor, který přebírá ukazatel na "
"podkladový typ C a instanci <classname>Gtk::Builder</classname>. Všechny "
"související třídy v <application>gtkmm</application> definují svůj "
"podkladový typ C jako <classname>BaseObjectType</classname> (například "
"<classname>Gtk::Dialog</classname> definuje typ <classname>BaseObjectType</"
"classname> jako <type>GtkDialog</type>)."

#: C/gtkmm-tutorial-in.xml:6451(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject)\n"
"{\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6448(para)
msgid ""
"You must call the base class's constructor in the initialization list, "
"providing the C pointer. For instance, <placeholder-1/>"
msgstr ""
"V seznamu inicializací musíte zavolat konstruktor základní třídy, abyste "
"získali ukazatel C. Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6463(programlisting)
#, no-wrap
msgid ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(0)\n"
"{\n"
"  //Get the Glade-instantiated Button, and connect a signal handler:\n"
"  m_builder-&gt;get_widget(\"quit_button\", m_pButton);\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"
msgstr ""
"\n"
"DerivedDialog::DerivedDialog(BaseObjectType* cobject, const Glib::RefPtr&lt;Gtk::Builder&gt;&amp; builder)\n"
": Gtk::Dialog(cobject),\n"
"  m_builder(builder),\n"
"  m_pButton(0)\n"
"{\n"
"  // Získat instanci Button z Glade a napojit obsluhu signálu:\n"
"  m_builder-&gt;get_widget(\"quit_button\", m_pButton);\n"
"  if(m_pButton)\n"
"  {\n"
"    m_pButton-&gt;signal_clicked().connect( sigc::mem_fun(*this, &amp;DerivedDialog::on_button_quit) );\n"
"  }\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:6459(para)
msgid ""
"You could then encapsulate the manipulation of the child widgets in the "
"constructor of the derived class, maybe using <methodname>get_widget()</"
"methodname> or <methodname>get_widget_derived()</methodname> again. For "
"instance, <placeholder-1/>"
msgstr ""
"Manipulaci se synovskými widgety v konstruktoru odvozené třidy byste mohli "
"zapouzdřit, třeba znovu pomocí <methodname>get_widget()</methodname> nebo "
"<methodname>get_widget_derived()</methodname>. Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6481(para)
msgid ""
"This example shows how to load a <application>Glade</application> file at "
"runtime and access the widgets via a derived class."
msgstr ""
"Tento příklad ukazuje, jak načíst soubor <application>Glade</application> za "
"běhu a jak přistupovat k widgetům přes odvozenou třídu."

#: C/gtkmm-tutorial-in.xml:6494(title)
msgid "Internationalization and Localization"
msgstr "Internacionalizace a lokalizace"

#: C/gtkmm-tutorial-in.xml:6496(para)
msgid ""
"<application>gtkmm</application> applications can easily support multiple "
"languages, including non-European languages such as Chinese and right-to-"
"left languages such as Arabic. An appropriately-written and translated "
"<application>gtkmm</application> application will use the appropriate "
"language at runtime based on the user's environment."
msgstr ""
"Aplikace s <application>gtkmm</application> mohou jednoduše podporovat více "
"jazyků, včetně neevropských, jako je čínština nebo zprava doleva psaná "
"arabština. Správně napsaná a přeložená aplikace s <application>gtkmm</"
"application> použije za běhu správný jazyk podle toho, jaké národní "
"prostředí má uživatel nastavené."

#: C/gtkmm-tutorial-in.xml:6502(para)
msgid ""
"You might not anticipate the need to support additional languages, but you "
"can never rule it out. And it's easier to develop the application properly "
"in the first place rather than retrofitting later."
msgstr ""
"Možná nebudete předpokládat potřebu podpory dalších jazyků, ale nikdy "
"neříkejte nikdy. A je jednodušší aplikace hned ze začátku napsat správně, "
"než ji později celou opravovat."

#: C/gtkmm-tutorial-in.xml:6508(para)
msgid ""
"The process of writing source code that allows for translation is called "
"<literal>internationalization</literal>, often abbreviated to <literal>i18n</"
"literal>. The <literal>Localization</literal> process, sometimes abbreviated "
"as <literal>l10n</literal>, provides translated text for other languages, "
"based on that source code."
msgstr ""
"Proces psaní zdrojového kódu, který umožňuje jazykové překlady, se nazývá "
"<literal>internacionalizace</literal>, což je často zkracováno na "
"<literal>i18n</literal>. <literal>Lokalizace</literal>, zkracovaná na "
"<literal>l10n</literal> je pak vlastní překlad textů vycházejících ze "
"zdrojového kódu do jiných jazyků."

#: C/gtkmm-tutorial-in.xml:6516(para)
msgid ""
"The main activity in the internationalization process is finding strings "
"seen by users and marking them for translation. You do not need to do it all "
"at once - if you set up the necessary project infrastructure correctly then "
"your application will work normally regardless of how many strings you've "
"covered."
msgstr ""
"Hlavní činností při internacionalizaci je vyhledání řetězců, které uživatele "
"uvidí a jejich označení k překladu. Nemusíte je všechny označit naráz – když "
"správně nastavíte potřebnou infrastrukturu projektu, bude vaše aplikace "
"normálně fungovat bez ohledu na to, kolik řetězců jste internacionalizací "
"pokryli."

#: C/gtkmm-tutorial-in.xml:6524(para)
msgid ""
"String literals should be typed in the source code in English, but "
"surrounded by a macro. The <application>gettext</application> (or intltool) "
"utility can then extract the marked strings for translation, and substitute "
"the translated text at runtime."
msgstr ""
"Řetězcové literály byste měli ve zdrojovém kódu psát v angličtině, ale "
"obalené do makra. Nástroj <application>gettext</application> (nebo "
"<application>intltool</application>) umí vytáhnout takto označené řetězce "
"pro překladatele a za běhu je pak nahrazovat překlady."

#: C/gtkmm-tutorial-in.xml:6532(title)
msgid "Preparing your project"
msgstr "Příprava vašeho projektu"

#: C/gtkmm-tutorial-in.xml:6535(para)
msgid ""
"In the instructions below we will assume that you will not be using "
"<application>gettext</application> directly, but <application>intltool</"
"application>, which was written specifically for <literal>GNOME</literal>. "
"<application>intltool</application> uses <function>gettext()</function>, "
"which extracts strings from source code, but <application>intltool</"
"application> can also combine strings from other files, for example from "
"desktop menu details, and GUI resource files such as <application>Glade</"
"application> files, into standard <application>gettext</"
"application><filename>.pot/.po</filename> files."
msgstr ""
"V následujících instrukcích nepočítáme s přímým použitím nástrojů "
"<application>gettext</application>, ale <application>intltool</application>, "
"které byly napsány speciálně pro projekt <literal>GNOME</literal>. "
"<application>intltool</application> používá <function>gettext()</function>, "
"který vytáhne řetězce ze zdrojového kódu, ale umí je kombinovat s řetězci z "
"dalších souborů, například ze souborů .desktop s detaily o aplikaci a ze "
"souborů <application>Glade</application> s prostředky grafického "
"uživatelského rozhraní. Výsledkem jsou standardní soubory <application>.pot/."
"po</application> ve formátu <application>gettext</application>."

#: C/gtkmm-tutorial-in.xml:6546(para)
msgid ""
"We also assume that you are using autotools (e.g. <application>automake</"
"application> and <application>autoconf</application>) to build your project, "
"and that you are using <ulink url=\"http://git.gnome.org/browse/gnome-common/"
"tree/autogen.sh\"><literal>./autogen.sh</literal> from <application>gnome-"
"common</application></ulink>, which, among other things, takes care of some "
"<application>intltool</application> initialization."
msgstr ""
"Rovněž předpokládáme použití nástrojů autotools (napří. "
"<application>automake</application> a <application>autoconf</application>) "
"pro sestavení vašeho projektu a tím pádem i použití <ulink url=\"http://git."
"gnome.org/browse/gnome-common/tree/autogen.sh\"><literal>./autogen.sh</"
"literal> z <application>gnome-common</application></ulink>, který se mimo "
"jiné věci stará o inicializaci <application>intltool</application>."

#: C/gtkmm-tutorial-in.xml:6559(para)
msgid ""
"Create a sub-directory named <literal>po</literal> in your project's root "
"directory. This directory will eventually contain all of your translations. "
"Within it, create a file named <literal>LINGUAS</literal> and a file named "
"<literal>POTFILES.in</literal>. It is common practice to also create a "
"<literal>ChangeLog</literal> file in the <literal>po</literal> directory so "
"that translators can keep track of translation changes."
msgstr ""
"Vytvořte v kořenové složce vašeho projektu podsložku s názvem <literal>po</"
"literal>. V budoucnu bude obsahovat všechny překlady. V ní vytvořte soubory "
"s názvy <literal>LINGUAS</literal> a <literal>POTFILES.in</literal>. Je "
"běžnou praxí v ní vytvořit také soubor <literal>ChangeLog</literal>, aby si "
"překladatelé mohli udržovat přehled o změnách v překladech."

#: C/gtkmm-tutorial-in.xml:6569(para)
msgid ""
"<literal>LINGUAS</literal> contains an alphabetically sorted list of codes "
"identifying the languages for which your program is translated (comment "
"lines starting with a <literal>#</literal> are ignored). Each language code "
"listed in the <literal>LINGUAS</literal> file must have a corresponding "
"<literal>.po</literal> file. So, if your program has German and Japanese "
"translations, your <literal>LINGUAS</literal> file would look like this:"
msgstr ""
"Soubor <literal>LINGUAS</literal> obsahuje abecedně seřazený seznam kódů "
"identifikujících jazyky, do kterých je aplikace přeložená (řádky začínající "
"# jsou komentáře a jsou ignorovány). Jednotlivé kódy jazyků uvedené v "
"<literal>LINGUAS</literal> musí odpovídat názvům souborů <literal>.po</"
"literal>. Když má například aplikace překlad do češtiny a japonštiny, měl by "
"váš soubor <literal>LINGUAS</literal> vypadat nějak takto:"

#: C/gtkmm-tutorial-in.xml:6578(programlisting)
#, no-wrap
msgid ""
"# keep this file sorted alphabetically, one language code per line\n"
"de\n"
"ja"
msgstr ""
"# keep this file sorted alphabetically, one language code per line\n"
"cs\n"
"ja"

#: C/gtkmm-tutorial-in.xml:6581(para)
msgid ""
"(In addition, you'd have the files <literal>ja.po</literal> and <literal>de."
"po</literal> in your <literal>po</literal> directory which contain the "
"German and Japanese translations, respectively.)"
msgstr ""
"(Podle toho pak musíte mít ve složce <literal>po</literal> soubory "
"<literal>cs.po</literal> a <literal>ja.po</literal>, které budou obsahovat "
"český, respektive japonský překlad.)"

#: C/gtkmm-tutorial-in.xml:6588(para)
msgid ""
"<literal>POTFILES.in</literal> is a list of paths to all files which contain "
"strings marked up for translation, starting from the project root directory. "
"So for example, if your project sources were located in a subdirectory named "
"<literal>src</literal>, and you had two files that contained strings that "
"should be translated, your <literal>POTFILES.in</literal> file might look "
"like this:"
msgstr ""
"Soubor <literal>POTFILES.in</literal> je seznam cest ke všem souborům, které "
"obsahují řetězce označené k překladu, počínaje kořenovou složkou projektu. "
"Takže když například má váš projekt zdrojové kódy umístěné v podsložce s "
"názvem <literal>src</literal> a v ní jsou dva soubory obsahující řetězce, "
"které chcete přeložit, může váš soubor <literal>POTFILES.in</literal> "
"vypadat nějak takto:"

#: C/gtkmm-tutorial-in.xml:6597(programlisting)
#, no-wrap
msgid ""
"src/main.cc\n"
"src/other.cc"
msgstr ""
"src/main.cc\n"
"src/other.cc"

#: C/gtkmm-tutorial-in.xml:6600(para)
msgid ""
"If you are using <application>gettext</application> directly, you can only "
"mark strings for translation if they are in source code file. However, if "
"you use <application>intltool</application>, you can mark strings for "
"translation in a variety of other file formats, including "
"<application>Glade</application> UI files, xml, <ulink url=\"http://"
"standards.freedesktop.org/desktop-entry-spec/latest/\">.desktop files</"
"ulink> and several more. So, if you have designed some of the application UI "
"in <application>Glade</application> then also add your <filename>.glade</"
"filename> files to the list in <literal>POTFILES.in</literal>."
msgstr ""
"Jestliže používáte <application>gettext</application> přímo, můžete označit "
"k překladu jen řetězce, které jsou přímo ve zdrojových kódech. Pokud ale "
"používáte <application>intltool</application>, můžete označit k překladu i "
"řetězce v různých jiných souborových formátech, včetně souborů "
"<application>Glade</application> s uživatelským rozhraním, souborů ve "
"formátu XML, <ulink url=\"http://standards.freedesktop.org/desktop-entry-"
"spec/latest/\">souborů .desktop</ulink> a několika dalších. Takže pokud máte "
"aplikaci s uživatelským rozhraním navrženým v <application>Glade</"
"application>, přidejte do <literal>POTFILES.in</literal> rovněž své soubory "
"<filename>.glade</filename>."

#: C/gtkmm-tutorial-in.xml:6613(para)
msgid ""
"Now that there is a place to put your translations, you need to initialize "
"<application>intltool</application> and <application>gettext</application>. "
"Add the following code to your <literal>configure.ac</literal>, substituting "
"'programname' with the name of your program:"
msgstr ""
"Nyní máte místo, kam dávat překlady, a teď potřebujete inicializovat "
"<application>intltool</application> a <application>gettext</application>. "
"Přidejte následující kód do svého souboru <literal>configure.ac</literal>, "
"přičemž „nazevaplikace“ nahraďte názvem svojí aplikace (platí pro celou "
"kapitolu)."

#: C/gtkmm-tutorial-in.xml:6620(programlisting)
#, no-wrap
msgid ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=programname\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [The domain to use with gettext])\n"
"AM_GLIB_GNU_GETTEXT\n"
"\n"
"PROGRAMNAME_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(PROGRAMNAME_LOCALEDIR)"
msgstr ""
"IT_PROG_INTLTOOL([0.35.0])\n"
"\n"
"GETTEXT_PACKAGE=nazev_aplikace\n"
"AC_SUBST(GETTEXT_PACKAGE)\n"
"AC_DEFINE_UNQUOTED([GETTEXT_PACKAGE], [\"$GETTEXT_PACKAGE\"],\n"
"                   [Doména, která se má použít pro gettext])\n"
"AM_GLIB_GNU_GETTEXT\n"
"\n"
"NAZEVAPLIKACE_LOCALEDIR=[${datadir}/locale]\n"
"AC_SUBST(NAZEVAPLIKACE_LOCALEDIR)"

#: C/gtkmm-tutorial-in.xml:6631(para)
msgid ""
"This <varname>PROGRAMNAME_LOCALEDIR</varname> variable will be used later in "
"the <literal>Makefile.am</literal> file, to define a macro that will be used "
"when you initialize <application>gettext</application> in your source code."
msgstr ""
"Proměnná <varname>NAZEVAPLIKACE_LOCALEDIR</varname> bude použita později v "
"souboru <literal>Makefile.am</literal> k definici makra, které se použije až "
"budeme ve zdrojovém kódu inicializovat <application>gettext</application>."

#: C/gtkmm-tutorial-in.xml:6642(para)
msgid ""
"Add <literal>po</literal> to the <literal>SUBDIRS</literal> variable. "
"Without this, your translations won't get built and installed when you build "
"the program"
msgstr ""
"Přidejte <literal>po</literal> do proměnné <literal>SUBDIRS</literal>. Bez "
"toho se překladu nebudou sestavovat a instalovat spolu s aplikací."

#: C/gtkmm-tutorial-in.xml:6649(programlisting)
#, no-wrap
msgid ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"
msgstr ""
"INTLTOOL_FILES = intltool-extract.in \\\n"
"                 intltool-merge.in \\\n"
"                 intltool-update.in"

#: C/gtkmm-tutorial-in.xml:6647(para)
msgid "Define <literal>INTLTOOL_FILES</literal> as: <placeholder-1/>"
msgstr "Definujte <literal>INTLTOOL_FILES</literal> takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6655(para)
msgid ""
"Add <literal>INTLTOOL_FILES</literal> to the <literal>EXTRA_DIST</literal> "
"list of files. This ensures that when you do a <command>make dist</command>, "
"these commands will be included in the source tarball."
msgstr ""
"Přidejte <literal>INTLTOOL_FILES</literal> do seznamu souborů "
"<literal>EXTRA_DIST</literal>. Tím se zajistí, že když provedete "
"<command>make dist</command>, budou tyto příkazy zahrnuty do zdrojového "
"balíčku."

#: C/gtkmm-tutorial-in.xml:6665(programlisting)
#, no-wrap
msgid ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"
msgstr ""
"DISTCLEANFILES = ... intltool-extract \\\n"
"                 intltool-merge \\\n"
"                 intltool-update \\\n"
"                 po/.intltool-merge-cache"

#: C/gtkmm-tutorial-in.xml:6663(para)
msgid "Update your <literal>DISTCLEANFILES</literal>: <placeholder-1/>"
msgstr "Aktualizujte svůj <literal>DISTCLEANFILES</literal>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6638(para)
msgid "In the top-level Makefile.am: <placeholder-1/>"
msgstr "V Makefile.am v nejvyšší úrovni: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6674(para)
msgid ""
"In your <literal>src/Makefile.am</literal>, update your "
"<literal>AM_CPPFLAGS</literal> to add the following preprocessor macro "
"definition:"
msgstr ""
"V souboru <literal>src/Makefile.am</literal> aktualizujte "
"<literal>AM_CPPFLAGS</literal> přidáním následujících definic maker "
"preprocesoru:"

#: C/gtkmm-tutorial-in.xml:6679(programlisting)
#, no-wrap
msgid "AM_CPPFLAGS = ... -DPROGRAMNAME_LOCALEDIR=\\\"${PROGRAMNAME_LOCALEDIR}\\\""
msgstr "AM_CPPFLAGS = ... -DNAZEVAPLIKACE_LOCALEDIR=\\\"${NAZEVAPLIKACE_LOCALEDIR}\\\""

#: C/gtkmm-tutorial-in.xml:6680(para)
msgid ""
"This macro will be used when you initialize <literal>gettext</literal> in "
"your source code."
msgstr ""
"Toto makro se použije, když inicializujete <literal>gettext</literal> ve "
"svém zdrojovém kódu."

#: C/gtkmm-tutorial-in.xml:6687(title)
msgid "Marking strings for translation"
msgstr "Označení řetězců k překladu"

#: C/gtkmm-tutorial-in.xml:6689(para)
msgid ""
"String literals should be typed in the source code in English, but they "
"should be surrounded by a call to the <function>gettext()</function> "
"function. These strings will be extracted for translation and the "
"translations may be used at runtime instead of the original English strings."
msgstr ""
"Řetězcové literály by se měly ve zdrojovém kódu psát v angličtině a zároveň "
"by měly být uzavřeny do volání funkce <function>gettext()</function>. Pak "
"budou vytaženy pro překlad a překlad bude použit za běhu místo původního "
"anglického řetězce."

#: C/gtkmm-tutorial-in.xml:6697(para)
msgid ""
"The <application>GNU gettext</application> package allows you to mark "
"strings in source code, extract those strings for translation, and use the "
"translated strings in your application."
msgstr ""
"Balíček <application>GNU gettext</application> umožňuje označit řetězce ve "
"zdrojovém kódu k překladu, vytáhnout tyto řetězce pro překlad a použít "
"přeložené řetězce v aplikaci."

#: C/gtkmm-tutorial-in.xml:6709(programlisting)
#, no-wrap
msgid "display_message(\"Getting ready for i18n.\");"
msgstr "display_message(\"Getting ready for i18n.\");"

#: C/gtkmm-tutorial-in.xml:6711(programlisting)
#, no-wrap
msgid "display_message(_(\"Getting ready for i18n.\"));"
msgstr "display_message(_(\"Getting ready for i18n.\"));"

#: C/gtkmm-tutorial-in.xml:6703(para)
#, fuzzy
msgid ""
"However, <application>Glib</application> defines <function>gettext()</"
"function> support macros which are shorter wrappers in an easy-to-use form. "
"To use these macros, include <literal>&lt;glibmm/i18n.h&gt;</literal>, and "
"then, for example, substitute: <placeholder-1/> with: <placeholder-2/>"
msgstr ""
"Nicméně <application>Glib</application> definuje makra podporující "
"<function>gettext()</function>, která zkracují obalující funkci na "
"jednodušší podobu. Když chcete tato makra použít, použijte <literal>#include "
"&lt;glibmm/i18n.h&gt;</literal> a pak například nahraďte: </literal> za: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6722(programlisting)
#, no-wrap
msgid "xgettext -a -o my-strings --omit-header *.cc *.h"
msgstr "xgettext -a -o moje-řetězce --omit-header *.cc *.h"

#: C/gtkmm-tutorial-in.xml:6714(para)
msgid ""
"For reference, it is possible to generate a file which contains all strings "
"which appear in your code, even if they are not marked for translation, "
"together with file name and line number references. To generate such a file "
"named <literal>my-strings</literal>, execute the following command, within "
"the source code directory: <placeholder-1/>"
msgstr ""
"Jen pro srovnání, je možné vygenerovat soubor, který bude obsahovat všechny "
"řetězce, které se objevují ve zdrojovém kódu, bez ohledu na to, že nejsou "
"označené k překladu, včetně názvu zdrojového souboru a čísla řádku. K "
"vygenerování takového souboru, nazvaného <literal>moje-řetězce</literal> "
"spusťte následující příkaz ve složce se zdrojovými kódy: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6729(programlisting)
#, no-wrap
msgid ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"
msgstr ""
"bindtextdomain(GETTEXT_PACKAGE, PROGRAMNAME_LOCALEDIR);\n"
"bind_textdomain_codeset(GETTEXT_PACKAGE, \"UTF-8\");\n"
"textdomain(GETTEXT_PACKAGE);"

#: C/gtkmm-tutorial-in.xml:6725(para)
msgid ""
"Finally, to let your program use the translation for the current locale, add "
"this code to the beginning of your <filename>main.cc</filename> file, to "
"initialize gettext. <placeholder-1/>"
msgstr ""
"Nakonec, aby mohla vaše aplikace používat překlady pro aktuální národní "
"prostředí, přidejte na začátek souboru <filename>main.cc</filename> tento "
"kód, aby inicializovat gettext. <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6735(title)
msgid "How gettext works"
msgstr "Jak gettext funguje"

#: C/gtkmm-tutorial-in.xml:6737(para)
msgid ""
"<application>intltool</application> / <application>xgettext</application> "
"script extracts the strings and puts them in a <filename>mypackage.pot</"
"filename> file. The translators of your application create their "
"translations by first copying this <filename>.pot</filename> file to a "
"<filename>localename.po</filename> file. A locale identifies a language and "
"an encoding for that language, including date and numerical formats. Later, "
"when the text in your source code has changed, the <literal>msmerge</"
"literal> script is used to update the <filename>localename.po</filename> "
"files from the regenerated <filename>.pot</filename> file."
msgstr ""
"Skript <application>intltool</application>/<application>xgettext</"
"application> vytáhne řetězce a vloží je do souboru <filename>mujbalicek.pot</"
"filename>. Překladatelé vaší aplikace vytvoří překlady tak, že nejprve "
"zkopírují tento soubor <filename>.pot</filename> do souboru "
"<filename>kod_narodniho_prostredi.po</filename>. Kód národního prostředí "
"udává jazyk a kódování pro tento jazyk, včetně formátu data a čísel. Když "
"později dojde ke změnám ve zdrojovém kódu, skript <literal>msmerge</literal> "
"použije znovu vygenerovaný soubor <filename>.pot</filename> k aktualizaci "
"souboru <filename>kod_narodniho_prostredi.po</filename>."

#: C/gtkmm-tutorial-in.xml:6751(para)
msgid ""
"At install time, the <filename>.po</filename> files are converted to a "
"binary format (with the extension <filename>.mo</filename>) and placed in a "
"system-wide directory for locale files, for example <filename>/usr/share/"
"locale/</filename>."
msgstr ""
"Před instalací jsou soubory <filename>.po</filename> převedeny do binárního "
"formátu (s příponou <filename>.mo</filename>) a při instalaci se nakopírují "
"do systémové složky pro lokalizační soubory, například <filename>/usr/share/"
"locale/</filename>."

#: C/gtkmm-tutorial-in.xml:6758(para)
msgid ""
"When the application runs, the <application>gettext</application> library "
"checks the system-wide directory to see if there is a <filename>.mo</"
"filename> file for the user's locale environment (you can set the locale "
"with, for instance, \"export LANG=de_DE.UTF-8\" from a bash console). Later, "
"when the program reaches a <literal>gettext</literal> call, it looks for a "
"translation of a particular string. If none is found, the original string is "
"used."
msgstr ""
"Když je aplikace spuštěna, knihovna <application>gettext</application> "
"zkontroluje systémovou složku, jestli v ní je soubor <filename>.mo</"
"filename> pro národní prostředí uživatele (národní prostředí můžete nastavit "
"například příkazem „export LANG=cs_CZ.UTF-8“ z příkazové řádky). Až později "
"běžící aplikace narazí na volání <literal>gettext</literal>, podívá se po "
"překladu konkrétního řetězce. Pokud jej nenajde, použije se řetězec původní."

#: C/gtkmm-tutorial-in.xml:6770(title)
msgid "Testing and adding translations"
msgstr "Testování a přidávání překladů"

#: C/gtkmm-tutorial-in.xml:6777(programlisting)
#, no-wrap
msgid "intltool-update --pot"
msgstr "intltool-update --pot"

#: C/gtkmm-tutorial-in.xml:6772(para)
msgid ""
"To convince yourself that you've done well, you may wish to add a "
"translation for a new locale. In order to do that, go to the <filename>po</"
"filename> subdirectory of your project and execute the following command: "
"<placeholder-1/>"
msgstr ""
"Chcete-li se přesvědčit, že jste vše udělali dobře, budete možná chtít "
"přidat překlad do nového jazyka. K tomu je potřeba přejít do podsložky "
"<filename>po</filename> ve vašem projektu a spustit následující příkaz: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6780(para)
msgid ""
"That will create a file named <filename>programname.pot</filename>. Now copy "
"that file to <filename>languagecode.po</filename>, such as <filename>de.po</"
"filename> or <filename>hu.po</filename>. Also add that language code to "
"<literal>LINGUAS</literal>. The <filename>.po</filename> file contains a "
"header and a list of English strings, with space for the translated strings "
"to be entered. Make sure you set the encoding of the <filename>.po</"
"filename> file (specified in the header, but also as content) to "
"<literal>UTF-8</literal>."
msgstr ""
"Vytvoří se tím soubor <filename>nazevaplikace.pot</filename>. Zkopírujte "
"tento soubor do <filename>kodjazyka.po</filename>, třeba <filename>cs.po</"
"filename> nebo <filename>hu.po</filename>. Příslušný jazyk také přidejte do "
"souboru <literal>LINGUAS</literal>. Soubor <filename>.po</filename> obsahuje "
"hlavičku a seznam anglických řetězců s rezervovaným místem pro zadání "
"přeložených řetězců. Ujistěte se, že je kódování souboru <filename>.po</"
"filename> nastavené na <literal>UTF-8</literal> (je to uvedené v hlavičce a "
"musí být v tomto kódování i řetězce)."

#: C/gtkmm-tutorial-in.xml:6793(para)
msgid ""
"It's possible that certain strings will be marked as <literal>fuzzy</"
"literal> in the <filename>.po</filename> file. These translations will not "
"substitute the original string. To make them appear, simply remove the "
"<literal>fuzzy</literal> tag."
msgstr ""
"Je možné, že některé řetězce budou v souboru <filename>.po</filename> "
"označené jako <literal>fuzzy</literal>. Tyto překlady nenahradí originální "
"řetězce. Aby se objevily, stačí po kontrole, a případné opravě překladu, "
"odstranit značku <literal>fuzzy</literal>."

#: C/gtkmm-tutorial-in.xml:6803(title)
msgid "Resources"
msgstr "Zdroje"

#: C/gtkmm-tutorial-in.xml:6812(ulink)
msgid "L10N Guidelines for Developers"
msgstr "příručka L10N pro vývojáře"

#: C/gtkmm-tutorial-in.xml:6819(ulink)
msgid "Intltool README"
msgstr "soubor README z intltool"

#: C/gtkmm-tutorial-in.xml:6825(ulink)
msgid "How to use Git for GNOME translators"
msgstr "jak používat Git pro překladatele GNOME"

#: C/gtkmm-tutorial-in.xml:6831(ulink)
msgid "gettext manual"
msgstr "příručka gettext"

#: C/gtkmm-tutorial-in.xml:6837(literal)
msgid "gtkmm_hello"
msgstr "gtkmm_hello"

#: C/gtkmm-tutorial-in.xml:6837(ulink) C/gtkmm-tutorial-in.xml:6843(ulink)
msgid "<placeholder-1/> example package"
msgstr "balíček s příkladem <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6843(literal)
msgid "gnomemm_hello"
msgstr "gnomemm_hello"

#: C/gtkmm-tutorial-in.xml:6805(para)
msgid ""
"More information about what lies behind the internationalization and "
"localization process is presented and demonstrated in: <placeholder-1/>"
msgstr ""
"Další informace o pozadí procesu internacionalizace a lokalizace jsou "
"představeny a ukázány v: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6853(title)
msgid "Expecting UTF8"
msgstr "Očekává se UTF-8"

#: C/gtkmm-tutorial-in.xml:6854(para)
msgid ""
"A properly internationalized application will not make assumptions about the "
"number of bytes in a character. That means that you shouldn't use pointer "
"arithmetic to step through the characters in a string, and it means you "
"shouldn't use <classname>std::string</classname> or standard C functions "
"such as <function>strlen()</function> because they make the same assumption."
msgstr ""
"Správně internacializovaná aplikace nebude mít žádné předpoklady ohledně "
"počtu bajtů na znak. To znamená, že byste neměli používat ukazatelovou "
"aritmetiku k procházení řetězců po znacích a neměli byste používat "
"<classname>std::string</classname> nebo standardní funkce C, jako je "
"<function>strlen()</function>, protože ty takové předpoklady mají."

#: C/gtkmm-tutorial-in.xml:6861(para)
msgid ""
"However, you probably already avoid bare char* arrays and pointer arithmetic "
"by using <classname>std::string</classname>, so you just need to start using "
"<classname>Glib::ustring</classname> instead. See the <link linkend=\"sec-"
"basics-ustring\">Basics</link> chapter about <classname>Glib::ustring</"
"classname>."
msgstr ""
"Místo obyčejných polí char* a ukazatelové aritmetiky už stejně nejspíše "
"používáte třídu <classname>std::string</classname>, takže stačí, když "
"přejdete místo ní na používání <classname>Glib::ustring</classname>. Viz "
"kapitola <link linkend=\"sec-basics-ustring\">Základy</link> o "
"<classname>Glib::ustring</classname>."

#: C/gtkmm-tutorial-in.xml:6869(title)
msgid "Glib::ustring and std::iostreams"
msgstr "Glib::ustring and std::iostreams"

#: C/gtkmm-tutorial-in.xml:6886(programlisting)
#, no-wrap
msgid ""
"std::ostringstream output;\n"
"output.imbue(std::locale(\"\")); // use the user's locale for this stream\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"
msgstr ""
"std::ostringstream output;\n"
"output.imbue(std::locale(\"\")); // pro tento textový proud použít uživatelův jazyk\n"
"output &lt;&lt; percentage &lt;&lt; \" % done\";\n"
"label-&gt;set_text(Glib::locale_to_utf8(output.str()));"

#. <para>TODO: This section is not clear - it needs to spell things out more clearly and obviously.</para>
#: C/gtkmm-tutorial-in.xml:6871(para)
msgid ""
"Unfortunately, the integration with the standard iostreams is not completely "
"foolproof. <application>gtkmm</application> converts <classname>Glib::"
"ustring</classname>s to a locale-specific encoding (which usually is not "
"UTF-8) if you output them to an <classname>ostream</classname> with "
"<function>operator&lt;&lt;</function>. Likewise, retrieving <classname>Glib::"
"ustrings</classname> from <classname>istream</classname> with "
"<function>operator&gt;&gt;</function> causes a conversion in the opposite "
"direction. But this scheme breaks down if you go through a <classname>std::"
"string</classname>, e.g. by inputting text from a stream to a "
"<classname>std::string</classname> and then implicitly converting it to a "
"<classname>Glib::ustring</classname>. If the string contained non-ASCII "
"characters and the current locale is not UTF-8 encoded, the result is a "
"corrupted <classname>Glib::ustring</classname>. You can work around this "
"with a manual conversion. For instance, to retrieve the <classname>std::"
"string</classname> from a <classname>ostringstream</classname>: "
"<placeholder-1/>"
msgstr ""
"Integrace se standardními iostream není bohužel úplně bezbolestná. Když "
"provádíte výstup do <classname>ostream</classname> pomocí "
"<function>operátoru &lt;&lt;</function>, <application>gtkmm</application> "
"převádí řetězce <classname>Glib::ustring</classname> na kódování podle "
"národního prostředí (které nemusí být UTF-8). Obdobně, získání řětězců "
"<classname>Glib::ustring</classname> z <classname>istream</classname> pomocí "
"<function>operátoru &gt;&gt;</function> způsobí převod opačným směrem. Tohle "
"schéma se ale naruší, když půjdete skrz <classname>std::string</classname>, "
"např. vložením textu z datového proudu do <classname>std::string</classname> "
"a jeho implicitním převodem na <classname>Glib::ustring</classname>. Pokud "
"řetězec obsahuje jiné znaky, než jen ASCII, a aktuální národní prostředí "
"není kódované v UTF-8, ve výsledkem poškozený řetězec <classname>Glib::"
"ustring</classname>. Můžete to obejít ručním převodem. Například když chcete "
"získat <classname>std::string</classname> z <classname>ostringstream</"
"classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6896(title)
msgid "Pitfalls"
msgstr "Úskalí"

#: C/gtkmm-tutorial-in.xml:6898(para)
msgid ""
"There are a few common mistakes that you would discover eventually yourself. "
"But this section might help you to avoid them."
msgstr ""
"Existuje několik běžných omylů, na které byste si jistě přišli sami. Tato "
"kapitola vám pomůže se jim vyhnout."

#: C/gtkmm-tutorial-in.xml:6901(title)
msgid "Same strings, different semantics"
msgstr "Stejné řetězce, jiný význam"

#: C/gtkmm-tutorial-in.xml:6903(para)
msgid ""
"Sometimes two english strings are identical but have different meanings in "
"different contexts, so they would probably not be identical when translated. "
"Since the English strings are used as look-up keys, this causes problems."
msgstr ""
"Občas bývají dva texty v angličtině stejné, ale mají různý význam podle "
"kontextu, takže pak budou mít nejspíše i jiné překlady. Protože se ale "
"anglické řetězce používají jako vyhledávací klíče, mám zde problém."

#: C/gtkmm-tutorial-in.xml:6907(para)
msgid ""
"In these cases, you should add extra characters to the strings. For "
"instance, use <literal>\"jumps[noun]\"</literal> and <literal>"
"\"jumps[verb]\"</literal> instead of just <literal>\"jumps\"</literal> and "
"strip them again outside the <function>gettext</function> call. If you add "
"extra characters you should also add a comment for the translators before "
"the <function>gettext</function> call. Such comments will be shown in the "
"<filename>.po</filename> files. For instance:"
msgstr ""
"V takovémto případě byste měli přidat do řetězce nějaké další znaky. "
"Například použít <literal>\"jumps[noun]\"</literal> a <literal>"
"\"jumps[verb]\"</literal> místo prostého <literal>\"jumps\"</literal> a po "
"zavolání funkce <function>gettext</function> je odříznout. Když něco "
"takového provedete, měli byste také přidat komentář pro překladatele před "
"volání <function>gettext</function>. Tyto komentáře se objeví v souborech "
"<filename>.po</filename>. Například:"

#: C/gtkmm-tutorial-in.xml:6917(programlisting)
#, no-wrap
msgid ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"
msgstr ""
"// note to translators: don't translate the \"[noun]\" part - it is\n"
"// just here to distinguish the string from another \"jumps\" string\n"
"text = strip(gettext(\"jumps[noun]\"), \"[noun]\");"

#: C/gtkmm-tutorial-in.xml:6923(title)
msgid "Composition of strings"
msgstr "Skládání řetězců"

#: C/gtkmm-tutorial-in.xml:6925(para)
msgid ""
"C programmers use <function>sprintf()</function> to compose and concatenate "
"strings. C++ favours streams, but unfortunately, this approach makes "
"translation difficult, because each fragment of text is translated "
"separately, without allowing the translators to rearrange them according to "
"the grammar of the language."
msgstr ""
"Programátoři v jazyce C používají pro skládání a spojování řetězců funkci "
"<function>sprintf()</function>. V C++ dávají přednost datovým proudům, což "
"ale bohužel znesnadňuje překlady, protože jednotlivé útržky textu se "
"překládají samostatně a nedává to překladateli možnost je přeuspořádat podle "
"pravidel gramatiky jeho jazyka."

#: C/gtkmm-tutorial-in.xml:6932(para)
msgid "For instance, this code would be problematic:"
msgstr "Například takovýto kód by mohl přinést problémy:"

#: C/gtkmm-tutorial-in.xml:6934(programlisting)
#, no-wrap
msgid ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"
msgstr ""
"std::cout &lt;&lt; _(\"Current amount: \") &lt;&lt; amount\n"
"          &lt;&lt; _(\" Future: \") &lt;&lt; future &lt;&lt; std::endl;\n"
"\n"
"label.set_text(_(\"Really delete \") + filename + _(\" now?\"));"

#: C/gtkmm-tutorial-in.xml:6943(programlisting)
#, no-wrap
msgid ""
"std::cout &lt;&lt; Glib::ustring::compose(\n"
"             _(\"Current amount: %1 Future: %2\"), amount, future) &lt;&lt; std::endl;\n"
"\n"
"label.set_text(Glib::ustring::compose(_(\"Really delete %1 now?\"), filename));"
msgstr ""
"std::cout &lt;&lt; Glib::ustring::compose(\n"
"             _(\"Current amount: %1 Future: %2\"), amount, future) &lt;&lt; std::endl;\n"
"\n"
"label.set_text(Glib::ustring::compose(_(\"Really delete %1 now?\"), filename));"

#: C/gtkmm-tutorial-in.xml:6939(para)
msgid ""
"So you should either avoid this situation or use <ulink url=\"http://"
"developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html"
"\"><function>Glib::ustring::compose()</function></ulink> which supports "
"syntax such as: <placeholder-1/>"
msgstr ""
"Proto byste se měli takovýmto situacím vyhnout nebo používat metodu <ulink "
"url=\"http://developer.gnome.org/glibmm/unstable/classGlib_1_1ustring.html"
"\"><function>Glib::ustring::compose()</function></ulink>, která podporuje "
"syntax takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:6951(title)
msgid "Assuming the displayed size of strings"
msgstr "Počítejte s dostatečnou šířkou pro zobrazení řetězců"

#: C/gtkmm-tutorial-in.xml:6953(para)
msgid ""
"You never know how much space a string will take on screen when translated. "
"It might very possibly be twice the size of the original English string. "
"Luckily, most <application>gtkmm</application> widgets will expand at "
"runtime to the required size."
msgstr ""
"Nemůžete dopředu vědět, kolik místa na obrazovce řetězec zabere po překladu. "
"Je klidně možné, že bude dvakrát delší, než anglický originál. Naštěstí se "
"většina widgetů <application>gtkmm</application> za běhu roztáhne na "
"velikost, která se po nich chce."

#: C/gtkmm-tutorial-in.xml:6957(title)
msgid "Unusual words"
msgstr "Neobvyklá slova"

#: C/gtkmm-tutorial-in.xml:6959(para)
msgid ""
"You should avoid cryptic abbreviations, slang, or jargon. They are usually "
"difficult to translate, and are often difficult for even native speakers to "
"understand. For instance, prefer \"application\" to \"app\""
msgstr ""
"Měli byste se vyhnout tajuplným zkratkám, slangu a nářečím. Většinou bývá "
"nesnadné je přeložit a někdy jim nerozumí ani rodilý mluvčí. Například "
"raději používejte „application“ než „app“."

#: C/gtkmm-tutorial-in.xml:6965(title)
msgid "Using non-ASCII characters in strings"
msgstr "Používání jiných znaků než ASCII v řetězcích"

#: C/gtkmm-tutorial-in.xml:6967(para)
msgid ""
"Currently, <application>gettext</application> does not support non-ASCII "
"characters (i.e. any characters with a code above 127) in source code. For "
"instance, you cannot use the copyright sign (©)."
msgstr ""
"V současnosti <application>gettext</application> nepodporuje jiné znaky než "
"ASCII (tj. znaky s kódem vyšším než 127) ve zdrojovém kódu. Například "
"nemůžete použít znak copyright (©)."

#: C/gtkmm-tutorial-in.xml:6973(para)
msgid ""
"To work around this, you could write a comment in the source code just "
"before the string, telling the translators to use the special character if "
"it is available in their languages. For english, you could then make an "
"American English <filename>en_US.po</filename> translation which used that "
"special character."
msgstr ""
"Pro částečné obejití byste mohli napsat do zdrojového kódu těsně před "
"řetězec komentář, ve kterém řeknete překladatelům, aby použili speciální "
"znak, pokud je v jejich jazyce dostupný. Pro angličtinu pak můžete vytvořit "
"překlad do americké angličtiny <filename>en_US.po</filename>, ve kterém "
"použijete speciální znak."

#: C/gtkmm-tutorial-in.xml:6981(title)
msgid "Getting help with translations"
msgstr "Získání pomoci s překladem"

#: C/gtkmm-tutorial-in.xml:6983(para)
msgid ""
"If your program is free software, there is a whole <literal>GNOME</literal> "
"subproject devoted to helping you make translations, the <ulink url="
"\"https://wiki.gnome.org/TranslationProject/\"><literal>GNOME</literal> "
"Translation Project</ulink>."
msgstr ""
"Pokud je vaše aplikace svobodným softwarem, je k dispozici celý dílčí "
"projekt v <literal>GNOME</literal>, který vám pomůže s překlad. Jedná se o "
"<ulink url=\"https://wiki.gnome.org/TranslationProject/\">Překladatelský "
"projekt <literal>GNOME</literal></ulink>."

#: C/gtkmm-tutorial-in.xml:6988(para)
msgid ""
"The way it works is that you upload your source code to a git repository "
"where translators can access it, then contact the gnome-i18n mailing list "
"and ask to have your program added to the <ulink url=\"http://l10n.gnome.org/"
"module/\">list of modules to translate</ulink>."
msgstr ""
"Funguje to tak, že nahrajete svoje zdrojové kódy do repozitáře git, kde se k "
"nim mohou dostat překladatelé. Pak kontaktujete poštovní konferenci gnome-"
"i18n a požádáte, aby vaši aplikaci přidali do <ulink url=\"http://l10n.gnome."
"org/module/\">seznamu modulů k překladu</ulink>."

#: C/gtkmm-tutorial-in.xml:6993(para)
msgid ""
"Then you make sure you update the file <filename>POTFILES.in</filename> in "
"the <filename>po/</filename> subdirectory (<command>intltool-update -M</"
"command> can help with this) so that the translators always access updated "
"<filename>myprogram.pot</filename> files, and simply freeze the strings at "
"least a couple of days before you make a new release, announcing it on gnome-"
"i18n. Depending on the number of strings your program contains and how "
"popular it is, the translations will then start to tick in as "
"<filename>languagename.po</filename> files."
msgstr ""
"Pak si zkontrolujte, že máte aktualizovaný soubor <filename>POTFILES.in</"
"filename> v podsložce <filename>po/</filename> (s tím vám může pomoci "
"<command>intltool-update -M</command>), aby se překladatelé dostali vždy k "
"aktuálnímu souboru <filename>vase_aplikace.pot</filename> a nejméně několik "
"dní před plánovaným vydáním zmrazte řetězce a proveďte oznámení v konferenci "
"gnome-i18n. V závislosti na množství řetězců ve vaší aplikaci a její "
"popularitě se vám začnou objevovat soubory <filename>kod_jazyka.pro</"
"filename> s překlady."

#: C/gtkmm-tutorial-in.xml:7005(para)
msgid ""
"Note that most language teams only consist of 1-3 persons, so if your "
"program contains a lot of strings, it might last a while before anyone has "
"the time to look at it. Also, most translators do not want to waste their "
"time (translating is a very time-consuming task) so if they do not assess "
"your project as being really serious (in the sense that it is polished and "
"being maintained) they may decide to spend their time on some other project."
msgstr ""
"Upozorňujeme, že většina překladatelských týmů se skládá jen z jednoho až "
"tří lidí, takže pokud vaše aplikace obsahuje spoustu řetězců, může to chvíli "
"trvat, něž si někdo najde čas se na ni podívat. Navíc většina překladatelů "
"nechce ztrácet svůj čas (překládání je časově velmi náročné) na nesolidních "
"projektech (ve smyslu, že je dotažený do použitelného stavu a udržovaný) a "
"mohou se věnovat raději jinému projektu."

#: C/gtkmm-tutorial-in.xml:7017(title) C/gtkmm-tutorial-in.xml:7135(title)
msgid "Custom Widgets"
msgstr "Vlastní widgety"

#: C/gtkmm-tutorial-in.xml:7019(para)
msgid ""
"<application>gtkmm</application> makes it very easy to derive new widgets by "
"inheriting from an existing widget class, either by deriving from a "
"container and adding child widgets, or by deriving from a single-item "
"widget, and changing its behaviour. But you might occasionally find that no "
"suitable starting point already exists. In this case, you can implement a "
"widget from scratch."
msgstr ""
"<application>gtkmm</application> velmi usnadňuje odvozování nových widgetů "
"děděním ze stávajících tříd widgetů, buď odvozením z kontejneru a přidáním "
"potomků, nebo odvozením z jednopoložkového widgetu a změnou jeho chování. "
"Občas ale můžete narazit na to, že vhodný výchozí bod neexistuje. V takovém "
"případě můžete implementovat widget od nuly."

#: C/gtkmm-tutorial-in.xml:7026(title)
msgid "Custom Containers"
msgstr "Vlastní kontejnery"

#: C/gtkmm-tutorial-in.xml:7029(para)
msgid ""
"<methodname>get_request_mode_vfunc()</methodname>: Return what <literal>Gtk::"
"SizeRequestMode</literal> is preferred by the container."
msgstr ""
"<methodname>get_request_mode_vfunc()</methodname>: Vrací, kterému "
"<literal>Gtk::SizeRequestMode</literal> kontejner dává přednost."

#: C/gtkmm-tutorial-in.xml:7030(para)
msgid ""
"<methodname>get_preferred_width_vfunc()</methodname>: Calculate the minimum "
"and natural width of the container."
msgstr ""
"<methodname>get_preferred_width_vfunc()</methodname>: Vypočítá minimální a "
"přirozenou šířku kontejneru."

#: C/gtkmm-tutorial-in.xml:7031(para)
msgid ""
"<methodname>get_preferred_height_vfunc()</methodname>: Calculate the minimum "
"and natural height of the container."
msgstr ""
"<methodname>get_preferred_height_vfunc()</methodname>: Vypočítá minimální a "
"přirozenou výšku kontejneru."

#: C/gtkmm-tutorial-in.xml:7032(para)
msgid ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Calculate "
"the minimum and natural width of the container, if it would be given the "
"specified height."
msgstr ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Vypočítá "
"minimální a přirozenou šířku kontejneru, když by byla dána konkrétní výška."

#: C/gtkmm-tutorial-in.xml:7033(para)
msgid ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Calculate "
"the minimum and natural height of the container, if it would be given the "
"specified width."
msgstr ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Vypočítá "
"minimální a přirozenou výšku kontejneru, když by byla dána konkrétní šířka."

#: C/gtkmm-tutorial-in.xml:7034(para)
msgid ""
"<methodname>on_size_allocate()</methodname>: Position the child widgets, "
"given the height and width that the container has actually been given."
msgstr ""
"<methodname>on_size_allocate()</methodname>: Umístí synovské widgety s "
"ohledem na výšku a šířku, kterou kontejner skutečně uvedl."

#: C/gtkmm-tutorial-in.xml:7035(para)
msgid ""
"<methodname>forall_vfunc()</methodname>: Call the same callback for each of "
"the children."
msgstr ""
"<methodname>forall_vfunc()</methodname>: Zavolá to stejné zpětné volání pro "
"jednotlivé potomky."

#: C/gtkmm-tutorial-in.xml:7036(para)
msgid "<methodname>on_add()</methodname>: Add a child widget to the container."
msgstr ""
"<methodname>on_add()</methodname>: Přidá widget jako potomka do kontejneru."

#: C/gtkmm-tutorial-in.xml:7037(para)
msgid ""
"<methodname>on_remove()</methodname>: Remove a child widget from the "
"container."
msgstr ""
"<methodname>on_remove()</methodname>: Odstraní synovský widget z kontejneru."

#: C/gtkmm-tutorial-in.xml:7038(para)
msgid ""
"<methodname>child_type_vfunc()</methodname>: Return what type of child can "
"be added."
msgstr ""
"<methodname>child_type_vfunc()</methodname>: Vrátí, jaký typ potomka lze "
"přidat."

#: C/gtkmm-tutorial-in.xml:7027(para)
msgid ""
"When deriving from <classname>Gtk::Container</classname>, you should "
"override the following virtual methods: <placeholder-1/>"
msgstr ""
"Když odvozujete z třídy <classname>Gtk::Container</classname>, měli byste "
"přepsat následující virtuální metody: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:7042(para)
msgid ""
"The <methodname>get_request_mode_vfunc()</methodname>, "
"<methodname>get_preferred_width_vfunc()</methodname>, "
"<methodname>get_preferred_height_vfunc()</methodname>, "
"<methodname>get_preferred_width_for_height_vfunc()</methodname>, "
"<methodname>get_preferred_height_for_width_vfunc()</methodname>, and "
"<methodname>on_size_allocate()</methodname> virtual methods control the "
"layout of the child widgets. For instance, if your container has 2 child "
"widgets, with one below the other, your "
"<methodname>get_request_mode_vfunc()</methodname> might request height-for-"
"width layout. Then your <methodname>get_preferred_width_vfunc()</methodname> "
"might report the maximum of the widths of the child widgets, and "
"<methodname>get_preferred_height_for_width_vfunc()</methodname> might report "
"the sum of their heights. If you want padding between the child widgets then "
"you would add that to the width and height too. Your widget's container will "
"use this result to ensure that your widget gets enough space, and not less. "
"By examining each widget's parent, and its parent, this logic will "
"eventually decide the size of the top-level window."
msgstr ""
"Virtuální metody <methodname>get_request_mode_vfunc()</methodname>, "
"<methodname>get_preferred_width_vfunc()</methodname>, "
"<methodname>get_preferred_height_vfunc()</methodname>, "
"<methodname>get_preferred_width_for_height_vfunc()</methodname>, "
"<methodname>get_preferred_height_for_width_vfunc()</methodname> a "
"<methodname>on_size_allocate()</methodname> řídí rozvržení synovských "
"widgetů. Například, když má kontejner dva synovské widgety, jeden nad "
"druhým, mohla by metoda <methodname>get_request_mode_vfunc()</methodname> "
"požádat o rozvržení height-for-width (widget si řekne, kolik místa na výšku "
"chce podle toho, kolik ho dostane na šířku). Pak by metoda "
"<methodname>get_preferred_width_vfunc()</methodname> mohla oznámit maximální "
"šířku synovských widgetů a metoda "
"<methodname>get_preferred_height_for_width_vfunc()</methodname> součet "
"jejich výšek. Pokud chcete mezi synovskými widgety odsazení, pak byste jej "
"přidali navíc k šířce a výšce. Kontejner pro widgety použije tyto výsledky, "
"aby zajistil, že widgety budou mít dostatek místa a ne méně. Postupným "
"zkoumáním rodičů widgetů a jejich rodičů a tak dále tato logika nakonec "
"rozhodne o velikosti okna nejvyšší úrovně."

#: C/gtkmm-tutorial-in.xml:7062(para)
msgid ""
"You are not guaranteed to get the <literal>Gtk::SizeRequestMode</literal> "
"that you request. Therefore all four of the "
"<methodname>get_preferred_xxx_vfunc()</methodname> methods must return "
"sensible values."
msgstr ""
"Není zaručeno, že dostanete velikost <literal>Gtk::SizeRequestMode</"
"literal>, kterou požadujete. Proto všechny čtyři metody "
"<methodname>get_preferred_xxx_vfunc()</methodname> musí vracet proměnlivé "
"hodnoty."

#: C/gtkmm-tutorial-in.xml:7067(para)
msgid ""
"<methodname>on_size_allocate()</methodname> receives the actual height and "
"width that the parent container has decided to give to your widget. This "
"might be more than the minimum, or even more than the natural size, for "
"instance if the top-level window has been expanded. You might choose to "
"ignore the extra space and leave a blank area, or you might choose to expand "
"your child widgets to fill the space, or you might choose to expand the "
"padding between your widgets. It's your container, so you decide. Don't "
"forget to call <methodname>set_allocation()</methodname> inside your "
"<methodname>on_size_allocate()</methodname> implementation to actually use "
"the allocated space that has been offered by the parent container."
msgstr ""
"<methodname>on_size_allocate()</methodname> obdrží skutečnou výšku a šířku, "
"kterou se rodičovský kontejner rozhodl widgetu dát. Což může být více než "
"minimum, i více než nahlášená přirozená velikost, například v případě "
"roztaženého hlavního okna. Můžete si zvolit, že budete místo navíc ignorovat "
"a necháte oblast prázdnou, nebo můžete zvolit roztažení synovského widgetu, "
"aby místo zaplnil, nebo můžete zvolit roztažení odsazení mezi widgety. Je to "
"váš kontejner, vaše rozhodnutí. Nezapomeňte zavolat "
"<methodname>set_allocation()</methodname> uvnitř implementace "
"<methodname>on_size_allocate()</methodname>, aby se skutečně použilo "
"naalokované místo, které bylo rodičovským kontejnerem nabídnuto."

#: C/gtkmm-tutorial-in.xml:7079(para)
msgid ""
"Unless your container is a top-level window that derives from "
"<classname>Gtk::Window</classname>, you should probably also call "
"<methodname>Gtk::Widget::set_has_window(false)</methodname> in your "
"constructor. This means that your container does not create its own "
"<classname>Gdk::Window</classname>, but uses its parent's window. (Note the "
"difference between <classname>Gtk::Window</classname> and <classname>Gdk::"
"Window</classname>.) If your container does need its own <classname>Gdk::"
"Window</classname>, and does not derive from <classname>Gtk::Window</"
"classname>, you must also override the <methodname>on_realize()</methodname> "
"method as described in the <link linkend=\"sec-custom-widgets\">Custom "
"Widgets</link> section. And unless your container draws directly onto the "
"underlying <classname>Gdk::Window</classname>, you should probably call "
"<methodname>set_redraw_on_allocate(false)</methodname> to improve "
"performance."
msgstr ""
"Vyjma situace, kdy je kontejner oknem nejvyšší úrovně odvozeným z "
"<classname>Gtk::Window</classname>, měli byste pravděpodobně ve svém "
"konstruktoru také volat <methodname>Gtk::Widget::set_has_window(false)</"
"methodname>. Znamená to, že váš kontejner nevytváří své vlastní okno "
"<classname>Gdk::Window</classname>, ale používá okno rodiče. (Všimněte si "
"rozdílu mezi <classname>Gtk::Window</classname> and <classname>Gdk::Window</"
"classname>.) Pokud váš kontejner nepotřebuje svůj vlastní objekt "
"<classname>Gdk::Window</classname> a není odvozený z <classname>Gtk::Window</"
"classname>, musíte rovněž přepsat metodu <methodname>on_realize()</"
"methodname>, jak bylo popsáno v oddíle <link linkend=\"sec-custom-widgets"
"\">Vlastní widgety</link>. A pokud váš kontejner nekreslí přímo do "
"podkladového <classname>Gdk::Window</classname>, budete muset kvůli "
"vylepšení výkonu pravděpodobně volat "
"<methodname>set_redraw_on_allocate(false)</methodname>."

#: C/gtkmm-tutorial-in.xml:7095(para)
msgid ""
"By overriding <methodname>forall_vfunc()</methodname> you can allow "
"applications to operate on all of the container's child widgets. For "
"instance, <methodname>show_all_children()</methodname> uses this to find all "
"the child widgets and show them."
msgstr ""
"Přepsáním <methodname>forall_vfunc()</methodname> umožníte aplikacím "
"operovat se všemi synovskými widgety v kontejneru. Například "
"<methodname>show_all_children()</methodname> ji používá k vyhledání všech "
"synovských widgetů a jejich zobrazení."

#: C/gtkmm-tutorial-in.xml:7100(para)
msgid ""
"Although your container might have its own method to set the child widgets, "
"you should still provide an implementation for the virtual "
"<methodname>on_add()</methodname> and <methodname>on_remove()</methodname> "
"methods from the base class, so that the add() and remove() methods will do "
"something appropriate if they are called."
msgstr ""
"Ačkoliv váš kontejner může mít svoji vlastní metodu pro nastavení synovských "
"widgetů, měli byste i tak poskytnou implementaci pro virtuální metody "
"<methodname>on_add()</methodname> a <methodname>on_remove()</methodname> ze "
"základní třídy tak, aby obě metody dělali něco vhodného, když jsou zavolány."

#: C/gtkmm-tutorial-in.xml:7106(para)
msgid ""
"Your implementation of the <methodname>child_type_vfunc()</methodname> "
"method should report the type of widget that may be added to your container, "
"if it is not yet full. This is usually <methodname>Gtk::Widget::get_type()</"
"methodname> to indicate that the container may contain any class derived "
"from <classname>Gtk::Widget</classname>. If the container may not contain "
"any more widgets, then this method should return <literal>G_TYPE_NONE</"
"literal>."
msgstr ""
"Vaše implementace metody <methodname>child_type_vfunc()</methodname> by měla "
"hlásit typ widgetu, který je možné přidat do vašeho kontejneru za "
"předpokladu, že ještě není plný. Obvykle to je <methodname>Gtk::Widget::"
"get_type()</methodname>, abyste dali najevo, že kontejner může obsahovat "
"libovolnou třídu zděděnou z <classname>Gtk::Widget</classname>. Pokud "
"kontejner již nemůže pojmou žádný další widget, měla by tato metoda vráti "
"<literal>G_TYPE_NONE</literal>."

#: C/gtkmm-tutorial-in.xml:7118(para)
msgid ""
"This example implements a container with two child widgets, one above the "
"other. Of course, in this case it would be far simpler just to use a "
"vertical <classname>Gtk::Box</classname>."
msgstr ""
"Tento příklad implementuje kontejner, který má dva synovské widgety nad "
"sebou. Samozřejmě v praxi by v tomto případě bylo jednodušší prostě použít "
"svislý <classname>Gtk::Box</classname>."

#: C/gtkmm-tutorial-in.xml:7123(title)
msgid "Custom Container"
msgstr "Vlastní kontejner"

#: C/gtkmm-tutorial-in.xml:7136(para)
msgid ""
"By deriving directly from <classname>Gtk::Widget</classname> you can do all "
"the drawing for your widget directly, instead of just arranging child "
"widgets. For instance, a <classname>Gtk::Label</classname> draws the text of "
"the label, but does not do this by using other widgets."
msgstr ""
"Při odvození z <classname>Gtk::Widget</classname> můžete provádět veškeré "
"kreslení pro svůj widget přímo, místo abyste jen uspořádali synovské "
"widgety. Například <classname>Gtk::Label</classname> kreslí text popisku, "
"ale nedělá to to pomocí jiných widgetů."

#: C/gtkmm-tutorial-in.xml:7147(para)
msgid ""
"<methodname>get_request_mode_vfunc()</methodname>: (optional) Return what "
"<literal>Gtk::SizeRequestMode</literal> is preferred by the widget."
msgstr ""
"<methodname>get_request_mode_vfunc()</methodname>: (volitelné) Vrátí, který "
"režim <literal>Gtk::SizeRequestMode</literal> je widgetem upřednostňován."

#: C/gtkmm-tutorial-in.xml:7148(para)
msgid ""
"<methodname>get_preferred_width_vfunc()</methodname>: Calculate the minimum "
"and natural width of the widget."
msgstr ""
"<methodname>get_preferred_width_vfunc()</methodname>: Vypočítá minimální a "
"přirozenou šířku widgetu."

#: C/gtkmm-tutorial-in.xml:7149(para)
msgid ""
"<methodname>get_preferred_height_vfunc()</methodname>: Calculate the minimum "
"and natural height of the widget."
msgstr ""
"<methodname>get_preferred_height_vfunc()</methodname>: Vypočítá minimální a "
"přirozenou výšku widgetu."

#: C/gtkmm-tutorial-in.xml:7150(para)
msgid ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Calculate "
"the minimum and natural width of the widget, if it would be given the "
"specified height."
msgstr ""
"<methodname>get_preferred_width_for_height_vfunc()</methodname>: Vypočítá "
"minimální a přirozenou šířku widgetu pro situaci, že by byla určena "
"konkrétní výška."

#: C/gtkmm-tutorial-in.xml:7151(para)
msgid ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Calculate "
"the minimum and natural height of the widget, if it would be given the "
"specified width."
msgstr ""
"<methodname>get_preferred_height_for_width_vfunc()</methodname>: Vypočítá "
"minimální a přirozenou výšku widgetu pro situaci, že by byla určena "
"konkrétní šířka."

#: C/gtkmm-tutorial-in.xml:7152(para)
msgid ""
"<methodname>on_size_allocate()</methodname>: Position the widget, given the "
"height and width that it has actually been given."
msgstr ""
"<methodname>on_size_allocate()</methodname>: Umístí widget s ohledem na "
"výšku a šířku, které byly skutečně zadány."

#: C/gtkmm-tutorial-in.xml:7153(para)
msgid ""
"<methodname>on_realize()</methodname>: Associate a <classname>Gdk::Window</"
"classname> with the widget."
msgstr ""
"<methodname>on_realize()</methodname>: Přidruží widget k oknu "
"<classname>Gdk::Window</classname>."

#: C/gtkmm-tutorial-in.xml:7154(para)
msgid ""
"<methodname>on_unrealize()</methodname>: (optional) Break the association "
"with the <classname>Gdk::Window</classname>."
msgstr ""
"<methodname>on_unrealize()</methodname>: (volitelné) Zruší přidružení k oknu "
"<classname>Gdk::Window</classname>."

#: C/gtkmm-tutorial-in.xml:7155(para)
msgid "<methodname>on_map()</methodname>: (optional)"
msgstr "<methodname>on_map()</methodname>: (volitelné)"

#: C/gtkmm-tutorial-in.xml:7156(para)
msgid "<methodname>on_unmap()</methodname>: (optional)"
msgstr "<methodname>on_unmap()</methodname>: (volitelné)"

#: C/gtkmm-tutorial-in.xml:7157(para)
msgid ""
"<methodname>on_draw()</methodname>: Draw on the supplied <classname>Cairo::"
"Context</classname>."
msgstr ""
"<methodname>on_draw()</methodname>: Kreslí na poskytnutý <classname>Cairo::"
"Context</classname>."

#: C/gtkmm-tutorial-in.xml:7142(para)
msgid ""
"When deriving from <classname>Gtk::Widget</classname>, you should override "
"the following virtual methods. The methods marked (optional) need not be "
"overridden in all custom widgets. The base class's methods may be "
"appropriate. <placeholder-1/>"
msgstr ""
"Když odvozujete z třídy <classname>Gtk::Widget</classname>, měli byste "
"přepsat následující virtuální metody. Metody označené „(volitelné)“ není "
"potřeba přepsat ve všech vlastních widgetech. U základních metod třídy to "
"může být vhodné. <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:7161(para)
msgid ""
"The first 6 methods in the previous table are also overridden in custom "
"containers. They are briefly described in the <link linkend=\"sec-custom-"
"containers\">Custom Containers</link> section."
msgstr ""
"Prvních šet metod z předchozí tabulky se přepisuje také ve vlastních "
"kontejnerech. Stručně jsou popsány v oddíle <link linkend=\"sec-custom-"
"containers\">Vlastní kontejnery</link>."

#: C/gtkmm-tutorial-in.xml:7166(para)
msgid ""
"Most custom widgets need their own <classname>Gdk::Window</classname> to "
"draw on. Then you can call <methodname>Gtk::Widget::set_has_window(true)</"
"methodname> in your constructor. (This is the default value.) If you do not "
"call <methodname>set_has_window(false)</methodname>, you must override "
"<methodname>on_realize()</methodname> and call <methodname>Gtk::Widget::"
"set_realized()</methodname> and <methodname>Gtk::Widget::set_window()</"
"methodname> from there."
msgstr ""
"Většina widgetů potřebuje své vlastní <classname>Gdk::Window</classname>, "
"aby na něj mohly kreslit. Pak můžete ve svém konstruktoru zavolat "
"<methodname>Gtk::Widget::set_has_window(true)</methodname>. (Jedná se o "
"výchozí hodnotu.) Když <methodname>set_has_window(false)</methodname> "
"nezavoláte, musíte přepsat <methodname>on_realize()</methodname> a zavolat "
"od tam <methodname>Gtk::Widget::set_realized()</methodname> a "
"<methodname>Gtk::Widget::set_window()</methodname>."

#: C/gtkmm-tutorial-in.xml:7177(para)
msgid "This example implements a widget which draws a Penrose triangle."
msgstr "Tento příklad implementuje widget, který kreslí Penroseův trojúhelník."

#: C/gtkmm-tutorial-in.xml:7180(title)
msgid "Custom Widget"
msgstr "Vlastní widget"

#: C/gtkmm-tutorial-in.xml:7196(title)
msgid "Multi-threaded programs"
msgstr "Vícevláknové programy"

#: C/gtkmm-tutorial-in.xml:7199(title)
msgid "The constraints"
msgstr "Omezení"

#: C/gtkmm-tutorial-in.xml:7201(para)
msgid ""
"<application>glibmm</application> provides the normal set of thread "
"launching functions, mutexes, condition variables and scoped locking classes "
"required for writing multi-threaded programs using C++."
msgstr ""
"<application>gtkmm</application> poskytuje normální sadu funkcí na spouštění "
"vláken, mutexy, podmíněné proměnné a třídy na zamykání v rozsahu působnosti "
"pro psaní vícevláknových programů pomocí C++."

#: C/gtkmm-tutorial-in.xml:7216(para)
msgid ""
"These interactions arise from the fact that, amongst other things, a class "
"inheriting from <classname>sigc::trackable</classname> will, via that "
"inheritance, have a <classname>std::list</classname> object keeping track of "
"slots created by calls to <function>sigc::mem_fun()</function> representing "
"any of its non-static methods (more particularly it keeps a list of "
"callbacks which will null the connected slots on its destruction). Each "
"<classname>sigc::slot</classname> object also keeps, via <classname>sigc::"
"slot_rep</classname>, its own <classname>sigc::trackable</classname> object "
"to track any <classname>sigc::connection</classname> objects which it needs "
"to inform about its demise, and also has a function to deregister itself "
"from any <classname>sigc::trackable</classname> on disconnection or "
"destruction. <classname>sigc::signal</classname> objects also keep lists of "
"slots, which will be updated by a call to their <methodname>connect()</"
"methodname> method or calls to any <classname>sigc::connection</classname> "
"object relating to such a connection."
msgstr ""
"Tyto interakce vyplývají ze skutečnosti, že, mimo jiné, třída dědící z "
"<classname>sigc::trackable</classname> bude mít, prostřednictvím rozhraní, "
"objekt <classname>std::list</classname> sledující sloty vytvořené voláním "
"<function>sigc::mem_fun()</function> představující jejich nestatické metody "
"(lépe řečeno, sleduje seznam zpětných volání, která nastavují na null "
"napojené sloty při jejich destrukci). Jednotlivé objekty <classname>sigc::"
"slot</classname> také udržují, přes <classname>sigc::slot_rep</classname>, "
"svůj vlastní objekt <classname>sigc::trackable</classname> pro sledování "
"objektů <classname>sigc::connection</classname>, které potřebuje kvůli "
"informacím o jejich zániku, a také má funkci k odregistrování sebe sama z "
"<classname>sigc::trackable</classname> pro odpojení nebo destrukci. Objekty "
"<classname>sigc::signal</classname> také uchovávají seznam slotů, které "
"budou aktualizovány voláním jejich metody <methodname>connect()</methodname> "
"nebo voláním objektu <classname>sigc::connection</classname> vztahujícího se "
"k takovému napojení."

#: C/gtkmm-tutorial-in.xml:7207(para)
msgid ""
"However, care is required when writing programs based on <application>gtkmm</"
"application> using multiple threads of execution, arising from the fact that "
"<application>libsigc++</application>, and in particular <classname>sigc::"
"trackable</classname>, are not thread-safe. That's because none of the "
"complex interactions that occur behind the scenes when using "
"<application>libsigc++</application> are protected by a mutex or other means "
"of synchronization. <placeholder-1/>"
msgstr ""
"Přesto je potřeba při psaní programů založených na <application>gtkmm</"
"application> a používajících spouštění více vláken věnovat některým věcem "
"pozornost. Pramení to z faktu, že <application>libsigc++</application>, a "
"zejména <classname>sigc::trackable</classname>, nejsou bezpečné z hlediska "
"vláken. Je to proto, že žádné složitější interakce, které se vyskytují při "
"použití <application>libsigc++</application>, nejsou chráněné mutexem nebo "
"jiným synchronizačním mechanizmem. <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:7240(title)
msgid "The rules"
msgstr "Pravidla"

#: C/gtkmm-tutorial-in.xml:7242(para)
msgid ""
"This requires a number of rules to be observed when writing multi-threaded "
"programs using <application>gtkmm</application>. These are set out below, "
"but one point to note is that extra care is required when deriving classes "
"from <classname>sigc::trackable</classname>, because the effects are "
"unintuitive (see particularly points 4 and 5 below)."
msgstr ""
"Celé to vyžaduje řadu pravidel, kterých je třeba se držet při psaní "
"vícevláknových aplikací pomocí <application>gtkmm</application>. Jsou "
"uvedena níže, ale jedna věc stojí zvlášť za pozornost, a to, že je potřeba "
"věnovat speciální péči odvozování tříd z <classname>sigc::trackable</"
"classname>, protože efekty jsou nepředvidatelné (viz hlavně body 4 a 5 níže)."

#: C/gtkmm-tutorial-in.xml:7253(para)
msgid ""
"Use <classname>Glib::Dispatcher</classname> to invoke <application>gtkmm</"
"application> functions from worker threads (this is dealt with in more "
"detail in the next section)."
msgstr ""
"Použijte <classname>Glib::Dispatcher</classname> k vyvolání funkcí "
"<application>gtkmm</application> z pracovních vláken (podrobněji bude "
"rozebráno dále)."

#: C/gtkmm-tutorial-in.xml:7261(para)
msgid ""
"A <classname>sigc::signal</classname> object should be regarded as owned by "
"the thread which created it. Only that thread should connect a "
"<classname>sigc::slot</classname> object to the signal object, and only that "
"thread should <methodname>emit()</methodname> or call <methodname>operator()"
"()</methodname> on the signal, or null any connected <classname>sigc::slot</"
"classname> object. It follows (amongst other things) that any signal object "
"provided by a <application>gtkmm</application> widget should only be "
"operated on in the main GUI thread and any object deriving from "
"<classname>sigc::trackable</classname> having its non-static methods "
"referenced by slots connected to the signal object should only be destroyed "
"in that thread."
msgstr ""
"Objekt <classname>sigc::signal</classname> by měl být považován za vlastněný "
"vláknem, které jej vytvořilo. Pouze toto vlákno by mělo napojit objekt "
"<classname>sigc::slot</classname> na objekt signálu a pouze toto vlákno by "
"mělo vyslat signál pomocí <methodname>emit()</methodname>, nebo na signál "
"zavolat <methodname>operator()()</methodname>, nebo napojený objekt "
"<classname>sigc::slot</classname> anulovat. Z toho vyplývá (mimo jiné), že "
"objekt signálu poskytovaný widgetem <application>gtkmm</application> by měl "
"operovat jen v hlavním vlákně starajícím se o grafické uživatelské rozhraní "
"a objekt odvozený z <classname>sigc::trackable</classname> mající nestatické "
"metody, na které se odkazuje slot napojený na objekt signálu, by měl být "
"zlikvidován v tomto vlákně."

#: C/gtkmm-tutorial-in.xml:7277(para)
msgid ""
"Any <classname>sigc::connection</classname> object should be regarded as "
"owned by the thread in which the method returning the <classname>sigc::"
"connection</classname> object was called. Only that thread should call "
"<classname>sigc::connection</classname> methods on the object."
msgstr ""
"Objekt <classname>sigc::connection</classname> by měl být považován za "
"vlastněný vláknem, ve kterém byl metoda vracející objekt <classname>sigc::"
"connection</classname> zavolána. Jen toto vlákno by mělo volat metody "
"<classname>sigc::connection</classname> na objektu."

#: C/gtkmm-tutorial-in.xml:7287(para)
msgid ""
"A <classname>sigc::slot</classname> object created by a call to "
"<function>sigc::mem_fun()</function> which references a method of a class "
"deriving from <classname>sigc::trackable</classname> should never be copied "
"to another thread, nor destroyed by a different thread than the one which "
"created it. (One consequence of this is that <methodname>Glib::Threads::"
"Thread::create()</methodname> should not be called with a slot argument "
"created by a call to <function>sigc::mem_fun()</function> which represents a "
"method of such a class. It is however safe to pass <methodname>Glib::"
"Threads::Thread::create()</methodname> a function object representing such a "
"method by using, say, <function>boost::bind()</function> or, in C++11, "
"<function>std::bind()</function> or a C++11 lambda expression.)"
msgstr ""
"Objekt <classname>sigc::slot</classname> vytvořený zavoláním <function>sigc::"
"mem_fun()</function>, který odkazuje na metodu třídy odvozené z "
"<classname>sigc::trackable</classname> by neměl být kopírován do jiného "
"vlákna, ani zničen jiným vláknem, než tím, které ho vytvořilo. (Jedním "
"důsledkem toho je, že <methodname>Gllib::Thread::create()</methodname> by "
"nemělo být voláno s argumentem se slotem, který byl vytvořený zavoláním "
"<function>sigc::mem_fun()</function>, která představuje metodu takového "
"třídy. Je však bezpečné předat objekt funkce <methodname>Glib::Threads:"
"Thread::create()</methodname> představující takovou metodu třeba pomocí "
"<function>boost::bind()</function> nebo v C++11 pomocí <function>std::"
"bind()</function> nebo lambda výrazem z C++11.)"

#: C/gtkmm-tutorial-in.xml:7305(para)
msgid ""
"If a particular class object derives from <classname>sigc::trackable</"
"classname>, only one thread should create <classname>sigc::slot</classname> "
"objects representing any of the class's non-static methods by calling "
"<function>sigc::mem_fun()</function>. The first thread to create such a slot "
"should be regarded as owning the relevant object for the purpose of creating "
"further slots referencing <emphasis>any</emphasis> of its non-static methods "
"using that function, or nulling those slots by disconnecting them or "
"destroying the trackable object."
msgstr ""
"Pokud je určitý objekt třídy odvozený z <classname>sigc::trackable</"
"classname>, jen jedno vlákno by mělo vytvářet objekty <classname>sigc::slot</"
"classname> představující některou z nestatických metod třídy volánm "
"<function>sigc::mem_fun()</function>. První vlákno, které má vytvořit "
"takovýto slot, by mělo být považováno za vlastníka příslušného objektu za "
"účelem vytváření dalších slotů odkazujících na <emphasis>kteroukoliv</"
"emphasis> z jeho nestatických metod používajících tuto funkci, nebo anulovat "
"tyto sloty jejich odpojením nebo zničeném sledovacího objektu."

#: C/gtkmm-tutorial-in.xml:7319(para)
msgid ""
"Although <application>glib</application> is itself thread-safe, any "
"<application>glibmm</application> wrappers which use <application>libsigc++</"
"application> will not be. So for example, only the thread in which a main "
"loop runs should call <methodname>Glib::SignalIdle::connect()</methodname>, "
"<methodname>Glib::SignalIO::connect()</methodname>, <methodname>Glib::"
"SignalTimeout::connect()</methodname>, <methodname>Glib::SignalTimeout::"
"connect_seconds</methodname> for that main loop, or manipulate any "
"<classname>sigc::connection</classname> object returned by them."
msgstr ""
"Ačkoliv <application>glib</application> je sama o sobě z hlediska vláken "
"bezpečná, některé obalující funkce z <application>glibmm</application>, "
"které používají <application>libsigc++</application>, bezpečné nebudou. "
"Takže například jen vlákno, ve kterém běží hlavní smyčka by mělo volat "
"<methodname>Glib::SignalIdle::connect()</methodname>, <methodname>Glib::"
"SignalIO::connect()</methodname>, <methodname>Glib::SignalTimeout::"
"connect()</methodname>, <methodname>Glib::SignalTimeout::connect_seconds</"
"methodname> pro hlavní smyčku, nebo manipulovat s objektem <classname>sigc::"
"connection</classname>, který vrací."

#: C/gtkmm-tutorial-in.xml:7331(para)
msgid ""
"The connect*_once() variants, <methodname>Glib::SignalIdle::connect_once()</"
"methodname>, <methodname>Glib::SignalTimeout::connect_once()</methodname>, "
"<methodname>Glib::SignalTimeout::connect_seconds_once()</methodname>, are "
"thread-safe for any case where the slot is not created by a call to "
"<function>sigc::mem_fun()</function> which represents a method of a class "
"deriving from <classname>sigc::trackable</classname>. This is similar to "
"<methodname>Glib::Threads::Thread::create()</methodname> as mentioned in "
"point 4."
msgstr ""
"Varianty connect*_once(), <methodname>Glib::SignalIdle::connect_once()</"
"methodname>, <methodname>Glib::SignalTimeout::connect_once()</methodname>, "
"<methodname>Glib::SignalTimeout::connect_seconds_once()</methodname>, jsou "
"bezpečné z hlediska vláken pro libovolný případ, kde slot není vytvořený "
"voláním <function>sigc::mem_fun()</function>, která představuje metodu třídy "
"odvozené z <classname>sigc::trackable</classname>. Je to obdobné jako "
"<methodname>Glib::Threads::Thread::create()</methodname>, která byla zmíněna "
"v bodě 4."

#: C/gtkmm-tutorial-in.xml:7350(title)
msgid "Using Glib::Dispatcher"
msgstr "Používání Glib::Dispatcher"

#: C/gtkmm-tutorial-in.xml:7352(para)
msgid ""
"The slots connected to <classname>sigc::signal</classname> objects execute "
"in the thread which calls <methodname>emit()</methodname> or "
"<methodname>operator()()</methodname> on the signal. <classname>Glib::"
"Dispatcher</classname> does not behave this way: instead its connected slots "
"execute in the thread in which the <classname>Glib::Dispatcher</classname> "
"object was constructed (which must have a glib main loop). If a "
"<classname>Glib::Dispatcher</classname> object is constructed in the main "
"GUI thread (which will therefore be the receiver thread), any worker thread "
"can emit on it and have the connected slots safely execute "
"<application>gtkmm</application> functions."
msgstr ""
"Sloty napojené na objekty <classname>sigc::signal</classname> běží ve "
"vlákně, které volá na signál <methodname>emit()</methodname> nebo "
"<methodname>operator()</methodname>. <classname>Glib::Dispatcher</classname> "
"se takto nechová: místo toho jeho napojené sloty běží ve vlákně, ve kterém "
"byl objekt <classname>Glib::Dispatcher</classname> vytvořen (které musí mít "
"hlavní smyčku glib). Pokud je objekt <classname>Glib::Dispatcher</classname> "
"vytvořen v hlavním vlákně grafického uživatelského rozhraní (který tedy bude "
"mít přijímací vlákno), libovolné pracovním vlákno pro něj může vysílat a mít "
"napojené sloty, které mohou bezpečně spouštět funkce <application>gtkmm</"
"application>. "

#: C/gtkmm-tutorial-in.xml:7366(para)
msgid ""
"Some thread safety rules on the use of <classname>Glib::Dispatcher</"
"classname> still apply. As mentioned, a <classname>Glib::Dispatcher</"
"classname> object must be constructed in the receiver thread (the thread in "
"whose main loop it will execute its connected slots). By default this is the "
"main program thread, although there is a <classname>Glib::Dispatcher</"
"classname> constructor which can take the <classname>Glib::MainContext</"
"classname> object of any thread which has a main loop. Only the receiver "
"thread should call <methodname>connect()</methodname> on the "
"<classname>Glib::Dispatcher</classname> object, or manipulate any related "
"<classname>sigc::connection</classname> object, unless additional "
"synchronization is employed. However, any worker thread can safely emit on "
"the <classname>Glib::Dispatcher</classname> object without any locking once "
"the receiver thread has connected the slots, provided that it is constructed "
"before the worker thread is started (if it is constructed after the thread "
"has started, additional synchronization will normally be required to ensure "
"visibility)."
msgstr ""
"Některá bezpečnostní pravidla pro vlákna při použití <classname>Glib::"
"Dispatcher</classname> stále platí. Jak bylo zmíněno, objekt "
"<classname>Glib::Dispatcher</classname> musí být vytvořen ve vlákně příjemce "
"(vlákno, ve kterém hlavní smyčka spustí jeho napojené sloty). Standardně je "
"to hlavní vlákno programu, ačkoliv existuje konstruktor třídy "
"<classname>Glib::Dispatcher</classname>, který umí převzít objekt "
"<classname>Glib::MainContext</classname> libovolného vlákna, které má hlavní "
"smyčku. Jen vlákno příjemce by mělo volat <methodname>connect()</methodname> "
"na objekt <classname>Glib::Dispatcher</classname>, nebo manipulovat s "
"souvisejícím objektem <classname>sigc::connection</classname>, pokud není "
"zajištěna dodatečná synchronizace. Na druhou stranu, libovolné vlákno může "
"bezpečně vyslat objekt <classname>Glib::Dispatcher</classname> bez zamykání, "
"jakmile má vlákno příjemce napojené sloty, za předpokladu, že je vytvořen "
"před spuštěním pracovního vlákna (jestliže je vytvořen po spuštění vlákna, "
"je pro zajištění viditelnosti vyžadována dodatečná synchronizace)."

#: C/gtkmm-tutorial-in.xml:7386(para)
msgid ""
"Aside from the fact that connected slots always execute in the receiver "
"thread, <classname>Glib::Dispatcher</classname> objects are similar to "
"<classname>sigc::signal&lt;void&gt;</classname> objects. They therefore "
"cannot pass unbound arguments nor return a value. The best way to pass "
"unbound arguments is with a thread-safe (asynchronous) queue. At the time of "
"writing <application>glibmm</application> does not have one, although most "
"people writing multi-threaded code will have one available to them (they are "
"relatively easy to write although there are subtleties in combining thread "
"safety with strong exception safety)."
msgstr ""
"Mimo skutečnosti, že napojené sloty vždy běží ve vlákně příjemce, objekty "
"<classname>Glib::Dispatcher</classname> jsou podobné objektům "
"<classname>sigc::signal&lt;void&gt;</classname>. Nemohou tedy předávat "
"nenavázané argumenty ani návratovou hodnotu. Nejlepším způsobem předání "
"nenavázaných argumentů je pomocí z hlediska vláken bezpečné (asynchronní) "
"fronty. V době psaní <classname>glibmm</classname> žádnou neměl, ale většina "
"lidí píšících vícevláknový kód bude mít nějakou k dispozici (je to relativně "
"snadné na napsání, i když v kombinaci bezpečnosti vláken se silnou "
"bezpečností výjimek vznikají jisté delikatesy)."

#: C/gtkmm-tutorial-in.xml:7399(para)
msgid ""
"A <classname>Glib::Dispatcher</classname> object can be emitted on by the "
"receiver thread as well as by a worker thread, although this should be done "
"within reasonable bounds. On unix-like systems <classname>Glib::Dispatcher</"
"classname> objects share a single common pipe, which could in theory at "
"least fill up on a very heavily loaded system running a program with a very "
"large number of <classname>Dispatcher</classname> objects in use. Were the "
"pipe to fill up before the receiver thread's main loop has had an "
"opportunity to read from it to empty it, and the receiver thread attempt to "
"emit and so write to it when it is in that condition, the receiver thread "
"would block on the write, so deadlocking. Where the receiver thread is to "
"emit, a normal <classname>sigc::signal&lt;void&gt;</classname> object could "
"of course be used instead."
msgstr ""
"Objekt <classname>Glib::Dispatcher</classname> může být vyslán vláknem "
"příjemce i pracovním vláknem, i když by se tak mělo dít v rozumných mezích. "
"V unixových systémech objekty <classname>Glib::Dispatcher</classname> sdílí "
"jednu společnou rouru, která by se teoreticky mohla přeplnit na velmi "
"vytíženém systému ve kterém poběží program používající velké množství "
"objektů <classname>Dispatcher</classname>. Roura by se musela zaplnit před "
"tím, než by hlavní smyčka ve vlákně příjemce měla příležitost z ní číst, a "
"tak ji vyprázdnit, a vlákno příjemce by zkoušelo vysílat, a tím pádem do ní "
"zapisovat. Když by byla v takovém stavu, pak by vlákno příjemce by blokovalo "
"zápis a skončilo by to na mrtvém bodě. V případě, že vlákno příjemce vysílá, "
"lze místo toho samozřejmě použít normální objekt <classname>sigc::signal&lt;"
"void&gt;</classname>."

#: C/gtkmm-tutorial-in.xml:7419(para)
msgid ""
"This is an example program with two threads, one GUI thread, like in all "
"<application>gtkmm</application> programs, and one worker thread. The worker "
"thread is created when you press the <literal>Start work</literal> button. "
"It is deleted when the work is finished, when you press the <literal>Stop "
"work</literal> button, or when you press the <literal>Quit</literal> button."
msgstr ""
"Jedná se o příklad programu se dvěma vlákny, jedním vláknem pro grafické "
"uživatelské rozhraní, podobně jako ve všech programech <application>gtkmm</"
"application>, a jedním pracovním vláknem. Pracovní vlákno se vytvoří, když "
"zmáčknete tlačítko <literal>Start work</literal>. Smaže se, když je práce "
"dokončena, když zmáčknete tlačítko <literal>Stop work</literal>, nebo když "
"zmáčknete tlačítko <literal>Quit</literal>."

#: C/gtkmm-tutorial-in.xml:7427(para)
msgid ""
"A <classname>Glib::Dispatcher</classname> is used for sending notifications "
"from the worker thread to the GUI thread. The <classname>ExampleWorker</"
"classname> class contains data which is accessed by both threads. This data "
"is protected by a <classname>Glib::Threads::Mutex</classname>. Only the GUI "
"thread updates the GUI."
msgstr ""
"<classname>Glib::Dispatchet</classname> se používá k zasílání upozornění z "
"pracovního vlákna do vlákna starajícího se o grafické uživatelské rozhraní. "
"Třída <classname>ExampleWorker</classname> obsahuje data, ke kterým je "
"přistupováno z obou vláken. Tato data jsou chráněna pomocí <classname>Glib::"
"Threads::Mutex</classname>. Pouze vlákno starající se o GUI může měnit GUI."

#: C/gtkmm-tutorial-in.xml:7436(title)
msgid "Multi-Threaded Program"
msgstr "Vícevláknový program"

#: C/gtkmm-tutorial-in.xml:7449(title)
msgid "Recommended Techniques"
msgstr "Doporučené techniky"

#: C/gtkmm-tutorial-in.xml:7451(para)
msgid ""
"This section is simply a gathering of wisdom, general style guidelines and "
"hints for creating <application>gtkmm</application> applications."
msgstr ""
"V této kapitole je taková všehochuť mouder, obecných pokynů a rad k "
"vytváření aplikací s <application>gtkmm</application>."

#: C/gtkmm-tutorial-in.xml:7455(para)
msgid ""
"Use GNU <application>autoconf</application> and <application>automake</"
"application>! They are your friends :) <application>Automake</application> "
"examines C files, determines how they depend on each other, and generates a "
"<filename>Makefile</filename> so the files can be compiled in the correct "
"order. <application>Autoconf</application> permits automatic configuration "
"of software installation, handling a large number of system quirks to "
"increase portability."
msgstr ""
"Používejte GNU <application>autoconf</application> a <application>automake</"
"application>! Jsou to vaši přátelé :-) <application>Automake</application> "
"prozkoumá soubory v C, určí, jak na sobě navzájem závisí, a vygeneruje "
"<filename>Makefile</filename>, takže lze soubory zkompilovat ve správném "
"pořadí. <application>Autoconf</application> umožňuje automatickou "
"konfiguraci instalace softwaru, která se vyrovná se spoustou specialit "
"jednotlivých systémů, takž dosáhnete lepší přenositelnosti."

#: C/gtkmm-tutorial-in.xml:7465(para)
msgid ""
"Subclass Widgets to better organize your code. You should probably subclass "
"your main <classname>Window</classname> at least. Then you can make your "
"child Widgets and signal handlers members of that class."
msgstr ""
"Odvozujte podtřídy widgetů kvůli lepší přehlednosti kódu. Pravděpodobně "
"odvodíte minimálně podtřídu z <classname>Window</classname>. Pak můžete ze "
"synovských widgetů a obsluh signálů udělat členy této třídy."

#: C/gtkmm-tutorial-in.xml:7470(para)
msgid ""
"Create your own signals instead of passing pointers around. Objects can "
"communicate with each other via signals and signal handlers. This is much "
"simpler than objects holding pointers to each other and calling each other's "
"methods. <application>gtkmm</application>'s classes uses special versions of "
"<classname>sigc::signal</classname>, but you should use normal "
"<classname>sigc::signal</classname>s, as described in the "
"<application>libsigc++</application> documentation."
msgstr ""
"Místo předávání ukazatelů všude možně vytvářejte své vlastní signály. "
"Objekty spolu mohou navzájem komunikovat přes signály a obsluhy signálů. Je "
"to mnohem jednodušší, než objekty uchovávající si ukazatele na sebe navzájem "
"a volající si navzájem metody. Třídy z <application>gtkmm</application> "
"používají speciální verze <classname>sigc::signal</classname>, ale vy byste "
"měli používat normální signály <classname>sigc::signal</classname>, jak je "
"popsáno v dokumentaci <application>libsigc++</application>."

#: C/gtkmm-tutorial-in.xml:7479(title)
msgid "Application Lifetime"
msgstr "Životnost aplikace"

#: C/gtkmm-tutorial-in.xml:7480(para)
msgid ""
"Most applications will have only one <classname>Window</classname>, or only "
"one main window. These applications can use the <methodname>Gtk::"
"Application::run(Gtk::Window&amp;)</methodname> overload. It shows the "
"window and returns when the window has been hidden. This might happen when "
"the user closes the window, or when your code decides to <methodname>hide()</"
"methodname> the window. You can prevent the user from closing the window "
"(for instance, if there are unsaved changes) by overriding <methodname>Gtk::"
"Window::on_delete_event()</methodname>."
msgstr ""
"Většina aplikací bude mít jen jeden objekt <classname>Window</classname>, "
"nebo aspoň jen jedno hlavní okno. Tyto aplikace mohou používat přetížení "
"<methodname>Gtk::Application::run(Gtk::Window&amp;)</methodname>. Tím se "
"zobrazí okno a k návratu z volání dojde, až se okno skryje. To může nastat, "
"když uživatel okno zavře, nebo když se váš kód rozhodne okno skrýt pomocí "
"<methodname>hide()</methodname>. Přepsáním <methodname>Gtk::Window::"
"on_delete_event()</methodname> můžete uživateli zabránit okno zavřít "
"(například, když existuje neuložené změny v jeho datech)."

#: C/gtkmm-tutorial-in.xml:7488(para)
msgid "Most of our examples use this technique."
msgstr "Většina našich příkladů používá tuto techniku."

#: C/gtkmm-tutorial-in.xml:7492(title)
msgid "Using a <application>gtkmm</application> widget"
msgstr "Používání widgetů <application>gtkmm</application>"

#: C/gtkmm-tutorial-in.xml:7494(para)
msgid ""
"Our examples all tend to have the same structure. They follow these steps "
"for using a <classname>Widget</classname>:"
msgstr ""
"Všechny naše příklady se snaží mít stejnou strukturu. V použití třídy "
"<classname>Widget</classname> se snaží držet těchto kroků:"

#: C/gtkmm-tutorial-in.xml:7503(para)
msgid ""
"Declare a variable of the type of <classname>Widget</classname> you wish to "
"use, generally as member variable of a derived container class. You could "
"also declare a pointer to the widget type, and then create it with "
"<literal>new</literal> in your code. Even when using the widget via a "
"pointer, it's still probably best to make that pointer a member variable of "
"a container class so that you can access it later."
msgstr ""
"Deklarovat proměnnou typu <classname>Widget</classname>, kterou si přejete "
"použit, obecně jako členskou proměnnou odvozené kontejnerové třídy. Mohli "
"byste také deklarovat ukazatel na typ widgetu a pak jej vytvořit pomocí "
"<literal>new</literal> ve svém kódu. Ale i když používáte widget přes "
"ukazatel, je pořád pravděpodobně nejlepší vytvořit ukazatel jako členskou "
"proměnnou v kontejnerové třídě, abyste se k widgetu později dostali."

#: C/gtkmm-tutorial-in.xml:7514(para)
msgid ""
"Set the attributes of the widget. If the widget has no default constructor, "
"then you will need to initialize the widget in the initalizer list of your "
"container class's constructor."
msgstr ""
"Nastavit vlastnosti widgetu. Pokud widget nemá výchozí konstruktor, "
"potřebujete jej inicializovat v seznamu inicializací v konstruktoru "
"kontejnerové třídy."

#: C/gtkmm-tutorial-in.xml:7520(para)
msgid "Connect any signals you wish to use to the appropriate handlers."
msgstr ""
"Napojit případné signály, které si přejete používat s příslušnou obsluhou."

#: C/gtkmm-tutorial-in.xml:7526(para)
msgid ""
"Pack the widget into a container using the appropriate call, e.g. "
"<methodname>Gtk::Container::add()</methodname> or <methodname>pack_start()</"
"methodname>."
msgstr ""
"Zabalit widget do kontejneru pomocí příslušného volání, např. "
"<methodname>Gtk::Container::add()</methodname> nebo "
"<methodname>pack_start()</methodname>."

#: C/gtkmm-tutorial-in.xml:7534(para)
msgid "Call <methodname>show()</methodname> to display the widget."
msgstr "Zavolat <methodname>show()</methodname>, aby se widget zobrazit."

#: C/gtkmm-tutorial-in.xml:7543(para)
msgid ""
"<methodname>Gtk::Widget::show()</methodname> lets <application>gtkmm</"
"application> know that we have finished setting the attributes of the "
"widget, and that it is ready to be displayed. You can use <methodname>Gtk::"
"Widget::hide()</methodname> to make it disappear again. The order in which "
"you show the widgets is not important, but we do suggest that you show the "
"top-level window last; this way, the whole window will appear with its "
"contents already drawn. Otherwise, the user will first see a blank window, "
"into which the widgets will be gradually drawn."
msgstr ""
"<methodname>Gtk::Widget::show()</methodname> dává <application>gtkmm</"
"application> najevo, že máme dokončené nastavení vlastností widgetu a widget "
"je připravený k zobrazení. Když jej chcete znovu skrýt, můžete použít "
"<methodname>Gtk::Widget::hide()</methodname>. Pořadí, ve které widgety "
"zobrazíte, není důležité, ale doporučujeme, abyste hlavní okno zobrazili až "
"jako poslední. Tak se celé okno objeví s již vykresleným obsahem. V opačném "
"případě by uživatel nejdříve spatřil prázdné okno, ve kterém by se mu "
"postupně zjevily widgety."

#: C/gtkmm-tutorial-in.xml:7557(title)
msgid "Contributing"
msgstr "Přispívání"

#: C/gtkmm-tutorial-in.xml:7559(para)
msgid ""
"This document, like so much other great software out there, was created for "
"free by volunteers. If you are at all knowledgeable about any aspect of "
"<application>gtkmm</application> that does not already have documentation, "
"please consider contributing to this document."
msgstr ""
"Tento dokument, stejně jako mnoho dalšího skvělého softwaru, byl vytvořen "
"zdarma dobrovolníky. Pokud víte o čemkoliv z <application>gtkmm</"
"application>, co není ještě zdokumentováno, pouvažujte prosím o přispění do "
"tohoto dokumentu."

#: C/gtkmm-tutorial-in.xml:7565(para)
msgid ""
"Ideally, we would like you to <ulink url=\"http://www.gtkmm.org/bugs.shtml"
"\">provide a patch</ulink> to the <filename>docs/tutorial/C/gtkmm-tutorial-"
"in.xml</filename> file. This file is currently in the <literal>gtkmm-"
"documentation</literal> module in GNOME git."
msgstr ""
"Ideální by bylo, kdybyste <ulink url=\"http://www.gtkmm.org/bugs.shtml"
"\">poskytli záplatu</ulink> k souboru <filename>docs/tutorial/C/gtkmm-"
"tutorial-in.xml</filename>. Tento soubor se momentálně nachází v modulu "
"<literal>gtkmm-documentation</literal> v repozitáři git projektu GNOME."

#: C/gtkmm-tutorial-in.xml:7571(para)
msgid ""
"If you do decide to contribute, please post your contribution to the "
"<application>gtkmm</application> mailing list at <ulink url=\"mailto:gtkmm-"
"list@gnome.org\">&lt;gtkmm-list@gnome.org&gt;</ulink>. Also, be aware that "
"the entirety of this document is free, and any addition you provide must "
"also be free. That is, people must be able to use any portion of your "
"examples in their programs, and copies of this document (including your "
"contribution) may be distributed freely."
msgstr ""
"Pokud se rozhodnete přispět, pošlete prosím příspěvek do poštovní konference "
"<application>gtkmm</application> na adrese <ulink url=\"mailto:gtkmm-"
"list@gnome.org\">&lt;gtkmm-list@gnome.org&gt;</ulink>. Pamatujte ale, že "
"celý dokument je svobodný a zdarma a i příspěvky, se kterými přijdete, musí "
"splňovat tyto podmínky. To mimo jiné znamená, že lidé mohou volně používat "
"části příkladů ve svých programech a volně šířit kopie tohoto dokumentu "
"(včetně příspěvků)."

#: C/gtkmm-tutorial-in.xml:7583(title)
msgid "The RefPtr smartpointer"
msgstr "Chytrý ukazatel RefPtr"

#: C/gtkmm-tutorial-in.xml:7584(para)
msgid ""
"<classname>Glib::RefPtr</classname> is a smartpointer. Specifically, it is a "
"reference-counting smartpointer. You might be familiar with <classname>std::"
"auto_ptr&lt;&gt;</classname>, <classname>std::unique_ptr&lt;&gt;</classname> "
"and <classname>std::shared_ptr&lt;&gt;</classname>, which are also "
"smartpointers. <classname>Glib::RefPtr&lt;&gt;</classname> is similar to "
"<classname>std::shared_ptr&lt;&gt;</classname>, which is also reference-"
"counting. <classname>Glib::RefPtr&lt;&gt;</classname> was introduced long "
"before there was a reference-counting smartpointer in the C++ Standard "
"Library."
msgstr ""
"<classname>Glib::RefPtr</classname> je chytrý ukazatel. Konkrétně je to "
"ukazatel s počítáním odkazů. Možná znáte <classname>std::auto_ptr&lt;&gt;</"
"classname>, <classname>std::unique_ptr&lt;&gt;</classname> a <classname>std::"
"shared_ptr&lt;&gt;</classname>, což jsou také chytré ukazatele. "
"<classname>Glib::RefPtr&lt;&gt;</classname> je podobný <classname>std::"
"shared_ptr&lt;&gt;</classname>, který také počítá odkazy. <classname>Glib::"
"RefPtr&lt;&gt;</classname> byl zaveden dlouho před tím, než se objevil "
"chytrý ukazatel s počítáním odkazů ve standardní knihovně C++."

#: C/gtkmm-tutorial-in.xml:7596(para)
msgid ""
"A smartpointer acts much like a normal pointer. Here are a few examples."
msgstr ""
"Chytré ukazatele fungují hodně podobně jako normální ukazatele.Zde je pár "
"příkladů."

#: C/gtkmm-tutorial-in.xml:7599(title)
msgid "Copying"
msgstr "Kopírování"

#: C/gtkmm-tutorial-in.xml:7600(para)
msgid ""
"You can copy <classname>RefPtr</classname>s, just like normal pointers. But "
"unlike normal pointers, you don't need to worry about deleting the "
"underlying instance."
msgstr ""
"<classname>RefPtr</classname> můžete kopírovat stejně jako normální "
"ukazatele. Ale na rozdíl od nich se nemusíte starat o smazání podkladové "
"instance."

#: C/gtkmm-tutorial-in.xml:7606(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf2 = refPixbuf;\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf2 = refPixbuf;\n"

#: C/gtkmm-tutorial-in.xml:7611(para)
msgid ""
"Of course this means that you can store <classname>RefPtr</classname>s in "
"standard containers, such as <classname>std::vector</classname> or "
"<classname>std::list</classname>."
msgstr ""
"To samozřejmě znamená, že můžete uchovávat <classname>RefPtr</classname> ve "
"standardních kontejnerech, jako je <classname>std::vector</classname> nebo "
"<classname>std::list</classname>."

#: C/gtkmm-tutorial-in.xml:7616(programlisting)
#, no-wrap
msgid ""
"\n"
"std::list&lt; Glib::RefPtr&lt;Gdk::Pixbuf&gt; &gt; listPixbufs;\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"listPixbufs.push_back(refPixbuf);\n"
msgstr ""
"\n"
"std::list&lt; Glib::RefPtr&lt;Gdk::Pixbuf&gt; &gt; listPixbufs;\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"listPixbufs.push_back(refPixbuf);\n"

#: C/gtkmm-tutorial-in.xml:7624(title)
msgid "Dereferencing"
msgstr "Snižování referencí"

#: C/gtkmm-tutorial-in.xml:7625(para)
msgid ""
"You can dereference a smartpointer with the -&gt; operator, to call the "
"methods of the underlying instance, just like a normal pointer."
msgstr ""
"Počitadlo referencí chytrého ukazatele můžete snížit (dereference) pomocí "
"operátoru -&gt;, který zavolá metodu podkladové instance, jako u normálního "
"ukazatele."

#: C/gtkmm-tutorial-in.xml:7629(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"int width = refPixbuf-&gt;get_width();\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"int width = refPixbuf-&gt;get_width();\n"

#: C/gtkmm-tutorial-in.xml:7634(para)
msgid ""
"But unlike most smartpointers, you can't use the * operator to access the "
"underlying instance."
msgstr ""
"Ale na rozdíl od většiny chytrých ukazatelů nemůžete použít operátor * pro "
"přístup k podkladové instanci."

#: C/gtkmm-tutorial-in.xml:7638(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Gdk::Pixbuf&amp; underlying = *refPixbuf; //Syntax error - will not compile.\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gdk::Pixbuf&gt; refPixbuf = Gdk::Pixbuf::create_from_file(filename);\n"
"Gdk::Pixbuf&amp; underlying = *refPixbuf; //Syntax error - will not compile.\n"

#: C/gtkmm-tutorial-in.xml:7645(title)
msgid "Casting"
msgstr "Přetypování"

#: C/gtkmm-tutorial-in.xml:7646(para)
msgid ""
"You can cast <classname>RefPtr</classname>s to base types, just like normal "
"pointers."
msgstr ""
"<classname>RefPtr</classname> můžete přetypovat na základní typy, stejně "
"jako normální ukazatele."

#: C/gtkmm-tutorial-in.xml:7651(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore = Gtk::TreeStore::create(columns);\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = refStore;\n"

#: C/gtkmm-tutorial-in.xml:7656(para)
msgid ""
"This means that any method which takes a <type>const Glib::RefPtr&lt;"
"BaseType&gt;</type> argument can also take a <type>const Glib::RefPtr&lt;"
"DerivedType&gt;</type>. The cast is implicit, just as it would be for a "
"normal pointer."
msgstr ""
"To znamená, že kterákoliv metoda, která přebírá argument <type>const Glib::"
"RefPtr&lt;BaseType&gt;</type>, může přebírat také <type>const Glib::"
"RefPtr&lt;DerivedType&gt;</type>. Přetypování je implicitní, jako by to bylo "
"pro normální ukazatel."

#: C/gtkmm-tutorial-in.xml:7660(para)
msgid ""
"You can also cast to a derived type, but the syntax is a little different "
"than with a normal pointer."
msgstr ""
"Můžete také přetypovat na zděděné typy, ale syntax je trochu rozdílná, než s "
"normálním ukazatelem."

#: C/gtkmm-tutorial-in.xml:7664(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_dynamic(refModel);\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt; refStore2 =\n"
"Glib::RefPtr&lt;Gtk::TreeStore&gt;::cast_static(refModel);\n"

#: C/gtkmm-tutorial-in.xml:7674(title)
msgid "Checking for null"
msgstr "Kontrola na null"

#: C/gtkmm-tutorial-in.xml:7675(para)
msgid ""
"Just like normal pointers, you can check whether a <classname>RefPtr</"
"classname> points to anything."
msgstr ""
"Stejně jako u normálních ukazatelů můžete kontrolovat, jestli "
"<classname>RefPtr</classname> neukazuje na nic."

#: C/gtkmm-tutorial-in.xml:7680(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();\n"
"if(refModel)\n"
"{\n"
"  int cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"
msgstr ""
"\n"
"Glib::RefPtr&lt;Gtk::TreeModel&gt; refModel = m_TreeView.get_model();\n"
"if(refModel)\n"
"{\n"
"  int cols_count = refModel-&gt;get_n_columns();\n"
"  ...\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7689(para)
msgid ""
"But unlike normal pointers, <classname>RefPtr</classname>s are automatically "
"initialized to null so you don't need to remember to do that yourself."
msgstr ""
"Ale na rozdíl od normálních ukazatelů, <classname>RefPtr</classname> jsou "
"automaticky inicializované na null, takže nemusíte myslet na to, abyste to "
"dělali sami."

#: C/gtkmm-tutorial-in.xml:7696(title)
msgid "Constness"
msgstr "Bezkonstantnost"

#: C/gtkmm-tutorial-in.xml:7697(para)
msgid ""
"The use of the <literal>const</literal> keyword in C++ is not always clear. "
"You might not realise that <type>const Something*</type> declares a pointer "
"to a <type>const Something</type>. The pointer can be changed, but not the "
"<type>Something</type> that it points to."
msgstr ""
"Použití klíčového slova <literal>const</literal> v jazyce C++ není vždy "
"zcela zřejmé. Možná si neuvědomujete, že <type>const Neco*</type> deklaruje "
"ukazatel na <type>const Neco</type>. Ukazatel lze měnit, ale nelze měnit "
"<type>Neco</type> na které ukazuje."

#: C/gtkmm-tutorial-in.xml:7703(para)
msgid ""
"Therefore, the <classname>RefPtr</classname> equivalent of <type>Something*</"
"type> for a method parameter is <type>const Glib::RefPtr&lt;Something&gt;"
"&amp;</type>, and the equivalent of <type>const Something*</type> is "
"<type>const Glib::RefPtr&lt;const Something&gt;&amp;</type>."
msgstr ""
"Proto <classname>RefPtr</classname> stejné jako <type>Neco*</type> pro "
"parametr metody je <type>const Glib::RefPtr&lt;Neco&gt;&amp;</type> a stejné "
"jako <type>const Neco*</type> je <type>const Glib::RefPtr&lt;const Neco&gt;"
"&amp;</type>."

#: C/gtkmm-tutorial-in.xml:7710(para)
msgid ""
"The <literal>const ... &amp;</literal> around both is just for efficiency, "
"like using <classname>const std::string&amp;</classname> instead of "
"<classname>std::string</classname> for a method parameter to avoid "
"unnecessary copying."
msgstr ""
"<literal>const … &amp;</literal> je u obou jen kvůli efektivitě, podobně "
"jako použití <classname>const std::string&amp;</classname> místo "
"<classname>std::string</classname> pro parametr metody, aby se zabránilo "
"zbytečnému kopírování."

#: C/gtkmm-tutorial-in.xml:7725(title)
msgid "Connecting signal handlers"
msgstr "Napojení obsluhy signálu"

#: C/gtkmm-tutorial-in.xml:7726(para)
msgid ""
"<application>gtkmm</application> widget classes have signal accessor "
"methods, such as <methodname>Gtk::Button::signal_clicked()</methodname>, "
"which allow you to connect your signal handler. Thanks to the flexibility of "
"<application>libsigc++</application>, the callback library used by "
"<application>gtkmm</application>, the signal handler can be almost any kind "
"of function, but you will probably want to use a class method. Among "
"<application>GTK+</application> C coders, these signal handlers are often "
"named callbacks."
msgstr ""
"Třídy widgetů v <application>gtkmm</application> mají metody zpřístupňující "
"signály, jako je <methodname>Gtk::Button::signal_clicked()</methodname>, "
"která vám umožňují napojit si svoji obsluhu signálu. Díky pružnosti "
"<application>libsigc++</application>, která je používaná <application>gtkmm</"
"application> jako knihovna pro zpětná volání, může být obsluhou signálu "
"většinou libovolný druh funkce, ale nejspíše budete chtít použít metodu "
"třídy. Mezi programátory <methodname>GTK+</methodname> v C jsou tyto obsluhy "
"signálů často nazývané „zpětná volání“."

#: C/gtkmm-tutorial-in.xml:7736(para)
msgid "Here's an example of a signal handler being connected to a signal:"
msgstr "Zde je příklad napojení obsluhy signálu na signál:"

#: C/gtkmm-tutorial-in.xml:7741(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"void on_button_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"}\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button(\"Hello World\");\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7757(para)
msgid ""
"There's rather a lot to think about in this (non-functional) code. First "
"let's identify the parties involved:"
msgstr ""
"V tomto (nefunkčním) kódu je toho hodně k zamyšlení. Nejdříve pojďme "
"pojmenovat zúčastněné věci:"

#: C/gtkmm-tutorial-in.xml:7765(para)
msgid "The signal handler is <methodname>on_button_clicked()</methodname>."
msgstr "Obsluha signálu je <methodname>on_button_clicked()</methodname>."

#: C/gtkmm-tutorial-in.xml:7771(para)
msgid ""
"We're hooking it up to the <classname>Gtk::Button</classname> object called "
"<varname>button</varname>."
msgstr ""
"Zaháčkovali jsme ji k objektu <classname>Gtk::Button</classname> nazvanému "
"<varname>button</varname>."

#: C/gtkmm-tutorial-in.xml:7778(para)
msgid ""
"When the Button emits its <literal>clicked</literal> signal, "
"<methodname>on_button_clicked()</methodname> will be called."
msgstr ""
"Když <classname>Button</classname> vyšle svůj signál <literal>clicked</"
"literal>, zavolá se <methodname>on_button_clicked()</methodname>."

#: C/gtkmm-tutorial-in.xml:7786(para)
msgid "Now let's look at the connection again:"
msgstr "Nyní se pojďme znovu podívat na přípojení:"

#: C/gtkmm-tutorial-in.xml:7791(programlisting)
#, no-wrap
msgid ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"
msgstr ""
"\n"
"    ...\n"
"    button.signal_clicked().connect(sigc::ptr_fun(&amp;on_button_clicked));\n"
"    ...\n"

#: C/gtkmm-tutorial-in.xml:7798(para)
msgid ""
"Note that we don't pass a pointer to <methodname>on_button_clicked()</"
"methodname> directly to the signal's <methodname>connect()</methodname> "
"method. Instead, we call <function>sigc::ptr_fun()</function>, and pass the "
"result to <methodname>connect()</methodname>."
msgstr ""
"Všimněte si, že ukazatel na <methodname>on_button_clicked()</methodname> "
"nepředáváme přímo do metody <methodname>connect()</methodname> patřící "
"signálu. Místo toho zavoláme <function>sigc::ptr_fun()</function> a do "
"<methodname>connect()</methodname> předáme výsledek."

#: C/gtkmm-tutorial-in.xml:7805(para)
msgid ""
"<function>sigc::ptr_fun()</function> generates a <classname>sigc::slot</"
"classname>. A slot is an object which looks and feels like a function, but "
"is actually an object. These are also known as function objects, or "
"functors. <function>sigc::ptr_fun()</function> generates a slot for a "
"standalone function or static method. <function>sigc::mem_fun()</function> "
"generates a slot for a member method of a particular instance."
msgstr ""
"<function>sigc::ptr_fun()</function> generuje <classname>sigc::slot</"
"classname>. Slot je objekt, který vypadá a působí jako funkce. Někdy se "
"můžete setkat i s označením funkční objekt nebo functor. <function>sigc::"
"ptr_fun()</function> generuje slot pro samostatnou funkci nebo statickou "
"metodu. <function>sigc::mem_fun()</function> generuje slot pro členskou "
"metodu konkrétní instance."

#: C/gtkmm-tutorial-in.xml:7814(para)
msgid "Here's a slightly larger example of slots in action:"
msgstr "Zde je trochu rozsáhlejší příklad slotů v činnosti:"

#: C/gtkmm-tutorial-in.xml:7819(programlisting)
#, no-wrap
msgid ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"
msgstr ""
"\n"
"void on_button_clicked();\n"
"\n"
"class some_class\n"
"{\n"
"    void on_button_clicked();\n"
"};\n"
"\n"
"some_class some_object;\n"
"\n"
"main()\n"
"{\n"
"    Gtk::Button button;\n"
"    button.signal_clicked().connect( sigc::ptr_fun(&amp;on_button_clicked) );\n"
"    button.signal_clicked().connect( sigc::mem_fun(some_object, &amp;some_class::on_button_clicked) );\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7838(para)
msgid ""
"The first call to <methodname>connect()</methodname> is just like the one we "
"saw last time; nothing new here."
msgstr ""
"První volání <methodname>connect()</methodname> je stejné, jak jsme již "
"viděli minule, nic nového."

#: C/gtkmm-tutorial-in.xml:7841(para)
msgid ""
"The next is more interesting. <function>sigc::mem_fun()</function> is called "
"with two arguments. The first argument is <parameter>some_object</"
"parameter>, which is the object that our new slot will be pointing at. The "
"second argument is a pointer to one of its methods. This particular version "
"of <function>sigc::mem_fun()</function> creates a slot which will, when "
"\"called\", call the pointed-to method of the specified object, in this case "
"<methodname>some_object.on_button_clicked()</methodname>."
msgstr ""
"Další už je podstatně zajímavější. <function>sigc::mem_fun()</function> je "
"volaná se dvěma argumenty. První argument je <parameter>some_object</"
"parameter>, což je objekt, na který náš nový slot bude ukazovat. Druhý "
"argument je ukazatel na jednu z jeho metod. Tato konkrétní verze "
"<function>sigc::mem_fun()</function> vytváří slot, který bude, když je "
"„zavolán“, volat metodu určeného objektu, na kterou ukazuje, v tomto případě "
"<methodname>some_object.on_button_clicked()</methodname>."

#: C/gtkmm-tutorial-in.xml:7851(para)
msgid ""
"Another thing to note about this example is that we made the call to "
"<methodname>connect()</methodname> twice for the same signal object. This is "
"perfectly fine - when the button is clicked, both signal handlers will be "
"called."
msgstr ""
"Další věcí, která stojí v tomto příkladu za zmínku, je, že voláme "
"<methodname>connect()</methodname> dvakrát pro ten samý objekt signálu. To "
"je úplně v pořádku – když je na tlačítko kliknuto, jsou zavolány obě obsluhy "
"signálu."

#: C/gtkmm-tutorial-in.xml:7858(para)
msgid ""
"We just told you that the button's <literal>clicked</literal> signal is "
"expecting to call a method with no arguments. All signals have requirements "
"like this - you can't hook a function with two arguments to a signal "
"expecting none (unless you use an adapter, such as <function>sigc::bind()</"
"function>, of course). Therefore, it's important to know what type of signal "
"handler you'll be expected to connect to a given signal."
msgstr ""
"Právě jsme vám řekli, že signál <literal>clicked</literal> tlačítka očekává "
"volání metody bez argumentu. Všechny signály mají obdobné požadavky – "
"nemůžete zaháčkovat funkci se dvěma argumenty na signál, který neočekává "
"žádný (ledaže použijete adaptér, jako je <function>sigc::bind()</function>). "
"Proto je důležité znát, jaký typ obsluhy signálu byste měli očekávat, že se "
"k danému signálu napojí."

#: C/gtkmm-tutorial-in.xml:7870(title)
msgid "Writing signal handlers"
msgstr "Psaní obsluhy signálů"

#: C/gtkmm-tutorial-in.xml:7872(para)
msgid ""
"To find out what type of signal handler you can connect to a signal, you can "
"look it up in the reference documentation or the header file. Here's an "
"example of a signal declaration you might see in the <application>gtkmm</"
"application> headers:"
msgstr ""
"Když chcete zjistit, které typy obsluhy signálu můžete na signál napojit, "
"podívejte se do referenční dokumentace nebo do hlavičkového souboru. Zde je "
"příklad deklarace signálu, která můžete vidět v hlavičkových souborech "
"<application>gtkmm</application>:"

#: C/gtkmm-tutorial-in.xml:7879(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy1&lt;bool, Gtk::DirectionType&gt; signal_focus()\n"
msgstr ""
"\n"
"Glib::SignalProxy1&lt;bool, Gtk::DirectionType&gt; signal_focus()\n"

#: C/gtkmm-tutorial-in.xml:7884(para)
msgid ""
"Other than the signal's name (<literal>focus</literal>), two things are "
"important to note here: the number following the word "
"<classname>SignalProxy</classname> at the beginning (1, in this case), and "
"the types in the list (<type>bool</type> and <type>Gtk::DirectionType</"
"type>). The number indicates how many arguments the signal handler should "
"have; the first type, <type>bool</type>, is the type that the signal handler "
"should return; and the next type, <type>Gtk::DirectionType</type>, is the "
"type of this signal's first, and only, argument. By looking at the reference "
"documentation, you can see the names of the arguments too."
msgstr ""
"Mimo názvu signálu (<literal>focus</literal>) stojí za zmínku ještě dvě "
"věci: číslo následující za slovem <classname>SignalProxy</classname> na "
"začátku deklarace (v tomto případě 1) a typy v seznamu (<type>bool</type> "
"and <type>Gtk::DirectionType</type>). Číslo říká, kolik argumentů by obsluha "
"signálu měla mít. První typ <type>bool</type> je typ, který by měla obsluha "
"signálu vracet a následující typ <type>Gtk::DirectionType</type> je typ "
"prvního a jediného argumentu signálu. Po nahlédnutí do referenční "
"dokumentace můžete zjistit také názvy argumentů."

#: C/gtkmm-tutorial-in.xml:7896(para)
msgid ""
"The same principles apply for signals which have more arguments. Here's one "
"with three (taken from <filename>&lt;gtkmm/textbuffer.h&gt;</filename>):"
msgstr ""
"Stejné principy se používají pro signály, které mají více argumentů. Zde je "
"jeden se třemi (pochází z <filename>&lt;gtkmm/textbuffer.h&gt;</filename>):"

#: C/gtkmm-tutorial-in.xml:7902(programlisting)
#, no-wrap
msgid ""
"\n"
"Glib::SignalProxy3&lt;void, const TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int&gt; signal_insert();\n"
msgstr ""
"\n"
"Glib::SignalProxy3&lt;void, const TextBuffer::iterator&amp;, const Glib::ustrin&amp;, int&gt; signal_insert();\n"

#: C/gtkmm-tutorial-in.xml:7907(para)
msgid ""
"It follows the same form. The number 3 at the end of the type's name "
"indicates that our signal handler will need three arguments. The first type "
"in the type list is <type>void</type>, so that should be our signal "
"handler's return type. The following three types are the argument types, in "
"order. Our signal handler's prototype could look like this:"
msgstr ""
"Má tu stejnou formu. Číslo 3 na konci názvu typu říká, že naše obsluha "
"signálu potřebuje tři argumenty. Prví typ v seznamu typů je <type>void</"
"type>, protože by měl být návratovým typem naší obsluhy signálu. Následující "
"tři typy jsou postupně typy argumentů. Prototyp naší obsluhy signálu by mohl "
"vypadat nějak takto:"

#: C/gtkmm-tutorial-in.xml:7916(programlisting)
#, no-wrap
msgid ""
"\n"
"void on_insert(const TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)\n"
msgstr ""
"\n"
"void on_insert(const TextBuffer::iterator&amp; pos, const Glib::ustring&amp; text, int bytes)\n"

#: C/gtkmm-tutorial-in.xml:7923(title)
msgid "Disconnecting signal handlers"
msgstr "Odpojení obsluhy signálu"

#: C/gtkmm-tutorial-in.xml:7925(para)
msgid ""
"Let's take another look at a Signal's <literal>connect</literal> method:"
msgstr ""
"Podívejme se ještě jednou na metodu <literal>connect()</literal> signálu:"

#: C/gtkmm-tutorial-in.xml:7930(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );\n"
msgstr ""
"\n"
"sigc::signal&lt;void,int&gt;::iterator signal&lt;void,int&gt;::connect( const sigc::slot&lt;void,int&gt;&amp; );\n"

#: C/gtkmm-tutorial-in.xml:7935(para)
msgid ""
"Notice that the return value is of type <classname>sigc::signal&lt;void,"
"int&gt;::iterator</classname>. This can be implicitly converted into a "
"<classname>sigc::connection</classname> which in turn can be used to control "
"the connection. By keeping a connection object you can disconnect its "
"associated signal handler using the method <methodname>sigc::connection::"
"disconnect()</methodname>."
msgstr ""
"Všimněte si, že návratová hodnota je typu <classname>sigc::signal&lt;void,"
"int&gt;::iterator</classname>. Ten se dá implicitně převést na "
"<classname>sigc::connection</classname>, který se pak dá použít k řízení "
"napojení. Když si objekt napojení zapamatujete, můžete přidruženou obsluhu "
"signálu odpojit pomocí metody <methodname>sigc::connection::disconnect()</"
"methodname>."

#: C/gtkmm-tutorial-in.xml:7946(title)
msgid "Overriding default signal handlers"
msgstr "Přepisování výchozí obsluhy signálu"

#: C/gtkmm-tutorial-in.xml:7948(para)
msgid ""
"So far we've told you to perform actions in response to button-presses and "
"the like by handling signals. That's certainly a good way to do things, but "
"it's not the only way."
msgstr ""
"Doposud jste se dozvěděli, jak provést nějakou činnost na základě zmáčknutí "
"tlačítka a jak obsluhovat signály. To je samozřejmě dobrý způsob, jak dělat "
"věci, ale není jediný."

#: C/gtkmm-tutorial-in.xml:7955(para)
msgid ""
"Instead of laboriously connecting signal handlers to signals, you can simply "
"make a new class which inherits from a widget - say, a Button - and then "
"override the default signal handler, such as Button::on_clicked(). This can "
"be a lot simpler than hooking up signal handlers for everything."
msgstr ""
"Namísto pracného napojení obsluhy signálu na signál můžete jednoduše "
"vytvořit novou třídu, která bude zděděná z widgetu – řekněme tlačítka – a "
"přepsat jeho výchozí obsluhu signálu, jako je Button::on_clicked(). To může "
"být mnohem jednodušší, než se zaháčkovat na obsluhu signálu pro všechno."

#: C/gtkmm-tutorial-in.xml:7962(para)
msgid ""
"Subclassing isn't always the best way to accomplish things. It is only "
"useful when you want the widget to handle its own signal by itself. If you "
"want some other class to handle the signal then you'll need to connect a "
"separate handler. This is even more true if you want several objects to "
"handle the same signal, or if you want one signal handler to respond to the "
"same signal from different objects."
msgstr ""
"Tvorba podtříd není ale vždy nejlepším způsobem, jak dosáhnout kýženého. Je "
"použitelná jen, když widget obsluhuje své vlastní signály. Když chcete, aby "
"signál obsluhovala jiná třída, potřebujete napojit samostatnou obsluhu. "
"Platí to o to víc, když chcete aby stejný signál obsluhovalo několik "
"objektů, nebo chcete, aby jedna obsluha reagovala na stejný signál z více "
"různých objektů."

#: C/gtkmm-tutorial-in.xml:7967(para)
msgid ""
"<application>gtkmm</application> classes are designed with overriding in "
"mind; they contain virtual member methods specifically intended to be "
"overridden."
msgstr ""
"Třídy <application>gtkmm</application> jsou navržené přímo s ohledem na "
"přepisování. Obsahují virtuální členské metody speciálně zamýšlené za účelem "
"přepsání."

#: C/gtkmm-tutorial-in.xml:7972(para)
msgid "Let's look at an example of overriding:"
msgstr "Pojďme se podívat na příklad s přepsáním:"

#: C/gtkmm-tutorial-in.xml:7977(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"    virtual void on_clicked();\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"    // call the base class's version of the method:\n"
"    Gtk::Button::on_clicked();\n"
"}\n"
msgstr ""
"\n"
"#include &lt;gtkmm/button.h&gt;\n"
"\n"
"class OverriddenButton : public Gtk::Button\n"
"{\n"
"protected:\n"
"    virtual void on_clicked();\n"
"}\n"
"\n"
"void OverriddenButton::on_clicked()\n"
"{\n"
"    std::cout &lt;&lt; \"Hello World\" &lt;&lt; std::endl;\n"
"\n"
"    // zavoláme základní verzi metody třídy\n"
"    Gtk::Button::on_clicked();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:7996(para)
msgid ""
"Here we define a new class called <classname>OverriddenButton</classname>, "
"which inherits from <classname>Gtk::Button</classname>. The only thing we "
"change is the <methodname>on_clicked()</methodname> method, which is called "
"whenever <classname>Gtk::Button</classname> emits the <literal>clicked</"
"literal> signal. This method prints \"Hello World\" to <literal>stdout</"
"literal>, and then calls the original, overridden method, to let "
"<classname>Gtk::Button</classname> do what it would have done had we not "
"overridden."
msgstr ""
"Zde definujeme novou třídu nazvanou <classname>OverriddenButton</classname>, "
"která je zděděná z <classname>Gtk::Button</classname>. Jedinou věcí, kterou "
"měníme, je metoda <methodname>on_clicked()</methodname>, která je zavolaná, "
"kdykoliv <classname>Gtk::Button</classname> vyšle signál <literal>clicked</"
"literal>. Tato metoda vypíše „Hello World“ na <literal>stdout</literal> a "
"pak zavolá původní, přepsanou metodu, aby třída <classname>Gtk::Button</"
"classname> mohla udělat to, co by dělala, kdybychom ji nepřepsali."

#: C/gtkmm-tutorial-in.xml:8007(para)
msgid ""
"You don't always need to call the parent's method; there are times when you "
"might not want to. Note that we called the parent method <emphasis>after</"
"emphasis> writing \"Hello World\", but we could have called it before. In "
"this simple example, it hardly matters much, but there are times when it "
"will. With signals, it's not quite so easy to change details like this, and "
"you can do something here which you can't do at all with connected signal "
"handlers: you can call the parent method in the <emphasis>middle</emphasis> "
"of your custom code."
msgstr ""
"Ne vždy je potřeba volat metodu rodiče. Jsou situace, kdy to možná chtít "
"nebudete. Všimněte si, že rodičovskou metodu voláme <emphasis>až po</"
"emphasis> vypsání „Hello World“, ale mohli bychom ji volat i před tím. V "
"tomto jednoduchém příkladu je to jedno, ale jsou případy, kdy to jedno není. "
"Se signály to není tak jednoduché měnit detaily, jak to bylo zde, a zde "
"můžete dělat něco, co obecně v obsluze signálů dělat není možné: můžete "
"zavolat rodičovskou metodu <emphasis>uprostřed</emphasis> svého vlastního "
"kódu."

#: C/gtkmm-tutorial-in.xml:8021(title)
msgid "Binding extra arguments"
msgstr "Navázání dodatečných argumentů"

#: C/gtkmm-tutorial-in.xml:8028(programlisting)
#, no-wrap
msgid ""
"\n"
"m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\") );\n"
msgstr ""
"\n"
"m_button1.signal_clicked().connect( sigc::bind&lt;Glib::ustring&gt;( sigc::mem_fun(*this, &amp;HelloWorld::on_button_clicked), \"button 1\") );\n"

#: C/gtkmm-tutorial-in.xml:8035(programlisting)
#, no-wrap
msgid ""
"\n"
"virtual void on_button_clicked(Glib::ustring data);\n"
msgstr ""
"\n"
"virtual void on_button_clicked(Glib::ustring data);\n"

#: C/gtkmm-tutorial-in.xml:8022(para)
msgid ""
"If you use one signal handler to catch the same signal from several widgets, "
"you might like that signal handler to receive some extra information. For "
"instance, you might want to know which button was clicked. You can do this "
"with <function>sigc::bind()</function>. Here's some code from the <link "
"linkend=\"sec-helloworld2\">helloworld2</link> example. <placeholder-1/> "
"This says that we want the signal to send an extra <classname>Glib::ustring</"
"classname> argument to the signal handler, and that the value of that "
"argument should be \"button 1\". Of course we will need to add that extra "
"argument to the declaration of our signal handler: <placeholder-2/> Of "
"course, a normal \"clicked\" signal handler would have no arguments."
msgstr ""
"V případě, že použijete obsluhu signálu k zachycení stejného signálu z "
"několika widgetů, byli byste rádi, kdyby obsluha signálu obdržela nějaké "
"doplňující informace. Například můžete chtít vědět, na které tlačítko bylo "
"kliknuto. To můžete udělat pomocí <function>sigc::bind()</function>. Zde je "
"kód z příkladu <link linkend=\"sec-helloworld2\">helloworld2</link>. "
"<placeholder-1/> Říká se v něm, že chceme po signálu, aby poslal do obsluhy "
"signálu doplňující argument <classname>Glib::ustring</classname> a hodnota "
"tohoto argumentu by měla být „button 1“. Samozřejmě potřebujeme přidat tento "
"doplňující argument do deklarace naší obsluhy signálu: <placeholder-2/> A "
"samozřejmě, normální obsluha signálu „clicked“ by neměla mít žádné argumenty."

#: C/gtkmm-tutorial-in.xml:8040(para)
msgid ""
"<function>sigc::bind()</function> is not commonly used, but you might find "
"it helpful sometimes. If you are familiar with <application>GTK+</"
"application> programming then you have probably noticed that this is similar "
"to the extra <literal>gpointer data</literal> arguments which all GTK+ "
"callbacks have. This is generally overused in <application>GTK+</"
"application> to pass information that should be stored as member data in a "
"derived widget, but widget derivation is very difficult in C. We have far "
"less need of this hack in <application>gtkmm</application>."
msgstr ""
"Funkce <function>sigc::bind()</function> se nepoužívá úplně běžné, ale občas "
"se vám hodit může. Pokud se dobře vyznáte v programování <application>GTK+</"
"application>, pak jste si nejspíše všimli, se je to podobné, jako doplňující "
"argument <literal>gpointer data</literal>, který mají všechna zpětná volání "
"v GTK+. Obecně je v <application>GTK+</application> nadužívaný k předávání "
"informací, které by měly být uložené v členských datech v odvozených "
"widgetech, ale v C je odvozování widgetů velmi složité. V "
"<application>gtkmm</application> máme mnohem menší potřebu takovýchto "
"obezliček."

#: C/gtkmm-tutorial-in.xml:8052(title)
msgid "X Event signals"
msgstr "Signály událostí X"

#: C/gtkmm-tutorial-in.xml:8053(para)
msgid ""
"The <classname>Widget</classname> class has some special signals which "
"correspond to the underlying X-Windows events. These are suffixed by "
"<literal>_event</literal>; for instance, <methodname>Widget::"
"signal_button_press_event()</methodname>."
msgstr ""
"Třída <classname>Widget</classname> má speciální signály, které odpovídají "
"událostem systému X-Windows v pozadí. Mají za svým názvem připojeno "
"<literal>_event</literal>, např. <methodname>Widget::"
"signal_button_press_event()</methodname>."

#: C/gtkmm-tutorial-in.xml:8059(para)
msgid ""
"You might occasionally find it useful to handle X events when there's "
"something you can't accomplish with normal signals. <classname>Gtk::Button</"
"classname>, for example, does not send mouse-pointer coordinates with its "
"<literal>clicked</literal> signal, but you could handle "
"<literal>button_press_event</literal> if you needed this information. X "
"events are also often used to handle key-presses."
msgstr ""
"Občas, když něčeho nejde dosáhnout s normálními signály, můžete shledat "
"užitečným obsluhovat události X. <classname>Gtk::Button</classname> "
"například neposílá v jeho signálu <literal>clicked</literal> souřadnice "
"ukazatele myši, ale pokud tuto informaci potřebujete, mohli byste obsluhovat "
"<literal>button_press_event</literal>. Události X jsou také často využívány "
"k obsluze zmačknutí kláves."

#: C/gtkmm-tutorial-in.xml:8068(para)
msgid ""
"These signals behave slightly differently. The value returned from the "
"signal handler indicates whether it has fully \"handled\" the event. If the "
"value is <literal>false</literal> then <application>gtkmm</application> will "
"pass the event on to the next signal handler. If the value is <literal>true</"
"literal> then no other signal handlers will need to be called."
msgstr ""
"Tyto signály se chovají lehce jinak. Hodnota vrácená z obsluhy signálu říká, "
"jestli událost byla „plně“ obsloužena. Pokud je hodnota <literal>false</"
"literal>, pak <application>gtkmm</application> předá událost následující "
"obsluze signálu v hierarchii. Pokud je hodnota <literal>true</literal>, není "
"potřeba volat žádnou další obsluhu signálu."

#: C/gtkmm-tutorial-in.xml:8073(para)
msgid ""
"Handling an X event doesn't affect the Widget's other signals. If you handle "
"<literal>button_press_event</literal> for <classname>Gtk::Button</"
"classname>, you'll still be able to get the <literal>clicked</literal> "
"signal. They are emitted at (nearly) the same time."
msgstr ""
"Obsluha událostí X neovlivňuje ostatní signály widgetu. Pokud třeba "
"obsluhujete <literal>button_press_event</literal> pro <classname>Gtk::"
"Button</classname>, stále budete schopni obdržet signál <literal>clicked</"
"literal>. Obojí je vysláno v (téměř) stejnou chvíli."

#: C/gtkmm-tutorial-in.xml:8080(para)
msgid ""
"Note also that not all widgets receive all X events by default. To receive "
"additional X events, you can use <methodname>Gtk::Widget::set_events()</"
"methodname> before showing the widget, or <methodname>Gtk::Widget::"
"add_events()</methodname> after showing the widget. However, some widgets "
"must first be placed inside an <classname>EventBox</classname> widget. See "
"the <link linkend=\"chapter-widgets-without-xwindows\">Widgets Without X-"
"Windows</link> chapter."
msgstr ""
"Pamatujte také, že ne všechny widgety přijímají ve výchozí podobě všechny "
"události X. K příjmu dalších událostí X můžete použít před zobrazením "
"widgetu jeho metodu <methodname>Gtk::Widget::set_events()</methodname> nebo "
"po jeho zobrazení metodu <methodname>Gtk::Widget::add_events()</methodname>. "
"Některé widgety je však třeba nejprve umístit do widgetu "
"<classname>EventBox</classname>. Viz kapitola <link linkend=\"chapter-"
"widgets-without-xwindows\">Widgety bez X-Windows</link>."

#: C/gtkmm-tutorial-in.xml:8089(programlisting)
#, no-wrap
msgid ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"
msgstr ""
"\n"
"bool on_button_press(GdkEventButton* event);\n"
"Gtk::Button button(\"label\");\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_button_press) );\n"

#: C/gtkmm-tutorial-in.xml:8095(para)
msgid ""
"When the mouse is over the button and a mouse button is pressed, "
"<methodname>on_button_press()</methodname> will be called."
msgstr ""
"Když je ukazatel myši nad tlačítkem a zmáčknete tlačítko myši, je zavoláno "
"<methodname>on_button_press()</methodname>."

#: C/gtkmm-tutorial-in.xml:8100(para)
msgid ""
"<type>GdkEventButton</type> is a structure containing the event's "
"parameters, such as the coordinates of the mouse pointer at the time the "
"button was pressed. There are several different types of <type>GdkEvent</"
"type> structures for the various events."
msgstr ""
"<type>GdkEventButton</type> je struktura, která obsahuje parametry události, "
"jako jsou souřadnice ukazatele myši ve chvíli, kdy bylo tlačítko zmáčknuto. "
"Existuje několik různých typů struktury <type>GdkEvent</type> pro různé "
"události."

#: C/gtkmm-tutorial-in.xml:8108(title)
msgid "Signal Handler sequence"
msgstr "Posloupnost obsluhy signálu"

#: C/gtkmm-tutorial-in.xml:8116(programlisting)
#, no-wrap
msgid ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"
msgstr ""
"\n"
"button.signal_button_press_event().connect( sigc::ptr_fun(&amp;on_mywindow_button_press), false );\n"

#: C/gtkmm-tutorial-in.xml:8109(para)
msgid ""
"By default, your signal handlers are called after any previously-connected "
"signal handlers. However, this can be a problem with the X Event signals. "
"For instance, the existing signal handlers, or the default signal handler, "
"might return <literal>true</literal> to stop other signal handlers from "
"being called. To specify that your signal handler should be called before "
"the other signal handlers, so that it will always be called, you can specify "
"<literal>false</literal> for the optional <literal>after</literal> "
"parameter. For instance, <placeholder-1/>"
msgstr ""
"Standardně je vaše obsluha signálu zavolána až po předchozích připojených "
"obsluhách signálu. To ale může dělat problém při obsluze signálů od událostí "
"X. Například stávající obsluhy signálu nebo výchozí obsluha signálu může "
"vrátit <literal>true</literal> a tím zastavit volání další obsluhy. Když "
"chcete určit, že vaše obsluha signálu by měla být zavoláno před ostatními, "
"což znamená, že bude zavolána vždy, můžete zadat <literal>false</literal> do "
"volitelného parametru <literal>after</literal>. Například, <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8120(para)
msgid ""
"The event is delivered first to the widget the event occurred in. If all "
"signal handlers in that widget return <literal>false</literal> (indicating "
"that the event has not been handled), then the signal will be propagated to "
"the parent widget and emitted there. This continues all the way up to the "
"top-level widget if no one handles the event."
msgstr ""
"Událost se nejprve doručí do widgetu, ve kterém se objevila. Pokud všechny "
"obsluhy signálu v tomto widgetu vrátí <literal>false</literal> (což značí, "
"že událost nebyl obsloužena), je signál propagován do rodičovského widgetu a "
"vyslán zde. Tak se postupně pokračuje až do widgetu v nejvyšší úrovni, dokud "
"se neobjeví nějaký, který událost obslouží."

#: C/gtkmm-tutorial-in.xml:8131(title)
msgid "Exceptions in signal handlers"
msgstr "Výjimky v obsluze signálu"

#: C/gtkmm-tutorial-in.xml:8132(para)
msgid ""
"When a program is aborted because of an unhandled C++ exception, it's "
"sometimes possible to use a debugger to find the location where the "
"exception was thrown. This is more difficult than usual if the exception was "
"thrown from a signal handler."
msgstr ""
"Když je program přerušen kvůli neobsloužené výjimce C++, je občas možné "
"použít ladicí program k nalezení místa, kde byla výjimka vyhozena. Pokud je "
"výjimka vyhozena v obsluze signálu, je to náročnější, než obvykle."

#: C/gtkmm-tutorial-in.xml:8137(para)
msgid ""
"This section describes primarily what you can expect on a Linux system, when "
"you use <ulink url=\"http://www.gnu.org/software/gdb/\">the gdb debugger</"
"ulink>."
msgstr ""
"Tento oddíl popisuje hlavně, co můžete očekávat v systému Linux, když "
"použijete <ulink url=\"http://www.gnu.org/software/gdb/\">ladicí program "
"gdb</ulink>."

#: C/gtkmm-tutorial-in.xml:8144(programlisting)
#, no-wrap
msgid ""
"\n"
"// without_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  throwSomething();\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.without_signal\");\n"
"  return app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"// without_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  throwSomething();\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.without_signal\");\n"
"  return app-&gt;run();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8141(para)
msgid ""
"First, let's look at a simple example where an exception is thrown from a "
"normal function (no signal handler). <placeholder-1/>"
msgstr ""
"Nejprve se podívejme na jednoduchý příklad, kde je výjimka vyhozena z "
"normální funkce (bez obsluhy signálu). <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8166(programlisting)
#, no-wrap
msgid ""
"\n"
"&gt; gdb without_signal\n"
"(gdb) run\n"
"terminate called after throwing an instance of 'char const*'\n"
"\n"
"Program received signal SIGABRT, Aborted.\n"
"(gdb) backtrace\n"
"#7  0x08048864 in throwSomething () at without_signal.cc:6\n"
"#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12\n"
msgstr ""
"\n"
"&gt; gdb without_signal\n"
"(gdb) run\n"
"terminate called after throwing an instance of 'char const*'\n"
"\n"
"Program received signal SIGABRT, Aborted.\n"
"(gdb) backtrace\n"
"#7  0x08048864 in throwSomething () at without_signal.cc:6\n"
"#8  0x0804887d in main (argc=1, argv=0xbfffecd4) at without_signal.cc:12\n"

#: C/gtkmm-tutorial-in.xml:8163(para)
msgid ""
"Here is an excerpt from a <application>gdb</application> session. Only the "
"most interesting parts of the output are shown. <placeholder-1/> You can see "
"that the exception was thrown from <filename>without_signal.cc</filename>, "
"line 6 (<code>throw \"Something\";</code>)."
msgstr ""
"Zde je výňatek z práce s <application>gdb</application>. Zobrazené jsou jen "
"nejzajímavější části výstupu. <placeholder-1/> Můžete vidět, že výjimka byla "
"vyhozená z <filename>without_signal.cc</filename>, řádek 6 (<code>throw "
"\"Something\";</code>)."

#: C/gtkmm-tutorial-in.xml:8182(programlisting)
#, no-wrap
msgid ""
"\n"
"// with_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.with_signal\");\n"
"  app-&gt;hold();\n"
"  return app-&gt;run();\n"
"}\n"
msgstr ""
"\n"
"// with_signal.cc\n"
"#include &lt;gtkmm.h&gt;\n"
"\n"
"bool throwSomething()\n"
"{\n"
"  throw \"Something\";\n"
"  return true;\n"
"}\n"
"\n"
"int main(int argc, char** argv)\n"
"{\n"
"  Glib::signal_timeout().connect(sigc::ptr_fun(throwSomething), 500);\n"
"  Glib::RefPtr&lt;Gtk::Application&gt; app =\n"
"    Gtk::Application::create(argc, argv, \"org.gtkmm.with_signal\");\n"
"  app-&gt;hold();\n"
"  return app-&gt;run();\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8179(para)
msgid ""
"Now let's see what happens when an exception is thrown from a signal "
"handler. Here's the source code. <placeholder-1/>"
msgstr ""
"Nyní se podívejme, co se stane, když je výjimka vyhozena z obsluhy signálu. "
"Zde je zdrojový kód. <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8204(programlisting)
#, no-wrap
msgid ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) run\n"
"(with_signal:2703): glibmm-ERROR **:\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
"(gdb) backtrace\n"
"#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77\n"
"#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150\n"
"#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212\n"
"#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178\n"
"#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16\n"
msgstr ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) run\n"
"(with_signal:2703): glibmm-ERROR **:\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
"(gdb) backtrace\n"
"#2  0x0063c6ab in glibmm_unexpected_exception () at exceptionhandler.cc:77\n"
"#3  Glib::exception_handlers_invoke () at exceptionhandler.cc:150\n"
"#4  0x0063d370 in glibmm_source_callback (data=0x804d620) at main.cc:212\n"
"#13 0x002e1b31 in Gtk::Application::run (this=0x804f300) at application.cc:178\n"
"#14 0x08048ccc in main (argc=1, argv=0xbfffecd4) at with_signal.cc:16\n"

#: C/gtkmm-tutorial-in.xml:8202(para)
msgid ""
"And here's an excerpt from a <application>gdb</application> session. "
"<placeholder-1/> The exception is caught in <application>glibmm</"
"application>, and the program ends with a call to <function>g_error()</"
"function>. Other exceptions may result in different behaviour, but in any "
"case the exception from a signal handler is caught in <application>glibmm</"
"application> or <application>gtkmm</application>, and <application>gdb</"
"application> can't see where it was thrown."
msgstr ""
"A tady je výňatek z práce s <application>gdb</application>. <placeholder-1/> "
"Výjimka je zachycena v <application>glibmm</application> a program končí "
"pomocí volání <function>g_error()</function>. Jiné výjimky mohou vést k "
"jinému chování, ale v každém případě je výjimka z obsluhy signálu zachycena "
"v <application>glibmm</application> nebo v <application>gtkmm</application> "
"a <application>gdb</application> nemůže vidět, kde byla vyhozena."

#: C/gtkmm-tutorial-in.xml:8227(programlisting)
#, no-wrap
msgid ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) catch throw\n"
"Catchpoint 1 (throw)\n"
"(gdb) run\n"
"Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()\n"
"(gdb) backtrace\n"
"#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6\n"
"#1  0x08048bd4 in throwSomething () at with_signal.cc:6\n"
"(gdb) continue\n"
"Continuing.\n"
"(with_signal:2375): glibmm-ERROR **\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"
msgstr ""
"\n"
"&gt; gdb with_signal\n"
"(gdb) catch throw\n"
"Catchpoint 1 (throw)\n"
"(gdb) run\n"
"Catchpoint 1 (exception thrown), 0x00714ff0 in __cxa_throw ()\n"
"(gdb) backtrace\n"
"#0  0x00714ff0 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6\n"
"#1  0x08048bd4 in throwSomething () at with_signal.cc:6\n"
"(gdb) continue\n"
"Continuing.\n"
"(with_signal:2375): glibmm-ERROR **\n"
"unhandled exception (type unknown) in signal handler\n"
"\n"
"Program received signal SIGTRAP, Trace/breakpoint trap.\n"

#: C/gtkmm-tutorial-in.xml:8224(para)
msgid ""
"To see where the exception is thrown, you can use the <application>gdb</"
"application> command <userinput>catch throw</userinput>. <placeholder-1/>"
msgstr ""
"Když chcete vidět, kde je výjimka vyhozena, můžete použít v "
"<application>gdb</application> příkaz <userinput>catch throw</userinput>. "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8248(programlisting)
#, no-wrap
msgid ""
"\n"
"(gdb) catch throw\n"
"(gdb) commands\n"
"(gdb)   backtrace\n"
"(gdb)   continue\n"
"(gdb)   end\n"
"(gdb) set pagination off\n"
"(gdb) run\n"
msgstr ""
"\n"
"(gdb) catch throw\n"
"(gdb) commands\n"
"(gdb)   backtrace\n"
"(gdb)   continue\n"
"(gdb)   end\n"
"(gdb) set pagination off\n"
"(gdb) run\n"

#: C/gtkmm-tutorial-in.xml:8244(para)
msgid ""
"If there are many caught exceptions before the interesting uncaught one, "
"this method can be tedious. It can be automated with the following "
"<application>gdb</application> commands. <placeholder-1/> These commands "
"will print a backtrace from each <code>throw</code> and continue. The "
"backtrace from the last (or possibly the last but one) <code>throw</code> "
"before the program stops, is the interesting one."
msgstr ""
"Pokud se před tím, než není zachycena zajímavá výjimka, zachytává příliš "
"jiných výjimek, může být tento postup poněkud únavný. Dá se ale "
"automatizovat následujícími příkazy <application>gdb</application>. "
"<placeholder-1/> Tyto příkazy vypíší zpětně zásobník volání pro každé "
"<code>throw</code> a pokračuje se. Výpis z posledního (nebo možná "
"předposledního) <code>throw</code> před zastavením programu je ten, který "
"nás zajímá."

#: C/gtkmm-tutorial-in.xml:8267(title)
msgid "Creating your own signals"
msgstr "Vytváření vlastních signálů"

#: C/gtkmm-tutorial-in.xml:8268(para)
msgid ""
"Now that you've seen signals and signal handlers in <application>gtkmm</"
"application>, you might like to use the same technique to allow interaction "
"between your own classes. That's actually very simple by using the "
"<application>libsigc++</application> library directly."
msgstr ""
"Nyní, když jste poznali signály a obsluhu signálů v <application>gtkmm</"
"application>, budete možná chtít používat stejnou techniku ke komunikaci "
"mezi vašimi vlastními třídami. Je to skutečně velmi jednoduché díky přímému "
"použití knihovny <application>libsigc++</application>."

#: C/gtkmm-tutorial-in.xml:8274(para)
msgid ""
"This isn't purely a <application>gtkmm</application> or GUI issue. "
"<application>gtkmm</application> uses <application>libsigc++</application> "
"to implement its proxy wrappers for the <application>GTK+</application> "
"signal system, but for new, non-GTK+ signals, you can create pure C++ "
"signals, using the <classname>sigc::signal&lt;&gt;</classname> template."
msgstr ""
"Není to záležitostí jen <application>gtkmm</application> nebo grafického "
"uživatelského rozhraní. <application>gtkmm</application> používá "
"<application>libsigc++</application> k implementaci vlastního zástupného "
"obalení pro systém signálu <application>GTK+</application>, ale pro nové "
"signály nepocházející z GTK+ můžete vytvářet signály čistě z C++, pomocí "
"šablony <classname>sigc::signal&lt;&gt;</classname>."

#: C/gtkmm-tutorial-in.xml:8285(programlisting)
#, no-wrap
msgid ""
"\n"
"sigc::signal&lt;void, bool, int&gt; signal_something;\n"
msgstr ""
"\n"
"sigc::signal&lt;void, bool, int&gt; signal_neco;\n"

#: C/gtkmm-tutorial-in.xml:8281(para)
msgid ""
"For instance, to create a signal that sends 2 parameters, a <type>bool</"
"type> and an <type>int</type>, just declare a <classname>sigc::signal</"
"classname>, like so: <placeholder-1/>"
msgstr ""
"Například, abyste vytvořili signál, který posílá dva parametry, <type>bool</"
"type> a <type>int</type>, jednoduše zadeklarujte <classname>sigc::signal</"
"classname>, nějak takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8293(programlisting)
#, no-wrap
msgid ""
"\n"
"class Server\n"
"{\n"
"public:\n"
"  //signal accessor:\n"
"  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;\n"
"  type_signal_something signal_something();\n"
"\n"
"protected:\n"
"  type_signal_something m_signal_something;\n"
"};\n"
"\n"
"Server::type_signal_something Server::signal_something()\n"
"{\n"
"  return m_signal_something;\n"
"}\n"
msgstr ""
"\n"
"class Server\n"
"{\n"
"public:\n"
"  // pro přístup k signálu:\n"
"  typedef sigc::signal&lt;void, bool, int&gt; type_signal_something;\n"
"  type_signal_something signal_something();\n"
"\n"
"protected:\n"
"  type_signal_something m_signal_something;\n"
"};\n"
"\n"
"Server::type_signal_something Server::signal_something()\n"
"{\n"
"  return m_signal_something;\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8289(para)
msgid ""
"You could just declare that signal as a public member variable, but some "
"people find that distasteful and prefer to make it available via an accessor "
"method, like so: <placeholder-1/>"
msgstr ""
"Stačilo by jen deklarovat signál, jako veřejnou členskou proměnnou, ale "
"někteří to nepovažují za vhodné a dávají přednost jeho zpřístupnění přes "
"metodu, nějak takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8315(programlisting)
#, no-wrap
msgid ""
"\n"
"server.signal_something().connect(\n"
"  sigc::mem_fun(client, &amp;Client::on_server_something) );\n"
msgstr ""
"\n"
"server.signal_something().connect(\n"
"  sigc::mem_fun(client, &amp;Client::on_server_something) );\n"

#: C/gtkmm-tutorial-in.xml:8312(para)
msgid ""
"You can then connect to the signal using the same syntax used when "
"connecting to <application>gtkmm</application> signals. For instance, "
"<placeholder-1/>"
msgstr ""
"Na signál se můžete napojit pomocí stejné syntaxe, jako se používá při "
"napojení k signálům <application>gtkmm</application>. Například "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8323(para)
msgid "This is a full working example that defines and uses custom signals."
msgstr ""
"Jedná se o úplný funkční příklad, který definuje a používá vlastní signály."

#: C/gtkmm-tutorial-in.xml:8337(title)
msgid "Comparison with other signalling systems"
msgstr "Srovnání s jinými signalizačními systémy"

#: C/gtkmm-tutorial-in.xml:8338(para)
msgid ""
"(An aside: <application>GTK+</application> calls this scheme \"signalling\"; "
"the sharp-eyed reader with GUI toolkit experience will note that this same "
"design is often seen under the name of \"broadcaster-listener\" (e.g., in "
"Metrowerks' PowerPlant framework for the Macintosh). It works in much the "
"same way: one sets up <literal>broadcasters</literal>, and then connects "
"<literal>listeners</literal> to them; the broadcaster keeps a list of the "
"objects listening to it, and when someone gives the broadcaster a message, "
"it calls all of its objects in its list with the message. In "
"<application>gtkmm</application>, signal objects play the role of "
"broadcasters, and slots play the role of listeners - sort of. More on this "
"later.)"
msgstr ""
"(Odbočení od tématu: <application>GTK+</application> nazývá toto schéma "
"„signalink“ – „signalizace“. Pozorný čtenář se zkušenostmi s vývojářskou "
"sadou GUI namítne, že ten stejný návrh můžete často vidět pod názvem "
"„broadcaster-listener“ – „hromadné vysílání-naslouchání“ (např. ve "
"frameworku PowerPlant v Mertokworks pro Macintowsh). Funguje to podobně: "
"nastaví se vysílače <literal>broadcaster</literal> a pak se k nim připojí "
"posluchači <literal>listeners</literal>. Vysílače udržují seznam objektů, "
"které je poslouchají, a když někdo vysílači předá zprávu, ten zavolá všechny "
"své objekty ze seznamu a zprávu jim předá. V <application>gtkmm</"
"application> signální objekty hrají roli vysílačů a sloty hrají roli "
"posluchačů. Více se o tom dozvíte dále."

#: C/gtkmm-tutorial-in.xml:8352(para)
msgid ""
"<application>gtkmm</application> signal handlers are strongly-typed, whereas "
"<application>GTK+</application> C code allows you to connect a callback with "
"the wrong number and type of arguments, leading to a segfault at runtime. "
"And, unlike <application>Qt</application>, <application>gtkmm</application> "
"achieves this without modifying the C++ language."
msgstr ""
"Obsluhy signálů <application>gtkmm</application> jsou silně typové, kdežto "
"kód <application>GTK+</application> v C umožní napojit zpětné volání s "
"nesprávným počtem a typem argumentů, což vede k selhání segmentace za běhu. "
"A na rozdíl od <application>Qt</application>, <application>gtkmm</"
"application> toho dosáhne beze změn v jazyce C++."

#: C/gtkmm-tutorial-in.xml:8358(para)
msgid ""
"Re. Overriding signal handlers: You can do this in the straight-C world of "
"GTK+ too; that's what GTK's object system is for. But in GTK+, you have to "
"go through some complicated procedures to get object-oriented features like "
"inheritance and overloading. In C++, it's simple, since those features are "
"supported in the language itself; you can let the compiler do the dirty work."
msgstr ""
"Přepisování obsluhy signálu: Můžete to dělat i přímo ve světě C v GTK+. Je "
"to to, k čemu objektový systém GTK slouží. V GTK+ ale musíte projít "
"složitými postupy, abyste získali objektově orientované vlastnosti, jako je "
"dědění nebo přetěžování. V C++ je to jednoduché, protože tyto vlastnosti "
"jsou podporované jazykem jako takovým. Necháte na kompilátoru, aby udělal "
"špinavou práci za vás."

#: C/gtkmm-tutorial-in.xml:8366(para)
msgid ""
"This is one of the places where the beauty of C++ really comes out. One "
"wouldn't think of subclassing a GTK+ widget simply to override its action "
"method; it's just too much trouble. In GTK+, you almost always use signals "
"to get things done, unless you're writing a new widget. But because "
"overriding methods is so easy in C++, it's entirely practical - and sensible "
"- to subclass a button for that purpose."
msgstr ""
"Je to jedna z věcí, na které se ukazuje krása C++. Neměli byste přemýšlet o "
"podtřídách widgetů GTK+ kvůli přepsání jeho akčních metod, to vám akorát "
"přinese potíže. V GTK+ se k udělání věcí většinou vždy používají signály, "
"vyjma situací, kdy píšete nový widget. Protože ale v C++ je přepisování "
"metod tak snadné, je pro tento účel praktické a rozumné, vytvořit podtřídu "
"tlačítka."

#: C/gtkmm-tutorial-in.xml:8377(title)
msgid "<application>gtkmm</application> and Win32"
msgstr "<application>gtkmm</application> a Win32"

#: C/gtkmm-tutorial-in.xml:8378(para)
msgid ""
"One of the major advantages of <application>gtkmm</application> is that it "
"is crossplatform. <application>gtkmm</application> programs written on other "
"platforms such as GNU/Linux can generally be transferred to Windows (and "
"vice versa) with few modifications to the source."
msgstr ""
"Jedním z hlavních přínosů <application>gtkmm</application> je, že je "
"multiplatformní. Programy <application>gtkmm</application> napsané na jiných "
"platformách, jako je GNU/Linux, mohou být obecně vzato přenesené do Windows "
"(a naopak) jen s pár změnami ve zdrojových kódech."

#: C/gtkmm-tutorial-in.xml:8383(para)
msgid ""
"<application>gtkmm</application> currently works with the <ulink url="
"\"http://mingw.org/\">MingW/GCC3.4 compiler</ulink> and Microsoft Visual C++ "
"2005 or later (including the freely available express editions) on the "
"Windows platform. There is an <ulink url=\"ftp://ftp.gnome.org/pub/GNOME/"
"binaries/win32/gtkmm\"> installer</ulink> available for gtkmm on Microsoft "
"Windows. Refer to <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/"
"MSWindows/\"> https://wiki.gnome.org/Projects/gtkmm/MSWindows</ulink> for "
"instructions how to use it."
msgstr ""
"<application>gtkmm</application> aktuálně funguje s <ulink url=\"http://"
"mingw.org/\">MingW/GCC3.4 compiler</ulink> a Microsoft Visual C++ 2005 nebo "
"novějším (včetně volně dostupné verze express) na platformě Windows. Zde je "
"<ulink url=\"ftp://ftp.gnome.org/pub/GNOME/binaries/win32/gtkmm"
"\">instalátor</ulink> dostupný pro gtkmm na MS "
"Windows. Instrukce, jak jej použít viz <ulink url=\"https://wiki.gnome.org/"
"Projects/gtkmm/MSWindows/\">https://wiki.gnome.org/Projects/gtkmm/MSWindows</"
"ulink>."

#: C/gtkmm-tutorial-in.xml:8395(title)
msgid "Building <application>gtkmm</application> on Win32"
msgstr "Sestavování <application>gtkmm</application> na Win32"

#: C/gtkmm-tutorial-in.xml:8396(para)
msgid ""
"Please see <ulink url=\"https://wiki.gnome.org/Projects/gtkmm/MSWindows/"
"BuildingGtkmm\"> https://wiki.gnome.org/Projects/gtkmm/MSWindows/"
"BuildingGtkmm</ulink> for instructions on how to build gtkmm on Windows."
msgstr ""
"Na instrukce, jak sestavit gtkmm na Windows se prosím podívejte na <ulink "
"url=\"https://wiki.gnome.org/Projects/gtkmm/MSWindows/BuildingGtkmm"
"\">https://wiki.gnome.org/Projects/gtkmm/MSWindows/BuildingGtkmm</ulink>"

#: C/gtkmm-tutorial-in.xml:8404(title)
msgid "Working with gtkmm's Source Code"
msgstr "Práce se zdrojovým kódem gtkmm"

#: C/gtkmm-tutorial-in.xml:8405(para)
msgid ""
"If you are interested in helping out with the development of "
"<application>gtkmm</application>, or fixing a bug in <application>gtkmm</"
"application>, you'll probably need to build the development version of "
"<application>gtkmm</application>. However, you should not install a "
"development version over your stable version. Instead, you should install it "
"alongside your existing <application>gtkmm</application> installation, in a "
"separate path."
msgstr ""
"Pokud byste měli zájem pomoci nám s vývojem <application>gtkmm</application> "
"nebo s opravou chyb v <application>gtkmm</application>, budete nejspíše "
"potřebovat sestavit vývojovou verzi <application>gtkmm</application>. Neměli "
"byste ale instalovat vývojovou verzi přes stabilní verzi. Místo toho byste "
"ji měli nainstalovat vedle stávající instalace <application>gtkmm</"
"application> do samostatné cesty."

#: C/gtkmm-tutorial-in.xml:8412(para)
msgid ""
"The easiest way to do this is using <ulink url=\"https://wiki.gnome.org/"
"Projects/Jhbuild\">jhbuild</ulink>. <application>jhbuild</application> is a "
"program that makes building GNOME software much easier by calculating "
"dependencies and building things in the correct order. This section will "
"give a brief explanation of how to set up <application>jhbuild</application> "
"to build and install <application>gtkmm</application> from the source "
"repository (git). For up-to-date information on <application>jhbuild</"
"application>, please refer to the <ulink url=\"http://developer.gnome.org/"
"jhbuild/unstable/\">jhbuild manual</ulink>. If you need assistance using "
"<application>jhbuild</application>, you should ask for help on the <ulink "
"url=\"http://mail.gnome.org/mailman/listinfo/gnome-love\">gnome-love mailing "
"list</ulink>."
msgstr ""
"Nejjednodušší je na to použít <ulink url=\"https://wiki.gnome.org/Projects/"
"Jhbuild\">jhbuild</ulink>. <application>jhbuild</application> je program, "
"který usnadňuje sestavení veškerého softwaru GNOME díky výpočtům závislostí "
"a sestavením věcí ve správném pořadí. V této části se dozvíte stručně něco o "
"tom, jako ho nastavit, aby sestavil a nainstaloval <application>gtkmm</"
"application> ze zdrojového repozitáře (git). Ohledně aktuálních informací o "
"programu <application>jhbuild</application> se prosím podívejte do <ulink "
"url=\"http://developer.gnome.org/jhbuild/unstable/\">příručky k systému "
"jhbuild</ulink>. Jestli budete potřebovat nějaké rady k použití programu "
"<application>jhbuild</application>, měli byste o pomoc žádat v <ulink url="
"\"http://mail.gnome.org/mailman/listinfo/gnome-love\">poštovní konferenci "
"gnome-love</ulink>."

#: C/gtkmm-tutorial-in.xml:8428(para)
msgid ""
"Note that to build <application>gtkmm</application> from git, you'll often "
"need to build many of its dependencies from git as well. "
"<application>jhbuild</application> makes this easier than it would normally "
"be, but it will take quite a while to build and install them all. You will "
"probably encounter build problems, though these will usually be corrected "
"quickly if you report them."
msgstr ""
"Upozorňujeme, že k sestavení <application>gtkmm</application> z repozitáře "
"git je často zapotřebí sestavení také mnoha jeho závislostí. "
"<application>jhbuild</application> to velmi usnadňuje oproti normálnímu "
"postupu, ale sestavení a instalace zabere poměrně hodně času. Pravděpodobně "
"také narazíte na nějaké problémy se sestavováním, ale když je nahlásíte, tak "
"bývají poměrně rychle opravené."

#: C/gtkmm-tutorial-in.xml:8437(title)
msgid "Setting up jhbuild"
msgstr "Nastavení systému jhbuild"

#: C/gtkmm-tutorial-in.xml:8438(para)
msgid ""
"To set up <application>jhbuild</application>, follow the basic installation "
"instructions from the <ulink url=\"http://developer.gnome.org/jhbuild/"
"unstable/\">jhbuild manual</ulink>. After you have installed "
"<application>jhbuild</application>, you should copy the sample "
"<application>jhbuild</application> configuration file into your home "
"directory by executing the following command from the <application>jhbuild</"
"application> directory: <screen>$ cp examples/sample.jhbuildrc ~/.jhbuildrc</"
"screen>"
msgstr ""
"Ohledně nastavení systému <application>jhbuild</application> se řiďte "
"základními instalačními instrukcemi z <ulink url=\"http://developer.gnome."
"org/jhbuild/unstable/\">příručky k systému jhbuild</ulink>. Po té, co "
"<application>jhbuild</application> nainstalujete, měli byste nakopírovat "
"ukázkový konfigurační soubor <application>jhbuild</application> do své "
"domovské složky spuštěním následujícího příkazu ve složce, kde se nachází "
"<application>jhbuild</application>: <screen>$ cp examples/sample.jhbuildrc "
"~/.jhbuildrc</screen>"

#: C/gtkmm-tutorial-in.xml:8453(programlisting)
#, no-wrap
msgid "moduleset = 'gnome-suites-core-deps-3.12'"
msgstr "moduleset = 'gnome-suites-core-deps-3.12'"

#: C/gtkmm-tutorial-in.xml:8448(para)
msgid ""
"The <application>gtkmm</application> module is defined in the "
"<filename>gnome-suites-core-deps-3.x.modules</filename> moduleset, so edit "
"your <filename>.jhbuildrc</filename> file and set your moduleset setting to "
"the latest version e.g. like so: <placeholder-1/>"
msgstr ""
"Modul <application>gtkmm</application> je definován v sadě modulů "
"<filename>gnome-suites-core-deps-3.x.modules</filename>, takže upravte svůj "
"soubor <filename>.jhbuildrc</filename> a nastavte nastavení sady modulů na "
"nejnovější verzi, například takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8460(programlisting)
#, no-wrap
msgid "modules = [ 'gtkmm' ]"
msgstr "modules = [ 'gtkmm' ]"

#: C/gtkmm-tutorial-in.xml:8455(para)
msgid ""
"After setting the correct moduleset, you need to tell <application>jhbuild</"
"application> which module or modules to build. To build <application>gtkmm</"
"application> and all of its dependencies, set <varname>modules</varname> "
"like so: <placeholder-1/>"
msgstr ""
"Po nastavení správné sady modulů potřebujete říci systému "
"<application>jhbuild</application>, který modul nebo sadu modulů sestavit. "
"Abyste sestavili <application>gtkmm</application> a všechny jeho závislosti, "
"nastavte <varname>modules</varname> takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8462(para)
msgid ""
"You can build several modules by setting the <varname>modules</varname> "
"variable to a meta-package, e.g. <literal>meta-gnome-core</literal>, or "
"listing more than one module name. The <varname>modules</varname> variable "
"specifies which modules will be built when you don't explicitly specify "
"anything on the command line. You can always build a different moduleset "
"later by specifying it on the commandline (e.g. <command>jhbuild build "
"gtkmm</command>)."
msgstr ""
"Můžete sestavit několik modulů nastavením proměnné <varname>modules</"
"varname> na metabalíček, např. <literal>meta-gnome-core</literal>, nebo "
"vypsáním více než jednoho názvu modulu. Proměnná <varname>modules</varname> "
"určuje, které moduly budou sestavené, když žádný výslovně neuvedete na "
"příkazové řádce. Vždy můžete sestavit jinou sadu modulů později jejich "
"zadáním na příkazové řádce (např. <command>jhbuild build gtkmm</command>)."

#: C/gtkmm-tutorial-in.xml:8472(title)
msgid "Setting a prefix"
msgstr "Nastavení prefixu"

#: C/gtkmm-tutorial-in.xml:8473(para)
msgid ""
"By default, <application>jhbuild</application>'s configuration is configured "
"to install all software built with <application>jhbuild</application> under "
"the <filename>/opt/gnome</filename> prefix. You can choose a different "
"prefix, but it is recommended that you keep this prefix different from other "
"software that you've installed (don't set it to <filename>/usr</filename>!) "
"If you've followed the jhbuild instructions then this prefix belongs to your "
"user, so you don't need to run jhbuild as <literal>root</literal>."
msgstr ""
"Standardně je <application>jhbuild</application> nakonfigurován pro "
"instalaci veškerého softwaru, který sestaví, do <filename>/opt/gnome</"
"filename>. Můžete zvolit i jinou cestu, ale doporučuje se, aby směřovala "
"jinam, než je ostatní nainstalovaný software (nenastavujte ji do <filename>/"
"usr</filename>!). Jestli jste se drželi instrukcí pro <application>jhbuild</"
"application>, pak tato cesta patří vám, jako uživateli, a není tak potřeba "
"spouštět <application>jhbuild</application> jako uživatel <literal>root</"
"literal>."

#: C/gtkmm-tutorial-in.xml:8485(para)
msgid ""
"When you downloaded <application>jhbuild</application> from the git "
"repository, you got a number of <filename>.modules</filename> files, "
"specifying dependencies between modules. By default <application>jhbuild</"
"application> does not use the downloaded versions of these files, but reads "
"the latest versions in the git repository. This is usually what you want. If "
"you don't want it, use the <varname>use_local_modulesets</varname> variable "
"in <filename>.jhbuildrc</filename>."
msgstr ""
"Když stáhnete <application>jhbuild</application> z repozitáře git, máte "
"spoustu souborů <filename>.modules</filename>, které specifikují závislosti "
"mezi moduly. Standardně <application>jhbuild</application> nepoužívá stažené "
"verze těchto souborů, ale čte si nejnovější verze přímo z repozitáře. "
"Obvykle to je to, co chcete. Pokut to tak ale nechcete, použijte proměnnou "
"<varname>use_local_modulesets</varname> v <filename>.jhbuildrc</filename>."

#: C/gtkmm-tutorial-in.xml:8496(title)
msgid ""
"Installing and Using the git version of <application>gtkmm</application>"
msgstr ""
"Instalace a používání vývojové verze <application>gtkmm</application> z "
"repozitáře git"

#: C/gtkmm-tutorial-in.xml:8497(para)
msgid ""
"Once you've configured <application>jhbuild</application> as described "
"above, building <application>gtkmm</application> should be relatively "
"straightforward. The first time you run <application>jhbuild</application>, "
"you should run the following sequence of commands to ensure that "
"<application>jhbuild</application> has the required tools and verify that it "
"is set up correctly: <screen>$ jhbuild bootstrap\n"
"$ jhbuild sanitycheck</screen>"
msgstr ""
"Jakmile nakonfigurujete <application>jhbuild</application> podle popisu "
"uvedeného výše, mělo by být sestavení <application>gtkmm</application> "
"relativně přímočaré. Když spouštíte <application>jhbuild</application> "
"poprvé, měli byste spustit následující posloupnost příkazů, která zajistí, "
"že <application>jhbuild</application> bude mít požadované nástroje, a která "
"ověří, že je vše správně nastavené: <screen>$ jhbuild bootstrap\n"
"$ jhbuild sanitycheck</screen>"

#: C/gtkmm-tutorial-in.xml:8508(title)
msgid ""
"Installing <application>gtkmm</application> with <application>jhbuild</"
"application>"
msgstr ""
"Instalace <application>gtkmm</application> pomocí programu "
"<application>jhbuild</application>"

#: C/gtkmm-tutorial-in.xml:8509(para)
msgid ""
"If everything worked correctly, you should be able to build "
"<application>gtkmm</application> and all of its dependencies from git by "
"executing <command>jhbuild build</command> (or, if you didn't specify "
"<application>gtkmm</application> in the <varname>modules</varname> variable, "
"with the command <command>jhbuild build gtkmm</command>)."
msgstr ""
"Pokud je vše správně, měli byste být schopni sestavit <application>gtkmm</"
"application> a všechny jeho závislosti z repozitáře git pomocí příkazu "
"<command>jhbuild build</command> (nebo, pokud neurčíte <application>gtkmm</"
"application> v proměnné <varname>modules</varname>, pomocí příkazu "
"<command>jhbuild build gtkmm</command>)."

#: C/gtkmm-tutorial-in.xml:8516(para)
msgid ""
"This command will build and install a series of modules and will probably "
"take quite a long time the first time through. After the first time, "
"however, it should go quite a bit faster since it only needs to rebuild "
"files that changed since the last build. Alternatively, after you've built "
"and installed <application>gtkmm</application> the first time, you can "
"rebuild <application>gtkmm</application> by itself (without rebuilding all "
"of its dependencies) with the command <command>jhbuild buildone gtkmm</"
"command>."
msgstr ""
"Tento příkaz sestaví a nainstaluje sérii modulů a bude pravděpodobně "
"napoprvé trvat dosti dlouho. Při následujících spuštění by už ale měl být o "
"něco rychlejší, protože bude potřebovat sestavit jen soubory, které se "
"změnily od předchozího sestavení. Jinou variantou je, že po té co napoprvé "
"sestavíte a nainstalujete <application>gtkmm</application>, můžete "
"<application>gtkmm</application> znovu sestavit sebou samým (bez opětovného "
"sestavování všech jeho závislostí) pomocí příkazu <command>jhbuild buildone "
"gtkmm</command>."

#: C/gtkmm-tutorial-in.xml:8527(title)
msgid "Using the git version of <application>gtkmm</application>"
msgstr ""
"Používání vývojové verze <application>gtkmm</application> z repozitáře git"

#: C/gtkmm-tutorial-in.xml:8528(para)
msgid ""
"After you've installed the git version of <application>gtkmm</application>, "
"you're ready to start using and experimenting with it. In order to use the "
"new version of <application>gtkmm</application> you've just installed, you "
"need to set some environment variables so that your <filename>configure</"
"filename> script knows where to find the new libraries. Fortunately, "
"<application>jhbuild</application> offers an easy solution to this problem. "
"Executing the command <command>jhbuild shell</command> will start a new "
"shell with all of the correct environment variables set. Now if you re-"
"configure and build your project just as you usually do, it should link "
"against the newly installed libraries. To return to your previous "
"environment, simply exit the <application>jhbuild</application> shell."
msgstr ""
"Po té, co jste nainstalovali verzi <application>gtkmm</application> z "
"repozitáře git, jste připraveni začít ji používat a experimentovat s ní. "
"Abyste mohli používat novou verzi <application>gtkmm</application>, kterou "
"jste právě nainstalovali, potřebujete nastavit některé proměnné prostředí, "
"aby váš skript <filename>configure</filename> věděl, kde najít nové "
"knihovny. Naštěstí <application>jhbuild</application> nabízí jednoduché "
"řešení tohoto problému. Spuštěním příkazu <command>jhbuild shell</command> "
"se spustí nový shell se správně nastavenými všemi proměnnými prostředí. Když "
"nyní, stejně jak jste zvyklí, znovu nakonfigurujete a sestavíte svůj "
"projekt, měl by být slinkován vůči nově nainstalovaným knihovnám. Pro návrat "
"do předchozího prostředí stačí prostě opustit shell, který "
"<application>jhbuild</application> spustil."

#: C/gtkmm-tutorial-in.xml:8542(para)
msgid ""
"Once you've built your software, you'll need to run your program within the "
"jhbuild environment as well. To do this, you can again use the "
"<command>jhbuild shell</command> command to start a new shell with the "
"<application>jhbuild</application> environment set up. Alternatively, you "
"can execute a one-off command in the <application>jhbuild</application> "
"environment using the following command: <command>jhbuild run command-name</"
"command>. In this case, the command will be run with the correct environment "
"variables set, but will return to your previous environment after the "
"program exits."
msgstr ""
"Jakmile máte svůj software sestavený, potřebujete jej spustit ve stejném "
"prostředí systému <application>jhbuild</application>. K tomu můžete znovu "
"spustit příkaz <command>jhbuild shell</command>, aby se spustil nový shell s "
"nastaveným prostředím pro <application>jhbuild</application>. Případně "
"můžete jednorázově spustit příkaz v prostředí systému <application>jhbuild</"
"application> následujícím příkazem: <command>jhbuild run command-name</"
"command>. V tomto případě bude příkaz spuštěn s nastavenými správnými "
"proměnnými prostředí, ale po jeho ukončení dojde návratu do předchozího "
"prostředí."

#: C/gtkmm-tutorial-in.xml:8559(title)
msgid "Wrapping C Libraries with gmmproc"
msgstr "Obalení knihoven C pomocí gmmproc"

#: C/gtkmm-tutorial-in.xml:8560(para)
msgid ""
"<application>gtkmm</application> uses the <command>gmmproc</command> tool to "
"generate most of its source code, using .defs files that define the APIs of "
"<classname>GObject</classname>-based libraries. So it's quite easy to create "
"additional gtkmm-style wrappers of other glib/GObject-based libraries."
msgstr ""
"<application>gtkmm</application> využívá nástroj <command>gmmproc</command> "
"k vygenerování většiny svých zdrojových kódů pomocí souborů .defs, které "
"definují API knihoven založených na <classname>GObject</classname>. Je tak "
"velmi snadné vytvořit další obalující kód ve stylu gtkmm pro další knihovny "
"založené na glib/GObject."

#: C/gtkmm-tutorial-in.xml:8565(para)
msgid ""
"This involves a variety of tools, some of them crufty, but at least they "
"work, and has been used successfully by several projects."
msgstr ""
"Ve skutečnosti se jedná o několik nástrojů, z nichž některé jsou záludnější, "
"ale určitě fungují a byly použité v několika projektech."

#: C/gtkmm-tutorial-in.xml:8570(title)
msgid "The build structure"
msgstr "Struktura sestavení"

#: C/gtkmm-tutorial-in.xml:8571(para)
msgid ""
"Generation of the source code for a gtkmm-style wrapper API requires use of "
"tools such as <command>gmmproc</command> and <filename>generate_wrap_init."
"pl</filename>. In theory you could write your own build files to use these "
"appropriately, but a much better option is to make use of the build "
"infrastructure provided by the mm-common module. To get started, it helps a "
"lot to pick an existing binding module as an example to look at."
msgstr ""
"Generování zdrojových kódů pro obalující API ve stylu gtkmm vyžaduje použití "
"nástrojů, jako jsou <command>gmmproc</command> a <filename>generate_wrap_int."
"pl</filename>. Teoreticky si můžete napsat vlastní sestavovací soubory pro "
"tentýž účel, ale mnohem lepší volbou je, použít sestavovací infrastrukturu "
"poskytovanou modulem mm-common. Jestli s tím začínáte, výrazně vám pomůže, "
"vzít si existující modul jako příklad na okoukání."

#: C/gtkmm-tutorial-in.xml:8578(para)
msgid ""
"For instance, let's pretend that we are wrapping a C library called "
"libsomething. It provides a <classname>GObject</classname>-based API with "
"types named, for instance, <classname>SomeWidget</classname> and "
"<classname>SomeStuff</classname>."
msgstr ""
"Například si představme, že obalujeme knihovnu C nazvanou libneco a že "
"poskytuje API na základě <classname>GObject</classname> s typy nazvanými "
"například <classname>NecoWidget</classname> a <classname>NecoNejakeho</"
"classname>."

#: C/gtkmm-tutorial-in.xml:8584(title)
msgid "Copying the skeleton project"
msgstr "Kopírování kostry projektu"

#: C/gtkmm-tutorial-in.xml:8589(programlisting)
#, no-wrap
msgid ""
"\n"
"  $ git clone git://git.gnome.org/mm-common\n"
"  $ cp -a mm-common/skeletonmm libsomethingmm\n"
msgstr ""
"\n"
"  $ git clone git://git.gnome.org/mm-common\n"
"  $ cp -a mm-common/skeletonmm libnecomm\n"

#: C/gtkmm-tutorial-in.xml:8586(para)
msgid ""
"Typically our wrapper library would be called libsomethingmm. We can start "
"by copying the <ulink url=\"http://git.gnome.org/browse/mm-common/tree/"
"skeletonmm\">skeleton source tree</ulink> from the mm-common module. "
"<placeholder-1/>"
msgstr ""
"Typicky by se naše obalujíc knihovna nazývala libnecomm. Můžeme začít "
"zkopírováním <ulink url=\"http://git.gnome.org/browse/mm-common/tree/"
"skeletonmm\">kostry zdrojového stromu</ulink> z modulu mm-common. "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8599(para)
msgid "<filename>libsomethingmm</filename>: The top-level directory."
msgstr "<filename>libnecomm</filename>: Složka nejvyšší úrovně."

#: C/gtkmm-tutorial-in.xml:8601(para)
msgid ""
"<filename>libsomething</filename>: Contains the main include file and the "
"pkg-config .pc file."
msgstr ""
"<filename>libneco</filename>: Obsahuje hlavní soubor pro vložení a soubor "
"<filename>.pc</filename> pro pkg-config."

#: C/gtkmm-tutorial-in.xml:8603(para)
msgid "<filename>src</filename>: Contains .hg and .ccg source files."
msgstr "<filename>src</filename>: Obsahuje zdrojové soubory.hg a .ccg."

#: C/gtkmm-tutorial-in.xml:8604(para)
msgid ""
"<filename>libsomethingmm</filename>: Contains generated and hand-written .h "
"and .cc files."
msgstr ""
"<filename>libnecomm</filename>: Obsahuje vygenerované a ručně napsané "
"soubory .h a .cc."

#: C/gtkmm-tutorial-in.xml:8606(para)
msgid ""
"<filename>private</filename>: Contains generated <filename>*_p.h</filename> "
"files."
msgstr ""
"<filename>private</filename>:Obsahuje vygenerované soubory <filename>*_p.h</"
"filename>."

#: C/gtkmm-tutorial-in.xml:8594(para)
msgid ""
"This provides a directory structure for the source .hg and .ccg files and "
"the generated .h and .cc files, with <filename>filelist.am</filename> "
"Automake include files that can specify the various files in use, in terms "
"of generic Automake variables. The directory structure usually looks like "
"this, after we have renamed the directories appropriately: <placeholder-1/>"
msgstr ""
"Tím se poskytne struktura složek pro zdrojové soubory <filename>.hg</"
"filename> a <filename>.ccg</filename> a generované soubory <filename>.h</"
"filename> a <filename>.cc</filename>, se souborem <filename>filelist.amd</"
"filename> pro Automake, který obsahuje soubory, kterými mohou být různé "
"soubory používané ve významu obecných proměnných Automake. Struktura složek, "
"po příslušném přejmenování složek, obvykle vypadá nějak takto: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8618(programlisting)
#, no-wrap
msgid ""
"\n"
"$ for f in $(find libsomethingmm -depth -name '*skeleton*'); do \\\n"
"    d=\"${f%/*}\"; b=\"${f##*/}\"; mv \"$f\" \"$d/${b//skeleton/libsomething}\"; \\\n"
"  done\n"
msgstr ""
"\n"
"$ for f in $(find libnecomm -depth -name '*skeleton*'); do \\\n"
"    d=\"${f%/*}\"; b=\"${f##*/}\"; mv \"$f\" \"$d/${b//skeleton/libneco}\"; \\\n"
"  done\n"

#: C/gtkmm-tutorial-in.xml:8616(para)
msgid ""
"As well as renaming the directories, we should rename some of the source "
"files. For instance: <placeholder-1/> A number of the skeleton files must "
"still be filled in with project-specific content later."
msgstr ""
"Stejně, jako jsme přejmenovali složky, měli bychom přejmenovat i některé "
"zdrojové soubory. Například: <placeholder-1/> U řady souborů v kostře se "
"také bude muset později vyplnit obsah podle projektu."

#: C/gtkmm-tutorial-in.xml:8625(para)
msgid ""
"Note that files ending in <filename>.in</filename> will be used to generate "
"files with the same name but without the <filename>.in</filename> suffix, by "
"replacing some variables with actual values during the configure stage."
msgstr ""
"Soubory končící na <filename>.in</filename> budou použity k vygenerování "
"souborů se stejným názvem, ale bez přípony <filename>.in</filename>. Během "
"konfigurační fáze se v nich nahradí některé proměnné skutečnými hodnotami."

#: C/gtkmm-tutorial-in.xml:8631(title)
msgid "Modifying build files"
msgstr "Úprava souborů řídících sestavení"

#: C/gtkmm-tutorial-in.xml:8633(para)
msgid ""
"Now we edit the files to adapt them to our needs. You might prefer to use a "
"multiple-file search-replace utility for this, such as <command>regexxer</"
"command>. Note that nearly all of the files provided with the skeleton "
"source tree contain placeholder text. Thus, the substitutions should be "
"performed globally, and not be limited to the Automake and Autoconf files."
msgstr ""
"Nyní upravíme soubory, abychom je přizpůsobili našim potřebám. Možná dáváte "
"přednost použití nějakého nástroje pro hledání a nahrazování ve více "
"souborech, jako je <command>regexxer</command>. Proto je dobré vědět, že "
"téměř všechny soubory poskytnuté v kostře zdrojového stromu obsahují "
"zástupné texty. Náhrady by tak měly být prováděné globálně a neomezovat se "
"jen na soubory Automake a Autoconf."

#: C/gtkmm-tutorial-in.xml:8637(para)
msgid ""
"All mentions of <varname>skeleton</varname> should be replaced by the "
"correct name of the C library you are wrapping, such as \"something\" or "
"\"libsomething\". In the same manner, all instances of <varname>SKELETON</"
"varname> should be replaced by \"SOMETHING\" or \"LIBSOMETHING\", and all "
"occurrences of <varname>Skeleton</varname> changed to \"Something\"."
msgstr ""
"Všechny výskyty <varname>skeleton</varname> by měly být nahrazeny správným "
"názvem knihovny C, kterou obalujete, např. za „neco“ a „libneco“. Stejně tak "
"všechny výskyty <varname>SKELETON</varname> by měly být nahrazeny za „NECO“ "
"a „LIBNECO“ a všechny výskyty <varname>Skeleton</varname> za „Neco“."

#: C/gtkmm-tutorial-in.xml:8641(para)
msgid ""
"Likewise, replace all instances of <varname>Joe Hacker</varname> by the name "
"of the intended copyright holder, which is probably you. Do the same for the "
"<varname>joe@example.com</varname> email address."
msgstr ""
"Obdobně nahraďte všechny výskyty <varname>Joe Hacker</varname> za "
"zamýšleného držitele práv, což budete nejspíše vy. To stejné proveďte s e-"
"mailovou adresou <varname>joe@example.com</varname>."

#: C/gtkmm-tutorial-in.xml:8646(title)
msgid "configure.ac"
msgstr "configure.ac"

#: C/gtkmm-tutorial-in.xml:8649(para)
msgid ""
"The <function>AC_CONFIG_SRCDIR()</function> line must mention a file in our "
"source tree. We can edit this later if we don't yet know the names of any of "
"the files that we will create."
msgstr ""
"Na řádku s <function>AC_CONFIG_SRCDIR()</function> musí být zmíněný soubor z "
"naše stromu zdrojových kódů. Pokud zatím nevíme názvy žádných souborů, které "
"vytvoříme, můžeme tento údaj doplnit později."

#: C/gtkmm-tutorial-in.xml:8652(para)
msgid ""
"It is common for binding modules to track the version number of the library "
"they are wrapping. So, for instance, if the C library is at version 1.23.4, "
"then the initial version of the binding module would be 1.23.0. However, "
"avoid starting with an even minor version number as that usually indicates a "
"stable release."
msgstr ""
"Pro vazební moduly je běžné, že sledují číslo verze knihovny, kterou "
"obalují. Takže například, když knihovna C je ve verzi 1.23.4, počáteční "
"verze vazebního modulu by byla 1.23.0. Vyhněte se ale počátku se sudým "
"vedlejším číslem verze, protože obvykle indikuje stabilní vydání."

#: C/gtkmm-tutorial-in.xml:8657(para)
msgid ""
"The <function>AC_CONFIG_HEADERS()</function> line is used to generate two or "
"more configuration header files. The first header file in the list contains "
"all configuration macros which are set during the configure run. The "
"remaining headers in the list contain only a subset of configuration macros "
"and their corresponding <filename>config.h.in</filename> file will not be "
"autogenerated. The reason for this separation is that the namespaced "
"configuration headers are installed with your library and define publically "
"visible macros."
msgstr ""
"Řádek <function>AC_CONFIG_HEADERS()</function> se používá ke generování dvou "
"nebo více hlavičkových souborů. První hlavičkový soubor v seznamu obsahuje "
"všechna konfigurační makra, která se nastaví při běhu konfigurace. Zbývající "
"hlavičkové soubory v seznamu obsahují jen podmnožinu konfiguračních maker a "
"jejich příslušný soubor <filename>config.h.in</filename> se automaticky "
"nevygeneruje. Důvodem je oddělení těchto věcí, protože konfigurační "
"hlavičkové soubory se jmenným prostorem se instalují spolu s vaší knihovnou "
"a definují veřejně viditelná makra."

#: C/gtkmm-tutorial-in.xml:8665(para)
msgid ""
"The <function>AC_SUBST([SOMETHINGMM_MODULES], ['...'])</function> line may "
"need to be modified to check for the correct dependencies."
msgstr ""
"Řádek <function>AC_SUBST([SOMETHINGMM_MODULES], ['…'])</function> může "
"potřebovat upravit, aby kontroloval správné závislosti."

#: C/gtkmm-tutorial-in.xml:8667(para)
msgid ""
"The <function>AC_CONFIG_FILES()</function> block must mention the correct "
"directory names, as described above."
msgstr ""
"Blok <function>AC_CONFIG_FILES()</function> musí uvádět správné názvy "
"složek, jak bylo popsáno výše."

#: C/gtkmm-tutorial-in.xml:8647(para)
msgid "In <filename>configure.ac</filename>, <placeholder-1/>"
msgstr "V souboru <filename>configure.ac</filename> <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8674(title)
msgid "Makefile.am files"
msgstr "Soubory Makefile.am"

#: C/gtkmm-tutorial-in.xml:8677(para)
msgid ""
"In <filename>skeleton/src/Makefile.am</filename> we must mention the correct "
"values for the generic variables that are used elsewhere in the build system:"
msgstr ""
"V <filename>skeleton/src/Makefile.am</filename> musíme uvést správné hodnoty "
"pro obecné proměnné, které s použijí všude možně v sestavovacím systému."

#: C/gtkmm-tutorial-in.xml:8682(varname)
msgid "binding_name"
msgstr "binding_name"

#: C/gtkmm-tutorial-in.xml:8683(para)
msgid "The name of the library, such as libsomethingmm."
msgstr "Název knihovny, jako libnecomm."

#: C/gtkmm-tutorial-in.xml:8687(varname)
msgid "wrap_init_flags"
msgstr "wrap_init_flags"

#: C/gtkmm-tutorial-in.xml:8688(para)
msgid ""
"Additional command-line flags passed to the <filename>generate_wrap_init.pl</"
"filename> script, such as the C++ namespace and the parent directory prefix "
"of include files."
msgstr ""
"Doplňkové přepínače z příkazové řádky předané skriptu "
"<filename>generate_wrap_init.pl</filename>, jako je jmenný prostor C++ a "
"prefix v podobě rodičovské složky pro vkládané soubory."

#: C/gtkmm-tutorial-in.xml:8695(para)
msgid ""
"In <filename>skeleton/skeletonmm/Makefile.am</filename> we must mention the "
"correct values for the generic variables that are used elsewhere in the "
"build system:"
msgstr ""
"V <filename>skeleton/skeletonmm/Makefile.am</filename> musíme uvést správné "
"hodnoty pro obecné proměnné, které se používají všude možně v sestavovacím "
"systému:"

#: C/gtkmm-tutorial-in.xml:8700(varname)
msgid "lib_LTLIBRARIES"
msgstr "lib_LTLIBRARIES"

#: C/gtkmm-tutorial-in.xml:8701(para)
msgid ""
"This variable must mention the correct library name, and this library name "
"must be used to form the <varname>_SOURCES</varname>, <varname>_LDFLAGS</"
"varname>, and <varname>_LIBADD</varname> variable names. It is permissible "
"to use variables substituted by <filename>configure</filename> like "
"<varname>@SOMETHINGMM_API_VERSION@</varname> as part of the variable names."
msgstr ""
"Tato proměnná musí uvádět správný název knihovny a název této knihovny musí "
"být použitý k vytvoření názvů proměnných <varname>_SOURCES</varname>, "
"<varname>_LDFLAGS</varname> a <varname>_LIBADD</varname>. Je zcela legitimní "
"použít jako součást názvů proměnných proměnné nahrazované skriptem "
"<filename>configure</filename>, jako <varname>@NECOMM_API_VERSION@</varname>."

#: C/gtkmm-tutorial-in.xml:8710(varname)
msgid "AM_CPPFLAGS"
msgstr "AM_CPPFLAGS"

#: C/gtkmm-tutorial-in.xml:8711(para)
msgid "The command line options passed to the C preprocessor."
msgstr "Volba příkazové řádky předávaná do preprocesoru C."

#: C/gtkmm-tutorial-in.xml:8715(varname)
msgid "AM_CXXFLAGS"
msgstr "AM_CXXFLAGS"

#: C/gtkmm-tutorial-in.xml:8716(para)
msgid "The command line options passed to the C++ compiler."
msgstr "Volba příkazové řádky předávaná do kompilátoru C++."

#: C/gtkmm-tutorial-in.xml:8675(para)
msgid ""
"Next we must adapt the various <filename>Makefile.am</filename> files: "
"<placeholder-1/>"
msgstr ""
"Následně musíme přizpůsobit různé soubory <filename>Makefile.am</filename>: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8726(title)
msgid "Creating .hg and .ccg files"
msgstr "Vytváření souborů .hg a .ccg"

#: C/gtkmm-tutorial-in.xml:8727(para)
msgid ""
"We should now create our first <filename>.hg</filename> and <filename>.ccg</"
"filename> files, to wrap one of the objects in the C library. One pair of "
"example source files already exists: <filename>skeleton.ccg</filename> and "
"<filename>skeleton.hg</filename>. Create copies of these files as necessary."
msgstr ""
"Měli bychom vytvořit své první soubory <filename>.hg</filename> a <filename>."
"ccg</filename> pro obalení některého z objektů v knihovně C. Jeden pár "
"ukázkových zdrojových souborů již existuje: <filename>skeleton.ccg</"
"filename> a <filename>skeleton.hg</filename>. Podle potřeby si vytvořte "
"kopie těchto souborů."

#: C/gtkmm-tutorial-in.xml:8731(para)
msgid ""
"We must mention all of our <filename>.hg</filename> and <filename>.ccg</"
"filename> files in the <filename>skeleton/src/filelist.am</filename> file, "
"typically in the <varname>files_hg</varname> variable."
msgstr ""
"Všechny naše soubory <filename>.hg</filename> a <filename>.ccg</filename> "
"musíme uvést v <filename>skeleton/src/filelist.am</filename>, typicky v "
"proměnné <varname>files_hg</varname>."

#: C/gtkmm-tutorial-in.xml:8735(para)
msgid ""
"Any additional non-generated <filename>.h</filename> and <filename>.cc</"
"filename> source files may be placed in <filename>skeleton/skeletonmm/</"
"filename> and listed in <filename>skeleton/skeletonmm/filelist.am</"
"filename>, typically in the <varname>files_extra_h</varname> and "
"<varname>files_extra_cc</varname> variables."
msgstr ""
"Případné další negenerované zdrojové soubory <filename>.h</filename> a "
"<filename>.cc</filename> mohou být umístěné v <filename>skeleton/skeletonmm/"
"</filename> a vypsané v <filename>skeleton/skeletonmm/filelist.am</"
"filename>, typicky v proměnných <varname>files_extra_h</varname> a "
"<varname>files_extra_cc</varname>."

#: C/gtkmm-tutorial-in.xml:8741(para)
msgid ""
"In the <link linkend=\"sec-wrapping-hg-files\">.hg and .ccg files</link> "
"section you can learn about the syntax used in these files."
msgstr ""
"V kapitole <link linkend=\"sec-wrapping-hg-files\">soubory .hg a .ccg</link> "
"se můžete dozvědět více o syntaxi používané v těchto souborech."

#: C/gtkmm-tutorial-in.xml:8748(title)
msgid "Generating the .defs files."
msgstr "Generování souborů .defs"

#: C/gtkmm-tutorial-in.xml:8752(para)
msgid "objects (GObjects, widgets, interfaces, boxed-types and plain structs)"
msgstr ""
"objektů (GObject, widgety, rozhraní, boxované typy a obyčejné struktury)"

#: C/gtkmm-tutorial-in.xml:8753(para)
msgid "functions"
msgstr "funkcí"

#: C/gtkmm-tutorial-in.xml:8754(para)
msgid "enums"
msgstr "výčtových typů"

#: C/gtkmm-tutorial-in.xml:8755(para)
msgid "signals"
msgstr "signálů"

#: C/gtkmm-tutorial-in.xml:8756(para)
msgid "properties"
msgstr "vlastností"

#: C/gtkmm-tutorial-in.xml:8757(para)
msgid "vfuncs"
msgstr "virtuálních funkcí"

#: C/gtkmm-tutorial-in.xml:8749(para)
msgid ""
"The <filename>.defs</filename> files are text files, in a lisp format, that "
"describe the API of a C library, including its <placeholder-1/>"
msgstr ""
"Soubory <filename>.defs</filename> jsou textové soubory ve formátu lisp, "
"které popisují API knihovny C, včetně jejích <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8766(filename)
msgid "gtk.defs"
msgstr "gtk.defs"

#: C/gtkmm-tutorial-in.xml:8767(para)
msgid "Includes the other files."
msgstr "Vložení dalších souborů"

#: C/gtkmm-tutorial-in.xml:8770(filename)
msgid "gtk_methods.defs"
msgstr "gtk_methods.defs"

#: C/gtkmm-tutorial-in.xml:8771(para)
msgid "Objects and functions."
msgstr "Objekty a funkce"

#: C/gtkmm-tutorial-in.xml:8774(filename)
msgid "gtk_enums.defs"
msgstr "gtk_enums.defs"

#: C/gtkmm-tutorial-in.xml:8775(para)
msgid "Enumerations."
msgstr "Výčty"

#: C/gtkmm-tutorial-in.xml:8778(filename)
msgid "gtk_signals.defs"
msgstr "gtk_signals.defs"

#: C/gtkmm-tutorial-in.xml:8779(para)
msgid "Signals and properties."
msgstr "Signály a vlastnosti"

#: C/gtkmm-tutorial-in.xml:8782(filename)
msgid "gtk_vfuncs.defs"
msgstr "gtk_vfuncs.defs"

#: C/gtkmm-tutorial-in.xml:8783(para)
msgid "vfuncs (function pointer member fields in structs), written by hand."
msgstr ""
"Virtuální funkce (ukazatel na funkci jako členské pole v struktuře), psané "
"ručně."

#: C/gtkmm-tutorial-in.xml:8760(para)
msgid ""
"At the moment, we have separate tools for generating different parts of "
"these <filename>.defs</filename>, so we split them up into separate files. "
"For instance, in the <filename>gtk/src</filename> directory of the "
"<application>gtkmm</application> sources, you will find these files: "
"<placeholder-1/>"
msgstr ""
"V tuto chvíli máme oddělené nástroje pro generování různých částí těchto "
"souborů <filename>.defs</filename>, takže je rozdělíme do samostatných "
"souborů. Například ve složce <filename>gtk/src</filename> se zdrojovými kódy "
"<application>gtkmm</application> můžete najít tyto soubory: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8787(para)
msgid ""
"The <filename>skeletonmm/codegen/generate_defs_and_docs.sh</filename> script "
"generates all <filename>.defs</filename> files and the <filename>*_docs.xml</"
"filename> file, described in the <link linkend=\"sec-wrapping-documentation"
"\">Documentation</link> section."
msgstr ""
"Skript <filename>skeletonmm/codegen/generate_defs_and_docs.sh</filename> "
"generuje všechny soubory <filename>.defs</filename> a soubor "
"<filename>*_docs.xml</filename>, popsaný v kapitole <link linkend=\"sec-"
"wrapping-documentation\">Dokumentace</link>."

#: C/gtkmm-tutorial-in.xml:8793(title)
msgid "Generating the methods .defs"
msgstr "Generování .defs  pro metody"

#: C/gtkmm-tutorial-in.xml:8797(programlisting)
#, no-wrap
msgid ""
"\n"
"$ ./h2def.py /usr/include/gtk-3.0/gtk/*.h &gt; gtk_methods.defs\n"
msgstr ""
"\n"
"$ ./h2def.py /usr/include/gtk-3.0/gtk/*.h &gt; gtk_methods.defs\n"

#: C/gtkmm-tutorial-in.xml:8794(para)
msgid ""
"This <filename>.defs</filename> file describes objects and their functions. "
"It is generated by the <command>h2def.py</command> script which you can find "
"in glibmm's <filename>tools/defs_gen</filename> directory. For instance, "
"<placeholder-1/>"
msgstr ""
"Soubor <filename>.defs</filename> popisuje objekty a jejich funkce. Je "
"generovaný pomocí skriptu <command>h2def.py</command>, který můžete najít ve "
"složce <filename>tools/defs_gen</filename> knihovny glibmm. Například "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8804(title)
msgid "Generating the enums .defs"
msgstr "Generování .defs  pro výčty"

#: C/gtkmm-tutorial-in.xml:8808(programlisting)
#, no-wrap
msgid ""
"\n"
"$ ./enum.pl /usr/include/gtk-3.0/gtk/*.h &gt; gtk_enums.defs\n"
msgstr ""
"\n"
"$ ./enum.pl /usr/include/gtk-3.0/gtk/*.h &gt; gtk_enums.defs\n"

#: C/gtkmm-tutorial-in.xml:8805(para)
msgid ""
"This <filename>.defs</filename> file describes enum types and their possible "
"values. It is generated by the <filename>enum.pl</filename> script which you "
"can find in glibmm's <filename>tools</filename> directory. For instance, "
"<placeholder-1/>"
msgstr ""
"Soubor <filename>.defs</filename> popisuje výčtové typy a jejich možné "
"hodnoty. Je generovaný pomocí skriptu <filename>enum.pl</filename>, který "
"můžete najít ve složce <filename>tools</filename> knihovny glibmm. Například "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8815(title)
msgid "Generating the signals and properties .defs"
msgstr "Generování .defs  pro signály a vlastnosti"

#: C/gtkmm-tutorial-in.xml:8820(programlisting)
#, no-wrap
msgid ""
"\n"
"$ cd tools/extra_defs_gen\n"
"$ ./generate_extra_defs &gt; gtk_signals.defs\n"
msgstr ""
"\n"
"$ cd tools/extra_defs_gen\n"
"$ ./generate_extra_defs &gt; gtk_signals.defs\n"

#: C/gtkmm-tutorial-in.xml:8816(para)
msgid ""
"This <filename>.defs</filename> file describes signals and properties. It is "
"generated by the special <filename>generate_extra_defs</filename> utility "
"that is in every wrapping project, such as <filename>gtkmm/tools/"
"extra_defs_gen/</filename>. For instance <placeholder-1/>"
msgstr ""
"Tento soubor <filename>.defs</filename> popisuje signály a vlastnosti. Je "
"generovaný pomocí speciálního nástroje <filename>generate_extra_defs</"
"filename>, která je v každém obalujicím projektu, jako je <filename>gtkmm/"
"tools/extra_defs_gen/</filename>. Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8825(para)
msgid ""
"You must edit the source code of your own <filename>generate_extra_defs</"
"filename> tool in order to generate the <filename>.defs</filename> for the "
"GObject C types that you wish to wrap. In the skeleton source tree, the "
"source file is named <filename>codegen/extradefs/"
"generate_extra_defs_skeleton.cc</filename>. If not done so already, the file "
"should be renamed, with the basename of your new binding substituted for the "
"<varname>skeleton</varname> placeholder. The <filename>codegen/Makefile.am</"
"filename> file should also mention the new source filename."
msgstr ""
"Aby se vygeneroval soubor <filename>.defs</filename> pro typy GObject v C, "
"které si přejete obalit, musíte upravit zdrojový kód svého vlastního "
"nástroje <filename>generate_extra_defs</filename>. Ve stromu zdrojových kódů "
"kostry je soubor s názvem <filename>codegen/extradefs/"
"generate_extra_defs_skeleton.cc</filename>. Pokud jste to zatím neudělali, "
"měli byste jej přejmenovat. Základní název by měla tvořit nová vazba "
"nahrazující zástupný název <varname>skeleton</varname>. Nový název "
"zdrojového souboru by měl být také uveden v <filename>codegen/Makefile.am</"
"filename>."

#: C/gtkmm-tutorial-in.xml:8834(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;libsomething.h&gt;\n"
"\n"
"int main(int, char**)\n"
"{\n"
"  something_init();\n"
"\n"
"  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)\n"
"            &lt;&lt; get_defs(SOME_TYPE_STUFF);\n"
"  return 0;\n"
"}\n"
msgstr ""
"\n"
"#include &lt;libsomething.h&gt;\n"
"\n"
"int main(int, char**)\n"
"{\n"
"  something_init();\n"
"\n"
"  std::cout &lt;&lt; get_defs(SOME_TYPE_WIDGET)\n"
"            &lt;&lt; get_defs(SOME_TYPE_STUFF);\n"
"  return 0;\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:8832(para)
msgid ""
"Then edit the <filename>.cc</filename> file to specify the correct types. "
"For instance, your <function>main()</function> function might look like "
"this: <placeholder-1/>"
msgstr ""
"Pak upravte soubor <filename>.cc</filename>, aby uváděl správné typy. "
"Například vaše funkce <function>main()</function> může vypadat nějak takto: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8850(title)
msgid "Writing the vfuncs .defs"
msgstr "Psaní .defs pro virtuální funkce"

#: C/gtkmm-tutorial-in.xml:8851(para)
msgid ""
"This <filename>.defs</filename> file describes virtual functions (vfuncs). "
"It must be written by hand. There is the skeleton file <filename>skeleton/"
"src/skeleton_vfunc.defs</filename> to start from. You can also look at "
"<application>gtkmm</application>'s <filename>gtk/src/gtk_vfuncs.defs</"
"filename> file."
msgstr ""
"Tento soubor <filename>.defs</filename> popisuje virtuální funkce. Musíte "
"jej napsat ručně. Existuje k tomu připravená kostra <filename>skeleton/src/"
"skeleton_vfunc.defs</filename>, ze které můžete vyjít. Můžete se také "
"podívat na soubor <filename>gtk/src/gtk_vfuncs.defs</filename> z "
"<application>gtkmm</application>."

#: C/gtkmm-tutorial-in.xml:8862(title)
msgid "The .hg and .ccg files"
msgstr "Soubory .hg a .ccg"

#: C/gtkmm-tutorial-in.xml:8863(para)
msgid ""
"The .hg and .ccg source files are very much like .h and .cc C++ source "
"files, but they contain extra macros, such as <function>_CLASS_GOBJECT()</"
"function> and <function>_WRAP_METHOD()</function>, from which "
"<command>gmmproc</command> generates appropriate C++ source code, usually at "
"the same position in the header. Any additional C++ source code will be "
"copied verbatim into the corresponding .h or .cc file."
msgstr ""
"Zdrojové soubory <filename>.hg</filename> a <filename>.ccg</filename> se "
"velmi podobají zdrojovým souborům <filename>.h</filename> a <filename>.cc</"
"filename>, ale mohou obsahovat další makra, jako je "
"<function>_CLASS_GOBJECT()</function> a <function>_WRAP_METHOD()</function>, "
"ze kterých <command>gmmproc</command> generuje příslušný zdrojový kód C++, "
"obvykle na stejném místě v hlavičkovém souboru. Případný doplňující zdrojový "
"kód C++ bude doslovně nakopírován do příslušného souboru <filename>.h</"
"filename> nebo <filename>.cc</filename>."

#: C/gtkmm-tutorial-in.xml:8876(programlisting)
#, no-wrap
msgid ""
"\n"
"#include &lt;gtkmm/bin.h&gt;\n"
"#include &lt;gtkmm/activatable.h&gt;\n"
"_DEFS(gtkmm,gtk)\n"
"_PINCLUDE(gtkmm/private/bin_p.h)\n"
"\n"
"namespace Gtk\n"
"{\n"
"\n"
"class Button\n"
"  : public Bin,\n"
"    public Activatable\n"
"{\n"
"  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
"  _IMPLEMENTS_INTERFACE(Activatable)\n"
"public:\n"
"\n"
"  _CTOR_DEFAULT\n"
"  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
"\n"
"  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
"};\n"
"\n"
"} // namespace Gtk\n"
msgstr ""
"\n"
"#include &lt;gtkmm/bin.h&gt;\n"
"#include &lt;gtkmm/activatable.h&gt;\n"
"_DEFS(gtkmm,gtk)\n"
"_PINCLUDE(gtkmm/private/bin_p.h)\n"
"\n"
"namespace Gtk\n"
"{\n"
"\n"
"class Button\n"
"  : public Bin,\n"
"    public Activatable\n"
"{\n"
"  _CLASS_GTKOBJECT(Button,GtkButton,GTK_BUTTON,Gtk::Bin,GtkBin)\n"
"  _IMPLEMENTS_INTERFACE(Activatable)\n"
"public:\n"
"\n"
"  _CTOR_DEFAULT\n"
"  explicit Button(const Glib::ustring&amp; label, bool mnemonic = false);\n"
"\n"
"  _WRAP_METHOD(void set_label(const Glib::ustring&amp; label), gtk_button_set_label)\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_SIGNAL(void clicked(), \"clicked\")\n"
"\n"
"  ...\n"
"\n"
"  _WRAP_PROPERTY(\"label\", Glib::ustring)\n"
"};\n"
"\n"
"} // jmenný prostor Gtk\n"

#: C/gtkmm-tutorial-in.xml:8871(para)
msgid ""
"A .hg file will typically include some headers and then declare a class, "
"using some macros to add API or behaviour to this class. For instance, "
"<application>gtkmm</application>'s <filename>button.hg</filename> looks "
"roughly like this: <placeholder-1/>"
msgstr ""
"Soubor <filename>.hg</filename> má typicky vložené některé hlavičkové "
"soubory a následně deklaruje. Pomocí některých maker se do této třídy přidá "
"API nebo chování. Například <filename>button.hg</filename> z "
"<application>gtkmm</application> vypadá zhruba takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8913(function)
msgid "_DEFS()"
msgstr "_DEFS()"

#: C/gtkmm-tutorial-in.xml:8914(para)
msgid ""
"Specifies the destination directory for generated sources, and the name of "
"the main .defs file that <command>gmmproc</command> should parse."
msgstr ""
"Určuje cílovou složku pro generované zdrojové soubory a název hlavního "
"souboru <filename>.defs</filename>, který by měl <command>gmmproc</command> "
"zpracovat."

#: C/gtkmm-tutorial-in.xml:8917(function)
msgid "_PINCLUDE()"
msgstr "_PINCLUDE()"

#: C/gtkmm-tutorial-in.xml:8918(para)
msgid ""
"Tells <command>gmmproc</command> to include a header in the generated "
"private/button_p.h file."
msgstr ""
"Řekne <command>gmmproc</command>, aby vložil hlavičkové soubory do "
"generovaného souboru <filename>private/button_p.h</filename>."

#: C/gtkmm-tutorial-in.xml:8921(function)
msgid "_CLASS_GTKOBJECT()"
msgstr "_CLASS_GTKOBJECT()"

#: C/gtkmm-tutorial-in.xml:8922(para)
msgid ""
"Tells <command>gmmproc</command> to add some typedefs, constructors, and "
"standard methods to this class, as appropriate when wrapping a widget."
msgstr ""
"Řekne <command>gmmproc</command>, aby přidal podle potřeby některé definice "
"typů, konstruktory a standardní metody do této třídy při obalování widgetu."

#: C/gtkmm-tutorial-in.xml:8925(function)
msgid "_IMPLEMENTS_INTERFACE()"
msgstr "_IMPLEMENTS_INTERFACE()"

#: C/gtkmm-tutorial-in.xml:8926(para)
msgid ""
"Tells <command>gmmproc</command> to add initialization code for the "
"interface."
msgstr ""
"Řekne <command>gmmproc</command>, aby přidal inicializační kód pro rozhraní."

#: C/gtkmm-tutorial-in.xml:8929(function) C/gtkmm-tutorial-in.xml:9175(title)
msgid "_CTOR_DEFAULT"
msgstr "_CTOR_DEFAULT"

#: C/gtkmm-tutorial-in.xml:8930(para)
msgid "Add a default constructor."
msgstr "Přidá výchozí konstruktor."

#: C/gtkmm-tutorial-in.xml:8933(term)
msgid ""
"<function>_WRAP_METHOD()</function>, <function>_WRAP_SIGNAL()</function>, "
"and <function>_WRAP_PROPERTY()</function>"
msgstr ""
"<function>_WRAP_METHOD()</function>, <function>_WRAP_SIGNAL()</function> a "
"<function>_WRAP_PROPERTY()</function>"

#: C/gtkmm-tutorial-in.xml:8936(para)
msgid "Add methods to wrap parts of the C API."
msgstr "Přidá metody pro obalení částí API C."

#: C/gtkmm-tutorial-in.xml:8910(para)
msgid "The macros in this example do the following: <placeholder-1/>"
msgstr "Makro v následujícím příkladu dělá následující: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8943(programlisting)
#, no-wrap
msgid ""
"\n"
"$ cd gtk/src\n"
"$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm\n"
msgstr ""
"\n"
"$ cd gtk/src\n"
"$ /usr/lib/glibmm-2.4/proc/gmmproc -I ../../tools/m4 --defs . button . ./../gtkmm\n"

#: C/gtkmm-tutorial-in.xml:8940(para)
msgid ""
"The .h and .cc files will be generated from the .hg and .ccg files by "
"processing them with <command>gmmproc</command> like so, though this happens "
"automatically when using the above build structure: <placeholder-1/>"
msgstr ""
"Soubory <filename>.h</filename> a <filename>.cc</filename> budou "
"vygenerované ze souborů <filename>.hg</filename> a <filename>.ccg</filename> "
"jejich zpracováním pomocí <command>gmmproc</command>, k čemuž dojde "
"automaticky při použití sestavovací struktury uvedené výše: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8948(para)
msgid ""
"Notice that we provided <command>gmmproc</command> with the path to the .m4 "
"convert files, the path to the .defs file, the name of a .hg file, the "
"source directory, and the destination directory."
msgstr ""
"Všimněte si, že <command>gmmproc</command> poskytujeme cestu k převodním "
"souborům <filename>.m4</filename>, cestu k souboru <filename>.defs</"
"filename>, název souboru <filename>.hg</filename>, složku se zdrojovými kódy "
"a cílovou složku."

#: C/gtkmm-tutorial-in.xml:8951(para)
msgid ""
"You should avoid including the C header from your C++ header, to avoid "
"polluting the global namespace, and to avoid exporting unnecessary public "
"API. But you will need to include the necessary C headers from your .ccg "
"file."
msgstr ""
"Měli byste se vyhnout vložení hlavičkového souboru C z vašeho hlavičkového "
"souboru C++, aby se předešlo šíření globálního jmenného prostoru a exportu "
"nepotřebného veřejného API. Budete ale potřebovat vložit nutné hlavičkové "
"soubory C ze souboru <filename>.ccg</filename>."

#: C/gtkmm-tutorial-in.xml:8956(para)
msgid "The macros are explained in more detail in the following sections."
msgstr "V následujících oddílech jsou podrobně rozebrána makra."

#: C/gtkmm-tutorial-in.xml:8959(title)
msgid "m4 Conversions"
msgstr "Konverze m4"

#: C/gtkmm-tutorial-in.xml:8966(programlisting)
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')\n"
msgstr ""
"\n"
"_CONVERSION(`GtkTreeView*',`TreeView*',`Glib::wrap($3)')\n"

#: C/gtkmm-tutorial-in.xml:8960(para)
msgid ""
"The macros that you use in the .hg and .ccg files often need to know how to "
"convert a C++ type to a C type, or vice-versa. gmmproc takes this "
"information from an .m4 file in your <literal>tools/m4/</literal> directory. "
"This allows it to call a C function in the implementation of your C++ "
"method, passing the appropriate parameters to that C functon. For instance, "
"this tells gmmproc how to convert a GtkTreeView pointer to a Gtk::TreeView "
"pointer: <placeholder-1/>"
msgstr ""
"Makra, která používáte v souborech <filename>.hg</filename> a <filename>."
"ccg</filename>, často potřebují znát, jak převést typ C++ na typ C a naopak. "
"<command>gmmproc</command> získává tyto informace z souboru <filename>.m4</"
"filename> ve složce <filename>tools/m4/</filename>. Díky tomu se mohou volat "
"funkce v C z implementací vašich metod v C++ se správným předáním parametrů "
"do funkce C. Například takto se řekne <command>gmmproc</command>, jak má "
"převést ukazatel na <classname>GtkTreeView</classname> na ukazatel na "
"<classname>Gtk::TreeView</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8971(para)
msgid ""
"<literal>$3</literal> will be replaced by the parameter name when this "
"conversion is used by gmmproc."
msgstr ""
"Když je tento převod použit skriptem <command>gmmproc</command>, je <literal>"
"$3</literal> nahrazeno názvem parametru."

#: C/gtkmm-tutorial-in.xml:8978(programlisting)
#, no-wrap
msgid ""
"\n"
"_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)\n"
"_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)\n"
"_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))\n"
msgstr ""
"\n"
"_CONVERSION(`PrintSettings&amp;',`GtkPrintSettings*',__FR2P)\n"
"_CONVERSION(`const PrintSettings&amp;',`GtkPrintSettings*',__FCR2P)\n"
"_CONVERSION(`const Glib::RefPtr&lt;Printer&gt;&amp;',`GtkPrinter*',__CONVERT_REFPTR_TO_P($3))\n"

#: C/gtkmm-tutorial-in.xml:8975(para)
msgid ""
"Some extra macros make this easier and consistent. Look in gtkmm's .m4 files "
"for examples. For instance: <placeholder-1/>"
msgstr ""
"Pár doplňujících maker to usnadňuje a zajistí jednotnost. Na příklady se "
"podívejte do souborů <filename>.m4</filename> z gtkmm. Například "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:8987(title)
msgid "m4 Initializations"
msgstr "Inicializace m4"

#: C/gtkmm-tutorial-in.xml:8988(para)
msgid ""
"Often when wrapping methods, it is desirable to store the return of the C "
"function in what is called an output parameter. In this case, the C++ method "
"returns <type>void</type> but an output parameter in which to store the "
"value of the C function is included in the argument list of the C++ method. "
"gmmproc allows such functionality, but appropriate initialization macros "
"must be included to tell gmmproc how to initialize the C++ parameter from "
"the return of the C function."
msgstr ""
"Při balení metod je často žádoucí ukládat návratové hodnoty funkce C v tzv. "
"výstupním parametru. V tomto případě metoda C ++ vrací <type>void</type>, "
"ale výstupní parametr, ve kterém je uložena hodnota z funkce v C, je zahrnut "
"v seznamu argumentů metody v C ++. <command>gmmproc</command> umožňuje tuto "
"funkcionalitu, ale musí být zahrnuta vhodná inicializační makra, které "
"řeknou <command>gmmproc</command>, jak inicializovat parametr C ++ z "
"návratové hodnoty funkce v C."

#: C/gtkmm-tutorial-in.xml:9003(programlisting)
#, no-wrap
msgid ""
"\n"
"_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')\n"
msgstr ""
"\n"
"_INITIALIZATION(`Gtk::Widget&amp;',`GtkWidget*',`$3 = Glib::wrap($4)')\n"

#: C/gtkmm-tutorial-in.xml:8997(para)
msgid ""
"For example, if there was a C function that returned a <type>GtkWidget*</"
"type> and for some reason, instead of having the C++ method also return the "
"widget, it was desirable to have the C++ method place the widget in a "
"specified output parameter, an initialization macro such as the following "
"would be necessary: <placeholder-1/>"
msgstr ""
"Pokud by například funkce v C vracela <type>GtkWidget*</type> a metoda v C++ "
"z nějakého důvodu místo widgetu vracela něco jiného, je žádoucí, aby metoda "
"v C++ umístila widget do určeného výstupního parametru, k čemuž by bylo "
"nutné následující inicializační makro: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9008(para)
msgid ""
"<literal>$3</literal> will be replaced by the output parameter name of the C+"
"+ method and <literal>$4</literal> will be replaced by the return of the C "
"function when this initialization is used by gmmproc. For convenience, "
"<literal>$1</literal> will also be replaced by the C++ type without the "
"ampersand (&amp;) and <literal>$2</literal> will be replaced by the C type."
msgstr ""
"Když je tato inicializace použita skriptem <command>gmmproc</command>, je "
"<literal>$3</literal> nahrazeno názvem výstupního parametru metody v C++ a "
"<literal>$4</literal> návratovým parametrem funkce v C. Někdy se může hodit "
"i <literal>$1</literal>, které je nahrazeno typem C++ bez amprsandu (&amp;) "
"a <literal>$2</literal>, které je nahrazeno typem C."

#: C/gtkmm-tutorial-in.xml:9019(title)
msgid "Class macros"
msgstr "Makra pro třídy"

#: C/gtkmm-tutorial-in.xml:9020(para)
msgid ""
"The class macro declares the class itself and its relationship with the "
"underlying C type. It generates some internal constructors, the member "
"<varname>gobject_</varname>, typedefs, the <function>gobj()</function> "
"accessors, type registration, and the <function>Glib::wrap()</function> "
"method, among other things."
msgstr ""
"Makro deklaruje samotnou třídu a její vztah k podkladovému typu v C. "
"Generuje některé interní konstruktory, definice členských typů "
"<varname>gobject</varname>, příslušníky <function>gobj()</function>, "
"registraci typu a metodu <function>Glib::wrap()</function>, spolu s dalšími "
"věcmi."

#: C/gtkmm-tutorial-in.xml:9025(para)
msgid ""
"Other macros, such as <function>_WRAP_METHOD()</function> and "
"<function>_WRAP_SIGNAL()</function> may only be used after a call to a "
"<function>_CLASS_*</function> macro."
msgstr ""
"Ostatní makra, jako je <function>_WRAP_METHOD()</function> a "
"<function>_WRAP_SIGNAL()</function> mohou být použita jen po zavolání makra "
"<function>_CLASS_*</function>."

#: C/gtkmm-tutorial-in.xml:9030(title)
msgid "_CLASS_GOBJECT"
msgstr "_CLASS_GOBJECT"

#: C/gtkmm-tutorial-in.xml:9031(para)
msgid ""
"This macro declares a wrapper for a type that is derived from "
"<classname>GObject</classname>, but whose wrapper is not derived from "
"<classname>Gtk::Object</classname>."
msgstr ""
"Toto makro deklaruje obalení pro typ, který je odvozený z "
"<classname>GObject</classname>, ale jeho obalení není odvozené z "
"<classname>Gtk::Object</classname>."

#: C/gtkmm-tutorial-in.xml:9034(function)
msgid ""
"_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base "
"class )"
msgstr ""
"_CLASS_GOBJECT( C++ class, C class, C casting macro, C++ base class, C base "
"class )"

#: C/gtkmm-tutorial-in.xml:9036(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)\n"
msgstr ""
"\n"
"_CLASS_GOBJECT(AccelGroup, GtkAccelGroup, GTK_ACCEL_GROUP, Glib::Object, GObject)\n"

#: C/gtkmm-tutorial-in.xml:9035(para)
msgid "For instance, from <filename>accelgroup.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>accelgroup.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9043(title)
msgid "_CLASS_GTKOBJECT"
msgstr "_CLASS_GTKOBJECT"

#: C/gtkmm-tutorial-in.xml:9044(para)
msgid ""
"This macro declares a wrapper for a type whose wrapper is derived from "
"<classname>Gtk::Object</classname>, such as a widget or dialog."
msgstr ""
"Toto makro deklaruje obalení pro typ, jehož obalení je odvozené z "
"<classname>Gtk::Object</classname>, jako je widget nebo dialog."

#: C/gtkmm-tutorial-in.xml:9046(function)
msgid ""
"_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C "
"base class )"
msgstr ""
"_CLASS_GTKOBJECT( C++ class, C class, C casting macro, C++ base class, C "
"base class )"

#: C/gtkmm-tutorial-in.xml:9048(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)\n"
msgstr ""
"\n"
"_CLASS_GTKOBJECT(Button, GtkButton, GTK_BUTTON, Gtk::Bin, GtkBin)\n"

#: C/gtkmm-tutorial-in.xml:9047(para) C/gtkmm-tutorial-in.xml:9386(para)
#: C/gtkmm-tutorial-in.xml:9447(para) C/gtkmm-tutorial-in.xml:9564(para)
msgid "For instance, from <filename>button.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>button.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9052(para)
msgid ""
"You will typically use this macro when the class already derives from Gtk::"
"Object. For instance, you will use it when wrapping a GTK+ Widget, because "
"Gtk::Widget derives from Gtk::Object."
msgstr ""
"Toto makro typicky použijete, když třída již existuje a je odvozená z "
"<classname>Gtk::Object</classname>. Například jej použijete, když obalujete "
"Widget z GTK+, protože <classname>Gtk::Widget</classname> je zděděný z "
"<classname>Gtk::Object</classname>."

#: C/gtkmm-tutorial-in.xml:9053(para)
msgid ""
"You might also derive non-widget classes from Gtk::Object so they can be "
"used without <classname>Glib::RefPtr</classname>. For instance, they could "
"then be instantiated with <function>Gtk::manage()</function> or on the stack "
"as a member variable. This is convenient, but you should use this only when "
"you are sure that true reference-counting is not needed. We consider it "
"useful for widgets."
msgstr ""
"Mohli byste také odvodit z <classname>Gtk::Object</classname> jinou třídu "
"než widget, takže by šla používat bez <classname>Glib::RefPtr</classname>. "
"Například by její instance mohly být vytvářeny pomocí <function>Gtk::"
"manage()</function> nebo na zásobníku jako členské proměnné. Pro některé "
"účely je to vhodné, ale musíte to použít jen v případě, kdy máte jistotu, že "
"počítání referencí není zapotřebí. Za užitečné to považujeme pro widgety."

#: C/gtkmm-tutorial-in.xml:9057(title)
msgid "_CLASS_BOXEDTYPE"
msgstr "_CLASS_BOXEDTYPE"

#: C/gtkmm-tutorial-in.xml:9058(para)
msgid ""
"This macro declares a wrapper for a non-<classname>GObject</classname> "
"struct, registered with <function>g_boxed_type_register_static()</function>."
msgstr ""
"Toto makro deklaruje obalení pro jinou strukturu než <classname>GObject</"
"classname> registrovanou pomocí <function>g_boxed_type_register_static()</"
"function>."

#: C/gtkmm-tutorial-in.xml:9061(function)
msgid ""
"_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free "
"function )"
msgstr ""
"_CLASS_BOXEDTYPE( C++ class, C class, new function, copy function, free "
"function )"

#: C/gtkmm-tutorial-in.xml:9063(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)\n"
msgstr ""
"\n"
"_CLASS_BOXEDTYPE(RGBA, GdkRGBA, NONE, gdk_rgba_copy, gdk_rgba_free)\n"

#: C/gtkmm-tutorial-in.xml:9062(para)
msgid "For instance, from <classname>Gdk::RGBA</classname>: <placeholder-1/>"
msgstr "Příklad z <classname>Gdk::RGBA</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9070(title)
msgid "_CLASS_BOXEDTYPE_STATIC"
msgstr "_CLASS_BOXEDTYPE_STATIC"

#: C/gtkmm-tutorial-in.xml:9071(para)
msgid ""
"This macro declares a wrapper for a simple assignable struct such as "
"<classname>GdkRectangle</classname>. It is similar to "
"<function>_CLASS_BOXEDTYPE</function>, but the C struct is not allocated "
"dynamically."
msgstr ""
"Toto makro deklaruje obalení pro jednoduchou přiřaditelnou strukturu, jako "
"je <classname>GdkRectangle</classname>. Je to podobné, jako u "
"<function>_CLASS_BOXEDTYPE</function>, jen struktura v C se nealokuje "
"dynamicky."

#: C/gtkmm-tutorial-in.xml:9075(function)
msgid "_CLASS_BOXEDTYPE_STATIC( C++ class, C class )"
msgstr "_CLASS_BOXEDTYPE_STATIC( C++ class, C class )"

#: C/gtkmm-tutorial-in.xml:9077(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)\n"
msgstr ""
"\n"
"_CLASS_BOXEDTYPE_STATIC(Rectangle, GdkRectangle)\n"

#: C/gtkmm-tutorial-in.xml:9076(para)
msgid ""
"For instance, for <classname>Gdk::Rectangle</classname>: <placeholder-1/>"
msgstr "Například pro <classname>Gdk::Rectangle</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9084(title)
msgid "_CLASS_OPAQUE_COPYABLE"
msgstr "_CLASS_OPAQUE_COPYABLE"

#: C/gtkmm-tutorial-in.xml:9085(para)
msgid ""
"This macro declares a wrapper for an opaque struct that has copy and free "
"functions. The new, copy and free functions will be used to instantiate the "
"default constructor, copy constructor and destructor."
msgstr ""
"Toto makro deklaruje obalení pro neprůhlednou strukturu, která má funkce "
"copy a free. Funkce new, copy a free se použijí pro vytváření instancí "
"pomocí výchozího konstruktoru, pro kopírovací konstruktor a pro destruktor."

#: C/gtkmm-tutorial-in.xml:9088(function)
msgid ""
"_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, "
"free function )"
msgstr ""
"_CLASS_OPAQUE_COPYABLE( C++ class, C class, new function, copy function, "
"free function )"

#: C/gtkmm-tutorial-in.xml:9090(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)\n"
msgstr ""
"\n"
"_CLASS_OPAQUE_COPYABLE(Checksum, GChecksum, NONE, g_checksum_copy, g_checksum_free)\n"

#: C/gtkmm-tutorial-in.xml:9089(para)
msgid ""
"For instance, from <classname>Glib::Checksum</classname>: <placeholder-1/>"
msgstr "Příklad z <classname>Glib::Checksum</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9097(title)
msgid "_CLASS_OPAQUE_REFCOUNTED"
msgstr "_CLASS_OPAQUE_REFCOUNTED"

#: C/gtkmm-tutorial-in.xml:9098(para)
msgid ""
"This macro declares a wrapper for a reference-counted opaque struct. The C++ "
"wrapper cannot be directly instantiated and can only be used with "
"<classname>Glib::RefPtr</classname>."
msgstr ""
"Toto makro deklaruje obalení pro neprůhlednou strukturu s počítáním "
"referencí. Pro obalení v C++ nelze přímo vytvářet instance a lze je použít "
"jen pomocí <classname>Glib::RefPtr</classname>."

#: C/gtkmm-tutorial-in.xml:9101(function)
msgid ""
"_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function, "
"unref function )"
msgstr ""
"_CLASS_OPAQUE_REFCOUNTED( C++ class, C class, new function, ref function, "
"unref function )"

#: C/gtkmm-tutorial-in.xml:9103(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)\n"
msgstr ""
"\n"
"_CLASS_OPAQUE_REFCOUNTED(Coverage, PangoCoverage, pango_coverage_new, pango_coverage_ref, pango_coverage_unref)\n"

#: C/gtkmm-tutorial-in.xml:9102(para)
msgid ""
"For instance, for <classname>Pango::Coverage</classname>: <placeholder-1/>"
msgstr "Například pro <classname>Pango::Coverage</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9110(title)
msgid "_CLASS_GENERIC"
msgstr "_CLASS_GENERIC"

#: C/gtkmm-tutorial-in.xml:9111(para)
msgid ""
"This macro can be used to wrap structs which don't fit into any specialized "
"category."
msgstr ""
"Toto makro se dá použít k obalení struktur, které nezapadají do žádné "
"speciální kategorie."

#: C/gtkmm-tutorial-in.xml:9113(function)
msgid "_CLASS_GENERIC( C++ class, C class )"
msgstr "_CLASS_GENERIC( C++ class, C class )"

#: C/gtkmm-tutorial-in.xml:9115(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_GENERIC(AttrIter, PangoAttrIterator)\n"
msgstr ""
"\n"
"_CLASS_GENERIC(AttrIter, PangoAttrIterator)\n"

#: C/gtkmm-tutorial-in.xml:9114(para)
msgid ""
"For instance, for <classname>Pango::AttrIter</classname>: <placeholder-1/>"
msgstr "Například pro <classname>Pango::AttrIter</classname>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9122(title)
msgid "_CLASS_INTERFACE"
msgstr "_CLASS_INTERFACE"

#: C/gtkmm-tutorial-in.xml:9123(para)
msgid ""
"This macro declares a wrapper for a type that is derived from "
"<classname>GTypeInterface</classname>."
msgstr ""
"Toto makro deklaruje obalení pro typ, který je odvozený z "
"<classname>GTypeInterface</classname>."

#: C/gtkmm-tutorial-in.xml:9126(function)
msgid ""
"_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, "
"Base C++ class (optional), Base C class (optional) )"
msgstr ""
"_CLASS_INTERFACE( C++ class, C class, C casting macro, C interface struct, "
"Base C++ class (optional), Base C class (optional) )"

#: C/gtkmm-tutorial-in.xml:9129(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)\n"
msgstr ""
"\n"
"_CLASS_INTERFACE(CellEditable, GtkCellEditable, GTK_CELL_EDITABLE, GtkCellEditableIface)\n"

#: C/gtkmm-tutorial-in.xml:9127(para)
msgid ""
"For instance, from <filename>celleditable.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>celleditable.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9136(programlisting)
#, no-wrap
msgid ""
"\n"
"_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)\n"
msgstr ""
"\n"
"_CLASS_INTERFACE(LoadableIcon, GLoadableIcon, G_LOADABLE_ICON, GLoadableIconIface, Icon, GIcon)\n"

#: C/gtkmm-tutorial-in.xml:9133(para)
msgid ""
"Two extra parameters are optional, for the case that the interface derives "
"from another interface, which should be the case when the GInterface has "
"another GInterface as a prerequisite. For instance, from "
"<filename>loadableicon.hg</filename>: <placeholder-1/>"
msgstr ""
"Dva doplňující parametry jsou volitelné, pro případ kdy je rozhraní odvozeno "
"z jiného rozhraní, což by mělo být, když GInterface má jako předpoklad jiný "
"GInterface. Příklad z <filename>loadableicon.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9145(title)
msgid "Constructor macros"
msgstr "Makra pro konstruktory"

#: C/gtkmm-tutorial-in.xml:9146(para)
msgid ""
"The <function>_CTOR_DEFAULT()</function> and <function>_WRAP_CTOR()</"
"function> macros add constructors, wrapping the specified <function>*_new()</"
"function> C functions. These macros assume that the C object has properties "
"with the same names as the function parameters, as is usually the case, so "
"that it can supply the parameters directly to a <function>g_object_new()</"
"function> call. These constructors never actually call the "
"<function>*_new()</function> C functions, because gtkmm must actually "
"instantiate derived GTypes, and the <function>*_new()</function> C functions "
"are meant only as convenience functions for C programmers."
msgstr ""
"Makra <function>_CTOR_DEFAULT()</function> a <function>_WRAP_CTOR()</"
"function> přidávají konstruktory pomocí obalení určených funkcí "
"<function>*_new()</function> v C. Tato makra předpokládají, že objekt C má "
"vlastnosti se stejnými názvy, jako jsou parametry funkce, což tak obvykle "
"je, takže se mohou parametry přímo předat do volání "
"<function>g_object_new()</function>. Tyto konstruktory ve skutečnosti nikdy "
"nevolají funkce <function>*_new()</function> v C, protože gtkmm musí ve "
"skutečnosti vytvořit instance odvozených typů GType a funkce "
"<function>*_new()</function> v C jsou zamýšlené jen pro pohodlí programátorů "
"v jazyce C."

#: C/gtkmm-tutorial-in.xml:9161(programlisting)
#, no-wrap
msgid ""
"\n"
"class TextMark : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)\n"
"\n"
"protected:\n"
"  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)\n"
"\n"
"public:\n"
"  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)\n"
msgstr ""
"\n"
"class TextMark : public Glib::Object\n"
"{\n"
"  _CLASS_GOBJECT(TextMark, GtkTextMark, GTK_TEXT_MARK, Glib::Object, GObject)\n"
"\n"
"protected:\n"
"  _WRAP_CTOR(TextMark(const Glib::ustring&amp; name, bool left_gravity = true), gtk_text_mark_new)\n"
"\n"
"public:\n"
"  _WRAP_CREATE(const Glib::ustring&amp; name, bool left_gravity = true)\n"

#: C/gtkmm-tutorial-in.xml:9156(para)
msgid ""
"When using <function>_CLASS_GOBJECT()</function>, the constructors should be "
"protected (rather than public) and each constructor should have a "
"corresponding <function>_WRAP_CREATE()</function> in the public section. "
"This prevents the class from being instantiated without using a "
"<classname>RefPtr</classname>. For instance: <placeholder-1/>"
msgstr ""
"Při použití <function>_CLASS_GOBJECT()</function> by konstruktor měl být "
"chráněný (místo veřejný) a jednotlivé konstruktory by měly mít příslušná "
"makra <function>_WRAP_CREATE()</function> ve veřejné části. Tím se zabrání "
"vytváření instancí třídy bez použití <classname>RefPtr</classname>. "
"Například: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9176(para)
msgid "This macro creates a default constructor with no arguments."
msgstr "Toto makro vytváří výchozí konstruktor bez argumentů."

#: C/gtkmm-tutorial-in.xml:9181(title)
msgid "_WRAP_CTOR"
msgstr "_WRAP_CTOR"

#: C/gtkmm-tutorial-in.xml:9182(para)
msgid ""
"This macro creates a constructor with arguments, equivalent to a "
"<function>*_new()</function> C function. It won't actually call the "
"<function>*_new()</function> function, but will simply create an equivalent "
"constructor with the same argument types. It takes a C++ constructor "
"signature, and a C function name."
msgstr ""
"Toto makro vytvoří konstruktor s argumenty ekvivalentní funkci "
"<function>*_new()</function> v C. Ve skutečnosti se nebude volat funkce "
"<function>*_new()</function>, ale jednoduše vytvoří ekvivalentní konstruktor "
"se stejnými typy argumentů. Vyžadována je hlavička konstruktoru v C++ a "
"název funkce v C."

#: C/gtkmm-tutorial-in.xml:9192(term) C/gtkmm-tutorial-in.xml:9251(term)
#: C/gtkmm-tutorial-in.xml:9487(term)
msgid "errthrow"
msgstr "errthrow"

#: C/gtkmm-tutorial-in.xml:9194(para)
msgid ""
"This tells gmmproc that the C <function>*_new()</function> has a final "
"GError** parameter which should be ignored."
msgstr ""
"Tímto se říká <command>gmmproc</command>, že <function>*_new()</function> v "
"C má poslední parametr GError**, který by se měl ignorovat."

#: C/gtkmm-tutorial-in.xml:9189(para)
msgid "It also takes an optional extra argument: <placeholder-1/>"
msgstr "Navíc přebírá dodatečný volitelný argument: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9203(title)
msgid "Hand-coding constructors"
msgstr "Ruční psaní konstruktorů"

#: C/gtkmm-tutorial-in.xml:9212(programlisting)
#, no-wrap
msgid ""
"\n"
"Button::Button(const Glib::ustring&amp; label, bool mnemonic)\n"
":\n"
"  _CONSTRUCT(\"label\", label.c_str(), \"use_underline\", gboolean(mnemonic))\n"
"{}\n"
msgstr ""
"\n"
"Button::Button(const Glib::ustring&amp; label, bool mnemonic)\n"
":\n"
"  _CONSTRUCT(\"label\", label.c_str(), \"use_underline\", gboolean(mnemonic))\n"
"{}\n"

#: C/gtkmm-tutorial-in.xml:9204(para)
msgid ""
"When a constructor must be partly hand written because, for instance, the "
"<function>*_new()</function> C function's parameters do not correspond "
"directly to object properties, or because the <function>*_new()</function> C "
"function does more than call <function>g_object_new()</function>, the "
"<function>_CONSTRUCT()</function> macro may be used in the .ccg file to save "
"some work. The <function>_CONSTRUCT</function> macro takes a series of "
"property names and values. For instance, from <filename>button.ccg</"
"filename>: <placeholder-1/>"
msgstr ""
"Pokud musí být konstruktor částečně napsán ručně, protože například "
"parametry funkce <function>*_new()</function> v C neodpovídají přímo "
"vlastnostem objektu, nebo protože funkce <function>*_new()</function> v C "
"toho dělá více, než že jen zavolá <function>g_object_new()</function>, pak "
"se může pro ušetření práce použít v souboru <filename>.ccg</filename> makro "
"<function>_CONSTRUCT()</function>. To vyžaduje sérii názvů vlastností a "
"hodnoty. Příklad z <filename>button.ccg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9224(title)
msgid "Method macros"
msgstr "Makra pro metody"

#: C/gtkmm-tutorial-in.xml:9227(title)
msgid "_WRAP_METHOD"
msgstr "_WRAP_METHOD"

#: C/gtkmm-tutorial-in.xml:9228(para)
msgid "This macro generates the C++ method to wrap a C function."
msgstr "Toto makro generuje metodu v C++ pro obalení funkce v C."

#: C/gtkmm-tutorial-in.xml:9229(function)
msgid "_WRAP_METHOD( C++ method signature, C function name)"
msgstr "_WRAP_METHOD( C++ method signature, C function name)"

#: C/gtkmm-tutorial-in.xml:9231(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)\n"
msgstr ""
"\n"
"_WRAP_METHOD(void set_text(const Glib::ustring&amp; text), gtk_entry_set_text)\n"

#: C/gtkmm-tutorial-in.xml:9230(para)
msgid "For instance, from <filename>entry.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>entry.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9235(para)
msgid ""
"The C function (e.g. <function>gtk_entry_set_text</function>) is described "
"more fully in the .defs file, and the <filename>convert*.m4</filename> files "
"contain the necessary conversion from the C++ parameter type to the C "
"parameter type. This macro also generates doxygen documentation comments "
"based on the <filename>*_docs.xml</filename> and <filename>*_docs_override."
"xml</filename> files."
msgstr ""
"Funkce v C (např. <function>gtk_entry_set_text</function>) je více popsaná v "
"souboru <filename>.defs</filename> a soubory <filename>convert*.m4</"
"filename> obsahují nutné převody z typů parametrů v C++ na typy parametrů v "
"C. Toto makro také generuje dokumentační komentáře Doxygen na základě "
"souborů <filename>*_docs.xml</filename> a <filename>*_docs_override.xml</"
"filename>."

#: C/gtkmm-tutorial-in.xml:9244(term) C/gtkmm-tutorial-in.xml:9423(term)
#: C/gtkmm-tutorial-in.xml:9470(term)
msgid "refreturn"
msgstr "refreturn"

#: C/gtkmm-tutorial-in.xml:9246(para)
msgid ""
"Do an extra <function>reference()</function> on the return value, in case "
"the C function does not provide a reference."
msgstr ""
"Provede pomocí <function>reference()</function> zvýšení počtu referencí na "
"návratové hodnotě v případě, že funkce v C neposkytuje reference."

#: C/gtkmm-tutorial-in.xml:9253(para)
msgid ""
"Use the last GError** parameter of the C function to throw an exception."
msgstr "Použijte poslední parametr GError** funkce v C k vyhození výjimky."

#: C/gtkmm-tutorial-in.xml:9258(term)
msgid "deprecated"
msgstr "deprecated"

#: C/gtkmm-tutorial-in.xml:9260(para)
msgid ""
"Puts the generated code in #ifdef blocks. Text about the deprecation can be "
"specified as an optional parameter."
msgstr ""
"Vloží vygenerovaný kód do bloků #ifdef. Jako volitelný parametr lze uvést "
"vysvětlující text o zavržení."

#: C/gtkmm-tutorial-in.xml:9266(term)
msgid "constversion"
msgstr "constversion"

#: C/gtkmm-tutorial-in.xml:9268(para)
msgid ""
"Just call the non-const version of the same function, instead of generating "
"almost duplicate code."
msgstr ""
"Prostě zavolá nekonstantní verzi té samé funkce, místo aby se generovalo "
"spousta duplicitního kódu."

#: C/gtkmm-tutorial-in.xml:9273(term) C/gtkmm-tutorial-in.xml:9431(term)
#: C/gtkmm-tutorial-in.xml:9509(term) C/gtkmm-tutorial-in.xml:9572(term)
msgid "ifdef"
msgstr "ifdef"

#: C/gtkmm-tutorial-in.xml:9275(para) C/gtkmm-tutorial-in.xml:9433(para)
#: C/gtkmm-tutorial-in.xml:9511(para) C/gtkmm-tutorial-in.xml:9574(para)
msgid "Puts the generated code in #ifdef blocks."
msgstr "Vloží vygenerovaný kód do bloků #ifdef."

#: C/gtkmm-tutorial-in.xml:9279(term) C/gtkmm-tutorial-in.xml:9515(term)
msgid "slot_name"
msgstr "slot_name"

#: C/gtkmm-tutorial-in.xml:9281(para) C/gtkmm-tutorial-in.xml:9517(para)
msgid ""
"Specifies the name of the slot parameter of the method, if it has one. This "
"enables <command>gmmproc</command> to generate code to copy the slot and "
"pass the copy on to the C function in its final <literal>gpointer user_data</"
"literal> parameter. The <literal>slot_callback</literal> option must also be "
"used to specify the name of the glue callback function to also pass on to "
"the C function."
msgstr ""
"Určuje název parametru slot v metodě, pokud existuje. Umožňuje to "
"<command>gmmproc</command> generovat kód pro kopírování slotu a předání "
"kopie do funkce v C v jejím posledním parametru <literal>gpointer user_data</"
"literal>. Musí být také použita volba <literal>slot_callback</literal> pro "
"určení názvu lepicí funkce zpětného volání, aby došlo k předání také do "
"funkce v C."

#: C/gtkmm-tutorial-in.xml:9291(term) C/gtkmm-tutorial-in.xml:9527(term)
msgid "slot_callback"
msgstr "slot_callback"

#: C/gtkmm-tutorial-in.xml:9293(para) C/gtkmm-tutorial-in.xml:9529(para)
msgid ""
"Used in conjunction with the <literal>slot_name</literal> option to specify "
"the name of the glue callback function that handles extracting the slot and "
"then calling it. The address of this callback is also passed on to the C "
"function that the method wraps."
msgstr ""
"Používá se ve spojení s volbou <literal>slot_name</literal> k určení názvu "
"lepicí funkce zpětného volání, která se stará o získání slotu a jeho "
"zavolání. Adresa tohoto zpětného volání je rovněž předaná do funkce C, "
"kterou metoda obaluje."

#: C/gtkmm-tutorial-in.xml:9301(term) C/gtkmm-tutorial-in.xml:9537(term)
msgid "no_slot_copy"
msgstr "no_slot_copy"

#: C/gtkmm-tutorial-in.xml:9303(para) C/gtkmm-tutorial-in.xml:9539(para)
msgid ""
"Tells <command>gmmproc</command> not to pass a copy of the slot to the C "
"function, if the method has one. Instead the slot itself is passed. The slot "
"parameter name and the glue callback function must have been specified with "
"the <literal>slot_name</literal> and <literal>slot_callbback</literal> "
"options respectively."
msgstr ""
"Říká <command>gmmproc</command> aby nepředával kopii slotu do funkce v C, "
"pokud metoda nějaké má. Místo slotu je předána sama funkce. Název parametru "
"se slotem a lepící funkce zpětného volání musí mít být zadány jako volby "
"<literal>slot_name</literal>, respektive <literal>slot_callback</literal>."

#: C/gtkmm-tutorial-in.xml:9241(para) C/gtkmm-tutorial-in.xml:9394(para)
#: C/gtkmm-tutorial-in.xml:9467(para)
msgid "There are some optional extra arguments: <placeholder-1/>"
msgstr "Je zde několik dalších volitelných argumentů: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9316(para)
msgid ""
"Objects used via <classname>RefPtr</classname>: Pass the <classname>RefPtr</"
"classname> as a const reference. For instance, <code>const Glib::RefPtr&lt;"
"Gtk::FileFilter&gt;&amp; filter</code>."
msgstr ""
"Objekty používané přes <classname>RefPtr</classname>: Předávejte "
"<classname>RefPtr</classname> jako konstantní referenci. Například "
"<code>const Glib::RefPtr&lt;Gtk::FileFilter&gt;&amp; filter</code>."

#: C/gtkmm-tutorial-in.xml:9320(para)
msgid ""
"Const Objects used via <classname>RefPtr</classname>: If the object should "
"not be changed by the function, then make sure that the object is const, "
"even if the <classname>RefPtr</classname> is already const. For instance, "
"<code>const Glib::RefPtr&lt;const Gtk::FileFilter&gt;&amp; filter</code>."
msgstr ""
"Konstantní objekty předávané přes <classname>RefPtr</classname>: Pokud nemá "
"být objekt měněn funkcí, zajistěte aby byl objekt konstantní, i když je již "
"konstantní <classname>RefPtr</classname>. Například <code>const Glib::"
"RefPtr&lt;const Gtk::FileFilter&gt;&amp; filter</code>."

#: C/gtkmm-tutorial-in.xml:9325(para)
msgid ""
"Wrapping <classname>GList*</classname> and <classname>GSList*</classname> "
"parameters: First, you need to discover what objects are contained in the "
"list's data field for each item, usually by reading the documentation for "
"the C function. The list can then be wrapped by a <classname>std::vector</"
"classname> type. For instance, <code>std::vector&lt; Glib::RefPtr&lt;Gdk::"
"Pixbuf&gt; &gt;</code>. You may need to define a Traits type to specify how "
"the C and C++ types should be converted."
msgstr ""
"Obaluje parametry<classname>GList*</classname> a <classname>GSList*</"
"classname>: Za prvé, potřebujete vyhledat, které objekty se nachází v "
"datových polích seznamu pro jednotlivé položky. Obvykle si k tomu stačí "
"přečíst dokumentaci pro funkci v C. Seznam je pak možné obalit typem "
"<classname>std::vector</classname>. Například <code>std::vector&lt; Glib::"
"RefPtr&lt;Gdk::Pixbuf&gt; &gt;</code>. Možná budete potřebovat definovat typ "
"Traits pro určení, jak se typy C a C++ mají převádět."

#: C/gtkmm-tutorial-in.xml:9342(programlisting)
#, no-wrap
msgid "#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')"
msgstr "#m4 _CONVERSION(`GSList*',`std::vector&lt;Widget*&gt;',`Glib::SListHandler&lt;Widget*&gt;::slist_to_vector($3, Glib::OWNERSHIP_SHALLOW)')"

#: C/gtkmm-tutorial-in.xml:9334(para)
msgid ""
"Wrapping <classname>GList*</classname> and <classname>GSList*</classname> "
"return types: You must discover whether the caller should free the list and "
"whether it should release the items in the list, again by reading the "
"documentation of the C function. With this information you can choose the "
"ownership (none, shallow or deep) for the m4 conversion rule, which you "
"should probably put directly into the .hg file because the ownership depends "
"on the function rather than the type. For instance: <placeholder-1/>"
msgstr ""
"Obalení návratových typů <classname>GList*</classname> a <classname>GSList*</"
"classname>: Musíte vyhledat, jestli má volající seznam uvolnit a jestli má "
"uvolnit položky v seznamu. Opět k tomu stačí přečíst si dokumentaci funkce v "
"C. S touto informací můžete zvolit vlastnictví (žádné, mělké nebo hluboké) "
"pro převodní pravidlo m4, které byste pravděpodobně měli vložit přímo do "
"souboru <filename>.hg</filename>, protože vlastnictví závisí spíše na "
"funkci, než na typu. Například: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9312(para)
msgid ""
"Selecting which C++ types should be used is also important when wrapping C "
"API. Though it's usually obvious what C++ types should be used in the C++ "
"method, here are some hints: <placeholder-1/>"
msgstr ""
"Výběr typů C++, které by se měli použít, je důležitý také při obalování API "
"C. Ačkoliv je většinou zřejmé, jaké typy C++ by se měly použít v metodě C++, "
"máme pro vás pár rad: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9348(title)
msgid "_WRAP_METHOD_DOCS_ONLY"
msgstr "_WRAP_METHOD_DOCS_ONLY"

#: C/gtkmm-tutorial-in.xml:9349(para)
msgid ""
"This macro is like <function>_WRAP_METHOD()</function>, but it generates "
"only the documentation for a C++ method that wraps a C function. Use this "
"when you must hand-code the method, but you want to use the documentation "
"that would be generated if the method was generated."
msgstr ""
"Toto makro je podobné jako <function>_WRAP_METHOD()</function>, ale generuje "
"jen dokumentaci pro metodu v C++, která obaluje funkci v C. Použijte v "
"situaci, kdy musíte ručně napsat metodu, ale chcete použít dokumentaci, "
"která by byla vygenerovaná, kdyby se generovala metoda."

#: C/gtkmm-tutorial-in.xml:9353(function)
msgid "_WRAP_METHOD_DOCS_ONLY(C function name)"
msgstr "_WRAP_METHOD_DOCS_ONLY(C function name)"

#: C/gtkmm-tutorial-in.xml:9355(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)\n"
msgstr ""
"\n"
"_WRAP_METHOD_DOCS_ONLY(gtk_container_remove)\n"

#: C/gtkmm-tutorial-in.xml:9354(para)
msgid "For instance, from <filename>container.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>container.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9362(title)
msgid "_IGNORE / _IGNORE_SIGNAL"
msgstr "_IGNORE / _IGNORE_SIGNAL"

#: C/gtkmm-tutorial-in.xml:9363(para)
msgid ""
"<command>gmmproc</command> will warn you on stdout about functions and "
"signals that you have forgotten to wrap, helping to ensure that you are "
"wrapping the complete API. But if you don't want to wrap some functions or "
"signals, or if you chose to hand-code some methods then you can use the "
"_IGNORE() or _IGNORE_SIGNAL() macro to make <command>gmmproc</command> stop "
"complaining."
msgstr ""
"<command>gmmproc</command> vás bude na standardním výstupu varovat o "
"funkcích a signálech, které jste zapomněli obalit, a pomůže vám tím zajistit "
"obalení celého API. Pokud ale některé funkce nebo signály obalit nechcete, "
"nebo když zvolíte ruční napsaní některých metod, můžete použít makro "
"<function>_IGNORE()</function> nebo <function>_IGNORE_SIGNAL()</function>, "
"abyste zastavili stížnosti <command>gmmproc</command>."

#: C/gtkmm-tutorial-in.xml:9368(function)
msgid "_IGNORE(C function name 1, C function name2, etc)"
msgstr "_IGNORE(C function name 1, C function name2, etc)"

#: C/gtkmm-tutorial-in.xml:9369(function)
msgid "_IGNORE_SIGNAL(C signal name 1, C signal name2, etc)"
msgstr "_IGNORE_SIGNAL(C signal name 1, C signal name2, etc)"

#: C/gtkmm-tutorial-in.xml:9371(programlisting)
#, no-wrap
msgid ""
"\n"
"_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing)\n"
msgstr ""
"\n"
"_IGNORE(gtk_button_box_set_spacing, gtk_button_box_get_spacing)\n"

#: C/gtkmm-tutorial-in.xml:9370(para)
msgid "For instance, from <filename>buttonbox.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>buttonbox.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9378(title)
msgid "_WRAP_SIGNAL"
msgstr "_WRAP_SIGNAL"

#: C/gtkmm-tutorial-in.xml:9379(para)
msgid ""
"This macro generates the C++ libsigc++-style signal to wrap a C GObject "
"signal. It actually generates a public accessor method, such as "
"<function>signal_clicked()</function>, which returns a proxy object. "
"<command>gmmproc</command> uses the .defs file to discover the C parameter "
"types and the .m4 convert files to discover appropriate type conversions."
msgstr ""
"Toto makro generuje signál v C++ ve stylu libsigc++ pro obalení signálu "
"objektu GObject v C. Ve skutečnosti generuje veřejně přístupnou metodu, jako "
"je <function>signal_clicked()</function>, která vrací zástupný objekt. "
"<command>gmmproc</command> používá soubor <filename>.defs</filename> k "
"vyhledání typů parametrů C a převodní soubory <filename>.m4</filename> k "
"vyhledání příslušných typů převodů."

#: C/gtkmm-tutorial-in.xml:9385(function)
msgid "_WRAP_SIGNAL( C++ signal handler signature, C signal name)"
msgstr "_WRAP_SIGNAL( C++ signal handler signature, C signal name)"

#: C/gtkmm-tutorial-in.xml:9387(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_SIGNAL(void clicked(),\"clicked\")\n"
msgstr ""
"\n"
"_WRAP_SIGNAL(void clicked(),\"clicked\")\n"

#: C/gtkmm-tutorial-in.xml:9391(para)
msgid ""
"Signals usually have function pointers in the GTK struct, with a "
"corresponding enum value and a <function>g_signal_new()</function> in the .c "
"file."
msgstr ""
"Signály obvykle mají ve struktuře GTK ukazatel na funkci s příslušnou "
"výčtovou hodnotou a <function>g_signal_new()</function> v souboru <filename>."
"c</filename>."

#: C/gtkmm-tutorial-in.xml:9397(term)
msgid "no_default_handler"
msgstr "no_default_handler"

#: C/gtkmm-tutorial-in.xml:9399(para)
msgid ""
"Do not generate an <function>on_something()</function> virtual method to "
"allow easy overriding of the default signal handler. Use this when adding a "
"signal with a default signal handler would break the ABI by increasing the "
"size of the class's virtual function table."
msgstr ""
"Negenerovat virtuální metodu <function>on_neco()</function>, která umožňuje "
"snadné přepsání výchozí obsluhy signálu. Použijte, když by přidání signál s "
"výchozí obsluhou signálu rozbilo ABI zvýšením velikosti tabulky virtuálních "
"funkcí pro třídu."

#: C/gtkmm-tutorial-in.xml:9407(term)
msgid "custom_default_handler"
msgstr "custom_default_handler"

#: C/gtkmm-tutorial-in.xml:9409(para)
msgid ""
"Generate a declaration of the <function>on_something()</function> virtual "
"method in the <filename>.h</filename> file, but do not generate a definition "
"in the <filename>.cc</filename> file. Use this when you must generate the "
"definition by hand."
msgstr ""
"Generovat deklaraci virtuální metody <function>on_neco()</function> v "
"souboru <filename>.h</filename>, ale negenerovat definici v souboru "
"<filename>.cc</filename>. Použijte, když musíte generovat definici ručně."

#: C/gtkmm-tutorial-in.xml:9416(term)
msgid "custom_c_callback"
msgstr "custom_c_callback"

#: C/gtkmm-tutorial-in.xml:9418(para)
msgid ""
"Do not generate a C callback function for the signal. Use this when you must "
"generate the callback function by hand."
msgstr ""
"Negenerovat funkce zpětného volání v C pro signál. Použijte to, když musíte "
"vygenerovat funkci zpětného volání ručně."

#: C/gtkmm-tutorial-in.xml:9425(para)
msgid ""
"Do an extra <function>reference()</function> on the return value of the "
"<function>on_something()</function> virtual method, in case the C function "
"does not provide a reference."
msgstr ""
"Provede pomocí <function>reference()</function> dodatečné zvýšení počitadla "
"referencí u návratové hodnoty z virtuální metody <function>on_neco()</"
"function> v případě, že funkce v C neposkytuje reference."

#: C/gtkmm-tutorial-in.xml:9441(title)
msgid "_WRAP_PROPERTY"
msgstr "_WRAP_PROPERTY"

#: C/gtkmm-tutorial-in.xml:9442(para)
msgid ""
"This macro generates the C++ method to wrap a C GObject property. You must "
"specify the property name and the wanted C++ type for the property. "
"<command>gmmproc</command> uses the .defs file to discover the C type and "
"the .m4 convert files to discover appropriate type conversions."
msgstr ""
"Toto makro generuje metodu C++ pro obalení vlastnosti objektu GObject v C. "
"Musíte správně uvést název vlastnosti a typ C++, který chcete. "
"<command>gmmproc</command> používá soubor <filename>.defs</filename> k "
"vyhledání typu C a převodní soubory <filename>.m4</filename> k vyhledání "
"příslušného typu převodů."

#: C/gtkmm-tutorial-in.xml:9446(function)
msgid "_WRAP_PROPERTY(C property name, C++ type)"
msgstr "_WRAP_PROPERTY(C property name, C++ type)"

#: C/gtkmm-tutorial-in.xml:9448(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_PROPERTY(\"label\", Glib::ustring)\n"
msgstr ""
"\n"
"_WRAP_PROPERTY(\"label\", Glib::ustring)\n"

#: C/gtkmm-tutorial-in.xml:9455(title)
msgid "_WRAP_VFUNC"
msgstr "_WRAP_VFUNC"

#: C/gtkmm-tutorial-in.xml:9456(para)
msgid "This macro generates the C++ method to wrap a virtual C function."
msgstr "Toto makro generuje metodu v C++ pro obalení virtuální funkce v C."

#: C/gtkmm-tutorial-in.xml:9457(function)
msgid "_WRAP_VFUNC( C++ method signature, C function name)"
msgstr "_WRAP_VFUNC( C++ method signature, C function name)"

#: C/gtkmm-tutorial-in.xml:9459(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)\n"
msgstr ""
"\n"
"_WRAP_VFUNC(SizeRequestMode get_request_mode() const, get_request_mode)\n"

#: C/gtkmm-tutorial-in.xml:9458(para)
msgid "For instance, from <filename>widget.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>widget.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9463(para)
msgid ""
"The C function (e.g. <function>get_request_mode</function>) is described "
"more fully in the <filename>*_vfuncs.defs</filename> file, and the "
"<filename>convert*.m4</filename> files contain the necessary conversion from "
"the C++ parameter type to the C parameter type."
msgstr ""
"Funkce v C (např. <function>get_request_mode()</function>) je více popsaná v "
"souboru <filename>*_vfunc.defs</filename> a soubory <filename>convert*.m4</"
"filename> obsahují nutné převody z typu parametru v C++ na typ parametru v C."

#: C/gtkmm-tutorial-in.xml:9472(para)
msgid ""
"Do an extra <function>reference()</function> on the return value of the "
"<function>something_vfunc()</function> function, in case the virtual C "
"function does not provide a reference."
msgstr ""
"V případě, že virtuální funkce v C neposkytuje reference, proveďte dodatečné "
"zvýšení počitadla referencí pomocí <function>reference()</function> u "
"návratové hodnoty funkce <function>neco_vfunc()</function>."

#: C/gtkmm-tutorial-in.xml:9478(term)
msgid "refreturn_ctype"
msgstr "refreturn_ctype"

#: C/gtkmm-tutorial-in.xml:9480(para)
msgid ""
"Do an extra <function>reference()</function> on the return value of an "
"overridden <function>something_vfunc()</function> function in the C callback "
"function, in case the calling C function expects it to provide a reference."
msgstr ""
"V případě, že volání funkce v C očekává, že mu bude poskytnuta reference, "
"proveďte dodatečné zvýšení počitadla referencí pomocí <function>reference()</"
"function> u návratové hodnoty přepsané funkce <function>neco_vfunc()</"
"function> ve funkci zpětného volání v C."

#: C/gtkmm-tutorial-in.xml:9489(para)
msgid ""
"Use the last GError** parameter of the C virtual function (if there is one) "
"to throw an exception."
msgstr ""
"Použijte poslední parametr GError** virtuální funkce v C (pokud existuje) k "
"vyhození výjimky."

#: C/gtkmm-tutorial-in.xml:9494(term)
msgid "custom_vfunc"
msgstr "custom_vfunc"

#: C/gtkmm-tutorial-in.xml:9496(para)
msgid ""
"Do not generate a definition of the vfunc in the <filename>.cc</filename> "
"file. Use this when you must generate the vfunc by hand."
msgstr ""
"Negenerujte definice virtuálních funkcí v souboru <filename>.cc</filename>. "
"Tohle použijte, když musíte generovat virtuální funkce ručně."

#: C/gtkmm-tutorial-in.xml:9502(term)
msgid "custom_vfunc_callback"
msgstr "custom_vfunc_callback"

#: C/gtkmm-tutorial-in.xml:9504(para)
msgid ""
"Do not generate a C callback function for the vfunc. Use this when you must "
"generate the callback function by hand."
msgstr ""
"Negenerujte funkce zpětných volání v C pro virtuální funkce. Tohle použijte, "
"když musíte generovat funkce zpětných volání ručně."

#: C/gtkmm-tutorial-in.xml:9548(para)
msgid ""
"A rule to which there may be exceptions: If the virtual C function returns a "
"pointer to an object derived from <classname>GObject</classname>, i.e. a "
"reference-counted object, then the virtual C++ function shall return a "
"<classname>Glib::RefPtr&lt;&gt;</classname> object. One of the extra "
"arguments <parameter>refreturn</parameter> or <parameter>refreturn_ctype</"
"parameter> is required."
msgstr ""
"Pravidlo, ze kterého mohou existovat výjimky: V případě, že virtuální funkce "
"v C vrací ukazatel na objekt odvozený z <classname>GObject</classname>, tj. "
"objekt s počítáním referencí, pak virtuální funkce v C++ vrátí objekt "
"<classname>Glib::RefPtr&lt;&gt;</classname>. Je vyžadován jeden z doplňující "
"argumentů <parameter>refreturn</parameter> nebo <parameter>refreturn_ctype</"
"parameter>."

#: C/gtkmm-tutorial-in.xml:9559(title)
msgid "Other macros"
msgstr "Ostatní makra"

#: C/gtkmm-tutorial-in.xml:9561(title)
msgid "_IMPLEMENTS_INTERFACE"
msgstr "_IMPLEMENTS_INTERFACE"

#: C/gtkmm-tutorial-in.xml:9562(para)
msgid "This macro generates initialization code for the interface."
msgstr "Toto makro generuje inicializační kód pro rozhraní."

#: C/gtkmm-tutorial-in.xml:9563(function)
msgid "_IMPLEMENTS_INTERFACE(C++ interface name)"
msgstr "_IMPLEMENTS_INTERFACE(C++ interface name)"

#: C/gtkmm-tutorial-in.xml:9565(programlisting)
#, no-wrap
msgid ""
"\n"
"_IMPLEMENTS_INTERFACE(Activatable)\n"
msgstr ""
"\n"
"_IMPLEMENTS_INTERFACE(Activatable)\n"

#: C/gtkmm-tutorial-in.xml:9569(para)
msgid "There is one optional extra argument: <placeholder-1/>"
msgstr "Existuje jeden další volitelný argument: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9582(title)
msgid "_WRAP_ENUM"
msgstr "_WRAP_ENUM"

#: C/gtkmm-tutorial-in.xml:9583(para)
msgid ""
"This macro generates a C++ enum to wrap a C enum. You must specify the "
"desired C++ name and the name of the underlying C enum."
msgstr ""
"Toto makro generuje výčet v C++ pro obalení výčtu v C. Musíte uvést "
"požadovaný název v C++ a název podkladového výčtu v C."

#: C/gtkmm-tutorial-in.xml:9586(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(WindowType, GtkWindowType)\n"
msgstr ""
"\n"
"_WRAP_ENUM(WindowType, GtkWindowType)\n"

#: C/gtkmm-tutorial-in.xml:9585(para)
msgid "For instance, from <filename>enums.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>enums.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9590(para)
msgid ""
"If the enum is not a <classname>GType</classname>, you must pass a third "
"parameter NO_GTYPE. This is the case when there is no "
"<function>*_get_type()</function> function for the C enum, but be careful "
"that you don't just need to include an extra header for that function. You "
"should also file a bug against the C API, because all enums should be "
"registered as GTypes."
msgstr ""
"Pokud výčet není <classname>GType</classname>, musíte předat třetí parametr "
"NO_GTYPE. To je případ, když neexistuje funkce <function>*_get_type()</"
"function> pro výčet v C, ale dávejte pozor, jestli jenom nepotřebujete "
"vložit další hlavičkový soubor pro onu funkci. Měli byste také vyplnit "
"chybové hlášení vůči API C, protože všechny výčtové typy by měli být "
"zaregistrované jako GType."

#: C/gtkmm-tutorial-in.xml:9595(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)\n"
msgstr ""
"\n"
"_WRAP_ENUM(IconLookupFlags, GtkIconLookupFlags, NO_GTYPE)\n"

#: C/gtkmm-tutorial-in.xml:9594(para)
msgid "For example, from <filename>icontheme.hg</filename>: <placeholder-1/>"
msgstr "Například z <filename>icontheme.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9602(title)
msgid "_WRAP_ENUM_DOCS_ONLY"
msgstr "_WRAP_ENUM_DOCS_ONLY"

#: C/gtkmm-tutorial-in.xml:9603(para)
msgid ""
"This macro just generates a Doxygen documentationn block for the enum. This "
"is useful for enums that can't be wrapped with <function>_WRAP_ENUM()</"
"function> because they are complexly defined (maybe using C macros) but "
"including the generated enum documentation is still desired. It is used with "
"the same syntax as <function>_WRAP_ENUM()</function> and also process the "
"same options (though NO_GTYPE is just ignored because it makes no difference "
"when just generating the enum's documentation)."
msgstr ""
"Toto makro jen vygeneruje pro výčet blok s dokumentací Doxygen. To se hodí "
"pro výčty, které nemohou být obalené pomocí <function>_WRAP_ENUM()</"
"function>, protože jsou definované komplexně (možná pomocí maker v C), ale "
"přejete si, aby vygenerovaná dokumentace k výčtu byl součástí. Používá se se "
"stejnou syntaxí, jako <function>_WRAP_ENUM()</function> a zpracovává ty samé "
"volby (a však NO_GTYPE je jednoduše ignorováno, protože nezpůsobuje žádný "
"rozdíl, když se generuje dokumentace k výčtu)."

#: C/gtkmm-tutorial-in.xml:9615(title)
msgid "_WRAP_GERROR"
msgstr "_WRAP_GERROR"

#: C/gtkmm-tutorial-in.xml:9616(para)
msgid ""
"This macro generates a C++ exception class, derived from Glib::Error, with a "
"Code enum and a code() method. You must specify the desired C++ name, the "
"name of the corresponding C enum, and the prefix for the C enum values."
msgstr ""
"Toto makro generuje třídu výjimky v C++ odvozenou z Glib::Error, s výčtem "
"Code a metodou code(). Musíte uvést požadovaný název v C++, název "
"příslušného výčtu v C a prefix pro hodnoty výčtu v C."

#: C/gtkmm-tutorial-in.xml:9619(para)
msgid ""
"This exception can then be thrown by methods which are generated from "
"_WRAP_METHOD() with the errthrow option."
msgstr ""
"Tato výjimka může být vyhozená metodou, která je vygenerovaná pomocí "
"_WRAP_METOD() s volbou errthrow."

#: C/gtkmm-tutorial-in.xml:9621(programlisting)
#, no-wrap
msgid ""
"\n"
"_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)\n"
msgstr ""
"\n"
"_WRAP_GERROR(PixbufError, GdkPixbufError, GDK_PIXBUF_ERROR)\n"

#: C/gtkmm-tutorial-in.xml:9620(para)
msgid "For instance, from <filename>pixbuf.hg</filename>: <placeholder-1/>"
msgstr "Příklad z <filename>pixbuf.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9628(title)
msgid "_MEMBER_GET / _MEMBER_SET"
msgstr "_MEMBER_GET / _MEMBER_SET"

#: C/gtkmm-tutorial-in.xml:9629(para)
msgid ""
"Use these macros if you're wrapping a simple struct or boxed type that "
"provides direct access to its data members, to create getters and setters "
"for the data members."
msgstr ""
"Tato makra použijte, když obalujete jednoduchou strukturu nebo boxovyný typ, "
"který poskytuje přímý přístup ke svým datovým členům, aby se vytvořily "
"funkce pro získávání a nastavování datových členů."

#: C/gtkmm-tutorial-in.xml:9633(function)
msgid "_MEMBER_GET(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_GET(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9634(function)
msgid "_MEMBER_SET(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_SET(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9637(programlisting)
#, no-wrap
msgid "_MEMBER_GET(x, x, int, int)"
msgstr "_MEMBER_GET(x, x, int, int)"

#: C/gtkmm-tutorial-in.xml:9635(para)
msgid "For example, in <filename>rectangle.hg</filename>: <placeholder-1/>"
msgstr "Například v <filename>rectangle.hg</filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9641(title)
msgid "_MEMBER_GET_PTR / _MEMBER_SET_PTR"
msgstr "_MEMBER_GET_PTR / _MEMBER_SET_PTR"

#: C/gtkmm-tutorial-in.xml:9642(para)
msgid ""
"Use these macros to automatically provide getters and setters for a data "
"member that is a pointer type. For the getter function, it will create two "
"methods, one const and one non-const."
msgstr ""
"Tato makra použijte k poskytnutí funkcí pro získávání a nastavování datového "
"člena, který je typu ukazatel. Pro funkci na získávání to vytvoří dvě "
"metody, jednu konstantní a jednu nekonstantní."

#: C/gtkmm-tutorial-in.xml:9647(function)
msgid "_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_GET_PTR(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9648(function)
msgid "_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_SET_PTR(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9650(programlisting)
#, no-wrap
msgid ""
"\n"
"// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)\n"
"// It's just a comment. It's difficult to find a real-world example.\n"
msgstr ""
"\n"
"// _MEMBER_GET_PTR(engine_lang, lang_engine, EngineLang*, PangoEngineLang*)\n"
"// Je to jen komentáře. Je těžké najít skutečný příklad ze života.\n"

#: C/gtkmm-tutorial-in.xml:9649(para)
msgid ""
"For example, for <classname>Pango::Analysis</classname> in <filename>item."
"hg</filename>: <placeholder-1/>"
msgstr ""
"Například pro <classname>Pango::Analysis</classname> v <filename>item.hg</"
"filename>: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9657(title)
msgid "_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT"
msgstr "_MEMBER_GET_GOBJECT / _MEMBER_SET_GOBJECT"

#: C/gtkmm-tutorial-in.xml:9658(para)
msgid ""
"Use these macros to provide getters and setters for a data member that is a "
"<classname>GObject</classname> type that must be referenced before being "
"returned."
msgstr ""
"Tato makra použijte k poskytnutí funkcí pro získávání a nastavování datového "
"člena typu <classname>GObject</classname>, u kterého musí být před jeho "
"vrácením zvýšeno počitadlo referencí."

#: C/gtkmm-tutorial-in.xml:9663(function)
msgid "_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_GET_GOBJECT(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9664(function)
msgid "_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)"
msgstr "_MEMBER_SET_GOBJECT(C++ name, C name, C++ type, C type)"

#: C/gtkmm-tutorial-in.xml:9666(programlisting)
#, no-wrap
msgid ""
"\n"
"_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)\n"
msgstr ""
"\n"
"_MEMBER_GET_GOBJECT(layout, layout, Pango::Layout, PangoLayout*)\n"

#: C/gtkmm-tutorial-in.xml:9665(para)
msgid ""
"For example, in Pangomm, <filename>layoutline.hg</filename>: <placeholder-1/>"
msgstr ""
"Například v <filename>layoutline.hg</filename> z Pangomm: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9674(title)
msgid "gmmproc Parameter Processing"
msgstr "Zpracování parametrů gmmproc"

#: C/gtkmm-tutorial-in.xml:9675(para)
msgid ""
"<command>gmmproc</command> allows processing the parameters in a method "
"signature for the macros that process method signatures (like "
"<function>_WRAP_METHOD()</function>, <function>_WRAP_CTOR()</function> and "
"<function>_WRAP_CREATE()</function>) in a variety of ways:"
msgstr ""
"<command>gmmproc</command> umožňuje zpracování parametrů v hlavičkách metod "
"různým způsobem pro makra, které zpracovávají hlavičky metod (jako jsou "
"<function>_WRAP_METHOD()</function>, <function>_WRAP_CTOR()</function> and "
"<function>_WRAP_CREATE()</function>):"

#: C/gtkmm-tutorial-in.xml:9682(title)
msgid "Parameter Reordering"
msgstr "Změna pořadí parametrů"

#: C/gtkmm-tutorial-in.xml:9689(programlisting)
#, no-wrap
msgid ""
"\n"
"        void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,\n"
"        GdkEventMask events);\n"
"      "
msgstr ""
"\n"
"        void gtk_widget_set_device_events(GtkWidget* widget, GdkDevice* device,\n"
"        GdkEventMask events);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9696(programlisting)
#, no-wrap
msgid ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},\n"
"        const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),\n"
"        gtk_widget_set_device_events)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{events},\n"
"        const Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{device}),\n"
"        gtk_widget_set_device_events)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9706(programlisting)
#, no-wrap
msgid ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const\n"
"        Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),\n"
"        gtk_widget_set_device_events)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(void set_device_events(Gdk::EventMask events{.}, const\n"
"        Glib::RefPtr&lt;const Gdk::Device&gt;&amp; device{.}),\n"
"        gtk_widget_set_device_events)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9683(para)
msgid ""
"For all the macros that process method signatures, it is possible to specify "
"a different order for the C++ parameters than the existing order in the C "
"function, virtual function or signal. For example, say that the following C "
"function were being wrapped as a C++ method for the <classname>Gtk::Widget</"
"classname> class: <placeholder-1/> However, changing the order of the C++ "
"method's two parameters is necessary. Something like the following would "
"wrap the function as a C++ method with a different order for the two "
"parameters: <placeholder-2/> The <literal>{c_param_name}</literal> following "
"the method parameter names tells <command>gmmproc</command> to map the C++ "
"parameter to the specified C parameter within the <literal>{}</literal>. "
"Since the C++ parameter names correspond to the C ones, the above could be "
"re-written as: <placeholder-3/>"
msgstr ""
"Pro všechna makra, která zpracovávají hlavičky metod, je možné určit jiné "
"pořadí parametrů C++, než je stávající pořadí ve funkcích, virtuálních "
"funkcích nebo signálech v jazyce C. Například řekněme, že následující funkce "
"C byly obaleny jako metody v C++ pro třídu <classname>Gtk::Widget</"
"classname>: <placeholder-1/> Je však nutné změnit pořadí dvou parametrů "
"metody v C++. Nějak takto by se dala funkce obalit jako metoda v C++ s jiným "
"pořadím pro dva parametry: <placeholder-2/> <literal>{c_param_name}</"
"literal> následující za názvy parametrů metody říká <command>gmmproc</"
"command>, aby mapoval parametr v C++ na daný parametr v C uvedený v "
"<literal>{}</literal>. Vzhledem k tomu, že názvy parametrů v C++ odpovídají "
"těm v C, lze výše uvedené zapsat jako: <placeholder-3/>"

#: C/gtkmm-tutorial-in.xml:9713(para)
msgid ""
"Please note that when reordering parameters for a <function>_WRAP_SIGNAL()</"
"function> method signature, the C parameter names would always be "
"<literal>p0</literal>, <literal>p1</literal>, etc. because the "
"<filename>generate_extra_defs</filename> utility uses those parameter names "
"no matter what the C API's parameter names may be. It's how the utility is "
"written presently."
msgstr ""
"Pamatujte, že při změně pořadí parametrů pro hlavičku metody "
"<function>_WRAP_SIGNAL()</function>, budou názvy parametrů v C vždy "
"<literal>p0</literal>, <literal>p1</literal> atd., protože nástroj "
"<filename>generate_extrac_defs</filename> používá tyto názvy parametrů bez "
"ohledu na názvy parametrů v API C. Takto prostě zmíněný nástroj v "
"současnosti funguje."

#: C/gtkmm-tutorial-in.xml:9725(title)
msgid "Optional Parameter Processing"
msgstr "Zpracování volitelných parametrů"

#: C/gtkmm-tutorial-in.xml:9734(programlisting)
#, no-wrap
msgid ""
"\n"
"        GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar*\n"
"        label);\n"
"      "
msgstr ""
"\n"
"        GtkToolItem* gtk_tool_button_new(GtkWidget* icon_widget, const gchar*\n"
"        label);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9744(programlisting)
#, no-wrap
msgid ""
"\n"
"        _WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp;\n"
"        label{?}), gtk_tool_button_new)\n"
"      "
msgstr ""
"\n"
"        _WRAP_CTOR(ToolButton(Widget&amp; icon_widget, const Glib::ustring&amp;\n"
"        label{?}), gtk_tool_button_new)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9726(para)
msgid ""
"For all macros processing method signatures except <function>_WRAP_SIGNAL()</"
"function> and <function>_WRAP_VFUNC()</function> it is also possible to make "
"the parameters optional so that extra C++ methods are generated without the "
"specified optional parameter. For example, say that the following "
"<function>*_new()</function> function were being wrapped as a constructor in "
"the <classname>Gtk::ToolButton</classname> class: <placeholder-1/> Also, say "
"that the C API allowed NULL for the function's <parameter>label</parameter> "
"parameter so that that parameter is optional. It would be possible to have "
"<command>gmmproc</command> generate the original constructor (with all the "
"parameters) along with an additional constructor without that optional "
"parameter by appending a <literal>{?}</literal> to the parameter name like "
"so: <placeholder-2/> In this case, two constructors would be generated: One "
"with the optional parameter and one without it."
msgstr ""
"Pro všechna makra zpracovávající hlavičky metod, vyjma maker "
"<function>_WRAP_SIGNAL()</function> a <function>_WRAP_VFUNC()</function>, je "
"také možné určit parametry jako volitelné tak, že se vygenerují další metody "
"v C++ bez určených volitelných parametrů. Například řekněme, že následující "
"funkce <function>*_new()</function> byla obalena jako konstruktor v třídě "
"<classname>Gtk::ToolButton</classname>: <placeholder-1/> Navíc řekněme, že "
"API C umožňuje NULL pro parametr <parameter>label</parameter> v této funkci, "
"takže parametr může být volitelný. Pak by bylo možné přimět "
"<command>gmmproc</command> vygenerovat původní konstruktor (se všemi "
"parametry) souběžně s dalším konstruktorem bez volitelného parametru tak, že "
"k názvu parametru připojí <literal>{?}</literal>: <placeholder-2/> V takovém "
"situaci se vygenerují dva konstruktory: Jeden s volitelným parametrem a "
"jeden bez něj."

#: C/gtkmm-tutorial-in.xml:9754(title)
msgid "Output Parameter Processing"
msgstr "Zpracování výstupních parametrů"

#: C/gtkmm-tutorial-in.xml:9764(programlisting)
#, no-wrap
msgid ""
"\n"
"        GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);\n"
"      "
msgstr ""
"\n"
"        GtkSizeRequestMode gtk_widget_get_request_mode(GtkWidget* widget);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9770(programlisting)
#, no-wrap
msgid ""
"\n"
"        _WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT})\n"
"        const, gtk_widget_get_request_mode)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(void get_request_mode(SizeRequestMode&amp; mode{OUT})\n"
"        const, gtk_widget_get_request_mode)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9779(programlisting)
#, no-wrap
msgid ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        (SizeRequestMode)($4)')\n"
"      "
msgstr ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        (SizeRequestMode)($4)')\n"
"      "

#: C/gtkmm-tutorial-in.xml:9784(programlisting)
#, no-wrap
msgid ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        ($1)($4)')\n"
"      "
msgstr ""
"\n"
"        _INITIALIZATION(`SizeRequestMode&amp;',`GtkSizeRequestMode',`$3 =\n"
"        ($1)($4)')\n"
"      "

#: C/gtkmm-tutorial-in.xml:9755(para)
msgid ""
"With <function>_WRAP_METHOD()</function> it is also possible for the return "
"of the wrapped C function (if it has one) to be placed in an output "
"parameter of the C++ method instead of having the C++ method also return a "
"value like the C function does. To do that, simply include the output "
"parameter in the C++ method parameter list appending a <literal>{OUT}</"
"literal> to the output parameter name. For example, if "
"<function>gtk_widget_get_request_mode()</function> is declared as the "
"following: <placeholder-1/> And having the C++ method set an output "
"parameter is desired instead of returning a <type>SizeRequestMode</type>, "
"something like the following could be used: <placeholder-2/> The "
"<literal>{OUT}</literal> appended to the name of the <parameter>mode</"
"parameter> output parameter tells <command>gmmproc</command> to place the "
"return of the C function in that output parameter. In this case, however, a "
"necessary initialization macro like the following would also have to be "
"specified: <placeholder-3/> Which could also be written as: <placeholder-4/>"
msgstr ""
"Pomocí <function>_WRAP_METHOD()</function> je pro návratovou hodnotu obalené "
"funkce v C (pokud nějakou mát) také možné umístit ji do některého výstupního "
"parametru metody v C++, místo aby byla návratovou hodnotou metody v C++ "
"stejně jako u funkce v C. Když to chcete takto, stačí vložit výstupní "
"parametr do seznamu parametrů metody v C++ a přidat za jeho název "
"<literal>{OUT}</literal>. Například, když je "
"<function>gtk_widget_get_request_mode()</function> deklarována následovně: "
"<placeholder-1/> a máme metodu v C++, která nastavuje výstupní parametr, jak "
"je požadováno, místo aby vracela <type>SizeRequestMode</type>, mohli bychom "
"použít něco takového: <placeholder-2/> <literal>{OUT}</literal> připojené k "
"názvu výstupního parametru <parameter>mode</parameter> říká skriptu "
"<command>gmmproc</command>, aby umístil návratovou hodnotu funkce v C do "
"tohoto výstupního parametru. V tomto případě byla ale navíc nutné určit "
"inicializační makro: <placeholder-3/> Což by šlo zapsat i jako: "
"<placeholder-4/>"

#: C/gtkmm-tutorial-in.xml:9795(programlisting)
#, no-wrap
msgid ""
"\n"
"        gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,\n"
"        GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);\n"
"      "
msgstr ""
"\n"
"        gboolean gtk_icon_view_get_cell_rect(GtkIconView* icon_view,\n"
"        GtkTreePath* path, GtkCellRenderer* cell, GdkRectangle* rect);\n"
"      "

#: C/gtkmm-tutorial-in.xml:9802(programlisting)
#, no-wrap
msgid ""
"\n"
"        _WRAP_METHOD(bool get_cell_rect(const TreeModel::Path&amp; path, const\n"
"        CellRenderer&amp; cell, Gdk::Rectangle&amp; rect{&gt;&gt;}) const,\n"
"        gtk_icon_view_get_cell_rect)\n"
"      "
msgstr ""
"\n"
"        _WRAP_METHOD(bool get_cell_rect(const TreeModel::Path&amp; path, const\n"
"        CellRenderer&amp; cell, Gdk::Rectangle&amp; rect{&gt;&gt;}) const,\n"
"        gtk_icon_view_get_cell_rect)\n"
"      "

#: C/gtkmm-tutorial-in.xml:9817(programlisting)
#, no-wrap
msgid ""
"\n"
"        _INITIALIZATION(`Gdk::Rectangle&amp;',`GdkRectangle', `$3 =\n"
"        Glib::wrap(&amp;($4))')\n"
"      "
msgstr ""
"\n"
"        _INITIALIZATION(`Gdk::Rectangle&amp;',`GdkRectangle', `$3 =\n"
"        Glib::wrap(&amp;($4))')\n"
"      "

#: C/gtkmm-tutorial-in.xml:9789(para)
msgid ""
"<function>_WRAP_METHOD()</function> also supports setting C++ output "
"parameters from C output parameters if the C function being wrapped has any. "
"Suppose, for example, that we want to wrap the following C function that "
"returns a value in its C output parameter <parameter>rect</parameter>: "
"<placeholder-1/> To have <command>gmmproc</command> place the value returned "
"in the C++ <parameter>rect</parameter> output parameter, something like the "
"following <function>_WRAP_METHOD()</function> directive could be used: "
"<placeholder-2/> The <literal>{&gt;&gt;}</literal> following the "
"<parameter>rect</parameter> parameter name indicates that the C++ output "
"parameter should be set from the value returned in the C parameter from the "
"C function. <command>gmmproc</command> will generate a declaration of a "
"temporary variable in which to store the value of the C output parameter and "
"a statement that sets the C++ output parameter from the temporary variable. "
"In this case it may be necessary to have an <function>_INITIALIZATION()</"
"function> describing how to set a <classname>Gdk::Rectangle&amp;</classname> "
"from a <classname>GdkRectangle*</classname> such as the following: "
"<placeholder-3/>"
msgstr ""
"<function>_WRAP_METHOD()</function> podporuje také nastavení výstupních "
"parametrů v C++ z výstupních parametrů v C, pokud obalená funkce v C nějaké "
"má. Předpokládejme například, že chceme obalit následující funkci v C, která "
"vrací hodnotu v jejím výstupním parametru <parameter>rect</parameter>: "
"<placeholder-1/> Aby <command>gmmproc</command> umístil hodnotu vracenou ve "
"výstupním parametru <parameter>rect</parameter> v C++, můžete použít nějak "
"takto direktivu <function>_WRAP_METHOD()</function>: <placeholder-2/> "
"<literal>{&gt;&gt;}</literal> následující za názvem parametru "
"<parameter>rect</parameter> říká, že výstupní parametr v C++ by se měl "
"nastavit z hodnoty vracené v parametru v C z funkce v C. <command>gmmproc</"
"command> vygeneruje deklaraci dočasné proměnné, ve které se uchová hodnota "
"výstupního parametru v C a výraz, který nastaví výstupní parametr v C++ z "
"dočasné proměnné. V tomto případě může být nutné mít nějaké makro "
"<function>_INITIALIZATION()</function> popisující, jak nastavit "
"<classname>Gdk::Rectangle&amp;</classname> z <classname>GdkRectangle*</"
"classname>. Může vypadat třeba takto: <placeholder-3/>"

#: C/gtkmm-tutorial-in.xml:9827(title)
msgid "Basic Types"
msgstr "Základní typy"

#: C/gtkmm-tutorial-in.xml:9828(para)
msgid ""
"Some of the basic types that are used in C APIs have better alternatives in C"
"++. For example, there's no need for a <type>gboolean</type> type since C++ "
"has <type>bool</type>. The following list shows some commonly-used types in "
"C APIs and what you might convert them to in a C++ wrapper library."
msgstr ""
"Některé základní typy, které se používají v API v C mají lepší náhrady v C+"
"+. Například, není potřeba používat typ <type>gboolean</type>, protože C++ "
"má <type>bool</type>. Následující seznam uvádí některé běžně používané typy "
"v API v C a na co je můžete převést v obalující knihovně C++."

#: C/gtkmm-tutorial-in.xml:9833(title)
msgid "Basic Type equivalents"
msgstr "Rovnocenné základní typy"

#: C/gtkmm-tutorial-in.xml:9835(segtitle)
msgid "C type"
msgstr "Typ v C"

#: C/gtkmm-tutorial-in.xml:9836(segtitle)
msgid "C++ type"
msgstr "Typ v C++"

#: C/gtkmm-tutorial-in.xml:9837(type)
msgid "gboolean"
msgstr "gboolean"

#: C/gtkmm-tutorial-in.xml:9837(type)
msgid "bool"
msgstr "bool"

#: C/gtkmm-tutorial-in.xml:9838(type)
msgid "gint"
msgstr "gint"

#: C/gtkmm-tutorial-in.xml:9838(type)
msgid "int"
msgstr "int"

#: C/gtkmm-tutorial-in.xml:9839(type)
msgid "guint"
msgstr "guint"

#: C/gtkmm-tutorial-in.xml:9840(type)
msgid "gdouble"
msgstr "gdouble"

#: C/gtkmm-tutorial-in.xml:9840(type)
msgid "double"
msgstr "double"

#: C/gtkmm-tutorial-in.xml:9841(type)
msgid "gunichar"
msgstr "gunichar"

#: C/gtkmm-tutorial-in.xml:9842(type)
msgid "gchar*"
msgstr "gchar*"

#: C/gtkmm-tutorial-in.xml:9842(classname)
msgid "std::string"
msgstr "std::string"

#: C/gtkmm-tutorial-in.xml:9842(seg)
msgid "<placeholder-1/> (or <placeholder-2/> for filenames)"
msgstr "<placeholder-1/> (nebo <placeholder-2/> pro názvy souborů)"

#: C/gtkmm-tutorial-in.xml:9849(title)
msgid "Hand-coded source files"
msgstr "Ručně psané soubory se zdrojovými kódy"

#: C/gtkmm-tutorial-in.xml:9850(para)
msgid ""
"You might want to include additional source files that will not be generated "
"by <command>gmmproc</command> from <filename>.hg</filename> and <filename>."
"ccg</filename> files. You can simply place these in your "
"<filename>libsomething/libsomethingmm</filename> directory and mention them "
"in the <filename>Makefile.am</filename> in the <varname>files_extra_h</"
"varname> and <varname>files_extra_cc</varname> variables."
msgstr ""
"Můžete chtít vložit další zdrojové soubory, které se nebudou generovat "
"pomocí <command>gmmproc</command> ze souborů <filename>.hg</filename> a "
"<filename>ccg</filename>. Stačí je prostě umístit do vaší složky "
"<filename>libneco/libnecomm</filename> a uvést je v <filename>Makefile.am</"
"filename> v proměnných <varname>files_extra_h</varname> and "
"<varname>files_extra_cc</varname>."

#: C/gtkmm-tutorial-in.xml:9860(title)
msgid "Initialization"
msgstr "Inicializace"

#: C/gtkmm-tutorial-in.xml:9869(programlisting)
#, no-wrap
msgid ""
"\n"
"void init()\n"
"{\n"
"  Gtk::Main::init_gtkmm_internals(); //Sets up the g type system and the Glib::wrap() table.\n"
"  wrap_init(); //Tells the Glib::wrap() table about the libsomethingmm classes.\n"
"}\n"
msgstr ""
"\n"
"void init()\n"
"{\n"
"  Gtk::Main::init_gtkmm_internals(); // Nastavuje systém typů g_* a tabulku Glib::wrap()\n"
"  wrap_init(); // Říká tabulce Glib::wrap() o třídě libnecomm.\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:9861(para)
msgid ""
"Your library must be initialized before it can be used, to register the new "
"types that it makes available. Also, the C library that you are wrapping "
"might have its own initialization function that you should call. You can do "
"this in an <function>init()</function> function that you can place in hand-"
"coded <filename>init.h</filename> and <filename>init.cc</filename> files. "
"This function should initialize your dependencies (such as the C function, "
"and <application>gtkmm</application>) and call your generated "
"<function>wrap_init()</function> function. For instance: <placeholder-1/>"
msgstr ""
"Než můžete svoji knihovnu použít, je potřeba ji inicializovat, aby se "
"zaregistrovaly nové typy, které zpřístupňuje. Také knihovny v C, které "
"obalujete, mohou mít své vlastní inicializační funkce, které byste měli "
"zavolat. Můžete to udělat ve funkci <function>init()</function>, kterou "
"můžete umístit do ručně napsaných souborů <filename>init.h</filename> a "
"<filename>init.cc</filename>. Tato funkce by měla inicializovat vaše "
"závislosti (např. funkci v C a <application>gtkmm</application>) a zavolat "
"vaši vygenerovanou funkci <function>wrap_init()</function>. Například: "
"<placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9877(para)
msgid ""
"The implementation of the <function>wrap_init()</function> method in "
"<filename>wrap_init.cc</filename> is generated by "
"<filename>generate_wrap_init.pl</filename>, but the declaration in "
"<filename>wrap_init.h</filename> is hand-coded, so you will need to adjust "
"<filename>wrap_init.h</filename> so that the <function>wrap_init()</"
"function> function appears in the correct C++ namespace."
msgstr ""
"Implementace metody <function>wrap_init()</function> ve <filename>wrap_init."
"cc</filename> je generovaná skriptem <filename>generate_wrap_init.pl</"
"filename>, ale deklarace ve <filename>wrap_init.h</filename> je psaná ručně, "
"takže musíte upravit <filename>wrap_init.h</filename>, aby se funkce "
"<function>wrap_init()</function> vyskytovala ve správném jmenném prostoru C+"
"+."

#: C/gtkmm-tutorial-in.xml:9886(title)
msgid "Problems in the C API."
msgstr "Problémy v API v C"

#: C/gtkmm-tutorial-in.xml:9887(para)
msgid ""
"You are likely to encounter some problems in the library that you are "
"wrapping, particularly if it is a new project. Here are some common "
"problems, with solutions."
msgstr ""
"Nejspíše se setkáte s některými problémy v knihovně, kterou balíte, zejména "
"pokud jde o nový projekt. Zde jsou některé běžné problémy včetně řešení."

#: C/gtkmm-tutorial-in.xml:9889(title)
msgid "Unable to predeclare structs"
msgstr "Nejde předeklarovat struktury"

#: C/gtkmm-tutorial-in.xml:9891(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _ExampleWidget ExampleWidget;\n"
"\n"
"struct _ExampleWidget\n"
"{\n"
"  ...\n"
"};\n"
msgstr ""
"\n"
"typedef struct _ExampleWidget ExampleWidget;\n"
"\n"
"struct _ExampleWidget\n"
"{\n"
"  …\n"
"};\n"

#: C/gtkmm-tutorial-in.xml:9890(para)
msgid ""
"By convention, structs are declared in glib/GTK+-style headers like so: "
"<placeholder-1/>"
msgstr ""
"Podle konvencí se struktury deklarují v hlavičkových souborech ve stylu glib/"
"GTK+ takto: <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9900(para)
msgid ""
"The extra typedef allows the struct to be used in a header without including "
"its full definition, simply by predeclaring it, by repeating that typedef. "
"This means that you don't have to include the C library's header in your C++ "
"header, thus keeping it out of your public API. <command>gmmproc</command> "
"assumes that this technique was used, so you will see compiler errors if "
"that is not the case."
msgstr ""
"Doplňující typedef umožňuje použít strukturu v hlavičkovém souboru bez "
"vložení její plné definice, pouze jejím předeklarováním pomocí zopakování "
"tohoto typedef. To znamená, že nemusíte vkládat hlavičkový soubor knihovny v "
"C do svého hlavičkového souboru v C++ a tím ji udržet mimo veřejné API. "
"<command>gmmproc</command> předpokládá, že je tato technika použita, takže "
"pokud tomu tak není, uvidíte chybové hlášení kompilátoru."

#: C/gtkmm-tutorial-in.xml:9907(programlisting)
#, no-wrap
msgid ""
"\n"
"example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'\n"
"../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here\n"
"make[4]: *** [example-widget.lo] Error 1\n"
msgstr ""
"\n"
"example-widget.h:56: error: using typedef-name 'ExampleWidget' after 'struct'\n"
"../../libexample/libexamplemm/example-widget.h:34: error: 'ExampleWidget' has a previous declaration here\n"
"make[4]: *** [example-widget.lo] Error 1\n"

#: C/gtkmm-tutorial-in.xml:9913(programlisting)
#, no-wrap
msgid ""
"\n"
"example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol\n"
"../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'\n"
msgstr ""
"\n"
"example-widget.h:60: error: '_ExampleWidget ExampleWidget' redeclared as different kind of symbol\n"
"../../libexample/libexamplemm/example-widget.h:34: error: previous declaration of 'typedef struct _ExampleWidget ExampleWidget'\n"

#: C/gtkmm-tutorial-in.xml:9905(para)
msgid ""
"This compiler error might look like this: <placeholder-1/> or this: "
"<placeholder-2/>"
msgstr ""
"Tato chyba kompilátoru může vypadat nějak takto: <placeholder-1/> nebo "
"takto: <placeholder-2/>"

#: C/gtkmm-tutorial-in.xml:9918(para)
msgid ""
"This is easy to correct in the C library, so do send a patch to the relevant "
"maintainer."
msgstr ""
"Takovéto věci se v knihovně v jazyce C opravují snadno, tak neváhejte poslat "
"příslušnému správci záplatu."

#: C/gtkmm-tutorial-in.xml:9922(title)
msgid "Lack of properties"
msgstr "Chybějící vlastnosti"

#: C/gtkmm-tutorial-in.xml:9929(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        return g_object_new (EXAMPLE_TYPE_WIDGET, \"something\", something, \"thing\", thing, NULL);\n"
"}\n"
msgstr ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        return g_object_new (EXAMPLE_TYPE_WIDGET, \"something\", something, \"thing\", thing, NULL);\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:9923(para)
msgid ""
"By convention, glib/GTK+-style objects have <function>*_new()</function> "
"functions, such as <function>example_widget_new()</function> that do nothing "
"more than call <function>g_object_new()</function> and return the result. "
"The input parameters are supplied to <function>g_object_new()</function> "
"along with the names of the properties for which they are values. For "
"instance, <placeholder-1/>"
msgstr ""
"Podle zvyklostí mají objekty ve stylu glib/GTK+ funkce <function>*_new()</"
"function>, jako třeba <function>example_widget_new()</function>, které "
"nedělají nic víc, než že zavolají <function>g_object_new()</function> a "
"vrátí jeho výsledek. Vstupní parametry se předají do "
"<function>g_object_new()</function> spolu s názvy vlastností, pro které tyto "
"hodnoty jsou. Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9936(para)
msgid ""
"This allows language bindings to implement their own equivalents (such as C+"
"+ constructors), without using the <function>*_new()</function> function. "
"This is often necessary so that they can actually instantiate a derived "
"GType, to add their own hooks for signal handlers and vfuncs."
msgstr ""
"To umožňuje vazbám mezi různými programovacími jazyky implementovat jejich "
"vlastní ekvivalenty (jako jsou konstruktory v C++), bez použití funkce "
"<function>*_new()</function>. Často je to nutné, protože mohou ve "
"skutečnosti vytvářet instanci odvozenin GType, do kterých přidají vlastní "
"háčky pro obsluhu signálů a virtuálních funkcí."

#: C/gtkmm-tutorial-in.xml:9940(para)
msgid ""
"At the least, the <function>_new()</function> function should not use any "
"private API (functions that are only in a .c file). Even when there are no "
"functions, we can sometimes reimplement 2 or 3 lines of code in a "
"<function>_new()</function> function as long as those lines of code use API "
"that is available to us."
msgstr ""
"Minimálně by funkce <function>_new()</function> neměla používat žádné "
"privátní API (funkce, které jsou jen v souboru .c). Dokonce i v případě, že "
"neexistují žádné funkce, můžeme napsat dva až tři řádky kódu s implementací "
"funkce <function>_new()</function>, pokud tyto řádky kódu používají API, "
"které je pro nás dostupné."

#: C/gtkmm-tutorial-in.xml:9948(programlisting)
#, no-wrap
msgid ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        ExampleWidget* widget;\n"
"        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);\n"
"        example_widget_construct(widget, \"something\", something, \"thing\", thing);\n"
"}\n"
"\n"
"void example_widget_construct(ExampleWidget* widget, int something, const char* thing)\n"
"{\n"
"        //Do stuff that uses private API:\n"
"        widget-&gt;priv-&gt;thing = thing;\n"
"        do_something(something);\n"
"}\n"
msgstr ""
"\n"
"GtkWidget* example_widget_new(int something, const char* thing)\n"
"{\n"
"        ExampleWidget* widget;\n"
"        widget = g_object_new (EXAMPLE_TYPE_WIDGET, NULL);\n"
"        example_widget_construct(widget, \"something\", something, \"thing\", thing);\n"
"}\n"
"\n"
"void example_widget_construct(ExampleWidget* widget, int something, const char* thing)\n"
"{\n"
"        //Do stuff that uses private API:\n"
"        widget-&gt;priv-&gt;thing = thing;\n"
"        do_something(something);\n"
"}\n"

#: C/gtkmm-tutorial-in.xml:9945(para)
msgid ""
"Another workaround is to add a <function>*_construct()</function> function "
"that the C++ constructor can call after instantiating its own type. For "
"instance, <placeholder-1/>"
msgstr ""
"Jiný řešením je přidat funkci <function>*_construct()</function>, kterou "
"konstruktor C++ může zavolat po vytvoření instance jeho vlastního typu. "
"Například <placeholder-1/>"

#: C/gtkmm-tutorial-in.xml:9964(para)
msgid ""
"Adding properties, and ensuring that they interact properly with each other, "
"is relatively difficult to correct in the C library, but it is possible, so "
"do file a bug and try to send a patch to the relevant maintainer."
msgstr ""
"Provést opravu přidání vlastností a zajištěním, že budou spolu navzájem "
"správně komunikovat, je v knihovně v jazyce C relativně obtížné, ale není to "
"nemožné. Takže vyplňte chybové hlášení a zkuste příslušnému správci poslat "
"záplatu."

#: C/gtkmm-tutorial-in.xml:9972(title)
msgid "Documentation"
msgstr "Dokumentace"

#: C/gtkmm-tutorial-in.xml:9973(para)
msgid ""
"In general, gtkmm-style projects use Doxygen, which reads specially "
"formatted C++ comments and generates HTML documentation. You may write these "
"doxygen comments directly in the header files."
msgstr ""
"Obecně používají projekty ve stylu gtkmm Doxygen, který čte speciálně "
"formátované komentáře jazyka C++ a generuje z nich dokumentaci v HTML. Tyto "
"komentáře můžete zapisovat přímo do hlavičkových souborů."

#: C/gtkmm-tutorial-in.xml:9976(title)
msgid "Reusing C documentation"
msgstr "Recyklace dokumentace ke knihovnám C"

#: C/gtkmm-tutorial-in.xml:9977(para)
msgid ""
"You might wish to reuse documentation that exists for the C library that you "
"are wrapping. GTK-style C libraries typically use gtk-doc and therefore have "
"source code comments formatted for gtk-doc and some extra documentation in ."
"sgml and .xml files. The docextract_to_xml.py script, from glibmm's "
"<filename>tools/defs_gen</filename> directory, can read these files and "
"generate an .xml file that <command>gmmproc</command> can use to generate "
"doxygen comments. <command>gmmproc</command> will even try to transform the "
"documentation to make it more appropriate for a C++ API."
msgstr ""
"Můžete si přát využít dokumentaci, která již existuje pro knihovny jazyka C, "
"které jsou pro C++ obalené. Tyto knihovny ve stylu GTK typicky používají gtk-"
"doc a proto mají komentáře ve zdrojovém kódu formátované pro gtk-doc a k "
"tomu nějakou doplňující dokumentaci v souborech .sgml a .xml. Skript "
"<filename>docextract_to_xml.py</filename> ze složky <filename>tools/"
"defs_gen</filename> umí tyto soubory číst a vygenerovat soubor .xml, který "
"může <command>gmmproc</command> použít k vygenerování komentářů pro doxygen. "
"<command>gmmproc</command> se navíc pokusí provést v dokumentaci nějaké "
"změny, aby lépe odpovídala API C++."

#: C/gtkmm-tutorial-in.xml:9987(programlisting)
#, no-wrap
msgid "./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ &gt; gtk_docs.xml\n"
msgstr "./docextract_to_xml.py -s ~/checkout/gnome/gtk+/gtk/ &gt; gtk_docs.xml\n"

#: C/gtkmm-tutorial-in.xml:9990(para)
msgid ""
"Because this automatic transformation is not always appropriate, you might "
"want to provide hand-written text for a particular method. You can do this "
"by copying the XML node for the function from your <filename>something_docs."
"xml</filename> file to the <filename>something_docs_override.xml</filename> "
"file and changing the contents."
msgstr ""
"Protože automatický převod není vždy zcela správný, můžete chtít pro některé "
"metody poskytnout ručně psaný text. Můžete to udělat zkopírováním uzlu XML "
"pro tuto funkci ze souboru <filename>neco_docs.xml</filename> do "
"<filename>neco_docs_override.xml</filename> a změnou jeho obsahu."

#: C/gtkmm-tutorial-in.xml:9999(title)
msgid "Documentation build structure"
msgstr "Struktura pro sestavení dokumentace"

#: C/gtkmm-tutorial-in.xml:10000(para)
msgid ""
"If you copied the skeleton source tree in mm-common and substituted the "
"placeholder text, then you will already have suitable <filename>Makefile.am</"
"filename> and <filename>Doxyfile.in</filename> files. With the mm-common "
"build setup, the list of Doxygen input files is not defined in the Doxygen "
"configuration file, but passed along from <command>make</command> to the "
"standard input of <command>doxygen</command>. The input file list is defined "
"by the <varname>doc_input</varname> variable in the <filename>Makefile.am</"
"filename> file."
msgstr ""
"Pokud jste zkopírovali kostru zdrojového stromu v mm-common a nahradili "
"zástupné texty, tak budete již mít vhodné soubory <filename>Makefile.am</"
"filename> a <filename>Doxyfile.in</filename>. S nastavení sestavení podle mm-"
"common není seznam vstupních souborů Doxygen definován v konfiguračním "
"souboru Doxygen, ale je předáván z <command>make</command> na standardní "
"vstup příkazu <command>doxygen</command>. Seznam vstupních souborů je "
"definován proměnnou <varname>doc_input</varname> v souboru "
"<filename>Makefile.am</filename>."

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: C/gtkmm-tutorial-in.xml:0(None)
msgid "translator-credits"
msgstr "Marek Černocký <marek@manet.cz>"
